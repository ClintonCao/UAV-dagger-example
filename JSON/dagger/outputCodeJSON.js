var codeExport = 
[
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\A.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport javax.inject.Inject;\n\nclass A {\n  @Inject A() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\AbstractMembersInjectingBaseClass.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport javax.inject.Inject;\n\nabstract class AbstractMembersInjectingBaseClass {\n  @Inject Thing thing;\n}\n\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\AbstractMiddleClassWithoutMembers.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nabstract class AbstractMiddleClassWithoutMembers extends AbstractMembersInjectingBaseClass {\n}\n\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\B.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport javax.inject.Inject;\n\nclass B {\n  @Inject B() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\BasicAbstractClassComponent.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.Component;\n\n/**\n * This component tests behavior equivalent to {@link BasicComponent}, but as an abstract class\n * rather than an interface.\n */\n@Component(modules \u003d {PrimitivesModule.class, NullableModule.class})\nabstract class BasicAbstractClassComponent implements BasicComponent {\n  void throwAParty() {\n    throw new RuntimeException(\"Paaarrrrrtaaaaaaaay!\");\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\BasicComponent.java",
    "code": "\"/*\n* Copyright (C) 2014 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.Component;\nimport dagger.Lazy;\nimport dagger.MembersInjector;\nimport javax.inject.Provider;\nimport test.NullableModule.Nullable;\n\n@Component(modules \u003d {PrimitivesModule.class, NullableModule.class})\ninterface BasicComponent extends Injector\u003cThing\u003e {\n  byte getByte();\n  char getChar();\n  short getShort();\n  int getInt();\n  long getLong();\n  boolean getBoolean();\n  float getFloat();\n  double getDouble();\n\n  Byte getBoxedByte();\n  Character getBoxedChar();\n  Short getBoxedShort();\n  Integer getBoxedInt();\n  Long getBoxedLong();\n  Boolean getBoxedBoolean();\n  Float getBoxedFloat();\n  Double getBoxedDouble();\n\n  Provider\u003cByte\u003e getByteProvider();\n  Provider\u003cCharacter\u003e getCharProvider();\n  Provider\u003cShort\u003e getShortProvider();\n  Provider\u003cInteger\u003e getIntProvider();\n  Provider\u003cLong\u003e getLongProvider();\n  Provider\u003cBoolean\u003e getBooleanProvider();\n  Provider\u003cFloat\u003e getFloatProvider();\n  Provider\u003cDouble\u003e getDoubleProvider();\n\n  byte[] getByteArray();\n  char[] getCharArray();\n  short[] getShortArray();\n  int[] getIntArray();\n  long[] getLongArray();\n  boolean[] getBooleanArray();\n  float[] getFloatArray();\n  double[] getDoubleArray();\n\n  Provider\u003cbyte[]\u003e getByteArrayProvider();\n  Provider\u003cchar[]\u003e getCharArrayProvider();\n  Provider\u003cshort[]\u003e getShortArrayProvider();\n  Provider\u003cint[]\u003e getIntArrayProvider();\n  Provider\u003clong[]\u003e getLongArrayProvider();\n  Provider\u003cboolean[]\u003e getBooleanArrayProvider();\n  Provider\u003cfloat[]\u003e getFloatArrayProvider();\n  Provider\u003cdouble[]\u003e getDoubleArrayProvider();\n\n  Object noOpMembersInjection(Object obviouslyDoesNotHaveMembersToInject);\n\n  Thing thing();\n  InjectedThing injectedThing();\n  Provider\u003cInjectedThing\u003e injectedThingProvider();\n  Lazy\u003cInjectedThing\u003e lazyInjectedThing();\n  Provider\u003cLazy\u003cInjectedThing\u003e\u003e lazyInjectedThingProvider();\n  MembersInjector\u003cInjectedThing\u003e injectedThingMembersInjector();\n  \n  @Nullable Object nullObject();\n  Provider\u003cObject\u003e nullObjectProvider();\n  Lazy\u003cObject\u003e lazyNullObject();\n\n  TypeWithInheritedMembersInjection typeWithInheritedMembersInjection();\n  MembersInjector\u003cTypeWithInheritedMembersInjection\u003e\n      typeWithInheritedMembersInjectionMembersInjector();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\binds\\Foo.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.binds;\n\n/**\n * This is the type that will be bound.  We throw in generics just to complicate the test.\n */\ninterface Foo\u003cT\u003e {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\binds\\FooOfObjects.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.binds;\n\nimport javax.inject.Inject;\n\nfinal class FooOfObjects implements Foo\u003cObject\u003e {\n  @Inject FooOfObjects() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\binds\\FooOfStrings.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.binds;\n\nimport javax.inject.Inject;\n\nfinal class FooOfStrings implements Foo\u003cString\u003e {\n  @Inject\n  FooOfStrings() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\binds\\InterfaceModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.binds;\n\nimport dagger.Binds;\nimport dagger.Module;\n\n@Module\ninterface InterfaceModule {\n  @Binds Foo\u003cObject\u003e bindFooOfObjects(FooOfObjects impl);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\binds\\SimpleBindingModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.binds;\n\nimport dagger.Binds;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.Reusable;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntKey;\nimport dagger.multibindings.IntoMap;\nimport dagger.multibindings.IntoSet;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport test.SomeQualifier;\n\n@Module(includes \u003d InterfaceModule.class)\nabstract class SimpleBindingModule {\n  @Binds\n  abstract Object bindObject(FooOfStrings impl);\n\n  @Binds\n  @Reusable\n  @SomeQualifier\n  abstract Object bindReusableObject(FooOfStrings impl);\n\n  @Binds\n  abstract Foo\u003cString\u003e bindFooOfStrings(FooOfStrings impl);\n\n  @Binds\n  abstract Foo\u003c? extends Number\u003e bindFooOfNumbers(Foo\u003cInteger\u003e fooOfIntegers);\n\n  @Binds\n  @Singleton\n  @SomeQualifier\n  abstract Foo\u003cString\u003e bindQualifiedFooOfStrings(FooOfStrings impl);\n\n  @Provides\n  static Foo\u003cInteger\u003e provideFooOfIntegers() {\n    return new Foo\u003cInteger\u003e() {};\n  }\n\n  @Provides\n  static Foo\u003cDouble\u003e provideFooOfDoubles() {\n    return new Foo\u003cDouble\u003e() {};\n  }\n\n  @Binds\n  @IntoSet\n  abstract Foo\u003c? extends Number\u003e bindFooOfIntegersIntoSet(Foo\u003cInteger\u003e fooOfIntegers);\n\n  @Binds\n  @IntoSet\n  abstract Foo\u003c? extends Number\u003e bindFooExtendsNumberIntoSet(Foo\u003cDouble\u003e fooOfDoubles);\n\n  @Binds\n  @ElementsIntoSet\n  abstract Set\u003cObject\u003e bindSetOfFooNumbersToObjects(Set\u003cFoo\u003c? extends Number\u003e\u003e setOfFooNumbers);\n\n  @Binds\n  @IntoSet\n  abstract Object bindFooOfStringsIntoSetOfObjects(FooOfStrings impl);\n\n  @Provides\n  static HashSet\u003cString\u003e provideStringHashSet() {\n    return new HashSet\u003c\u003e(Arrays.asList(\"hash-string1\", \"hash-string2\"));\n  }\n\n  @Provides\n  static TreeSet\u003cCharSequence\u003e provideCharSequenceTreeSet() {\n    return new TreeSet\u003cCharSequence\u003e(Arrays.asList(\"tree-charSequence1\", \"tree-charSequence2\"));\n  }\n\n  @Provides\n  static Collection\u003cCharSequence\u003e provideCharSequenceCollection() {\n    return Arrays.\u003cCharSequence\u003easList(\"list-charSequence\");\n  }\n\n  @Binds\n  @ElementsIntoSet\n  abstract Set\u003cCharSequence\u003e bindHashSetOfStrings(HashSet\u003cString\u003e set);\n\n  @Binds\n  @ElementsIntoSet\n  abstract Set\u003cCharSequence\u003e bindTreeSetOfCharSequences(TreeSet\u003cCharSequence\u003e set);\n\n  @Binds\n  @ElementsIntoSet\n  abstract Set\u003cCharSequence\u003e bindCollectionOfCharSequences(Collection\u003cCharSequence\u003e collection);\n\n  @Binds\n  @IntoMap\n  @IntKey(123)\n  abstract Object bind123ForMap(@Named(\"For-123\") String string);\n\n  @Binds\n  @IntoMap\n  @IntKey(456)\n  abstract Object bind456ForMap(@Named(\"For-456\") String string);\n\n  @Provides\n  @IntoMap\n  @IntKey(789)\n  static Object provide789ForMap() {\n    return \"789-string\";\n  }\n\n  @Binds\n  @IntoMap\n  @IntKey(123)\n  @SomeQualifier\n  abstract Object bindFooOfStringsIntoQualifiedMap(FooOfStrings fooOfStrings);\n  \n  @Provides\n  @Named(\"For-123\")\n  static String provide123String() {\n    return \"123-string\";\n  }\n\n  @Provides\n  @Named(\"For-456\")\n  static String provide456String() {\n    return \"456-string\";\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\binds\\TestComponent.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.binds;\n\nimport dagger.Component;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\nimport test.SomeQualifier;\n\n@Singleton\n@Component(modules \u003d SimpleBindingModule.class)\npublic interface TestComponent {\n  Object object();\n\n  @SomeQualifier\n  Object reusableObject();\n\n  Foo\u003cString\u003e fooOfStrings();\n\n  Foo\u003cObject\u003e fooOfObjects();\n\n  @SomeQualifier\n  Foo\u003cString\u003e qualifiedFooOfStrings();\n\n  Foo\u003cInteger\u003e fooOfIntegers();\n\n  Set\u003cFoo\u003c? extends Number\u003e\u003e foosOfNumbers();\n\n  Set\u003cObject\u003e objects();\n\n  Set\u003cCharSequence\u003e charSequences();\n\n  Map\u003cInteger, Object\u003e integerObjectMap();\n\n  Map\u003cInteger, Provider\u003cObject\u003e\u003e integerProviderOfObjectMap();\n\n  @SomeQualifier Map\u003cInteger, Object\u003e qualifiedIntegerObjectMap();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\BooleanKey.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.MapKey;\n\n@MapKey(unwrapValue \u003d true)\n@interface BooleanKey {\n  boolean value();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\BoundedGenericComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Component;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\n@Component(modules \u003d BoundedGenericModule.class)\ninterface BoundedGenericComponent {\n  BoundedGenerics\u003cInteger, ArrayList\u003cString\u003e, LinkedList\u003cCharSequence\u003e, Integer, List\u003cInteger\u003e\u003e\n      bounds1();\n  BoundedGenerics\u003cDouble, LinkedList\u003cString\u003e, LinkedList\u003cComparable\u003cString\u003e\u003e, Double, Set\u003cDouble\u003e\u003e\n      bounds2();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\BoundedGenericModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\n\n@Module\nclass BoundedGenericModule {\n\n  @Provides\n  Integer provideInteger() {\n    return 1;\n  }\n\n  @Provides\n  Double provideDouble() {\n    return 2d;\n  }\n\n  @Provides\n  ArrayList\u003cString\u003e provideArrayListString() {\n    ArrayList\u003cString\u003e list \u003d new ArrayList\u003c\u003e();\n    list.add(\"arrayListOfString\");\n    return list;\n  }\n\n  @Provides\n  LinkedList\u003cString\u003e provideLinkedListString() {\n    LinkedList\u003cString\u003e list \u003d new LinkedList\u003c\u003e();\n    list.add(\"linkedListOfString\");\n    return list;\n  }\n\n  @Provides\n  LinkedList\u003cCharSequence\u003e provideLinkedListCharSeq() {\n    LinkedList\u003cCharSequence\u003e list \u003d new LinkedList\u003c\u003e();\n    list.add(\"linkedListOfCharSeq\");\n    return list;\n  }\n\n  @Provides\n  @SuppressWarnings(\"unchecked\")\n  LinkedList\u003cComparable\u003cString\u003e\u003e provideArrayListOfComparableString() {\n    LinkedList\u003cComparable\u003cString\u003e\u003e list \u003d new LinkedList\u003c\u003e();\n    list.add(\"arrayListOfComparableOfString\");\n    return list;\n  }\n\n  @Provides\n  List\u003cInteger\u003e provideListOfInteger() {\n    LinkedList\u003cInteger\u003e list \u003d new LinkedList\u003c\u003e();\n    list.add(3);\n    return list;\n  }\n\n  @Provides\n  Set\u003cDouble\u003e provideSetOfDouble() {\n    Set\u003cDouble\u003e set \u003d new HashSet\u003c\u003e();\n    set.add(4d);\n    return set;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\BoundedGenerics.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport java.util.List;\nimport javax.inject.Inject;\n\nclass BoundedGenerics\u003cA extends Number \u0026 Comparable\u003c? super A\u003e, \n      B extends List\u003c? extends CharSequence\u003e,\n      C extends List\u003c? super String\u003e,\n      D extends A,\n      E extends Iterable\u003cD\u003e\u003e {\n  \n  final A a;\n  final B b;\n  final C c;\n  final D d;\n  final E e;\n  \n  @Inject BoundedGenerics(A a, B b, C c, D d, E e) {\n    this.a \u003d a;\n    this.b \u003d b;\n    this.c \u003d c;\n    this.d \u003d d;\n    this.e \u003d e;\n  }\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\ByteModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\nclass ByteModule {\n  final byte b;\n\n  ByteModule(byte b) {\n    this.b \u003d b;\n  }\n  \n  @Provides byte b() { return b; }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\DepComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Component;\n\n@Component\ninterface DepComponent {\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\DoubleModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\nclass DoubleModule {\n  @Provides\n  double d() {\n    return 4.2d;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\FloatModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\nclass FloatModule {  \n  @Provides\n  float f() {\n    return 5.5f;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\GenericParent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\ninterface GenericParent\u003cB\u003e {  \n  B subcomponentBuilder();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\Grandchild.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Subcomponent;\n\n@Subcomponent(modules \u003d IntModuleIncludingDoubleAndFloat.class)\ninterface Grandchild {\n  int i();\n  String s();\n\n  @Subcomponent.Builder\n  interface Builder {\n    Grandchild build();\n    Builder set(IntModuleIncludingDoubleAndFloat intModule);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\IntModuleIncludingDoubleAndFloat.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module(includes \u003d { DoubleModule.class, FloatModule.class })\nclass IntModuleIncludingDoubleAndFloat {\n  final int integer;\n\n  IntModuleIncludingDoubleAndFloat(int integer) {\n    this.integer \u003d integer;\n  }\n  \n  @Provides\n  int integer() {\n    return integer;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\LongModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\nclass LongModule {  \n  @Provides\n  long l() {\n    return 6L;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\MiddleChild.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Subcomponent;\n\n@MiddleScope\n@Subcomponent(modules \u003d StringModule.class)\ninterface MiddleChild {\n  String s();\n  \n  Grandchild.Builder grandchildBuilder();\n  \n  RequiresSubcomponentBuilder\u003cGrandchild.Builder\u003e requiresGrandchildBuilder();\n  \n  @Subcomponent.Builder\n  interface Builder {\n    MiddleChild build();\n    Builder set(StringModule stringModule);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\MiddleScope.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Retention;\nimport javax.inject.Scope;\n\n@Scope\n@Retention(RUNTIME)\n@interface MiddleScope {\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\OtherMiddleChild.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Subcomponent;\n\n@MiddleScope\n@Subcomponent(modules \u003d {StringModule.class, LongModule.class})\ninterface OtherMiddleChild {\n  long l();\n  String s();\n  \n  Grandchild.Builder grandchildBuilder();\n  \n  @Subcomponent.Builder\n  interface Builder {\n    OtherMiddleChild build();\n    Builder set(StringModule stringModule);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\ParentComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Component;\nimport javax.inject.Singleton;\n\n@Singleton\n@Component\ninterface ParentComponent {  \n  TestChildComponentWithBuilderAbstractClass.Builder childAbstractClassBuilder();\n  TestChildComponentWithBuilderInterface.Builder childInterfaceBuilder();\n  \n  MiddleChild.Builder middleBuilder();\n  OtherMiddleChild.Builder otherBuilder();\n  \n  RequiresSubcomponentBuilder\u003cMiddleChild.Builder\u003e requiresMiddleChildBuilder();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\ParentOfGenericComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Component;\nimport javax.inject.Singleton;\n\n@Component(modules \u003d StringModule.class)\n@Singleton\ninterface ParentOfGenericComponent extends GenericParent\u003cGrandchild.Builder\u003e {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\RequiresSubcomponentBuilder.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport javax.inject.Inject;\nimport javax.inject.Provider;\n\nclass RequiresSubcomponentBuilder\u003cB\u003e {\n  private final Provider\u003cB\u003e subcomponentBuilderProvider;\n  private final B subcomponentBuilder;\n\n  @Inject\n  RequiresSubcomponentBuilder(Provider\u003cB\u003e subcomponentBuilderProvider, B subcomponentBuilder) {\n    this.subcomponentBuilderProvider \u003d subcomponentBuilderProvider;\n    this.subcomponentBuilder \u003d subcomponentBuilder;\n  }\n\n  Provider\u003cB\u003e subcomponentBuilderProvider() {\n    return subcomponentBuilderProvider;\n  }\n  \n  B subcomponentBuilder() {\n    return subcomponentBuilder;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\StringModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\nclass StringModule {\n  final String string;\n\n  StringModule(String string) {\n    this.string \u003d string;\n  }\n  \n  @Provides\n  String string() {\n    return string;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\TestChildComponentWithBuilderAbstractClass.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Subcomponent;\n\n@Subcomponent(modules \u003d {StringModule.class, IntModuleIncludingDoubleAndFloat.class,\n    LongModule.class, ByteModule.class})\ninterface TestChildComponentWithBuilderAbstractClass {\n  String s();\n  int i();\n  long l();\n  float f();\n  double d();\n  byte b();\n \n  abstract class SharedBuilder\u003cB, C, M1, M2\u003e {\n    abstract C build(); // Test resolving return type of build()\n    abstract B setM1(M1 m1); // Test resolving return type \u0026 param of setter\n    abstract SharedBuilder\u003cB, C, M1, M2\u003e setM2(M2 m2); // Test being overridden\n    abstract void setM3(DoubleModule doubleModule);  // Test being overridden\n    abstract SharedBuilder\u003cB, C, M1, M2\u003e set(FloatModule floatModule); // Test returning supertype.\n  }\n  \n  @Subcomponent.Builder\n  abstract class Builder extends SharedBuilder\u003cBuilder, TestChildComponentWithBuilderAbstractClass,\n      StringModule, IntModuleIncludingDoubleAndFloat\u003e {\n    @Override abstract Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariance\n    @Override abstract void setM3(DoubleModule doubleModule); // Test simple overrides allowed    \n    abstract void set(ByteModule byteModule);\n    \n    // Note we\u0027re missing LongModule -- it\u0027s implicit\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\TestChildComponentWithBuilderInterface.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Subcomponent;\n\n@Subcomponent(modules \u003d {StringModule.class, IntModuleIncludingDoubleAndFloat.class,\n    LongModule.class, ByteModule.class})\ninterface TestChildComponentWithBuilderInterface {\n  String s();\n  int i();\n  long l();\n  float f();\n  double d();\n  byte b();\n  \n  interface SharedBuilder\u003cB, C, M1, M2\u003e {\n    C build(); // Test resolving return type of build()\n    B setM1(M1 m1); // Test resolving return type \u0026 param of setter\n    SharedBuilder\u003cB, C, M1, M2\u003e setM2(M2 m2); // Test being overridden\n    void setM3(DoubleModule doubleModule);  // Test being overridden\n    SharedBuilder\u003cB, C, M1, M2\u003e set(FloatModule floatModule); // Test return type is supertype.\n  }\n  \n  @Subcomponent.Builder\n  interface Builder extends SharedBuilder\u003cBuilder, TestChildComponentWithBuilderInterface,\n      StringModule, IntModuleIncludingDoubleAndFloat\u003e {\n    @Override Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides\n    @Override void setM3(DoubleModule doubleModule); // Test simple overrides allowed    \n    void set(ByteModule byteModule);\n    \n    // Note we\u0027re missing LongModule -- it\u0027s implicit\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\TestComponentWithBuilderAbstractClass.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Component;\n\n@Component(\n    modules \u003d {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},\n    dependencies \u003d DepComponent.class)\nabstract class TestComponentWithBuilderAbstractClass {\n  \n  static Builder builder() {\n    return DaggerTestComponentWithBuilderAbstractClass.builder();\n  }\n  \n  abstract String s();\n  abstract int i();\n  abstract long l();\n  abstract float f();\n  abstract double d();\n  \n\n  static abstract class SharedBuilder {\n    // Make sure we use the overriding signature.\n    abstract Object build();\n    \n    Object stringModule(@SuppressWarnings(\"unused\") StringModule stringModule) {\n      return null;\n    } \n\n    SharedBuilder ignoredLongModule(@SuppressWarnings(\"unused\") LongModule longModule) {\n      return null;\n    }\n    \n  }\n  \n  @Component.Builder\n  static abstract class Builder extends SharedBuilder {\n    @Override abstract TestComponentWithBuilderAbstractClass build(); // Narrowing return type\n    @Override abstract Builder stringModule(StringModule stringModule); // Make abstract \u0026 narrow\n    abstract Builder intModule(IntModuleIncludingDoubleAndFloat intModule);\n    abstract void doubleModule(DoubleModule doubleModule); // Module w/o args\n    abstract void depComponent(DepComponent depComponent);\n\n    Builder ignoredIntModule(\n        @SuppressWarnings(\"unused\") IntModuleIncludingDoubleAndFloat intModule) {\n      return null;\n    }    \n    \n    // Note we\u0027re missing LongModule \u0026 FloatModule -- they/re implicit\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\TestComponentWithBuilderInterface.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Component;\n\n@Component(\n    modules \u003d {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},\n    dependencies \u003d DepComponent.class)\ninterface TestComponentWithBuilderInterface {\n  String s();\n  int i();\n  long l();\n  float f();\n  double d();\n  \n  interface SharedBuilder {\n    // Make sure we use the overriding signature.\n    Object build();\n    Object stringModule(StringModule m1); \n  }\n  \n  @Component.Builder\n  interface Builder extends SharedBuilder {\n    @Override TestComponentWithBuilderInterface build(); // Narrowing return type\n    @Override Builder stringModule(StringModule stringModule); // Narrowing return type\n    Builder intModule(IntModuleIncludingDoubleAndFloat intModule);\n    void doubleModule(DoubleModule doubleModule); // Module w/o args\n    void depComponent(DepComponent depComponent);\n    \n    // Note we\u0027re missing LongModule \u0026 FloatModule -- they/re implicit\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\TestComponentWithGenericBuilderAbstractClass.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Component;\n\n@Component(\n    modules \u003d {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},\n    dependencies \u003d DepComponent.class)\ninterface TestComponentWithGenericBuilderAbstractClass {\n  String s();\n  int i();\n  long l();\n  float f();\n  double d();\n  \n  static abstract class SharedBuilder\u003cB, C, M1, M2\u003e {\n    abstract C build(); // Test resolving return type of build()\n    abstract B setM1(M1 m1); // Test resolving return type \u0026 param of setter\n    abstract SharedBuilder\u003cB, C, M1, M2\u003e setM2(M2 m2); // Test being overridden\n    abstract void doubleModule(DoubleModule doubleModule);  // Test being overridden\n    abstract SharedBuilder\u003cB, C, M1, M2\u003e depComponent(FloatModule floatModule); // Test return type\n  }\n  \n  @Component.Builder\n  static abstract class Builder extends SharedBuilder\u003cBuilder,\n      TestComponentWithGenericBuilderAbstractClass, StringModule,\n      IntModuleIncludingDoubleAndFloat\u003e {\n    @Override abstract Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides\n    @Override abstract void doubleModule(DoubleModule module3); // Test simple overrides allowed    \n    abstract void depComponent(DepComponent depComponent);\n    \n    // Note we\u0027re missing LongModule \u0026 FloatModule -- they\u0027re implicit\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\builder\\TestComponentWithGenericBuilderInterface.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport dagger.Component;\n\n@Component(\n    modules \u003d {StringModule.class, IntModuleIncludingDoubleAndFloat.class, LongModule.class},\n    dependencies \u003d DepComponent.class)\ninterface TestComponentWithGenericBuilderInterface {\n  String s();\n  int i();\n  long l();\n  float f();\n  double d();\n  \n  interface SharedBuilder\u003cB, C, M1, M2\u003e {\n    C build(); // Test resolving return type of build()\n    B setM1(M1 m1); // Test resolving return type \u0026 param of setter\n    SharedBuilder\u003cB, C, M1, M2\u003e setM2(M2 m2); // Test being overridden\n    void doubleModule(DoubleModule doubleModule);  // Test being overridden\n    SharedBuilder\u003cB, C, M1, M2\u003e set(FloatModule floatModule); // Test return type is supertype.\n  }\n  \n  @Component.Builder\n  interface Builder extends SharedBuilder\u003cBuilder, TestComponentWithGenericBuilderInterface,\n      StringModule, IntModuleIncludingDoubleAndFloat\u003e {\n    @Override Builder setM2(IntModuleIncludingDoubleAndFloat m2); // Test covariant overrides allowed\n    @Override void doubleModule(DoubleModule module3); // Test simple overrides allowed    \n    void depComponent(DepComponent depComponent);\n    \n    // Note we\u0027re missing M5 -- that\u0027s implicit.\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ByteKey.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.MapKey;\n\n@MapKey(unwrapValue \u003d true)\n@interface ByteKey {\n  byte value();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\CharKey.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.MapKey;\n\n@MapKey(unwrapValue \u003d true)\n@interface CharKey {\n  char value();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ChildDoubleModule.java",
    "code": "\"package test;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Module\nclass ChildDoubleModule extends ParentModule\u003cDouble, String, List\u003cDouble\u003e\u003e {\n\n  @Provides Double provideDouble() {\n    return 3d;\n  }\n\n  @Provides List\u003cDouble\u003e provideListOfDouble() {\n    List\u003cDouble\u003e list \u003d new ArrayList\u003c\u003e();\n    list.add(4d);\n    return list;\n  }\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ChildIntegerModule.java",
    "code": "\"package test;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@Module\nclass ChildIntegerModule extends ParentModule\u003cInteger, String, List\u003cInteger\u003e\u003e {\n\n  @Provides Integer provideInteger() {\n    return 1;\n  }\n\n  @Provides List\u003cInteger\u003e provideListOfInteger() {\n    List\u003cInteger\u003e list \u003d new ArrayList\u003c\u003e();\n    list.add(2);\n    return list;\n  }\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ComplexGenerics.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Lazy;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\n\nclass ComplexGenerics {\n  \n  final Generic2\u003cGeneric\u003cA\u003e\u003e g2ga;\n  final Lazy\u003cGeneric2\u003cGeneric\u003cA\u003e\u003e\u003e g2gaLazy;\n  final Provider\u003cGeneric2\u003cGeneric\u003cA\u003e\u003e\u003e g2gaProvider;\n  final Generic2\u003cGeneric\u003cB\u003e\u003e g2gb;\n  final Lazy\u003cGeneric2\u003cGeneric\u003cB\u003e\u003e\u003e g2gbLazy;\n  final Provider\u003cGeneric2\u003cGeneric\u003cB\u003e\u003e\u003e g2gbProvider;\n  final Generic2\u003cA\u003e g2a;\n  final Generic\u003cGeneric2\u003cA\u003e\u003e gg2a;\n  final Generic\u003cGeneric2\u003cB\u003e\u003e gg2b;\n  \n  @Inject ComplexGenerics(\n      Generic2\u003cGeneric\u003cA\u003e\u003e g2ga,\n      Lazy\u003cGeneric2\u003cGeneric\u003cA\u003e\u003e\u003e g2gaLazy,\n      Provider\u003cGeneric2\u003cGeneric\u003cA\u003e\u003e\u003e g2gaProvider,\n      Generic2\u003cGeneric\u003cB\u003e\u003e g2gb,\n      Lazy\u003cGeneric2\u003cGeneric\u003cB\u003e\u003e\u003e g2gbLazy,\n      Provider\u003cGeneric2\u003cGeneric\u003cB\u003e\u003e\u003e g2gbProvider,\n      Generic2\u003cA\u003e g2a,\n      Generic\u003cGeneric2\u003cA\u003e\u003e gg2a,\n      Generic\u003cGeneric2\u003cB\u003e\u003e gg2b) {\n    this.g2ga \u003d g2ga;\n    this.g2gaLazy \u003d g2gaLazy;\n    this.g2gaProvider \u003d g2gaProvider;\n    this.g2gb \u003d g2gb;\n    this.g2gbLazy \u003d g2gbLazy;\n    this.g2gbProvider \u003d g2gbProvider;\n    this.g2a \u003d g2a;\n    this.gg2a \u003d gg2a;\n    this.gg2b \u003d gg2b;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ComponentDependsOnGeneratedCode.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.Component;\n\n/**\n * A component that indirectly depends on code generated by another processor, in this case\n * {@link com.google.auto.factory.AutoFactory}. Neither this type nor its immediately referenced\n * types are generated, but {@link NeedsFactory} depends on the generated\n * {@link NeedsFactory_SomethingFactory}.\n *\n */\n@Component\ninterface ComponentDependsOnGeneratedCode {\n  NeedsFactory needsFactory();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ComponentSupertypeDependsOnGeneratedCode.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Component;\n\n/**\n * A component whose supertype depends on code generated by another processor, in this case\n * {@link com.google.auto.factory.AutoFactory}.\n *\n */\n@Component\ninterface ComponentSupertypeDependsOnGeneratedCode\n    extends ComponentSupertypeDependsOnGeneratedCodeInterface {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ComponentSupertypeDependsOnGeneratedCodeInterface.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\ninterface ComponentSupertypeDependsOnGeneratedCodeInterface {\n  NeedsFactory_SomethingFactory somethingFactory();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ComponentsWithNestedModules.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Component;\nimport dagger.Module;\n\n// https://github.com/google/dagger/issues/279\npublic class ComponentsWithNestedModules {\n  @Component(modules \u003d RegularComponent.SharedModule.class)\n  public interface RegularComponent {\n    @Module class SharedModule {}\n  }\n\n  @Component(modules \u003d ExtendsRegularComponent.SharedModule.class)\n  public interface ExtendsRegularComponent extends RegularComponent {\n    @Module(includes \u003d RegularComponent.SharedModule.class)\n    class SharedModule {}\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ComponentWithReusableBindings.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Component;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.Reusable;\nimport dagger.Subcomponent;\nimport javax.inject.Qualifier;\n\n@Component(modules \u003d ComponentWithReusableBindings.ReusableBindingsModule.class)\ninterface ComponentWithReusableBindings {\n\n  @Qualifier\n  @interface InParent {}\n\n  @Qualifier\n  @interface InChildren {}\n\n  @InParent\n  Object reusableInParent();\n\n  ChildOne childOne();\n\n  ChildTwo childTwo();\n\n  @Subcomponent\n  interface ChildOne {\n    @InParent\n    Object reusableInParent();\n\n    @InChildren\n    Object reusableInChild();\n  }\n\n  @Subcomponent\n  interface ChildTwo {\n    @InParent\n    Object reusableInParent();\n\n    @InChildren\n    Object reusableInChild();\n  }\n\n  @Module\n  static class ReusableBindingsModule {\n    @Provides\n    @Reusable\n    @InParent\n    static Object inParent() {\n      return new Object();\n    }\n\n    @Provides\n    @Reusable\n    @InChildren\n    static Object inChildren() {\n      return new Object();\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\cycle\\Cycles.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.cycle;\n\nimport dagger.Binds;\nimport dagger.Component;\nimport dagger.Lazy;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.Subcomponent;\nimport dagger.multibindings.IntoMap;\nimport dagger.multibindings.StringKey;\nimport java.util.Map;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\n\n/**\n * Cycle classes used for testing cyclic dependencies.\n * A \u003c- (E \u003c- D \u003c- B \u003c- C \u003c- Provider\u003cA\u003e, Lazy\u003cA\u003e), (B \u003c- C \u003c- Provider\u003cA\u003e, Lazy\u003cA\u003e)\n * S \u003c- Provider\u003cS\u003e, Lazy\u003cS\u003e\n *\n * @author Tony Bentancur\n * @since 2.0\n */\n\nfinal class Cycles {\n  private Cycles() {}\n\n  static class A {\n    public final B b;\n    public final E e;\n\n    @Inject\n    A(E e, B b) {\n      this.e \u003d e;\n      this.b \u003d b;\n    }\n  }\n\n  static class B {\n    public final C c;\n\n    @Inject\n    B(C c) {\n      this.c \u003d c;\n    }\n  }\n\n  static class C {\n    public final Provider\u003cA\u003e aProvider;\n    @Inject public Lazy\u003cA\u003e aLazy;\n    @Inject public Provider\u003cLazy\u003cA\u003e\u003e aLazyProvider;\n\n    @Inject\n    C(Provider\u003cA\u003e aProvider) {\n      this.aProvider \u003d aProvider;\n    }\n  }\n\n  static class D {\n    public final B b;\n\n    @Inject\n    D(B b) {\n      this.b \u003d b;\n    }\n  }\n\n  static class E {\n    public final D d;\n\n    @Inject\n    E(D d) {\n      this.d \u003d d;\n    }\n  }\n\n  static class S {\n    public final Provider\u003cS\u003e sProvider;\n    @Inject public Lazy\u003cS\u003e sLazy;\n\n    @Inject\n    S(Provider\u003cS\u003e sProvider) {\n      this.sProvider \u003d sProvider;\n    }\n  }\n\n  static class X {\n    public final Y y;\n\n    @Inject\n    X(Y y) {\n      this.y \u003d y;\n    }\n  }\n\n  static class Y {\n    public final Map\u003cString, Provider\u003cX\u003e\u003e mapOfProvidersOfX;\n    public final Map\u003cString, Provider\u003cY\u003e\u003e mapOfProvidersOfY;\n\n    @Inject\n    Y(Map\u003cString, Provider\u003cX\u003e\u003e mapOfProvidersOfX, Map\u003cString, Provider\u003cY\u003e\u003e mapOfProvidersOfY) {\n      this.mapOfProvidersOfX \u003d mapOfProvidersOfX;\n      this.mapOfProvidersOfY \u003d mapOfProvidersOfY;\n    }\n  }\n\n  @Module\n  abstract static class CycleMapModule {\n    @Binds\n    @IntoMap\n    @StringKey(\"X\")\n    abstract X x(X x);\n\n    @Binds\n    @IntoMap\n    @StringKey(\"Y\")\n    abstract Y y(Y y);\n  }\n\n  @SuppressWarnings(\"dependency-cycle\")\n  @Component(modules \u003d CycleMapModule.class)\n  interface CycleMapComponent {\n    Y y();\n  }\n\n  @SuppressWarnings(\"dependency-cycle\")\n  @Component(modules \u003d CycleModule.class)\n  interface CycleComponent {\n    A a();\n\n    C c();\n\n    ChildCycleComponent child();\n  }\n\n  @Module\n  static class CycleModule {\n    @Provides\n    static Object provideObjectWithCycle(@SuppressWarnings(\"unused\") Provider\u003cObject\u003e object) {\n      return \"object\";\n    }\n  }\n\n  @SuppressWarnings(\"dependency-cycle\")\n  @Component\n  interface SelfCycleComponent {\n    S s();\n  }\n\n  @Subcomponent\n  interface ChildCycleComponent {\n    @SuppressWarnings(\"dependency-cycle\")\n    A a();\n\n    @SuppressWarnings(\"dependency-cycle\")\n    Object object();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\cycle\\LongCycle.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.cycle;\n\nimport dagger.Component;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\n\n/**\n * Component with a long enough cycle such that the initialization of a provider happens in a\n * separate {@code initialize} method from the one where it is used as a delegated factory.\n *\n */\n// Each nested class\u0027s constructor has an intentionally unused parameter.\n@SuppressWarnings(\"unused\")\nfinal class LongCycle {\n  static class Class1 { @Inject Class1(Class2 class2) {} }\n  static class Class2 { @Inject Class2(Class3 class3) {} }\n  static class Class3 { @Inject Class3(Class4 class4) {} }\n  static class Class4 { @Inject Class4(Class5 class5) {} }\n  static class Class5 { @Inject Class5(Class6 class6) {} }\n  static class Class6 { @Inject Class6(Class7 class7) {} }\n  static class Class7 { @Inject Class7(Class8 class8) {} }\n  static class Class8 { @Inject Class8(Class9 class9) {} }\n  static class Class9 { @Inject Class9(Class10 class10) {} }\n  static class Class10 { @Inject Class10(Class11 class11) {} }\n  static class Class11 { @Inject Class11(Class12 class12) {} }\n  static class Class12 { @Inject Class12(Class13 class13) {} }\n  static class Class13 { @Inject Class13(Class14 class14) {} }\n  static class Class14 { @Inject Class14(Class15 class15) {} }\n  static class Class15 { @Inject Class15(Class16 class16) {} }\n  static class Class16 { @Inject Class16(Class17 class17) {} }\n  static class Class17 { @Inject Class17(Class18 class18) {} }\n  static class Class18 { @Inject Class18(Class19 class19) {} }\n  static class Class19 { @Inject Class19(Class20 class20) {} }\n  static class Class20 { @Inject Class20(Class21 class21) {} }\n  static class Class21 { @Inject Class21(Class22 class22) {} }\n  static class Class22 { @Inject Class22(Class23 class23) {} }\n  static class Class23 { @Inject Class23(Class24 class24) {} }\n  static class Class24 { @Inject Class24(Class25 class25) {} }\n  static class Class25 { @Inject Class25(Class26 class26) {} }\n  static class Class26 { @Inject Class26(Class27 class27) {} }\n  static class Class27 { @Inject Class27(Class28 class28) {} }\n  static class Class28 { @Inject Class28(Class29 class29) {} }\n  static class Class29 { @Inject Class29(Class30 class30) {} }\n  static class Class30 { @Inject Class30(Class31 class31) {} }\n  static class Class31 { @Inject Class31(Class32 class32) {} }\n  static class Class32 { @Inject Class32(Class33 class33) {} }\n  static class Class33 { @Inject Class33(Class34 class34) {} }\n  static class Class34 { @Inject Class34(Class35 class35) {} }\n  static class Class35 { @Inject Class35(Class36 class36) {} }\n  static class Class36 { @Inject Class36(Class37 class37) {} }\n  static class Class37 { @Inject Class37(Class38 class38) {} }\n  static class Class38 { @Inject Class38(Class39 class39) {} }\n  static class Class39 { @Inject Class39(Class40 class40) {} }\n  static class Class40 { @Inject Class40(Class41 class41) {} }\n  static class Class41 { @Inject Class41(Class42 class42) {} }\n  static class Class42 { @Inject Class42(Class43 class43) {} }\n  static class Class43 { @Inject Class43(Class44 class44) {} }\n  static class Class44 { @Inject Class44(Class45 class45) {} }\n  static class Class45 { @Inject Class45(Class46 class46) {} }\n  static class Class46 { @Inject Class46(Class47 class47) {} }\n  static class Class47 { @Inject Class47(Class48 class48) {} }\n  static class Class48 { @Inject Class48(Class49 class49) {} }\n  static class Class49 { @Inject Class49(Class50 class50) {} }\n  static class Class50 { @Inject Class50(Class51 class51) {} }\n  static class Class51 { @Inject Class51(Class52 class52) {} }\n  static class Class52 { @Inject Class52(Class53 class53) {} }\n  static class Class53 { @Inject Class53(Class54 class54) {} }\n  static class Class54 { @Inject Class54(Class55 class55) {} }\n  static class Class55 { @Inject Class55(Class56 class56) {} }\n  static class Class56 { @Inject Class56(Class57 class57) {} }\n  static class Class57 { @Inject Class57(Class58 class58) {} }\n  static class Class58 { @Inject Class58(Class59 class59) {} }\n  static class Class59 { @Inject Class59(Class60 class60) {} }\n  static class Class60 { @Inject Class60(Class61 class61) {} }\n  static class Class61 { @Inject Class61(Class62 class62) {} }\n  static class Class62 { @Inject Class62(Class63 class63) {} }\n  static class Class63 { @Inject Class63(Class64 class64) {} }\n  static class Class64 { @Inject Class64(Class65 class65) {} }\n  static class Class65 { @Inject Class65(Class66 class66) {} }\n  static class Class66 { @Inject Class66(Class67 class67) {} }\n  static class Class67 { @Inject Class67(Class68 class68) {} }\n  static class Class68 { @Inject Class68(Class69 class69) {} }\n  static class Class69 { @Inject Class69(Class70 class70) {} }\n  static class Class70 { @Inject Class70(Class71 class71) {} }\n  static class Class71 { @Inject Class71(Class72 class72) {} }\n  static class Class72 { @Inject Class72(Class73 class73) {} }\n  static class Class73 { @Inject Class73(Class74 class74) {} }\n  static class Class74 { @Inject Class74(Class75 class75) {} }\n  static class Class75 { @Inject Class75(Class76 class76) {} }\n  static class Class76 { @Inject Class76(Class77 class77) {} }\n  static class Class77 { @Inject Class77(Class78 class78) {} }\n  static class Class78 { @Inject Class78(Class79 class79) {} }\n  static class Class79 { @Inject Class79(Class80 class80) {} }\n  static class Class80 { @Inject Class80(Class81 class81) {} }\n  static class Class81 { @Inject Class81(Class82 class82) {} }\n  static class Class82 { @Inject Class82(Class83 class83) {} }\n  static class Class83 { @Inject Class83(Class84 class84) {} }\n  static class Class84 { @Inject Class84(Class85 class85) {} }\n  static class Class85 { @Inject Class85(Class86 class86) {} }\n  static class Class86 { @Inject Class86(Class87 class87) {} }\n  static class Class87 { @Inject Class87(Class88 class88) {} }\n  static class Class88 { @Inject Class88(Class89 class89) {} }\n  static class Class89 { @Inject Class89(Class90 class90) {} }\n  static class Class90 { @Inject Class90(Class91 class91) {} }\n  static class Class91 { @Inject Class91(Class92 class92) {} }\n  static class Class92 { @Inject Class92(Class93 class93) {} }\n  static class Class93 { @Inject Class93(Class94 class94) {} }\n  static class Class94 { @Inject Class94(Class95 class95) {} }\n  static class Class95 { @Inject Class95(Class96 class96) {} }\n  static class Class96 { @Inject Class96(Class97 class97) {} }\n  static class Class97 { @Inject Class97(Class98 class98) {} }\n  static class Class98 { @Inject Class98(Class99 class99) {} }\n  static class Class99 { @Inject Class99(Class100 class100) {} }\n  static class Class100 { @Inject Class100(Class101 class101) {} }\n  static class Class101 { @Inject Class101(Provider\u003cClass1\u003e class1Provider) {} }\n\n  @SuppressWarnings(\"dependency-cycle\")\n  @Component\n  interface LongCycleComponent {\n    Class1 class1();\n  }\n\n  private LongCycle() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\Generic.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport javax.inject.Inject;\n\npublic class Generic\u003cT\u003e {\n  final T t;\n\n  @Inject public Generic(T t) {\n    this.t \u003d t;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\Generic2.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport javax.inject.Inject;\n\npublic class Generic2\u003cT\u003e {\n  final T t;\n\n  @Inject Generic2(T t) {\n    this.t \u003d t;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\GenericChild.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport javax.inject.Inject;\n\nclass GenericChild\u003cT\u003e extends GenericParent\u003cT, B\u003e {\n  \n  A registeredA;\n  T registeredT;\n  \n  @Inject GenericChild() {}\n  \n  @Inject A a;\n  @Inject T t;\n  \n  @Inject void registerA(A a) { this.registeredA \u003d a; }\n  @Inject void registerT(T t) { this.registeredT \u003d t; }\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\GenericComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Component;\nimport test.sub.Exposed;\nimport test.sub.PublicSubclass;\n\n@Component(modules \u003d {ChildDoubleModule.class, ChildIntegerModule.class})\ninterface GenericComponent {\n  ReferencesGeneric referencesGeneric();\n  GenericDoubleReferences\u003cA\u003e doubleGenericA();\n  GenericDoubleReferences\u003cB\u003e doubleGenericB();\n  ComplexGenerics complexGenerics();\n  GenericNoDeps\u003cA\u003e noDepsA();\n  GenericNoDeps\u003cB\u003e noDepsB();\n\n  void injectA(GenericChild\u003cA\u003e childA);\n  void injectB(GenericChild\u003cB\u003e childB);\n\n  Exposed exposed();\n  PublicSubclass publicSubclass();\n  \n  Iterable\u003cInteger\u003e iterableInt();\n  Iterable\u003cDouble\u003e iterableDouble();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\GenericDoubleReferences.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport javax.inject.Inject;\n\nclass GenericDoubleReferences\u003cT\u003e {\n  final T t;\n  final T t2;\n  final Thing a;\n  final Thing a2;\n\n  @Inject GenericDoubleReferences(T t, Thing a, T t2, Thing a2) {\n    this.t \u003d t;\n    this.a \u003d a;\n    this.t2 \u003d t2;\n    this.a2 \u003d a2;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\GenericNoDeps.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport javax.inject.Inject;\n\nclass GenericNoDeps\u003cT\u003e {\n  \n  @Inject GenericNoDeps() {}\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\GenericParent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport javax.inject.Inject;\nimport javax.inject.Provider;\n\nclass GenericParent\u003cX, Y\u003e {\n  \n  Provider\u003cX\u003e registeredX;\n  Y registeredY;\n  B registeredB;\n  \n  @Inject GenericParent() {}\n  \n  @Inject Provider\u003cX\u003e x;\n  @Inject Y y;\n  @Inject B b;\n  \n  @Inject\n  void registerX(Provider\u003cX\u003e x) {\n    this.registeredX \u003d x;\n  }\n  @Inject void registerY(Y y) { this.registeredY \u003d y; }\n  @Inject void registerB(B b) { this.registeredB \u003d b; }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\InjectedThing.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Lazy;\nimport dagger.MembersInjector;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\n\n@SuppressWarnings(\"unused\")\nfinal class InjectedThing {\n  @Inject byte primitiveByte;\n  @Inject char primitiveChar;\n  @Inject short primitiveShort;\n  @Inject int primitiveInt;\n  @Inject long primitiveLong;\n  @Inject boolean primitiveBoolean;\n  @Inject float primitiveFloat;\n  @Inject double primitiveDouble;\n\n  @Inject Provider\u003cByte\u003e byteProvider;\n  @Inject Provider\u003cCharacter\u003e charProvider;\n  @Inject Provider\u003cShort\u003e shortProvider;\n  @Inject Provider\u003cInteger\u003e intProvider;\n  @Inject Provider\u003cLong\u003e longProvider;\n  @Inject Provider\u003cBoolean\u003e booleanProvider;\n  @Inject Provider\u003cFloat\u003e floatProvider;\n  @Inject Provider\u003cDouble\u003e doubleProvider;\n\n  @Inject Lazy\u003cByte\u003e lazyByte;\n  @Inject Lazy\u003cCharacter\u003e lazyChar;\n  @Inject Lazy\u003cShort\u003e lazyShort;\n  @Inject Lazy\u003cInteger\u003e lazyInt;\n  @Inject Lazy\u003cLong\u003e lazyLong;\n  @Inject Lazy\u003cBoolean\u003e lazyBoolean;\n  @Inject Lazy\u003cFloat\u003e lazyFloat;\n  @Inject Lazy\u003cDouble\u003e lazyDouble;\n\n  @Inject Byte boxedBype;\n  @Inject Character boxedChar;\n  @Inject Short boxedShort;\n  @Inject Integer boxedInt;\n  @Inject Long boxedLong;\n  @Inject Boolean boxedBoolean;\n  @Inject Float boxedFloat;\n  @Inject Double boxedDouble;\n\n  @Inject byte[] byteArray;\n  @Inject char[] charArray;\n  @Inject short[] shortArray;\n  @Inject int[] intArray;\n  @Inject long[] longArray;\n  @Inject boolean[] booleanArray;\n  @Inject float[] floatArray;\n  @Inject double[] doubleArray;\n\n  @Inject Provider\u003cbyte[]\u003e byteArrayProvider;\n  @Inject Provider\u003cchar[]\u003e charArrayProvider;\n  @Inject Provider\u003cshort[]\u003e shortArrayProvider;\n  @Inject Provider\u003cint[]\u003e intArrayProvider;\n  @Inject Provider\u003clong[]\u003e longArrayProvider;\n  @Inject Provider\u003cboolean[]\u003e booleanArrayProvider;\n  @Inject Provider\u003cfloat[]\u003e floatArrayProvider;\n  @Inject Provider\u003cdouble[]\u003e doubleArrayProvider;\n\n  @Inject Lazy\u003cbyte[]\u003e lazyByteArray;\n  @Inject Lazy\u003cchar[]\u003e lazyCharArray;\n  @Inject Lazy\u003cshort[]\u003e lazyShortArray;\n  @Inject Lazy\u003cint[]\u003e lazyIntArray;\n  @Inject Lazy\u003clong[]\u003e lazyLongArray;\n  @Inject Lazy\u003cboolean[]\u003e lazyBooleanArray;\n  @Inject Lazy\u003cfloat[]\u003e lazy;\n  @Inject Lazy\u003cdouble[]\u003e lazyDoubleArray;\n\n  @Inject Thing thing;\n  @Inject Provider\u003cThing\u003e thingProvider;\n  @Inject Lazy\u003cThing\u003e lazyThing;\n  @Inject Provider\u003cLazy\u003cThing\u003e\u003e lazyThingProvider;\n  @Inject MembersInjector\u003cThing\u003e thingMembersInjector;\n\n  @Inject InjectedThing(\n      byte primitiveByte,\n      char primitiveChar,\n      short primitiveShort,\n      int primitiveInt,\n      long primitiveLong,\n      boolean primitiveBoolean,\n      float primitiveFloat,\n      double primitiveDouble,\n\n      Provider\u003cByte\u003e byteProvider,\n      Provider\u003cCharacter\u003e charProvider,\n      Provider\u003cShort\u003e shortProvider,\n      Provider\u003cInteger\u003e intProvider,\n      Provider\u003cLong\u003e longProvider,\n      Provider\u003cBoolean\u003e booleanProvider,\n      Provider\u003cFloat\u003e floatProvider,\n      Provider\u003cDouble\u003e doubleProvider,\n\n      Lazy\u003cByte\u003e lazyByte,\n      Lazy\u003cCharacter\u003e lazyChar,\n      Lazy\u003cShort\u003e lazyShort,\n      Lazy\u003cInteger\u003e lazyInt,\n      Lazy\u003cLong\u003e lazyLong,\n      Lazy\u003cBoolean\u003e lazyBoolean,\n      Lazy\u003cFloat\u003e lazyFloat,\n      Lazy\u003cDouble\u003e lazyDouble,\n\n      Byte boxedBype,\n      Character boxedChar,\n      Short boxedShort,\n      Integer boxedInt,\n      Long boxedLong,\n      Boolean boxedBoolean,\n      Float boxedFloat,\n      Double boxedDouble,\n\n      byte[] byteArray,\n      char[] charArray,\n      short[] shortArray,\n      int[] intArray,\n      long[] longArray,\n      boolean[] booleanArray,\n      float[] floatArray,\n      double[] doubleArray,\n\n      Provider\u003cbyte[]\u003e byteArrayProvider,\n      Provider\u003cchar[]\u003e charArrayProvider,\n      Provider\u003cshort[]\u003e shortArrayProvider,\n      Provider\u003cint[]\u003e intArrayProvider,\n      Provider\u003clong[]\u003e longArrayProvider,\n      Provider\u003cboolean[]\u003e booleanArrayProvider,\n      Provider\u003cfloat[]\u003e floatArrayProvider,\n      Provider\u003cdouble[]\u003e doubleArrayProvider,\n\n      Lazy\u003cbyte[]\u003e lazyByteArray,\n      Lazy\u003cchar[]\u003e lazyCharArray,\n      Lazy\u003cshort[]\u003e lazyShortArray,\n      Lazy\u003cint[]\u003e lazyIntArray,\n      Lazy\u003clong[]\u003e lazyLongArray,\n      Lazy\u003cboolean[]\u003e lazyBooleanArray,\n      Lazy\u003cfloat[]\u003e lazy,\n      Lazy\u003cdouble[]\u003e lazyDoubleArray,\n\n      Thing thing,\n      Provider\u003cThing\u003e thingProvider,\n      Lazy\u003cThing\u003e lazyThing,\n      MembersInjector\u003cThing\u003e thingMembersInjector) {}\n\n  @Inject void primitiveByte(byte primitiveByte) {}\n  @Inject void primitiveChar(char primitiveChar) {}\n  @Inject void primitiveShort(short primitiveShort) {}\n  @Inject void primitiveInt(int primitiveInt) {}\n  @Inject void primitiveLong(long primitiveLong) {}\n  @Inject void primitiveBoolean(boolean primitiveBoolean) {}\n  @Inject void primitiveFloat(float primitiveFloat) {}\n  @Inject void primitiveDouble(double primitiveDouble) {}\n\n  @Inject void byteProvider(Provider\u003cByte\u003e byteProvider) {}\n  @Inject void charProvider(Provider\u003cCharacter\u003e charProvider) {}\n  @Inject void shortProvider(Provider\u003cShort\u003e shortProvider) {}\n  @Inject void intProvider(Provider\u003cInteger\u003e intProvider) {}\n  @Inject void longProvider(Provider\u003cLong\u003e longProvider) {}\n  @Inject void booleanProvider(Provider\u003cBoolean\u003e booleanProvider) {}\n  @Inject void floatProvider(Provider\u003cFloat\u003e floatProvider) {}\n  @Inject void doubleProvider(Provider\u003cDouble\u003e doubleProvider) {}\n\n  @Inject void lazyByte(Lazy\u003cByte\u003e lazyByte) {}\n  @Inject void lazyChar(Lazy\u003cCharacter\u003e lazyChar) {}\n  @Inject void lazyShort(Lazy\u003cShort\u003e lazyShort) {}\n  @Inject void lazyInt(Lazy\u003cInteger\u003e lazyInt) {}\n  @Inject void lazyLong(Lazy\u003cLong\u003e lazyLong) {}\n  @Inject void lazyBoolean(Lazy\u003cBoolean\u003e lazyBoolean) {}\n  @Inject void lazyFloat(Lazy\u003cFloat\u003e lazyFloat) {}\n  @Inject void lazyDouble(Lazy\u003cDouble\u003e lazyDouble) {}\n\n  @Inject void boxedBype(Byte boxedBype) {}\n  @Inject void boxedChar(Character boxedChar) {}\n  @Inject void boxedShort(Short boxedShort) {}\n  @Inject void boxedInt(Integer boxedInt) {}\n  @Inject void boxedLong(Long boxedLong) {}\n  @Inject void boxedBoolean(Boolean boxedBoolean) {}\n  @Inject void boxedFloat(Float boxedFloat) {}\n  @Inject void boxedDouble(Double boxedDouble) {}\n\n  @Inject void byteArray(byte[] byteArray) {}\n  @Inject void charArray(char[] charArray) {}\n  @Inject void shortArray(short[] shortArray) {}\n  @Inject void intArray(int[] intArray) {}\n  @Inject void longArray(long[] longArray) {}\n  @Inject void booleanArray(boolean[] booleanArray) {}\n  @Inject void floatArray(float[] floatArray) {}\n  @Inject void doubleArray(double[] doubleArray) {}\n\n  @Inject void byteArrayProvider(Provider\u003cbyte[]\u003e byteArrayProvider) {}\n  @Inject void charArrayProvider(Provider\u003cchar[]\u003e charArrayProvider) {}\n  @Inject void shortArrayProvider(Provider\u003cshort[]\u003e shortArrayProvider) {}\n  @Inject void intArrayProvider(Provider\u003cint[]\u003e intArrayProvider) {}\n  @Inject void longArrayProvider(Provider\u003clong[]\u003e longArrayProvider) {}\n  @Inject void booleanArrayProvider(Provider\u003cboolean[]\u003e booleanArrayProvider) {}\n  @Inject void floatArrayProvider(Provider\u003cfloat[]\u003e floatArrayProvider) {}\n  @Inject void doubleArrayProvider(Provider\u003cdouble[]\u003e doubleArrayProvider) {}\n\n  @Inject void lazyByteArray(Lazy\u003cbyte[]\u003e lazyByteArray) {}\n  @Inject void lazyCharArray(Lazy\u003cchar[]\u003e lazyCharArray) {}\n  @Inject void lazyShortArray(Lazy\u003cshort[]\u003e lazyShortArray) {}\n  @Inject void lazyIntArray(Lazy\u003cint[]\u003e lazyIntArray) {}\n  @Inject void lazyLongArray(Lazy\u003clong[]\u003e lazyLongArray) {}\n  @Inject void lazyBooleanArray(Lazy\u003cboolean[]\u003e lazyBooleanArray) {}\n  @Inject void lazy(Lazy\u003cfloat[]\u003e lazy) {}\n  @Inject void lazyDoubleArray(Lazy\u003cdouble[]\u003e lazyDoubleArray) {}\n\n  @Inject void thing(Thing thing) {}\n  @Inject void thingProvider(Provider\u003cThing\u003e thingProvider) {}\n  @Inject void lazyThing(Lazy\u003cThing\u003e lazyThing) {}\n  @Inject void thingMembersInjector(MembersInjector\u003cThing\u003e thingMembersInjector) {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\Injector.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Lazy;\nimport dagger.MembersInjector;\nimport javax.inject.Provider;\n\n/**\n * A simple interface that exercises all forms of injection for a given type.\n */\ninterface Injector\u003cT\u003e {\n  T instance();\n  Provider\u003cT\u003e provider();\n  Lazy\u003cT\u003e lazy();\n  MembersInjector\u003cT\u003e membersInjector();\n  void injectMembers(T t);\n  T injectMembersAndReturn(T t);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\membersinject\\ChildOfArrayOfParentOfStringArray.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.membersinject;\n\nclass ChildOfArrayOfParentOfStringArray extends\n    MembersInjectGenericParent\u003cMembersInjectGenericParent\u003cString[]\u003e[]\u003e {\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\membersinject\\ChildOfPrimitiveIntArray.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.membersinject;\n\nclass ChildOfPrimitiveIntArray extends MembersInjectGenericParent\u003cint[]\u003e {\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\membersinject\\ChildOfStringArray.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.membersinject;\n\nclass ChildOfStringArray extends MembersInjectGenericParent\u003cString[]\u003e {\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\membersinject\\MembersInjectComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.membersinject;\n\nimport dagger.Component;\n\n@Component(modules \u003d {MembersInjectModule.class})\ninterface MembersInjectComponent {\n  \n  void inject(ChildOfStringArray subfoo);\n  void inject(ChildOfArrayOfParentOfStringArray subfoo);\n  void inject(ChildOfPrimitiveIntArray subfoo);\n  void inject(RawFrameworkTypes rawFrameworkTypes);\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\membersinject\\MembersInjectGenericParent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.membersinject;\n\nimport javax.inject.Inject;\n\nclass MembersInjectGenericParent\u003cT\u003e {\n  \n  @Inject T t; \n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\membersinject\\MembersInjectModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.membersinject;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\nclass MembersInjectModule {\n  \n  @Provides String[] provideStringArray() { return new String[10]; }\n  \n  @Provides int[] provideIntArray() { return new int[10]; }\n  \n  @SuppressWarnings(\"unchecked\")\n  @Provides MembersInjectGenericParent\u003cString[]\u003e[] provideFooArrayOfStringArray() { return new MembersInjectGenericParent[10]; }\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\membersinject\\NonRequestedChild.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.membersinject;\n\nimport javax.inject.Inject;\n\n/**\n * A class that should not be requested by any component, to ensure that we still generate a members\n * injector for it.\n */\nclass NonRequestedChild extends MembersInjectGenericParent\u003cString\u003e {\n  @Inject\n  NonRequestedChild() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\membersinject\\RawFrameworkTypes.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.membersinject;\n\nimport dagger.Lazy;\nimport dagger.MembersInjector;\nimport javax.inject.Provider;\n\n// https://github.com/google/dagger/issues/419\n@SuppressWarnings({\"rawtypes\", \"unused\"})\nclass RawFrameworkTypes {\n  void nonInjectMethodWithARawProvider(Provider rawProvider) {}\n  void nonInjectMethodWithARawLazy(Lazy rawLazy) {}\n  void nonInjectMethodWithARawMembersInjector(MembersInjector rawMembersInjector) {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ModuleIncludesCollectedFromModuleSuperclasses.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Component;\nimport dagger.Module;\nimport dagger.Provides;\n\n/**\n * This tests that @Module.includes are traversed for supertypes of a module.\n */\nfinal class ModuleIncludesCollectedFromModuleSuperclasses {\n  @Component(modules \u003d TopLevelModule.class)\n  interface C {\n    Foo\u003cString\u003e foo();\n    int includedInTopLevelModule();\n    String includedFromModuleInheritance();\n  }\n\n  @Module(includes \u003d IncludedTopLevel.class)\n  static class TopLevelModule extends FooModule\u003cString\u003e {}\n\n  static class Foo\u003cT\u003e {}\n\n  @Module(includes \u003d IncludedFromModuleInheritance.class)\n  abstract static class FooModule\u003cT\u003e extends FooCreator {\n    @Provides Foo\u003cT\u003e fooOfT() {\n      return createFoo();\n    }\n  }\n\n  static class FooCreator {\n    \u003cT\u003e Foo\u003cT\u003e createFoo() {\n      return new Foo\u003cT\u003e();\n    }\n  }\n\n  @Module\n  static class IncludedTopLevel {\n    @Provides int i() {\n      return 123;\n    }\n  }\n\n  @Module\n  static class IncludedFromModuleInheritance {\n    @Provides String inheritedProvision() {\n      return \"inherited\";\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ModuleWithConflictingNames.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\n\n/**\n * Module with bindings that might result in generated factories with conflicting field and\n * parameter names.\n */\n@Module\nfinal class ModuleWithConflictingNames {\n  @Provides\n  static Object object(int foo, Provider\u003cString\u003e fooProvider) {\n    return foo + fooProvider.get();\n  }\n\n  /**\n   * A class that might result in a generated factory with conflicting field and parameter names.\n   */\n  static class InjectedClassWithConflictingNames {\n    final int foo;\n    final Provider\u003cString\u003e fooProvider;\n\n    @Inject\n    InjectedClassWithConflictingNames(int foo, Provider\u003cString\u003e fooProvider) {\n      this.foo \u003d foo;\n      this.fooProvider \u003d fooProvider;\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\MultibindingComponent.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.Component;\nimport dagger.multibindings.StringKey;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport test.sub.ContributionsModule;\n\n@Component(\n  modules \u003d {MultibindingModule.class, MultibindsModule.class, ContributionsModule.class},\n  dependencies \u003d MultibindingDependency.class\n)\ninterface MultibindingComponent {\n  Map\u003cString, String\u003e map();\n  Map\u003cString, String[]\u003e mapOfArrays();\n  Map\u003cString, Provider\u003cString\u003e\u003e mapOfProviders();\n  Set\u003cString\u003e mapKeys();\n  Collection\u003cString\u003e mapValues();\n  Set\u003cInteger\u003e set();\n  Map\u003cNestedAnnotationContainer.NestedWrappedKey, String\u003e nestedKeyMap();\n  Map\u003cClass\u003c? extends Number\u003e, String\u003e numberClassKeyMap();\n  Map\u003cClass\u003c?\u003e, String\u003e classKeyMap();\n  Map\u003cLong, String\u003e longKeyMap();\n  Map\u003cInteger, String\u003e integerKeyMap();\n  Map\u003cShort, String\u003e shortKeyMap();\n  Map\u003cByte, String\u003e byteKeyMap();\n  Map\u003cBoolean, String\u003e booleanKeyMap();\n  Map\u003cCharacter, String\u003e characterKeyMap();\n  Map\u003cStringKey, String\u003e unwrappedAnnotationKeyMap();\n  Map\u003cWrappedAnnotationKey, String\u003e wrappedAnnotationKeyMap();\n  @Named(\"complexQualifier\") Set\u003cString\u003e complexQualifierStringSet();\n  Set\u003cObject\u003e emptySet();\n\n  @Named(\"complexQualifier\")\n  Set\u003cObject\u003e emptyQualifiedSet();\n\n  Map\u003cString, Object\u003e emptyMap();\n\n  @Named(\"complexQualifier\")\n  Map\u003cString, Object\u003e emptyQualifiedMap();\n\n  Set\u003cCharSequence\u003e maybeEmptySet();\n\n  @Named(\"complexQualifier\")\n  Set\u003cCharSequence\u003e maybeEmptyQualifiedSet();\n\n  Map\u003cString, CharSequence\u003e maybeEmptyMap();\n\n  @Named(\"complexQualifier\")\n  Map\u003cString, CharSequence\u003e maybeEmptyQualifiedMap();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\MultibindingComponentWithMultibindingsInterface.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Component;\nimport dagger.Multibindings;\nimport test.sub.ContributionsModule;\n\n/**\n * A component used to test multibindings that use {@link Multibindings @Multibindings}-annotated\n * nested interfaces to declare multibindings.\n */\n@Component(\n  modules \u003d {\n    MultibindingModule.class,\n    MultibindingsInterfaceModule.class,\n    ContributionsModule.class\n  },\n  dependencies \u003d MultibindingDependency.class\n)\ninterface MultibindingComponentWithMultibindingsInterface extends MultibindingComponent {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\MultibindingDependency.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\ninterface MultibindingDependency {\n  double doubleDependency();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\MultibindingModule.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.ClassKey;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntKey;\nimport dagger.multibindings.IntoMap;\nimport dagger.multibindings.IntoSet;\nimport dagger.multibindings.LongKey;\nimport dagger.multibindings.StringKey;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.inject.Named;\nimport javax.inject.Provider;\n\n@Module\nclass MultibindingModule {\n  @Provides\n  @IntoMap\n  @StringKey(\"foo\")\n  static String provideFooKey(@SuppressWarnings(\"unused\") double doubleDependency) {\n    return \"foo value\";\n  }\n\n  @Provides\n  @IntoMap\n  @StringKey(\"foo @Provides(type)\")\n  static String provideFooProvidesTypeKey(@SuppressWarnings(\"unused\") double doubleDependency) {\n    return \"foo @Provides(type) value\";\n  }\n\n  @Provides\n  @IntoMap\n  @StringKey(\"bar\")\n  static String provideBarKey() {\n    return \"bar value\";\n  }\n\n  @Provides\n  @IntoMap\n  @StringKey(\"foo\")\n  static String[] provideFooArrayValue(@SuppressWarnings(\"unused\") double doubleDependency) {\n    return new String[] {\"foo1\", \"foo2\"};\n  }\n\n  @Provides\n  @IntoMap\n  @StringKey(\"bar\")\n  static String[] provideBarArrayValue() {\n    return new String[] {\"bar1\", \"bar2\"};\n  }\n\n  @Provides\n  @IntoSet\n  static int provideFiveToSet() {\n    return 5;\n  }\n\n  @Provides\n  @IntoSet\n  static int provideSixToSet() {\n    return 6;\n  }\n\n  @Provides\n  @IntoSet\n  static int provideIntoSetWithProvidesType() {\n    return -100;\n  }\n\n  @Provides\n  @ElementsIntoSet\n  static Set\u003cInteger\u003e provideElementsIntoSetWithProvidesType() {\n    Set\u003cInteger\u003e set \u003d new HashSet\u003c\u003e();\n    set.add(-101);\n    set.add(-102);\n    return set;\n  }\n\n  @Provides\n  static Set\u003cString\u003e provideMapKeys(Map\u003cString, Provider\u003cString\u003e\u003e map) {\n    return map.keySet();\n  }\n\n  @Provides\n  static Collection\u003cString\u003e provideMapValues(Map\u003cString, String\u003e map) {\n    return map.values();\n  }\n\n  @Provides\n  @IntoMap\n  @NestedAnnotationContainer.NestedWrappedKey(Integer.class)\n  static String valueForInteger() {\n    return \"integer\";\n  }\n\n  @Provides\n  @IntoMap\n  @NestedAnnotationContainer.NestedWrappedKey(Long.class)\n  static String valueForLong() {\n    return \"long\";\n  }\n\n  @Provides\n  @IntoMap\n  @ClassKey(Integer.class)\n  static String valueForClassInteger() {\n    return \"integer\";\n  }\n\n  @Provides\n  @IntoMap\n  @ClassKey(Long.class)\n  static String valueForClassLong() {\n    return \"long\";\n  }\n\n  @Provides\n  @IntoMap\n  @NumberClassKey(BigDecimal.class)\n  static String valueForNumberClassBigDecimal() {\n    return \"bigdecimal\";\n  }\n\n  @Provides\n  @IntoMap\n  @NumberClassKey(BigInteger.class)\n  static String valueForNumberClassBigInteger() {\n    return \"biginteger\";\n  }\n\n  @Provides\n  @IntoMap\n  @LongKey(100)\n  static String valueFor100Long() {\n    return \"100 long\";\n  }\n\n  @Provides\n  @IntoMap\n  @IntKey(100)\n  static String valueFor100Int() {\n    return \"100 int\";\n  }\n\n  @Provides\n  @IntoMap\n  @ShortKey(100)\n  static String valueFor100Short() {\n    return \"100 short\";\n  }\n\n  @Provides\n  @IntoMap\n  @ByteKey(100)\n  static String valueFor100Byte() {\n    return \"100 byte\";\n  }\n\n  @Provides\n  @IntoMap\n  @BooleanKey(true)\n  static String valueForTrue() {\n    return \"true\";\n  }\n\n  @Provides\n  @IntoMap\n  @CharKey(\u0027a\u0027)\n  static String valueForA() {\n    return \"a char\";\n  }\n\n  @Provides\n  @IntoMap\n  @CharKey(\u0027\\n\u0027)\n  static String valueForNewline() {\n    return \"newline char\";\n  }\n\n  @Provides\n  @IntoMap\n  @UnwrappedAnnotationKey(@StringKey(\"foo\\n\"))\n  static String valueForUnwrappedAnnotationKeyFoo() {\n    return \"foo annotation\";\n  }\n\n  @Provides\n  @IntoMap\n  @WrappedAnnotationKey(\n    value \u003d @StringKey(\"foo\"),\n    integers \u003d {1, 2, 3},\n    annotations \u003d {},\n    classes \u003d {Long.class, Integer.class}\n  )\n  static String valueForWrappedAnnotationKeyFoo() {\n    return \"wrapped foo annotation\";\n  }\n\n  @Provides\n  @IntoSet\n  @Named(\"complexQualifier\")\n  static String valueForComplexQualifierSet() {\n    return \"foo\";\n  }\n\n  @Provides\n  @IntoSet\n  static CharSequence setContribution() {\n    return \"foo\";\n  }\n\n  @Provides\n  @IntoSet\n  @Named(\"complexQualifier\")\n  static CharSequence qualifiedSetContribution() {\n    return \"qualified foo\";\n  }\n\n  @Provides\n  @IntoMap\n  @StringKey(\"key\")\n  static CharSequence mapContribution() {\n    return \"foo value\";\n  }\n\n  @Provides\n  @IntoMap\n  @Named(\"complexQualifier\")\n  @StringKey(\"key\")\n  static CharSequence qualifiedMapContribution() {\n    return \"qualified foo value\";\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\MultibindingsInterfaceModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Module;\nimport dagger.Multibindings;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.inject.Named;\n\n/**\n * A module that uses a {@link Multibindings @Multibindings}-annotated nested interface to declare\n * multibindings.\n */\n@Module\nfinal class MultibindingsInterfaceModule {\n\n  interface EmptiesSupertype {\n    Set\u003cObject\u003e emptySet();\n\n    Map\u003cString, Object\u003e emptyMap();\n\n    Set\u003cCharSequence\u003e set();\n\n    Map\u003cString, CharSequence\u003e map();\n  }\n\n  @Multibindings\n  interface Empties extends EmptiesSupertype {\n    @Named(\"complexQualifier\")\n    Set\u003cObject\u003e emptyQualifiedSet();\n\n    @Named(\"complexQualifier\")\n    Map\u003cString, Object\u003e emptyQualifiedMap();\n\n    @Named(\"complexQualifier\")\n    Set\u003cCharSequence\u003e qualifiedSet();\n\n    @Named(\"complexQualifier\")\n    Map\u003cString, CharSequence\u003e qualifiedMap();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\MultibindsModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Module;\nimport dagger.multibindings.Multibinds;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.inject.Named;\n\n/**\n * A module that uses {@link Multibinds @Multibinds}-annotated abstract methods to declare\n * multibindings.\n */\n@Module\nabstract class MultibindsModule {\n\n  @Multibinds\n  abstract Set\u003cObject\u003e emptySet();\n\n  @Multibinds\n  abstract Map\u003cString, Object\u003e emptyMap();\n\n  @Multibinds\n  abstract Set\u003cCharSequence\u003e set();\n\n  @Multibinds\n  abstract Map\u003cString, CharSequence\u003e map();\n\n  @Multibinds\n  @Named(\"complexQualifier\")\n  abstract Set\u003cObject\u003e emptyQualifiedSet();\n\n  @Multibinds\n  @Named(\"complexQualifier\")\n  abstract Map\u003cString, Object\u003e emptyQualifiedMap();\n\n  @Multibinds\n  @Named(\"complexQualifier\")\n  abstract Set\u003cCharSequence\u003e qualifiedSet();\n\n  @Multibinds\n  @Named(\"complexQualifier\")\n  abstract Map\u003cString, CharSequence\u003e qualifiedMap();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\a\\AGrandchild.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.a;\n\nimport javax.inject.Inject;\nimport test.multipackage.b.BChild;\n\npublic class AGrandchild extends BChild {\n\n  @Inject APackagePrivateObject aGrandchildField;\n\n  private APackagePrivateObject aGrandchildMethod;\n\n  @Inject\n  void aGrandchildMethod(APackagePrivateObject aGrandchildMethod) {\n    this.aGrandchildMethod \u003d aGrandchildMethod;\n  }\n\n  @Override\n  @Inject\n  protected void aParentMethod(APublicObject aParentMethod) {\n    super.aParentMethod(aParentMethod);\n  }\n\n  @SuppressWarnings(\"OverridesJavaxInjectableMethod\")\n  @Override\n  protected void aChildMethod(APublicObject aChildMethod) {\n    super.aChildMethod(aChildMethod);\n  }\n\n  public APackagePrivateObject aGrandchildField() {\n    return aGrandchildField;\n  }\n\n  public APackagePrivateObject aGrandchildMethod() {\n    return aGrandchildMethod;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\a\\AModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.a;\n\nimport dagger.Binds;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntoMap;\nimport dagger.multibindings.IntoSet;\nimport dagger.multibindings.StringKey;\nimport java.util.HashSet;\nimport java.util.Set;\n\n@Module\npublic abstract class AModule {\n  @Provides\n  @IntoSet\n  static String provideString() {\n    return \"a\";\n  }\n\n  @Binds\n  @IntoSet\n  abstract Inaccessible provideInaccessible(Inaccessible inaccessible);\n\n  @Provides\n  @ElementsIntoSet\n  static Set\u003cInaccessible\u003e provideSetOfInaccessibles() {\n    return new HashSet\u003c\u003e();\n  }\n\n  @Binds\n  @IntoMap\n  @StringKey(\"inaccessible\")\n  abstract Inaccessible provideInaccessibleToMap(Inaccessible inaccessible);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\a\\AMultibindsModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.a;\n\nimport dagger.Module;\nimport dagger.multibindings.Multibinds;\nimport java.util.Map;\nimport java.util.Set;\n\n/** A module that {@code @Multibinds} a set and a map of {@link Inaccessible}. */\n@Module\npublic abstract class AMultibindsModule {\n  @Multibinds\n  abstract Set\u003cInaccessible\u003e inaccessibleSet();\n\n  @Multibinds\n  abstract Map\u003cString, Inaccessible\u003e inaccessibleMap();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\a\\APackagePrivateObject.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.a;\n\nimport javax.inject.Inject;\n\nclass APackagePrivateObject {\n\n  @Inject\n  APackagePrivateObject() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\a\\AParent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.a;\n\nimport javax.inject.Inject;\n\npublic class AParent {\n\n  @Inject APackagePrivateObject aParentField;\n\n  private APublicObject aParentMethod;\n\n  @Inject\n  protected void aParentMethod(APublicObject aParentMethod) {\n    this.aParentMethod \u003d aParentMethod;\n  }\n\n  public APackagePrivateObject aParentField() {\n    return aParentField;\n  }\n\n  public APublicObject aParentMethod() {\n    return aParentMethod;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\a\\APublicObject.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.a;\n\nimport javax.inject.Inject;\n\npublic class APublicObject {\n\n  @Inject\n  APublicObject() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\a\\Inaccessible.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.a;\n\nimport javax.inject.Inject;\n\nfinal class Inaccessible {\n  @Inject Inaccessible() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\a\\UsesInaccessible.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.a;\n\nimport java.util.Map;\nimport java.util.Set;\nimport javax.inject.Inject;\n\n@SuppressWarnings(\"unused\")\npublic class UsesInaccessible {\n  @Inject\n  UsesInaccessible(\n      Inaccessible inaccessible,\n      Set\u003cInaccessible\u003e inaccessibleSet,\n      Map\u003cString, Inaccessible\u003e inaccessibleMap) {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\b\\BChild.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.b;\n\nimport javax.inject.Inject;\nimport test.multipackage.a.AParent;\nimport test.multipackage.a.APublicObject;\n\npublic class BChild extends AParent {\n\n  @Inject BPackagePrivateObject aChildField;\n\n  private APublicObject aChildMethod;\n\n  @Inject\n  protected void aChildMethod(APublicObject aChildMethod) {\n    this.aChildMethod \u003d aChildMethod;\n  }\n\n  @SuppressWarnings(\"OverridesJavaxInjectableMethod\")\n  @Override\n  protected void aParentMethod(APublicObject aParentMethod) {\n    super.aParentMethod(aParentMethod);\n  }\n\n  public BPackagePrivateObject aChildField() {\n    return aChildField;\n  }\n\n  public APublicObject aChildMethod() {\n    return aChildMethod;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\b\\BModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.b;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.IntoSet;\n\n@Module\npublic final class BModule {\n  @Provides\n  @IntoSet\n  static String provideString() {\n    return \"b\";\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\b\\BPackagePrivateObject.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.b;\n\nimport javax.inject.Inject;\n\nclass BPackagePrivateObject {\n\n  @Inject\n  BPackagePrivateObject() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\c\\CModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.c;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.IntoSet;\n\n@Module\npublic final class CModule {\n  @Provides\n  @IntoSet\n  static String provideString() {\n    return \"c\";\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\d\\DModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.d;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.IntoSet;\n\n@Module\npublic final class DModule {\n  @Provides\n  @IntoSet\n  static String provideString() {\n    return \"d\";\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\foo\\Foo.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.foo;\n\nimport java.util.Set;\nimport javax.inject.Inject;\n\npublic final class Foo\u003cT\u003e {\n  public final Set\u003cString\u003e strings;\n\n  @Inject Foo(Set\u003cString\u003e strings) {\n    this.strings \u003d strings;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\FooComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage;\n\nimport dagger.Component;\nimport java.util.Set;\nimport test.multipackage.a.AModule;\nimport test.multipackage.a.UsesInaccessible;\nimport test.multipackage.sub.FooChildComponent;\n\n/**\n * A component that tests the interaction between subcomponents, multiple packages, and\n * multibindings. Specifically, we want:\n * \u003cul\u003e\n * \u003cli\u003eA set binding with some contributions in the parent component, and some in the subcomponent.\n * \u003cli\u003eThe contributions come from different packages, but not the package of either component.\n * \u003cli\u003eThe set binding is requested in the subcomponent through a binding from a separate package.\n * \u003cli\u003eNo binding in the subcomponent, that\u0027s in the subcomponent\u0027s package, directly uses any\n *     binding from the component\u0027s package.\n * \u003c/ul\u003e\n */\n// NOTE(beder): Be careful about changing any bindings in either this component or the subcomponent.\n// Even adding a binding might stop this test from testing what it\u0027s supposed to test.\n@Component(modules \u003d {AModule.class})\ninterface FooComponent {\n  Set\u003cString\u003e setOfString();\n\n  FooChildComponent fooChildComponent();\n\n  UsesInaccessible usesInaccessible();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\grandsub\\FooGrandchildComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.grandsub;\n\nimport dagger.Subcomponent;\nimport test.multipackage.d.DModule;\nimport test.multipackage.foo.Foo;\n\n@Subcomponent(modules \u003d DModule.class)\npublic interface FooGrandchildComponent {\n  Foo\u003cFooGrandchildComponent\u003e foo();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\MembersInjectionVisibilityComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage;\n\nimport dagger.Component;\nimport test.multipackage.a.AGrandchild;\nimport test.multipackage.a.AModule;\nimport test.multipackage.a.AParent;\nimport test.multipackage.b.BChild;\n\n/**\n * A component that tests members injection across packages and subclasses.\n */\n@Component(modules \u003d {AModule.class})\npublic interface MembersInjectionVisibilityComponent {\n  void inject(AParent aParent);\n\n  void inject(BChild aChild);\n\n  void inject(AGrandchild aGrandchild);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\MultibindsComponent.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage;\n\nimport dagger.Component;\nimport test.multipackage.a.AMultibindsModule;\nimport test.multipackage.a.UsesInaccessible;\n\n/**\n * A component that tests the interaction between multiple packages and {@code @Multibinding}s.\n * Specifically, we want:\n *\n * \u003cul\u003e\n * \u003cli\u003eA {@code @Multibinding} for an empty set of a type not accessible from this package.\n * \u003cli\u003eA {@code @Multibinding} for an empty map of a type not accessible from this package.\n * \u003cli\u003eA public type that injects the empty set and map of inaccessible objects.\n * \u003c/ul\u003e\n */\n@Component(modules \u003d {AMultibindsModule.class})\ninterface MultibindsComponent {\n  UsesInaccessible usesInaccessible();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\multipackage\\sub\\FooChildComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.multipackage.sub;\n\nimport dagger.Subcomponent;\nimport test.multipackage.b.BModule;\nimport test.multipackage.c.CModule;\nimport test.multipackage.foo.Foo;\nimport test.multipackage.grandsub.FooGrandchildComponent;\n\n@Subcomponent(modules \u003d {BModule.class, CModule.class})\npublic interface FooChildComponent {\n  Foo\u003cFooChildComponent\u003e foo();\n\n  FooGrandchildComponent fooGrandchildComponent();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\NeedsFactory.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport com.google.auto.factory.AutoFactory;\nimport javax.inject.Inject;\n\nclass NeedsFactory {\n  @Inject\n  NeedsFactory(@SuppressWarnings(\"unused\") NeedsFactory_SomethingFactory somethingFactory) {}\n\n  @AutoFactory\n  static class Something {}\n}\n\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\NestedAnnotationContainer.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.MapKey;\n\npublic final class NestedAnnotationContainer {\n\n  @MapKey(unwrapValue \u003d false)\n  @interface NestedWrappedKey {\n    Class\u003c?\u003e value();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\NonComponentDependencyComponent.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.Component;\nimport javax.inject.Inject;\nimport test.sub.OtherThing;\n\n@Component(dependencies \u003d {NonComponentDependencyComponent.ThingComponent.class})\ninterface NonComponentDependencyComponent {\n  ThingTwo thingTwo();\n\n  static class ThingTwo {\n    @SuppressWarnings(\"unused\")\n    @Inject\n    ThingTwo(\n        Thing thing,\n        NonComponentDependencyComponent nonComponentDependencyComponent,\n        NonComponentDependencyComponent.ThingComponent thingComponent) {}\n  }\n\n  // A non-component interface which this interface depends upon.\n  interface ThingComponent {\n    Thing thing();\n  }\n\n  // The implementation for that interface.\n  static class ThingComponentImpl implements ThingComponent {\n    @Override\n    public Thing thing() {\n      return new Thing(new OtherThing(1));\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\NullableModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\nfinal class NullableModule {\n  /**\n   * A {@code Nullable} that isn\u0027t {@link javax.annotation.Nullable}, to ensure that Dagger can be\n   * built without depending on JSR-305.\n   */\n  @interface Nullable {}\n\n  @Provides\n  @Nullable\n  static Object nullObject() {\n    return null;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\nullables\\Nullable.java",
    "code": "\"package test.nullables;\n\n@interface Nullable {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\nullables\\NullComponent.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test.nullables;\n\nimport dagger.Component;\nimport javax.inject.Provider;\n\n@Component(modules \u003d NullModule.class)\ninterface NullComponent {\n  NullFoo nullFoo();\n  @Nullable String string();\n  Provider\u003cString\u003e stringProvider();\n  Number number();\n  Provider\u003cNumber\u003e numberProvider();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\nullables\\NullComponentWithDependency.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test.nullables;\n\nimport dagger.Component;\nimport javax.inject.Provider;\n\n@Component(dependencies \u003d NullComponent.class)\ninterface NullComponentWithDependency {\n  @Nullable String string();\n  Provider\u003cString\u003e stringProvider();\n  Number number();\n  Provider\u003cNumber\u003e numberProvider();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\nullables\\NullFoo.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test.nullables;\n\nimport javax.inject.Inject;\nimport javax.inject.Provider;\n\nclass NullFoo {\n  final String string;\n  final Provider\u003cString\u003e stringProvider;\n  final Number number;\n  final Provider\u003cNumber\u003e numberProvider;\n\n  @Inject\n  NullFoo(@Nullable String string,\n      Provider\u003cString\u003e stringProvider,\n      Number number,\n      Provider\u003cNumber\u003e numberProvider) {\n    this.string \u003d string;\n    this.stringProvider \u003d stringProvider;\n    this.number \u003d number;\n    this.numberProvider \u003d numberProvider;\n  }\n\n  String methodInjectedString;\n  Provider\u003cString\u003e methodInjectedStringProvider;\n  Number methodInjectedNumber;\n  Provider\u003cNumber\u003e methodInjectedNumberProvider;\n  @Inject void inject(@Nullable String string,\n      Provider\u003cString\u003e stringProvider,\n      Number number,\n      Provider\u003cNumber\u003e numberProvider) {\n    this.methodInjectedString \u003d string;\n    this.methodInjectedStringProvider \u003d stringProvider;\n    this.methodInjectedNumber \u003d number;\n    this.methodInjectedNumberProvider \u003d numberProvider;\n  }\n\n  @Nullable @Inject String fieldInjectedString;\n  @Inject Provider\u003cString\u003e fieldInjectedStringProvider;\n  @Inject Number fieldInjectedNumber;\n  @Inject Provider\u003cNumber\u003e fieldInjectedNumberProvider;\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\nullables\\NullModule.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test.nullables;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\nclass NullModule {\n  Number numberValue \u003d null;\n\n  @Nullable\n  @Provides\n  String provideNullableString() {\n    return null;\n  }\n\n  @Provides\n  Number provideNumber() {\n    return numberValue;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\NumberClassKey.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.MapKey;\n\n@MapKey(unwrapValue \u003d true)\n@interface NumberClassKey {\n  Class\u003c? extends Number\u003e value();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\OuterClassBar.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Component;\n\nfinal class OuterClassBar {\n  @Component(modules \u003d PrimitivesModule.class)\n  interface NestedComponent {\n    InjectedThing injectedThing();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\OuterClassFoo.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport dagger.Component;\n\nfinal class OuterClassFoo {\n  @Component(modules \u003d PrimitivesModule.class)\n  interface NestedComponent {\n    Thing thing();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ParentModule.java",
    "code": "\"package test;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\n@Module\nabstract class ParentModule\u003cA extends Number \u0026 Comparable\u003cA\u003e, B, C extends Iterable\u003cA\u003e\u003e {\n  @Provides Iterable\u003cA\u003e provideIterableOfAWithC(A a, C c) {\n    List\u003cA\u003e list \u003d new ArrayList\u003c\u003e();\n    list.add(a);\n    for (A elt : c) {\n      list.add(elt);\n    }\n    return list;\n  }\n\n  @Provides static char provideNonGenericBindingInParameterizedModule() {\n    return \u0027c\u0027;\n  }\n\n  @Provides\n  static List\u003cSet\u003cString\u003e\u003e provideStaticGenericTypeWithNoTypeParametersInParameterizedModule() {\n    return new ArrayList\u003c\u003e();\n  }\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\PrimitivesModule.java",
    "code": "\"package test;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\nfinal class PrimitivesModule {\n  static final byte BOUND_BYTE \u003d -41;\n  static final char BOUND_CHAR \u003d \u0027g\u0027;\n  static final short BOUND_SHORT \u003d 21840;\n  static final int BOUND_INT \u003d 1894833693;\n  static final long BOUND_LONG \u003d -4369839828653523584L;\n  static final boolean BOUND_BOOLEAN \u003d true;\n  static final float BOUND_FLOAT \u003d (float) 0.9964542;\n  static final double BOUND_DOUBLE \u003d 0.12681322049667765;\n\n  /*\n   * While we can\u0027t ensure that these constants stay constant, this is a test so we\u0027re just going to\n   * keep our fingers crossed that we\u0027re not going to be jerks.\n   */\n  static final byte[] BOUND_BYTE_ARRAY \u003d  {1, 2, 3};\n  static final char[] BOUND_CHAR_ARRAY \u003d {\u0027g\u0027, \u0027a\u0027, \u0027k\u0027};\n  static final short[] BOUND_SHORT_ARRAY \u003d {2, 4};\n  static final int[] BOUND_INT_ARRAY \u003d {3, 1, 2};\n  static final long[] BOUND_LONG_ARRAY \u003d {1, 1, 2, 3, 5};\n  static final boolean[] BOUND_BOOLEAN_ARRAY \u003d {false, true, false, false};\n  static final float[] BOUND_FLOAT_ARRAY \u003d {(float) 0.1, (float) 0.01, (float) 0.001};\n  static final double[] BOUND_DOUBLE_ARRAY \u003d {0.2, 0.02, 0.002};\n\n  @Provides static byte provideByte() {\n    return BOUND_BYTE;\n  }\n\n  @Provides static char provideChar() {\n    return BOUND_CHAR;\n  }\n\n  @Provides static short provideShort() {\n    return BOUND_SHORT;\n  }\n\n  @Provides static int provideInt() {\n    return BOUND_INT;\n  }\n\n  @Provides static long provideLong() {\n    return BOUND_LONG;\n  }\n\n  @Provides static boolean provideBoolean() {\n    return BOUND_BOOLEAN;\n  }\n\n  @Provides static float provideFloat() {\n    return BOUND_FLOAT;\n  }\n\n  @Provides static double boundDouble() {\n    return BOUND_DOUBLE;\n  }\n\n  @Provides static byte[] provideByteArray() {\n    return BOUND_BYTE_ARRAY;\n  }\n\n  @Provides static char[] provideCharArray() {\n    return BOUND_CHAR_ARRAY;\n  }\n\n  @Provides static short[] provideShortArray() {\n    return BOUND_SHORT_ARRAY;\n  }\n\n  @Provides static int[] provideIntArray() {\n    return BOUND_INT_ARRAY;\n  }\n\n  @Provides static long[] provideLongArray() {\n    return BOUND_LONG_ARRAY;\n  }\n\n  @Provides static boolean[] provideBooleanArray() {\n    return BOUND_BOOLEAN_ARRAY;\n  }\n\n  @Provides static float[] provideFloatArray() {\n    return BOUND_FLOAT_ARRAY;\n  }\n\n  @Provides static double[] boundDoubleArray() {\n    return BOUND_DOUBLE_ARRAY;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ReferencesGeneric.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport javax.inject.Inject;\n\nclass ReferencesGeneric {\n  final Generic\u003cA\u003e genericA;\n  \n  @Inject ReferencesGeneric(Generic\u003cA\u003e genericA) {\n    this.genericA \u003d genericA;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\scope\\BlueModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.scope;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.IntoSet;\n\n@Module\nfinal class BlueModule {\n  @Provides\n  @IntoSet\n  @BlueScope\n  static Object blue() {\n    return new Object();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\scope\\BlueScope.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.scope;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport javax.inject.Scope;\n\n@Documented\n@Retention(RUNTIME)\n@Scope\n@interface BlueScope {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\scope\\GreenModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.scope;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.IntoSet;\n\n@Module\nfinal class GreenModule  {\n  @Provides\n  @IntoSet\n  @GreenScope\n  static Object green() {\n    return new Object();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\scope\\GreenScope.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.scope;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport javax.inject.Scope;\n\n@Documented\n@Retention(RUNTIME)\n@Scope\n@interface GreenScope {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\scope\\ScopedComponent.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.scope;\n\nimport dagger.Component;\nimport java.util.Set;\n\n@BlueScope\n@GreenScope\n@Component(modules \u003d {BlueModule.class, GreenModule.class, TurquoiseModule.class})\ninterface ScopedComponent {\n  Set\u003cObject\u003e set();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\scope\\TurquoiseModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.scope;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.IntoSet;\n\n@Module\nfinal class TurquoiseModule {\n  @Provides\n  @IntoSet\n  @BlueScope\n  static Object blue() {\n    return new Object();\n  }\n\n  @Provides\n  @IntoSet\n  @GreenScope\n  static Object green() {\n    return new Object();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ScopedGeneric.java",
    "code": "\"package test;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\n\n@Singleton\nclass ScopedGeneric\u003cT\u003e { \n  final T t;  \n  @Inject ScopedGeneric(T t) {\n    this.t \u003d t;\n  }  \n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\ShortKey.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.MapKey;\n\n@MapKey(unwrapValue \u003d true)\n@interface ShortKey {\n  short value();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\SingletonGenericComponent.java",
    "code": "\"package test;\n\nimport dagger.Component;\nimport javax.inject.Singleton;\n\n@Singleton\n@Component\ninterface SingletonGenericComponent {\n  \n  ScopedGeneric\u003cA\u003e scopedGenericA();\n  ScopedGeneric\u003cB\u003e scopedGenericB();\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\SomeQualifier.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport javax.inject.Qualifier;\n\n@Documented\n@Retention(RUNTIME)\n@Qualifier\npublic @interface SomeQualifier {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\staticprovides\\AllStaticModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.staticprovides;\n\nimport static java.util.Collections.emptySet;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntoSet;\nimport java.util.Set;\n\n@Module\nfinal class AllStaticModule {\n  @Provides\n  @IntoSet\n  static String contributeString() {\n    return AllStaticModule.class + \".contributeString\";\n  }\n\n  @Provides\n  @ElementsIntoSet\n  static Set\u003cInteger\u003e contibuteEmptyIntegerSet() {\n    return emptySet();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\staticprovides\\SomeStaticModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.staticprovides;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.IntoSet;\n\n@Module\nfinal class SomeStaticModule {\n  @Provides\n  @IntoSet\n  static String contributeStringFromAStaticMethod() {\n    return SomeStaticModule.class + \".contributeStringFromAStaticMethod\";\n  }\n\n  @Provides\n  @IntoSet\n  static String contributeStringFromAnInstanceMethod() {\n    return SomeStaticModule.class + \".contributeStringFromAnInstanceMethod\";\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\staticprovides\\StaticTestComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.staticprovides;\n\nimport dagger.Component;\nimport java.util.Set;\n\n/**\n * A simple component that demonstrates both static and non-static provides methods.\n */\n@Component(modules \u003d {AllStaticModule.class, SomeStaticModule.class})\ninterface StaticTestComponent {\n  Set\u003cString\u003e getMultiboundStrings();\n  Set\u003cInteger\u003e getMultiboundIntegers();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\staticprovides\\StaticTestComponentWithBuilder.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.staticprovides;\n\nimport dagger.Component;\n\n/**\n * A simple component that demonstrates both static and non-static provides methods with a builder.\n */\n@Component(modules \u003d {AllStaticModule.class, SomeStaticModule.class})\ninterface StaticTestComponentWithBuilder extends StaticTestComponent {\n  @Component.Builder\n  interface Builder {\n    Builder allStaticModule(AllStaticModule allStaticModule);\n    Builder someStaticModule(SomeStaticModule someStaticModule);\n    StaticTestComponentWithBuilder build();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\sub\\ContributionsModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.sub;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntoSet;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\n@Module\npublic final class ContributionsModule {\n  @Provides\n  @IntoSet\n  static int contributeAnInt(@SuppressWarnings(\"unused\") double doubleDependency) {\n    return 1742;\n  }\n\n  @Provides\n  @IntoSet\n  static int contributeAnotherInt() {\n    return 832;\n  }\n\n  @Provides\n  @ElementsIntoSet\n  static Set\u003cInteger\u003e contributeSomeInts() {\n    return Collections.unmodifiableSet(new LinkedHashSet\u003cInteger\u003e(Arrays.asList(-1, -90, -17)));\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\sub\\Exposed.java",
    "code": "\"package test.sub;\n\nimport javax.inject.Inject;\nimport test.Generic;\nimport test.Generic2;\n\npublic class Exposed {\n  \n  @Inject public Generic2\u003cPackagePrivate\u003e gpp2;\n  @Inject public Generic2\u003cPackagePrivateContainer.PublicEnclosed\u003e gppc2;\n\n  public Generic\u003cPackagePrivate\u003e gpp;\n  public Generic\u003cPackagePrivateContainer.PublicEnclosed\u003e gppc;\n  \n  @Inject Exposed(Generic\u003cPackagePrivate\u003e gpp, Generic\u003cPackagePrivateContainer.PublicEnclosed\u003e gppc) {\n    this.gpp \u003d gpp;\n    this.gppc \u003d gppc;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\sub\\OtherThing.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.sub;\n\nimport javax.inject.Inject;\n\npublic final class OtherThing {\n  @Inject\n  public OtherThing(@SuppressWarnings(\"unused\") int i) {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\sub\\PackagePrivate.java",
    "code": "\"package test.sub;\n\nimport javax.inject.Inject;\n\nclass PackagePrivate {  \n  @Inject PackagePrivate() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\sub\\PackagePrivateContainer.java",
    "code": "\"package test.sub;\n\nimport javax.inject.Inject;\n\nclass PackagePrivateContainer {  \n  public static class PublicEnclosed {\n    @Inject PublicEnclosed() {}\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\sub\\PublicSubclass.java",
    "code": "\"package test.sub;\n\nimport javax.inject.Inject;\nimport test.Generic;\n\npublic class PublicSubclass extends Generic\u003cPackagePrivate\u003e {\n  @Inject public PublicSubclass(PackagePrivate pp) {\n    super(pp);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\sub\\PublicSubclass2.java",
    "code": "\"package test.sub;\n\nimport javax.inject.Inject;\nimport test.Generic;\n\npublic class PublicSubclass2 extends Generic\u003cPackagePrivateContainer.PublicEnclosed\u003e {\n  @Inject public PublicSubclass2(PackagePrivateContainer.PublicEnclosed pp) {\n    super(pp);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\AnInterface.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\ninterface AnInterface {\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\BoundAsSingleton.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport javax.inject.Qualifier;\n\n@Documented\n@Retention(RUNTIME)\n@Qualifier\n@interface BoundAsSingleton {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\ChildAbstractClassComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Subcomponent;\n\n@Subcomponent(modules \u003d {ChildModule.class, StaticChildModule.class})\nabstract class ChildAbstractClassComponent implements ChildComponent {\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\ChildComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Subcomponent;\nimport java.util.Set;\nimport javax.inject.Provider;\n\n@Subcomponent(modules \u003d {ChildModule.class, StaticChildModule.class})\ninterface ChildComponent {\n  Provider\u003cUnscopedType\u003e getUnscopedTypeProvider();\n\n  RequiresSingletons requiresSingleton();\n\n  Set\u003cObject\u003e objectSet();\n\n  GrandchildComponent newGrandchildComponent();\n  \n  Object object();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\ChildComponentRequiringModules.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Subcomponent;\n\n@Subcomponent(modules \u003d {\n    ChildModule.class,\n    ChildModuleWithParameters.class,\n    ChildModuleWithState.class})\ninterface ChildComponentRequiringModules {\n  int getInt();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\ChildModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.IntoSet;\n\n@Module\nfinal class ChildModule {\n  @Provides\n  @IntoSet\n  static Object provideUnscopedObject() {\n    return new Object() {\n      @Override public String toString() {\n        return \"unscoped in child\";\n      }\n    };\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\ChildModuleWithParameters.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Module;\n\n/**\n * This is a module that can\u0027t be constructed with a default constructor.\n */\n@Module\nfinal class ChildModuleWithParameters {\n  public ChildModuleWithParameters(@SuppressWarnings(\"unused\") Object whatever) {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\ChildModuleWithState.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n/**\n * This is a module that can be constructed with a default constructor, but has state, so callers\n * might want to pass a reference anyway.\n */\n@Module\nfinal class ChildModuleWithState {\n  private int i \u003d 0;\n\n  @Provides int provideInt() {\n    return i++;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\GenericParentComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\ninterface GenericParentComponent\u003cB\u003e {  \n  B subcomponent();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\GrandchildComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Subcomponent;\nimport java.util.Set;\nimport javax.inject.Provider;\n\n@Subcomponent(modules \u003d GrandchildModule.class)\ninterface GrandchildComponent {\n  Provider\u003cUnscopedType\u003e getUnscopedTypeProvider();\n\n  RequiresSingletons requiresSingleton();\n\n  Set\u003cObject\u003e objectSet();\n\n  NeedsAnInterface needsAnInterface();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\GrandchildModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Binds;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.IntoSet;\n\n@Module\nabstract class GrandchildModule {\n  @Provides\n  @IntoSet\n  static Object provideUnscopedObject() {\n    return new Object() {\n      @Override public String toString() {\n        return \"unscoped in grandchild\";\n      }\n    };\n  }\n\n  @Binds\n  abstract AnInterface provideAnInterface(ImplementsAnInterface implementsAnInterface);\n\n  @Provides\n  static NeedsAnInterface provideNeedsAnInterface(AnInterface anInterface) {\n    return new NeedsAnInterface(anInterface);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\hiding\\a\\CommonModuleName.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.hiding.a;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\npublic class CommonModuleName {\n  @Provides String provideString() {\n    return \"a\";\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\hiding\\a\\CommonName.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.hiding.a;\n\nimport javax.inject.Inject;\n\npublic final class CommonName {\n  private final String s;\n\n  @Inject CommonName(String s) {\n    this.s \u003d s;\n  }\n\n  @Override\n  public String toString() {\n    return s;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\hiding\\b\\CommonModuleName.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.hiding.b;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\npublic class CommonModuleName {\n  @Provides int provideString() {\n    return 1;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\hiding\\b\\CommonName.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.hiding.b;\n\nimport javax.inject.Inject;\n\npublic final class CommonName {\n  private final int i;\n\n  @Inject CommonName(int i) {\n    this.i \u003d i;\n  }\n\n  @Override\n  public String toString() {\n    return Integer.toString(i);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\hiding\\ChildComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.hiding;\n\nimport dagger.Subcomponent;\n\n@Subcomponent(modules \u003d test.subcomponent.hiding.b.CommonModuleName.class)\ninterface ChildComponent {\n  //ensure that t.s.h.a.CommonName gets bound in this component\n  test.subcomponent.hiding.a.CommonName aCommonName();\n  //ensure that t.s.h.b.CommonName gets bound in this component\n  test.subcomponent.hiding.b.CommonName bCommonName();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\hiding\\ParentComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.hiding;\n\nimport dagger.Component;\nimport javax.inject.Singleton;\n\n@Component(modules \u003d test.subcomponent.hiding.a.CommonModuleName.class)\n@Singleton\ninterface ParentComponent {\n  // ensure that t.s.h.a.CommonName gets bound in this component\n  test.subcomponent.hiding.a.CommonName aCommonName();\n\n  ChildComponent newChildComponent();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\ImplementsAnInterface.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport javax.inject.Inject;\n\nclass ImplementsAnInterface implements AnInterface {\n  @Inject ImplementsAnInterface() {}\n}\n\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\MultibindingSubcomponents.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Binds;\nimport dagger.Component;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.Subcomponent;\nimport dagger.multibindings.IntoMap;\nimport dagger.multibindings.IntoSet;\nimport dagger.multibindings.StringKey;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport javax.inject.Inject;\n\nfinal class MultibindingSubcomponents {\n\n  /** Multibindings for this type are bound only in the parent component. */\n  enum BoundInParent {\n    INSTANCE;\n  }\n\n  /** Multibindings for this type are bound only in the child component. */\n  enum BoundInChild {\n    INSTANCE;\n  }\n\n  /** Multibindings for this type are bound in the parent component and the child component. */\n  enum BoundInParentAndChild {\n    IN_PARENT,\n    IN_CHILD;\n  }\n\n  static final class RequiresMultibindings\u003cT\u003e {\n    private final Set\u003cT\u003e set;\n    private final Map\u003cString, T\u003e map;\n\n    @Inject\n    RequiresMultibindings(Set\u003cT\u003e set, Map\u003cString, T\u003e map) {\n      this.set \u003d set;\n      this.map \u003d map;\n    }\n\n    Set\u003cT\u003e set() {\n      return set;\n    }\n\n    Map\u003cString, T\u003e map() {\n      return map;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n      return obj instanceof RequiresMultibindings\u003c?\u003e\n          \u0026\u0026 set.equals(((RequiresMultibindings\u003c?\u003e) obj).set)\n          \u0026\u0026 map.equals(((RequiresMultibindings\u003c?\u003e) obj).map);\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(set, map);\n    }\n\n    @Override\n    public String toString() {\n      return String.format(\n          \"%s{set\u003d%s, map\u003d%s}\", RequiresMultibindings.class.getSimpleName(), set, map);\n    }\n  }\n\n  @Module\n  abstract static class ParentMultibindingModule {\n\n    @Provides\n    @IntoSet\n    static BoundInParent onlyInParentElement() {\n      return BoundInParent.INSTANCE;\n    }\n\n    @Provides\n    @IntoMap\n    @StringKey(\"parent key\")\n    static BoundInParent onlyInParentEntry() {\n      return BoundInParent.INSTANCE;\n    }\n\n    @Provides\n    @IntoSet\n    static BoundInParentAndChild inParentAndChildElement() {\n      return BoundInParentAndChild.IN_PARENT;\n    }\n\n    @Provides\n    @IntoMap\n    @StringKey(\"parent key\")\n    static BoundInParentAndChild inParentAndChildEntry() {\n      return BoundInParentAndChild.IN_PARENT;\n    }\n\n    /* This is not static because otherwise we have no tests that cover the case where a\n     * subcomponent uses a module instance installed onto a parent component. */\n    @Binds\n    @IntoSet\n    abstract RequiresMultibindings\u003cBoundInParentAndChild\u003e\n        requiresMultibindingsInParentAndChildElement(\n            RequiresMultibindings\u003cBoundInParentAndChild\u003e requiresMultibindingsInParentAndChild);\n  }\n\n  @Module\n  static final class ChildMultibindingModule {\n\n    @Provides\n    @IntoSet\n    static BoundInParentAndChild inParentAndChildElement() {\n      return BoundInParentAndChild.IN_CHILD;\n    }\n\n    @Provides\n    @IntoMap\n    @StringKey(\"child key\")\n    static BoundInParentAndChild inParentAndChildEntry() {\n      return BoundInParentAndChild.IN_CHILD;\n    }\n\n    @Provides\n    @IntoSet\n    static BoundInChild onlyInChildElement() {\n      return BoundInChild.INSTANCE;\n    }\n\n    @Provides\n    @IntoMap\n    @StringKey(\"child key\")\n    static BoundInChild onlyInChildEntry() {\n      return BoundInChild.INSTANCE;\n    }\n  }\n\n  @Module\n  abstract static class ChildMultibindingModuleWithOnlyBindsMultibindings {\n    @Provides\n    static BoundInParentAndChild provideBoundInParentAndChildForBinds() {\n      return BoundInParentAndChild.IN_CHILD;\n    }\n\n    @Binds\n    @IntoSet\n    abstract BoundInParentAndChild bindsLocalContribution(BoundInParentAndChild instance);\n\n    @Binds\n    @IntoMap\n    @StringKey(\"child key\")\n    abstract BoundInParentAndChild inParentAndChildEntry(BoundInParentAndChild instance);\n\n    @Provides\n    static BoundInChild provideBoundInChildForBinds() {\n      return BoundInChild.INSTANCE;\n    }\n\n    @Binds\n    @IntoSet\n    abstract BoundInChild inChild(BoundInChild instance);\n\n    @Binds\n    @IntoMap\n    @StringKey(\"child key\")\n    abstract BoundInChild inChildEntry(BoundInChild instance);\n  }\n\n  interface ProvidesBoundInParent {\n    RequiresMultibindings\u003cBoundInParent\u003e requiresMultibindingsBoundInParent();\n  }\n\n  interface ProvidesBoundInChild {\n    RequiresMultibindings\u003cBoundInChild\u003e requiresMultibindingsBoundInChild();\n  }\n\n  interface ProvidesBoundInParentAndChild {\n    RequiresMultibindings\u003cBoundInParentAndChild\u003e requiresMultibindingsBoundInParentAndChild();\n  }\n\n  interface ProvidesSetOfRequiresMultibindings {\n    Set\u003cRequiresMultibindings\u003cBoundInParentAndChild\u003e\u003e setOfRequiresMultibindingsInParentAndChild();\n  }\n\n  interface ParentWithProvision\n      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild,\n          ProvidesSetOfRequiresMultibindings {}\n\n  interface HasChildWithProvision {\n    ChildWithProvision childWithProvision();\n  }\n\n  interface HasChildWithoutProvision {\n    ChildWithoutProvision childWithoutProvision();\n  }\n\n  @Component(modules \u003d ParentMultibindingModule.class)\n  interface ParentWithoutProvisionHasChildWithoutProvision extends HasChildWithoutProvision {}\n\n  @Component(modules \u003d ParentMultibindingModule.class)\n  interface ParentWithoutProvisionHasChildWithProvision extends HasChildWithProvision {}\n\n  @Component(modules \u003d ParentMultibindingModule.class)\n  interface ParentWithProvisionHasChildWithoutProvision\n      extends ParentWithProvision, HasChildWithoutProvision {}\n\n  @Component(modules \u003d ParentMultibindingModule.class)\n  interface ParentWithProvisionHasChildWithProvision\n      extends ParentWithProvision, HasChildWithProvision {}\n\n  @Subcomponent(modules \u003d ChildMultibindingModule.class)\n  interface ChildWithoutProvision {\n    Grandchild grandchild();\n  }\n\n  @Subcomponent(modules \u003d ChildMultibindingModule.class)\n  interface ChildWithProvision\n      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild, ProvidesBoundInChild,\n          ProvidesSetOfRequiresMultibindings {\n\n    Grandchild grandchild();\n  }\n\n  @Subcomponent\n  interface Grandchild\n      extends ProvidesBoundInParent, ProvidesBoundInParentAndChild, ProvidesBoundInChild,\n          ProvidesSetOfRequiresMultibindings {}\n\n  @Component(modules \u003d ParentMultibindingModule.class)\n  interface ParentWithProvisionHasChildWithBinds extends ParentWithProvision {\n    ChildWithBinds childWithBinds();\n  }\n\n  @Subcomponent(modules \u003d ChildMultibindingModuleWithOnlyBindsMultibindings.class)\n  interface ChildWithBinds extends ChildWithProvision {}\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\NeedsAnInterface.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nclass NeedsAnInterface {\n  NeedsAnInterface(@SuppressWarnings(\"unused\") AnInterface anInterface) {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\ParentComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Component;\nimport javax.inject.Singleton;\nimport test.SomeQualifier;\n\n@Component(modules \u003d {ParentModule.class, UnresolvableChildComponentModule.class})\n@Singleton\ninterface ParentComponent extends ParentGetters {\n  ChildComponent newChildComponent();\n\n  ChildAbstractClassComponent newChildAbstractClassComponent();\n\n  ChildComponentRequiringModules newChildComponentRequiringModules(\n      ChildModuleWithParameters cmwp,\n      ChildModuleWithState childModuleWithState);\n\n  /**\n   * Requests a qualified version of this subcomponent builder, which does not install it as a\n   * subcomponent, but instead, uses the explicit binding of this qualified builder.\n   */\n  @SomeQualifier UnresolvableChildComponent.Builder unresolvableChildComponentBuilder();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\ParentGetters.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport java.util.Set;\nimport javax.inject.Provider;\n\ninterface ParentGetters {\n  Provider\u003cUnscopedType\u003e getUnscopedTypeProvider();\n\n  Set\u003cObject\u003e objectSet();\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\ParentModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Binds;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.IntoSet;\nimport javax.inject.Singleton;\n\n@Module\nabstract class ParentModule {\n  @Provides\n  @IntoSet\n  static Object provideUnscopedObject() {\n    return new Object() {\n      @Override public String toString() {\n        return \"unscoped in parent\";\n      }\n    };\n  }\n\n  @Provides\n  @IntoSet\n  @Singleton\n  static Object provideSingletonObject() {\n    return new Object() {\n      @Override public String toString() {\n        return \"singleton\";\n      }\n    };\n  }\n\n  @Binds\n  @Singleton\n  @BoundAsSingleton\n  abstract UnscopedType provideUnscopedTypeBoundAsSingleton(UnscopedType unscopedType);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\ParentOfGenericComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Component;\nimport javax.inject.Singleton;\n\n@Component(modules \u003d ParentModule.class)\n@Singleton\ninterface ParentOfGenericComponent extends GenericParentComponent\u003cChildComponent\u003e, ParentGetters {\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\pruning\\ParentDoesntUseSubcomponent.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.pruning;\n\nimport dagger.Component;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.Subcomponent;\nimport dagger.multibindings.IntoSet;\nimport java.util.Set;\nimport javax.inject.Qualifier;\n\n/**\n * Supporting types for {@link SubcomponentOnlyRequestedBySiblingTest}. {@link ChildA} is a direct\n * child of the top level component, but is only requested within its sibling, not directly from its\n * parent.\n */\n@Component(modules \u003d ParentDoesntUseSubcomponent.ParentModule.class)\ninterface ParentDoesntUseSubcomponent {\n\n  ChildB.Builder childBBuilder();\n\n  @Subcomponent(modules \u003d ChildAModule.class)\n  interface ChildA {\n    @Subcomponent.Builder\n    interface Builder {\n      ChildA build();\n    }\n\n    Set\u003cClass\u003c?\u003e\u003e componentHierarchy();\n  }\n\n  @Subcomponent(modules \u003d ChildBModule.class)\n  interface ChildB {\n    @Subcomponent.Builder\n    interface Builder {\n      ChildB build();\n    }\n\n    Set\u003cClass\u003c?\u003e\u003e componentHierarchy();\n\n    @FromChildA\n    Set\u003cClass\u003c?\u003e\u003e componentHierarchyFromChildA();\n  }\n\n  @Module(subcomponents \u003d {ChildA.class, ChildB.class})\n  class ParentModule {\n    @Provides\n    @IntoSet\n    static Class\u003c?\u003e provideComponentType() {\n      return ParentDoesntUseSubcomponent.class;\n    }\n  }\n\n  @Module\n  class ChildAModule {\n    @Provides\n    @IntoSet\n    static Class\u003c?\u003e provideComponentType() {\n      return ChildA.class;\n    }\n  }\n\n  @Module\n  class ChildBModule {\n    @Provides\n    @IntoSet\n    static Class\u003c?\u003e provideComponentType() {\n      return ChildB.class;\n    }\n\n    @Provides\n    @FromChildA\n    Set\u003cClass\u003c?\u003e\u003e fromChildA(ChildA.Builder childABuilder) {\n      return childABuilder.build().componentHierarchy();\n    }\n  }\n\n  @Qualifier\n  @interface FromChildA {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\repeat\\OnlyUsedInChild.java",
    "code": "\"package test.subcomponent.repeat;\n\nabstract class OnlyUsedInChild {\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\repeat\\OnlyUsedInParent.java",
    "code": "\"package test.subcomponent.repeat;\n\nabstract class OnlyUsedInParent {\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\repeat\\OtherSubcomponentWithRepeatedModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.repeat;\n\nimport dagger.Subcomponent;\n\n@Subcomponent(modules \u003d RepeatedModule.class)\ninterface OtherSubcomponentWithRepeatedModule extends SubcomponentWithRepeatedModule {\n\n  @Subcomponent.Builder\n  interface Builder {\n    Builder repeatedModule(RepeatedModule repeatedModule);\n\n    OtherSubcomponentWithRepeatedModule build();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\repeat\\ParentComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.repeat;\n\nimport dagger.Component;\nimport java.util.Set;\n\n@Component(modules \u003d RepeatedModule.class)\ninterface ParentComponent {\n  Object state();\n\n  String getString();\n  Set\u003cString\u003e getMultiboundStrings();\n  OnlyUsedInParent getOnlyUsedInParent();\n\n  SubcomponentWithRepeatedModule.Builder newChildComponentBuilder();\n\n  SubcomponentWithoutRepeatedModule newChildComponentWithoutRepeatedModule();\n\n  @Component.Builder\n  interface Builder {\n    Builder repeatedModule(RepeatedModule repeatedModule);\n\n    ParentComponent build();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\repeat\\RepeatedModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.repeat;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.IntoSet;\n\n@Module\nfinal class RepeatedModule {\n  private final Object state \u003d new Object();\n\n  @Provides\n  Object state() {\n    return state;\n  }\n\n  @Provides\n  static String provideString() {\n    return \"a string\";\n  }\n\n  @Provides\n  @IntoSet\n  static String contributeString() {\n    return \"a string in a set\";\n  }\n\n  @Provides\n  static OnlyUsedInParent provideOnlyUsedInParent() {\n    return new OnlyUsedInParent() {};\n  }\n\n  @Provides\n  static OnlyUsedInChild provideOnlyUsedInChild() {\n    return new OnlyUsedInChild() {};\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\repeat\\SubcomponentWithoutRepeatedModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.repeat;\n\nimport dagger.Subcomponent;\n\n@Subcomponent\ninterface SubcomponentWithoutRepeatedModule {\n  OtherSubcomponentWithRepeatedModule.Builder newGrandchildBuilder();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\repeat\\SubcomponentWithRepeatedModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.repeat;\n\nimport dagger.Subcomponent;\nimport java.util.Set;\n\n@Subcomponent(modules \u003d RepeatedModule.class)\ninterface SubcomponentWithRepeatedModule {\n  Object state();\n\n  String getString();\n\n  Set\u003cString\u003e getMultiboundStrings();\n\n  OnlyUsedInChild getOnlyUsedInChild();\n\n  @Subcomponent.Builder\n  interface Builder {\n    Builder repeatedModule(RepeatedModule repeatedModule);\n\n    SubcomponentWithRepeatedModule build();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\RequiresSingletons.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport javax.inject.Inject;\n\nfinal class RequiresSingletons {\n  private final SingletonType singletonType;\n  private final UnscopedType unscopedTypeBoundAsSingleton;\n\n  @Inject RequiresSingletons(SingletonType singletonType,\n      @BoundAsSingleton UnscopedType unscopedTypeBoundAsSingleton) {\n    this.singletonType \u003d singletonType;\n    this.unscopedTypeBoundAsSingleton \u003d unscopedTypeBoundAsSingleton;\n  }\n\n  SingletonType singletonType() {\n    return singletonType;\n  }\n\n  UnscopedType unscopedTypeBoundAsSingleton() {\n    return unscopedTypeBoundAsSingleton;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\SingletonType.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\n\n@Singleton\nfinal class SingletonType {\n  @Inject SingletonType() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\StaticChildModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\nfinal class StaticChildModule {\n  private StaticChildModule() {}\n  \n  @Provides static Object provideStaticObject() {\n    return \"static\";\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\SubcomponentFromModuleAndFactoryMethod.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Component;\nimport dagger.Module;\nimport dagger.Subcomponent;\n\n/**\n * Tests for {@link Subcomponent}s which are defined with {@link Module#subcomponents()} and are\n * also requested as component factory methods.\n */\npublic class SubcomponentFromModuleAndFactoryMethod {\n  @Subcomponent\n  interface Sub {\n    @Subcomponent.Builder\n    interface Builder {\n      Sub sub();\n    }\n  }\n\n  @Module(subcomponents \u003d Sub.class)\n  class ModuleWithSubcomponent {}\n\n  @Component(modules \u003d ModuleWithSubcomponent.class)\n  interface ExposesBuilder {\n    Sub.Builder subcomponentBuilder();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\Unbound.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport javax.inject.Qualifier;\n\n/**\n * A qualifier representing an unbound type, to verify that the compiler does not attempt to\n * generate code depending on it.\n */\n@Documented\n@Retention(RUNTIME)\n@Qualifier\n@interface Unbound {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\UnresolvableChildComponent.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Subcomponent;\n\n/**\n * A subcomponent that\u0027s not resolvable in any parent component, for testing that qualified methods\n * on components that return subcomponents do not trigger actual subcomponents.\n */\n@Subcomponent\ninterface UnresolvableChildComponent {\n  /**\n   * Requests a type that is never bound in any component that this subcomponent might be installed\n   * in. If this subcomponent is ever attempted to be installed in a component, then it will produce\n   * a compiler error.\n   */\n  @Unbound\n  String unboundString();\n\n  @Subcomponent.Builder\n  interface Builder {\n    UnresolvableChildComponent build();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\UnresolvableChildComponentModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport test.SomeQualifier;\n\n@Module\nfinal class UnresolvableChildComponentModule {\n  /**\n   * Provides a qualified version of the {@link UnresolvableChildComponent}\u0027s builder. If the\n   * subcomponent were actually installed in a component, this would be a duplicate binding; but\n   * since that doesn\u0027t happen, this binding is OK.\n   */\n  @Provides\n  @SomeQualifier\n  static UnresolvableChildComponent.Builder unresolvableChildComponentBuilder() {\n    return new UnresolvableChildComponent.Builder() {\n      @Override\n      public UnresolvableChildComponent build() {\n        return new UnresolvableChildComponent() {\n          @Override\n          public String unboundString() {\n            return \"unbound\";\n          }\n        };\n      }\n    };\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\UnscopedType.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport javax.inject.Inject;\n\nfinal class UnscopedType {\n  @Inject UnscopedType(@SuppressWarnings(\"unused\") SingletonType singletonType) {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\subcomponent\\UsesModuleSubcomponents.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport dagger.Component;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.Subcomponent;\nimport dagger.multibindings.IntoSet;\nimport java.util.Set;\nimport javax.inject.Inject;\n\n/** Supporting types for {@link ModuleWithSubcomponentsTest}. */\n@Component(modules \u003d UsesModuleSubcomponents.ModuleWithSubcomponents.class)\npublic interface UsesModuleSubcomponents {\n  UsesChild usesChild();\n\n  Set\u003cString\u003e strings();\n\n  @Module(subcomponents \u003d Child.class, includes \u003d AlsoIncludesSubcomponents.class)\n  class ModuleWithSubcomponents {\n    @Provides\n    @IntoSet\n    static String provideStringInParent() {\n      return \"from parent\";\n    }\n  }\n\n  @Module(subcomponents \u003d Child.class)\n  class AlsoIncludesSubcomponents {}\n\n  @Subcomponent(modules \u003d ChildModule.class)\n  interface Child {\n    Set\u003cString\u003e strings();\n\n    @Subcomponent.Builder\n    interface Builder {\n      Child build();\n    }\n  }\n\n  @Module\n  class ChildModule {\n    @Provides\n    @IntoSet\n    static String provideStringInChild() {\n      return \"from child\";\n    }\n  }\n\n  class UsesChild {\n    Set\u003cString\u003e strings;\n\n    @Inject\n    UsesChild(Child.Builder childBuilder) {\n      this.strings \u003d childBuilder.build().strings();\n    }\n  }\n\n  @Module(includes \u003d ModuleWithSubcomponents.class)\n  class OnlyIncludesModuleWithSubcomponents {}\n\n  @Component(modules \u003d OnlyIncludesModuleWithSubcomponents.class)\n  interface ParentIncludesSubcomponentTransitively extends UsesModuleSubcomponents {}\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\Thing.java",
    "code": "\"/*\n* Copyright (C) 2014 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport javax.inject.Inject;\nimport test.sub.OtherThing;\n\nfinal class Thing {\n  @Inject Thing(@SuppressWarnings(\"unused\") OtherThing unused) {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\TypeWithInheritedMembersInjection.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport javax.inject.Inject;\n\nfinal class TypeWithInheritedMembersInjection extends AbstractMiddleClassWithoutMembers {\n  @Inject TypeWithInheritedMembersInjection() {}\n}\n\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\UnwrappedAnnotationKey.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.MapKey;\nimport dagger.multibindings.StringKey;\n\n@MapKey(unwrapValue \u003d true)\n@interface UnwrappedAnnotationKey {\n  StringKey value();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\main\\java\\test\\WrappedAnnotationKey.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport dagger.MapKey;\nimport dagger.multibindings.ClassKey;\nimport dagger.multibindings.StringKey;\n\n@MapKey(unwrapValue \u003d false)\n@interface WrappedAnnotationKey {\n  StringKey value();\n  int[] integers();\n  ClassKey[] annotations();\n  Class\u003c? extends Number\u003e[] classes();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\BasicTest.java",
    "code": "\"/*\n* Copyright (C) 2014 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static test.PrimitivesModule.BOUND_BOOLEAN;\nimport static test.PrimitivesModule.BOUND_BOOLEAN_ARRAY;\nimport static test.PrimitivesModule.BOUND_BYTE;\nimport static test.PrimitivesModule.BOUND_BYTE_ARRAY;\nimport static test.PrimitivesModule.BOUND_CHAR;\nimport static test.PrimitivesModule.BOUND_CHAR_ARRAY;\nimport static test.PrimitivesModule.BOUND_DOUBLE;\nimport static test.PrimitivesModule.BOUND_DOUBLE_ARRAY;\nimport static test.PrimitivesModule.BOUND_FLOAT;\nimport static test.PrimitivesModule.BOUND_FLOAT_ARRAY;\nimport static test.PrimitivesModule.BOUND_INT;\nimport static test.PrimitivesModule.BOUND_INT_ARRAY;\nimport static test.PrimitivesModule.BOUND_LONG;\nimport static test.PrimitivesModule.BOUND_LONG_ARRAY;\nimport static test.PrimitivesModule.BOUND_SHORT;\nimport static test.PrimitivesModule.BOUND_SHORT_ARRAY;\n\nimport dagger.Lazy;\nimport javax.inject.Provider;\nimport org.junit.experimental.theories.DataPoint;\nimport org.junit.experimental.theories.Theories;\nimport org.junit.experimental.theories.Theory;\nimport org.junit.runner.RunWith;\n\n@RunWith(Theories.class)\npublic class BasicTest {\n  @DataPoint\n  public static final BasicComponent basicComponent \u003d DaggerBasicComponent.create();\n  @DataPoint\n  public static final BasicComponent abstractClassBasicComponent \u003d\n      DaggerBasicAbstractClassComponent.create();\n\n  @Theory public void primitives(BasicComponent basicComponent) {\n    assertThat(basicComponent.getByte()).isEqualTo(BOUND_BYTE);\n    assertThat(basicComponent.getChar()).isEqualTo(BOUND_CHAR);\n    assertThat(basicComponent.getShort()).isEqualTo(BOUND_SHORT);\n    assertThat(basicComponent.getInt()).isEqualTo(BOUND_INT);\n    assertThat(basicComponent.getLong()).isEqualTo(BOUND_LONG);\n    assertThat(basicComponent.getBoolean()).isEqualTo(BOUND_BOOLEAN);\n    assertThat(basicComponent.getFloat()).isWithin(0).of(BOUND_FLOAT);\n    assertThat(basicComponent.getDouble()).isWithin(0).of(BOUND_DOUBLE);\n  }\n\n  @Theory public void boxedPrimitives(BasicComponent basicComponent) {\n    assertThat(basicComponent.getBoxedByte()).isEqualTo(new Byte(BOUND_BYTE));\n    assertThat(basicComponent.getBoxedChar()).isEqualTo(new Character(BOUND_CHAR));\n    assertThat(basicComponent.getBoxedShort()).isEqualTo(new Short(BOUND_SHORT));\n    assertThat(basicComponent.getBoxedInt()).isEqualTo(new Integer(BOUND_INT));\n    assertThat(basicComponent.getBoxedLong()).isEqualTo(new Long(BOUND_LONG));\n    assertThat(basicComponent.getBoxedBoolean()).isEqualTo(new Boolean(BOUND_BOOLEAN));\n    assertThat(basicComponent.getBoxedFloat()).isWithin(0).of(BOUND_FLOAT);\n    assertThat(basicComponent.getBoxedDouble()).isWithin(0).of(BOUND_DOUBLE);\n  }\n\n  @Theory public void boxedPrimitiveProviders(BasicComponent basicComponent) {\n    assertThat(basicComponent.getByteProvider().get()).isEqualTo(new Byte(BOUND_BYTE));\n    assertThat(basicComponent.getCharProvider().get()).isEqualTo(new Character(BOUND_CHAR));\n    assertThat(basicComponent.getShortProvider().get()).isEqualTo(new Short(BOUND_SHORT));\n    assertThat(basicComponent.getIntProvider().get()).isEqualTo(new Integer(BOUND_INT));\n    assertThat(basicComponent.getLongProvider().get()).isEqualTo(new Long(BOUND_LONG));\n    assertThat(basicComponent.getBooleanProvider().get()).isEqualTo(new Boolean(BOUND_BOOLEAN));\n    assertThat(basicComponent.getFloatProvider().get()).isWithin(0).of(BOUND_FLOAT);\n    assertThat(basicComponent.getDoubleProvider().get()).isWithin(0).of(BOUND_DOUBLE);\n  }\n\n  @Theory public void primitiveArrays(BasicComponent basicComponent) {\n    assertThat(basicComponent.getByteArray()).isSameAs(BOUND_BYTE_ARRAY);\n    assertThat(basicComponent.getCharArray()).isSameAs(BOUND_CHAR_ARRAY);\n    assertThat(basicComponent.getShortArray()).isSameAs(BOUND_SHORT_ARRAY);\n    assertThat(basicComponent.getIntArray()).isSameAs(BOUND_INT_ARRAY);\n    assertThat(basicComponent.getLongArray()).isSameAs(BOUND_LONG_ARRAY);\n    assertThat(basicComponent.getBooleanArray()).isSameAs(BOUND_BOOLEAN_ARRAY);\n    assertThat(basicComponent.getFloatArray()).isSameAs(BOUND_FLOAT_ARRAY);\n    assertThat(basicComponent.getDoubleArray()).isSameAs(BOUND_DOUBLE_ARRAY);\n  }\n\n  @Theory public void primitiveArrayProviders(BasicComponent basicComponent) {\n    assertThat(basicComponent.getByteArrayProvider().get()).isSameAs(BOUND_BYTE_ARRAY);\n    assertThat(basicComponent.getCharArrayProvider().get()).isSameAs(BOUND_CHAR_ARRAY);\n    assertThat(basicComponent.getShortArrayProvider().get()).isSameAs(BOUND_SHORT_ARRAY);\n    assertThat(basicComponent.getIntArrayProvider().get()).isSameAs(BOUND_INT_ARRAY);\n    assertThat(basicComponent.getLongArrayProvider().get()).isSameAs(BOUND_LONG_ARRAY);\n    assertThat(basicComponent.getBooleanArrayProvider().get()).isSameAs(BOUND_BOOLEAN_ARRAY);\n    assertThat(basicComponent.getFloatArrayProvider().get()).isSameAs(BOUND_FLOAT_ARRAY);\n    assertThat(basicComponent.getDoubleArrayProvider().get()).isSameAs(BOUND_DOUBLE_ARRAY);\n  }\n\n  @Theory public void noOpMembersInjection(BasicComponent basicComponent) {\n    Object object \u003d new Object();\n    assertThat(basicComponent.noOpMembersInjection(object)).isSameAs(object);\n  }\n\n  @Theory public void basicObject_noDeps(BasicComponent basicComponent) {\n    assertThat(basicComponent.thing()).isNotNull();\n  }\n\n  @Theory public void inheritedMembersInjection(BasicComponent basicComponent) {\n    assertThat(basicComponent.typeWithInheritedMembersInjection().thing).isNotNull();\n  }\n  \n  @Theory\n  public void nullableInjection(BasicComponent basicComponent) {\n    assertThat(basicComponent.nullObject()).isNull();\n    assertThat(basicComponent.nullObjectProvider().get()).isNull();\n    assertThat(basicComponent.lazyNullObject().get()).isNull();\n  }\n  \n  @Theory\n  public void providerOfLazy(BasicComponent basicComponent) {\n    Provider\u003cLazy\u003cInjectedThing\u003e\u003e lazyInjectedThingProvider \u003d\n        basicComponent.lazyInjectedThingProvider();\n    Lazy\u003cInjectedThing\u003e lazyInjectedThing1 \u003d lazyInjectedThingProvider.get();\n    Lazy\u003cInjectedThing\u003e lazyInjectedThing2 \u003d lazyInjectedThingProvider.get();\n    assertThat(lazyInjectedThing2).isNotSameAs(lazyInjectedThing1);\n    assertThat(lazyInjectedThing1.get()).isSameAs(lazyInjectedThing1.get());\n    assertThat(lazyInjectedThing2.get()).isSameAs(lazyInjectedThing2.get());\n    assertThat(lazyInjectedThing2.get()).isNotSameAs(lazyInjectedThing1.get());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\binds\\BindsCollectionsWithoutMultibindingsTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.binds;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.google.common.collect.ImmutableMap;\nimport dagger.Binds;\nimport dagger.Component;\nimport dagger.Module;\nimport dagger.Provides;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class BindsCollectionsWithoutMultibindingsTest {\n  @Module\n  abstract static class M {\n    @Provides\n    static HashSet\u003cString\u003e provideHashSet() {\n      HashSet\u003cString\u003e set \u003d new HashSet\u003c\u003e();\n      set.add(\"binds\");\n      set.add(\"set\");\n      return set;\n    }\n\n    @Binds\n    abstract Set\u003cString\u003e bindStringSet(HashSet\u003cString\u003e set);\n\n    @Provides\n    static HashMap\u003cString, String\u003e provideHashMap() {\n      HashMap\u003cString, String\u003e map \u003d new HashMap\u003c\u003e();\n      map.put(\"binds\", \"map\");\n      map.put(\"without\", \"multibindings\");\n      return map;\n    }\n\n    @Binds\n    abstract Map\u003cString, String\u003e bindStringMap(HashMap\u003cString, String\u003e map);\n  }\n\n  @Component(modules \u003d M.class)\n  interface C {\n    Set\u003cString\u003e set();\n\n    Map\u003cString, String\u003e map();\n  }\n\n  @Test\n  public void works() {\n    C component \u003d DaggerBindsCollectionsWithoutMultibindingsTest_C.create();\n\n    assertThat(component.set()).containsExactly(\"binds\", \"set\");\n    assertThat(component.map())\n        .containsExactlyEntriesIn(\n            ImmutableMap.of(\n                \"binds\", \"map\",\n                \"without\", \"multibindings\"));\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\binds\\BindsTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.binds;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.google.common.collect.ImmutableMap;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class BindsTest {\n\n  private TestComponent component;\n\n  @Before\n  public void setUp() {\n    component \u003d DaggerTestComponent.create();\n  }\n\n  @Test\n  public void bindDelegates() {\n    assertThat(component.object()).isInstanceOf(FooOfStrings.class);\n    assertThat(component.fooOfStrings()).isInstanceOf(FooOfStrings.class);\n    assertThat(component.fooOfObjects()).isInstanceOf(FooOfObjects.class);\n    assertThat(component.fooOfIntegers()).isNotNull();\n  }\n\n  @Test\n  public void bindWithScope() {\n    assertThat(component.qualifiedFooOfStrings())\n        .isSameAs(component.qualifiedFooOfStrings());\n  }\n\n  @Test\n  public void multibindings() {\n    assertThat(component.foosOfNumbers()).hasSize(2);\n    assertThat(component.objects()).hasSize(3);\n    assertThat(component.charSequences()).hasSize(5);\n\n    assertThat(component.integerObjectMap())\n        .containsExactlyEntriesIn(\n            ImmutableMap.of(123, \"123-string\", 456, \"456-string\", 789, \"789-string\"));\n    assertThat(component.integerProviderOfObjectMap()).hasSize(3);\n    assertThat(component.integerProviderOfObjectMap().get(123).get()).isEqualTo(\"123-string\");\n    assertThat(component.integerProviderOfObjectMap().get(456).get()).isEqualTo(\"456-string\");\n    assertThat(component.integerProviderOfObjectMap().get(789).get()).isEqualTo(\"789-string\");\n\n    assertThat(component.qualifiedIntegerObjectMap()).hasSize(1);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\builder\\BuilderTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.builder;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class BuilderTest {\n\n  @Test public void interfaceBuilder() {\n    TestComponentWithBuilderInterface.Builder builder \u003d\n        DaggerTestComponentWithBuilderInterface.builder();\n\n    // Make sure things fail if we don\u0027t set our required modules.\n    try {\n      builder.build();\n      fail();\n    } catch(IllegalStateException expected) {}\n    \n    builder.intModule(new IntModuleIncludingDoubleAndFloat(1))\n        .stringModule(new StringModule(\"sam\"))\n        .depComponent(new DepComponent() {});\n    builder.doubleModule(new DoubleModule());\n    // Don\u0027t set other modules -- make sure it works.\n    \n    TestComponentWithBuilderInterface component \u003d builder.build();\n    assertThat(component.s()).isEqualTo(\"sam\");\n    assertThat(component.i()).isEqualTo(1);\n    assertThat(component.d()).isWithin(0).of(4.2d);\n    assertThat(component.f()).isWithin(0).of(5.5f);\n    assertThat(component.l()).isEqualTo(6L);\n  }\n\n  @Test public void abstractClassBuilder() {\n    TestComponentWithBuilderAbstractClass.Builder builder \u003d\n        TestComponentWithBuilderAbstractClass.builder();\n\n    // Make sure things fail if we don\u0027t set our required modules.\n    try {\n      builder.build();\n      fail();\n    } catch(IllegalStateException expected) {}\n    \n    builder.intModule(new IntModuleIncludingDoubleAndFloat(1))\n        .stringModule(new StringModule(\"sam\"))\n        .depComponent(new DepComponent() {});\n    builder.doubleModule(new DoubleModule());\n    // Don\u0027t set other modules -- make sure it works.\n    \n    TestComponentWithBuilderAbstractClass component \u003d builder.build();\n    assertThat(component.s()).isEqualTo(\"sam\");\n    assertThat(component.i()).isEqualTo(1);\n    assertThat(component.d()).isWithin(0).of(4.2d);\n    assertThat(component.f()).isWithin(0).of(5.5f);\n    assertThat(component.l()).isEqualTo(6L);\n  }\n\n  @Test public void interfaceGenericBuilder() {\n    TestComponentWithGenericBuilderInterface.Builder builder \u003d\n        DaggerTestComponentWithGenericBuilderInterface.builder();\n\n    // Make sure things fail if we don\u0027t set our required modules.\n    try {\n      builder.build();\n      fail();\n    } catch(IllegalStateException expected) {}\n    \n    builder.setM2(new IntModuleIncludingDoubleAndFloat(1))\n        .setM1(new StringModule(\"sam\"))\n        .depComponent(new DepComponent() {});\n    builder.doubleModule(new DoubleModule());\n    // Don\u0027t set other modules -- make sure it works.\n    \n    TestComponentWithGenericBuilderInterface component \u003d builder.build();\n    assertThat(component.s()).isEqualTo(\"sam\");\n    assertThat(component.i()).isEqualTo(1);\n    assertThat(component.d()).isWithin(0).of(4.2d);\n    assertThat(component.f()).isWithin(0).of(5.5f);\n    assertThat(component.l()).isEqualTo(6L);\n  }\n\n  @Test public void abstractClassGenericBuilder() {\n    TestComponentWithGenericBuilderAbstractClass.Builder builder \u003d\n        DaggerTestComponentWithGenericBuilderAbstractClass.builder();\n\n    // Make sure things fail if we don\u0027t set our required modules.\n    try {\n      builder.build();\n      fail();\n    } catch(IllegalStateException expected) {}\n    \n    builder.setM2(new IntModuleIncludingDoubleAndFloat(1))\n        .setM1(new StringModule(\"sam\"))\n        .depComponent(new DepComponent() {});\n    builder.doubleModule(new DoubleModule());\n    // Don\u0027t set other modules -- make sure it works.\n    \n    TestComponentWithGenericBuilderAbstractClass component \u003d builder.build();\n    assertThat(component.s()).isEqualTo(\"sam\");\n    assertThat(component.i()).isEqualTo(1);\n    assertThat(component.d()).isWithin(0).of(4.2d);\n    assertThat(component.f()).isWithin(0).of(5.5f);\n    assertThat(component.l()).isEqualTo(6L);\n  }\n  \n  @Test public void subcomponents_interface() {\n    ParentComponent parent \u003d DaggerParentComponent.create();    \n    TestChildComponentWithBuilderInterface.Builder builder1 \u003d parent.childInterfaceBuilder();\n    try {\n      builder1.build();\n      fail();\n    } catch(IllegalStateException expected) {}\n    \n    builder1.setM2(new IntModuleIncludingDoubleAndFloat(1))\n        .setM1(new StringModule(\"sam\"))\n        .set(new ByteModule((byte)7));\n    builder1.set(new FloatModule());\n    TestChildComponentWithBuilderInterface child1 \u003d builder1.build();\n    assertThat(child1.s()).isEqualTo(\"sam\");\n    assertThat(child1.i()).isEqualTo(1);\n    assertThat(child1.d()).isWithin(0).of(4.2d);\n    assertThat(child1.f()).isWithin(0).of(5.5f);\n    assertThat(child1.l()).isEqualTo(6L);\n    assertThat(child1.b()).isEqualTo((byte)7);\n  }\n  \n  @Test public void subcomponents_abstractclass() {\n    ParentComponent parent \u003d DaggerParentComponent.create();\n    TestChildComponentWithBuilderAbstractClass.Builder builder2 \u003d\n        parent.childAbstractClassBuilder();\n    try {\n      builder2.build();\n      fail();\n    } catch(IllegalStateException expected) {}\n    \n    builder2.setM2(new IntModuleIncludingDoubleAndFloat(10))\n        .setM1(new StringModule(\"tara\"))\n        .set(new ByteModule((byte)70));\n    builder2.set(new FloatModule());\n    TestChildComponentWithBuilderAbstractClass child2 \u003d builder2.build();\n    assertThat(child2.s()).isEqualTo(\"tara\");\n    assertThat(child2.i()).isEqualTo(10);\n    assertThat(child2.d()).isWithin(0).of(4.2d);\n    assertThat(child2.f()).isWithin(0).of(5.5f);\n    assertThat(child2.l()).isEqualTo(6L);\n    assertThat(child2.b()).isEqualTo((byte)70);\n  }\n    \n  @Test\n  public void grandchildren() {\n    ParentComponent parent \u003d DaggerParentComponent.create();\n    MiddleChild middle1 \u003d parent.middleBuilder().set(new StringModule(\"sam\")).build();\n    Grandchild grandchild1 \u003d\n        middle1.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(21)).build();\n    Grandchild grandchild2 \u003d\n        middle1.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(22)).build();\n    \n    assertThat(middle1.s()).isEqualTo(\"sam\");\n    assertThat(grandchild1.i()).isEqualTo(21);\n    assertThat(grandchild1.s()).isEqualTo(\"sam\");\n    assertThat(grandchild2.i()).isEqualTo(22);\n    assertThat(grandchild2.s()).isEqualTo(\"sam\");\n\n    // Make sure grandchildren from newer children have no relation to the older ones.\n    MiddleChild middle2 \u003d parent.middleBuilder().set(new StringModule(\"tara\")).build();\n    Grandchild grandchild3 \u003d\n        middle2.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(23)).build();\n    Grandchild grandchild4 \u003d\n        middle2.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(24)).build();\n    \n    assertThat(middle2.s()).isEqualTo(\"tara\");\n    assertThat(grandchild3.i()).isEqualTo(23);\n    assertThat(grandchild3.s()).isEqualTo(\"tara\");\n    assertThat(grandchild4.i()).isEqualTo(24);\n    assertThat(grandchild4.s()).isEqualTo(\"tara\");\n  }\n  \n  @Test\n  public void diamondGrandchildren() {\n    ParentComponent parent \u003d DaggerParentComponent.create();\n    MiddleChild middle \u003d parent.middleBuilder().set(new StringModule(\"sam\")).build();\n    OtherMiddleChild other \u003d parent.otherBuilder().set(new StringModule(\"tara\")).build();\n    \n    Grandchild middlegrand \u003d\n        middle.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(21)).build();\n    Grandchild othergrand \u003d\n        other.grandchildBuilder().set(new IntModuleIncludingDoubleAndFloat(22)).build();\n    \n    assertThat(middle.s()).isEqualTo(\"sam\");\n    assertThat(other.s()).isEqualTo(\"tara\");\n    assertThat(middlegrand.s()).isEqualTo(\"sam\");\n    assertThat(othergrand.s()).isEqualTo(\"tara\");\n    assertThat(middlegrand.i()).isEqualTo(21);\n    assertThat(othergrand.i()).isEqualTo(22);\n  }\n  \n  @Test\n  public void genericSubcomponentMethod() {\n    ParentOfGenericComponent parent \u003d\n        DaggerParentOfGenericComponent.builder().stringModule(new StringModule(\"sam\")).build();\n    Grandchild.Builder builder \u003d parent.subcomponentBuilder();\n    Grandchild child \u003d builder.set(new IntModuleIncludingDoubleAndFloat(21)).build();\n    assertThat(child.s()).isEqualTo(\"sam\");\n    assertThat(child.i()).isEqualTo(21);\n  }\n  \n  @Test\n  public void requireSubcomponentBuilderProviders() {\n    ParentComponent parent \u003d DaggerParentComponent.create();\n    MiddleChild middle \u003d\n        parent\n            .requiresMiddleChildBuilder()\n            .subcomponentBuilderProvider()\n            .get()\n            .set(new StringModule(\"sam\"))\n            .build();\n    Grandchild grandchild \u003d\n        middle\n            .requiresGrandchildBuilder()\n            .subcomponentBuilderProvider()\n            .get()\n            .set(new IntModuleIncludingDoubleAndFloat(12))\n            .build();\n    assertThat(middle.s()).isEqualTo(\"sam\");\n    assertThat(grandchild.i()).isEqualTo(12);\n    assertThat(grandchild.s()).isEqualTo(\"sam\");\n  }\n  \n  @Test\n  public void requireSubcomponentBuilders() {\n    ParentComponent parent \u003d DaggerParentComponent.create();\n    MiddleChild middle \u003d\n        parent\n            .requiresMiddleChildBuilder()\n            .subcomponentBuilder()\n            .set(new StringModule(\"sam\"))\n            .build();\n    Grandchild grandchild \u003d\n        middle\n            .requiresGrandchildBuilder()\n            .subcomponentBuilder()\n            .set(new IntModuleIncludingDoubleAndFloat(12))\n            .build();\n    assertThat(middle.s()).isEqualTo(\"sam\");\n    assertThat(grandchild.i()).isEqualTo(12);\n    assertThat(grandchild.s()).isEqualTo(\"sam\");\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\cycle\\CycleTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.cycle;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport test.cycle.Cycles.A;\nimport test.cycle.Cycles.C;\nimport test.cycle.Cycles.ChildCycleComponent;\nimport test.cycle.Cycles.CycleComponent;\nimport test.cycle.Cycles.CycleMapComponent;\nimport test.cycle.Cycles.S;\nimport test.cycle.Cycles.SelfCycleComponent;\n\n@RunWith(JUnit4.class)\npublic class CycleTest {\n  @Test\n  public void providerIndirectionSelfCycle() {\n    SelfCycleComponent selfCycleComponent \u003d DaggerCycles_SelfCycleComponent.create();\n    S s \u003d selfCycleComponent.s();\n    assertThat(s.sProvider.get()).isNotNull();\n  }\n\n  @Test\n  public void providerIndirectionCycle() {\n    CycleComponent cycleComponent \u003d DaggerCycles_CycleComponent.create();\n    A a \u003d cycleComponent.a();\n    C c \u003d cycleComponent.c();\n    assertThat(c.aProvider.get()).isNotNull();\n    assertThat(a.b.c.aProvider.get()).isNotNull();\n    assertThat(a.e.d.b.c.aProvider.get()).isNotNull();\n  }\n\n  @Test\n  public void lazyIndirectionSelfCycle() {\n    SelfCycleComponent selfCycleComponent \u003d DaggerCycles_SelfCycleComponent.create();\n    S s \u003d selfCycleComponent.s();\n    assertThat(s.sLazy.get()).isNotNull();\n  }\n\n  @Test\n  public void lazyIndirectionCycle() {\n    CycleComponent cycleComponent \u003d DaggerCycles_CycleComponent.create();\n    A a \u003d cycleComponent.a();\n    C c \u003d cycleComponent.c();\n    assertThat(c.aLazy.get()).isNotNull();\n    assertThat(a.b.c.aLazy.get()).isNotNull();\n    assertThat(a.e.d.b.c.aLazy.get()).isNotNull();\n  }\n  \n  @Test\n  public void subcomponentIndirectionCycle() {\n    ChildCycleComponent childCycleComponent \u003d DaggerCycles_CycleComponent.create().child();\n    A a \u003d childCycleComponent.a();\n    assertThat(a.b.c.aProvider.get()).isNotNull();\n    assertThat(a.e.d.b.c.aProvider.get()).isNotNull();\n  }\n  \n  @Test\n  public void providerMapIndirectionCycle() {\n    CycleMapComponent cycleMapComponent \u003d DaggerCycles_CycleMapComponent.create();\n    assertThat(cycleMapComponent.y()).isNotNull();\n    assertThat(cycleMapComponent.y().mapOfProvidersOfX).containsKey(\"X\");\n    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get(\"X\")).isNotNull();\n    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get(\"X\").get()).isNotNull();\n    assertThat(cycleMapComponent.y().mapOfProvidersOfX.get(\"X\").get().y).isNotNull();\n    assertThat(cycleMapComponent.y().mapOfProvidersOfX).hasSize(1);\n    assertThat(cycleMapComponent.y().mapOfProvidersOfY).containsKey(\"Y\");\n    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get(\"Y\")).isNotNull();\n    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get(\"Y\").get()).isNotNull();\n    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get(\"Y\").get().mapOfProvidersOfX).hasSize(1);\n    assertThat(cycleMapComponent.y().mapOfProvidersOfY.get(\"Y\").get().mapOfProvidersOfY).hasSize(1);\n    assertThat(cycleMapComponent.y().mapOfProvidersOfY).hasSize(1);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\cycle\\LongCycleTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.cycle;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport test.cycle.LongCycle.LongCycleComponent;\n\n@RunWith(JUnit4.class)\npublic class LongCycleTest {\n  \n  /**\n   * Tests a cycle long enough that the real factory is created in a separate initialize method from\n   * the delegate factory.\n   */\n  @Test\n  public void longCycle() {\n    LongCycleComponent longCycleComponent \u003d DaggerLongCycle_LongCycleComponent.create();\n    assertThat(longCycleComponent.class1()).isNotNull();\n  }\n\n  /**\n   * Fails if {@link LongCycleComponent} doesn\u0027t have a long enough cycle to make sure the real\n   * factory is created in a separate method from the delegate factory.\n   */\n  @Test\n  public void longCycleHasMoreThanOneInitializeMethod() throws NoSuchMethodException {\n    DaggerLongCycle_LongCycleComponent.class\n        .getDeclaredMethod(\"initialize2\", DaggerLongCycle_LongCycleComponent.Builder.class);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\DependsOnGeneratedCodeTest.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/**\n * @see \u003ca href\u003d\"http://b/19435358\"\u003eBug 19435358\u003c/a\u003e\n */\n@RunWith(JUnit4.class)\npublic class DependsOnGeneratedCodeTest {\n  @Test public void testComponentDependsOnGeneratedCode() {\n    assertThat(DaggerComponentDependsOnGeneratedCode.create().needsFactory()).isNotNull();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\GenericTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport test.sub.Exposed;\nimport test.sub.PublicSubclass;\n\n@RunWith(JUnit4.class)\npublic class GenericTest {\n\n  @Test public void testGenericComponentCreate() {\n    GenericComponent component \u003d DaggerGenericComponent.create();\n    assertThat(component).isNotNull();\n  }\n  \n  @Test public void testGenericSimpleReferences() {\n    GenericComponent component \u003d DaggerGenericComponent.create();\n    assertThat(component.referencesGeneric().genericA.t).isNotNull();    \n  }\n  \n  @Test public void testGenericDoubleReferences() {\n    GenericComponent component \u003d DaggerGenericComponent.create();\n    GenericDoubleReferences\u003cA\u003e doubleA \u003d component.doubleGenericA();\n    assertThat(doubleA.a).isNotNull();\n    assertThat(doubleA.a2).isNotNull();\n    assertThat(doubleA.t).isNotNull();\n    assertThat(doubleA.t2).isNotNull();\n\n    GenericDoubleReferences\u003cB\u003e doubleB \u003d component.doubleGenericB();\n    assertThat(doubleB.a).isNotNull();\n    assertThat(doubleB.a2).isNotNull();\n    assertThat(doubleB.t).isNotNull();\n    assertThat(doubleB.t2).isNotNull();\n  }\n  \n  @Test public void complexGenerics() {\n    GenericComponent component \u003d DaggerGenericComponent.create();\n    // validate these can be called w/o exceptions.\n    component.complexGenerics();\n  }\n  \n  @Test public void noDepsGenerics() {\n    GenericComponent component \u003d DaggerGenericComponent.create();\n    // validate these can be called w/o exceptions.\n    component.noDepsA();\n    component.noDepsB();\n  }\n  \n  @Test public void boundedGenerics() {\n    BoundedGenericModule expected \u003d new BoundedGenericModule();\n    BoundedGenericComponent component \u003d DaggerBoundedGenericComponent.create();\n    BoundedGenerics\u003cInteger, ArrayList\u003cString\u003e, LinkedList\u003cCharSequence\u003e, Integer, List\u003cInteger\u003e\u003e\n        b1 \u003d component.bounds1();\n    assertEquals(expected.provideInteger(), b1.a);\n    assertEquals(expected.provideArrayListString(), b1.b);\n    assertEquals(expected.provideLinkedListCharSeq(), b1.c);\n    assertEquals(expected.provideInteger(), b1.d);\n    assertEquals(expected.provideListOfInteger(), b1.e);\n\n    BoundedGenerics\u003cDouble, LinkedList\u003cString\u003e, LinkedList\u003cComparable\u003cString\u003e\u003e, Double, Set\u003cDouble\u003e\u003e\n        b2 \u003d component.bounds2();\n    assertEquals(expected.provideDouble(), b2.a);\n    assertEquals(expected.provideLinkedListString(), b2.b);\n    assertEquals(expected.provideArrayListOfComparableString(), b2.c);\n    assertEquals(expected.provideDouble(), b2.d);\n    assertEquals(expected.provideSetOfDouble(), b2.e);\n  }\n  \n  @Test public void membersInjections() {\n    GenericComponent component \u003d DaggerGenericComponent.create();\n    GenericChild\u003cA\u003e childA \u003d new GenericChild\u003cA\u003e();\n    component.injectA(childA);\n    assertThat(childA.a).isNotNull();\n    assertThat(childA.b).isNotNull();\n    assertThat(childA.registeredA).isNotNull();\n    assertThat(childA.registeredB).isNotNull();\n    assertThat(childA.registeredT).isNotNull();\n    assertThat(childA.registeredX).isNotNull();\n    assertThat(childA.registeredY).isNotNull();\n    \n    GenericChild\u003cB\u003e childB \u003d new GenericChild\u003cB\u003e();\n    component.injectB(childB);\n    assertThat(childB.a).isNotNull();\n    assertThat(childB.b).isNotNull();\n    assertThat(childB.registeredA).isNotNull();\n    assertThat(childB.registeredB).isNotNull();\n    assertThat(childB.registeredT).isNotNull();\n    assertThat(childB.registeredX).isNotNull();\n    assertThat(childB.registeredY).isNotNull();\n  }\n  \n  @Test public void packagePrivateTypeParameterDependencies() {\n    GenericComponent component \u003d DaggerGenericComponent.create();\n    Exposed exposed \u003d component.exposed();\n    assertThat(exposed.gpp.t).isNotNull();\n    assertThat(exposed.gpp2).isNotNull();\n  }\n  \n  @SuppressWarnings(\"rawtypes\")\n  @Test public void publicSubclassWithPackagePrivateTypeParameterOfSuperclass() {\n    GenericComponent component \u003d DaggerGenericComponent.create();\n    PublicSubclass publicSubclass \u003d component.publicSubclass();\n    assertThat(((Generic)publicSubclass).t).isNotNull();\n  }\n  \n  @Test public void singletonScopesAppliesToEachResolvedType() {\n    SingletonGenericComponent component \u003d DaggerSingletonGenericComponent.create();\n    ScopedGeneric\u003cA\u003e a \u003d component.scopedGenericA();\n    assertThat(a).isSameAs(component.scopedGenericA());\n    assertThat(a.t).isNotNull();\n    \n    ScopedGeneric\u003cB\u003e b \u003d component.scopedGenericB();\n    assertThat(b).isSameAs(component.scopedGenericB());\n    assertThat(b.t).isNotNull();\n    \n    assertThat(a).isNotSameAs(b);\n  }\n  \n  @Test public void genericModules() {\n    GenericComponent component \u003d DaggerGenericComponent.create();\n    assertThat(component.iterableInt()).containsExactly(1, 2).inOrder();\n    assertThat(component.iterableDouble()).containsExactly(3d, 4d).inOrder();\n    \n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\membersinject\\MembersInjectTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.membersinject;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport dagger.MembersInjector;\nimport javax.inject.Provider;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport test.multipackage.DaggerMembersInjectionVisibilityComponent;\nimport test.multipackage.MembersInjectionVisibilityComponent;\nimport test.multipackage.a.AGrandchild;\nimport test.multipackage.a.AParent;\nimport test.multipackage.b.BChild;\n\n@RunWith(JUnit4.class)\npublic class MembersInjectTest {\n  @Test public void testMembersInject_arrays() {\n    MembersInjectComponent component \u003d DaggerMembersInjectComponent.builder().build();\n\n    ChildOfStringArray childOfStringArray \u003d new ChildOfStringArray();\n    component.inject(childOfStringArray);\n  }\n\n  @Test public void testMembersInject_nestedArrays() {\n    MembersInjectComponent component \u003d DaggerMembersInjectComponent.builder().build();\n\n    ChildOfArrayOfParentOfStringArray childOfArrayOfParentOfStringArray \u003d\n        new ChildOfArrayOfParentOfStringArray();\n    component.inject(childOfArrayOfParentOfStringArray);\n  }\n\n  @Test public void testMembersInject_primitives() {\n    MembersInjectComponent component \u003d DaggerMembersInjectComponent.builder().build();\n\n    ChildOfPrimitiveIntArray childOfPrimitiveIntArray \u003d new ChildOfPrimitiveIntArray();\n    component.inject(childOfPrimitiveIntArray);\n  }\n\n  @Test\n  public void testMembersInject_overrides() {\n    MembersInjectionVisibilityComponent component \u003d\n        DaggerMembersInjectionVisibilityComponent.create();\n    AParent aParent \u003d new AParent();\n    component.inject(aParent);\n    assertThat(aParent.aParentField()).isNotNull();\n    assertThat(aParent.aParentMethod()).isNotNull();\n\n    BChild aChild \u003d new BChild();\n    component.inject(aChild);\n    assertThat(aChild.aParentField()).isNotNull();\n    assertThat(aChild.aParentMethod()).isNull();\n    assertThat(aChild.aChildField()).isNotNull();\n    assertThat(aChild.aChildMethod()).isNotNull();\n\n    AGrandchild aGrandchild \u003d new AGrandchild();\n    component.inject(aGrandchild);\n    assertThat(aGrandchild.aParentField()).isNotNull();\n    assertThat(aGrandchild.aParentMethod()).isNotNull();\n    assertThat(aGrandchild.aChildField()).isNotNull();\n    assertThat(aGrandchild.aChildMethod()).isNull();\n    assertThat(aGrandchild.aGrandchildField()).isNotNull();\n    assertThat(aGrandchild.aGrandchildMethod()).isNotNull();\n  }\n\n  @Test\n  public void testNonRequestedMembersInjector() {\n    NonRequestedChild child \u003d new NonRequestedChild();\n    Provider\u003cString\u003e provider \u003d\n        new Provider\u003cString\u003e() {\n          @Override\n          public String get() {\n            return \"field!\";\n          }\n        };\n    MembersInjector\u003cNonRequestedChild\u003e injector \u003d new NonRequestedChild_MembersInjector(provider);\n    injector.injectMembers(child);\n    assertThat(child.t).isEqualTo(\"field!\");\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\MultibindingTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage test;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.google.auto.value.AutoAnnotation;\nimport com.google.common.collect.ImmutableList;\nimport dagger.multibindings.ClassKey;\nimport dagger.multibindings.StringKey;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Map;\nimport javax.inject.Provider;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\n\n@RunWith(Parameterized.class)\npublic class MultibindingTest {\n\n  private static final MultibindingDependency MULTIBINDING_DEPENDENCY \u003d\n      new MultibindingDependency() {\n        @Override\n        public double doubleDependency() {\n          return 0.0;\n        }\n      };\n\n  @Parameters(name \u003d \"{0}\")\n  public static Iterable\u003cObject[]\u003e parameters() {\n    return ImmutableList.copyOf(\n        new Object[][] {\n          {\n            DaggerMultibindingComponent.builder()\n                .multibindingDependency(MULTIBINDING_DEPENDENCY)\n                .build()\n          },\n          {\n            DaggerMultibindingComponentWithMultibindingsInterface.builder()\n                .multibindingDependency(MULTIBINDING_DEPENDENCY)\n                .build()\n          }\n        });\n  }\n\n  private final MultibindingComponent multibindingComponent;\n\n  public MultibindingTest(MultibindingComponent multibindingComponent) {\n    this.multibindingComponent \u003d multibindingComponent;\n  }\n\n  @Test public void map() {\n    Map\u003cString, String\u003e map \u003d multibindingComponent.map();\n    assertThat(map).hasSize(3);\n    assertThat(map).containsEntry(\"foo\", \"foo value\");\n    assertThat(map).containsEntry(\"bar\", \"bar value\");\n    assertThat(map).containsEntry(\"foo @Provides(type)\", \"foo @Provides(type) value\");\n  }\n\n  @Test public void mapOfArrays() {\n    Map\u003cString, String[]\u003e map \u003d multibindingComponent.mapOfArrays();\n    assertThat(map).hasSize(2);\n    assertThat(map).containsKey(\"foo\");\n    assertThat(map.get(\"foo\")).asList().containsExactly(\"foo1\", \"foo2\").inOrder();\n    assertThat(map).containsKey(\"bar\");\n    assertThat(map.get(\"bar\")).asList().containsExactly(\"bar1\", \"bar2\").inOrder();\n  }\n\n  @Test public void mapOfProviders() {\n    Map\u003cString, Provider\u003cString\u003e\u003e mapOfProviders \u003d multibindingComponent.mapOfProviders();\n    assertThat(mapOfProviders).hasSize(3);\n    assertThat(mapOfProviders.get(\"foo\").get()).isEqualTo(\"foo value\");\n    assertThat(mapOfProviders.get(\"bar\").get()).isEqualTo(\"bar value\");\n    assertThat(mapOfProviders.get(\"foo @Provides(type)\").get())\n        .isEqualTo(\"foo @Provides(type) value\");\n  }\n\n  @Test public void mapKeysAndValues() {\n    assertThat(multibindingComponent.mapKeys())\n        .containsExactly(\"foo\", \"bar\", \"foo @Provides(type)\");\n    assertThat(multibindingComponent.mapValues())\n        .containsExactly(\"foo value\", \"bar value\", \"foo @Provides(type) value\");\n  }\n\n  @Test public void nestedKeyMap() {\n    assertThat(multibindingComponent.nestedKeyMap())\n        .containsExactly(\n            nestedWrappedKey(Integer.class), \"integer\", nestedWrappedKey(Long.class), \"long\");\n  }\n\n  @Test\n  public void unwrappedAnnotationKeyMap() {\n    assertThat(multibindingComponent.unwrappedAnnotationKeyMap())\n        .containsExactly(testStringKey(\"foo\\n\"), \"foo annotation\");\n  }\n\n  @Test\n  public void wrappedAnnotationKeyMap() {\n    @SuppressWarnings(\"unchecked\")\n    Class\u003c? extends Number\u003e[] classes \u003d new Class[] {Long.class, Integer.class};\n    assertThat(multibindingComponent.wrappedAnnotationKeyMap())\n        .containsExactly(\n            testWrappedAnnotationKey(\n                testStringKey(\"foo\"), new int[] {1, 2, 3}, new ClassKey[] {}, classes),\n            \"wrapped foo annotation\");\n  }\n\n  @Test\n  public void booleanKeyMap() {\n    assertThat(multibindingComponent.booleanKeyMap()).containsExactly(true, \"true\");\n  }\n\n  @Test\n  public void byteKeyMap() {\n    assertThat(multibindingComponent.byteKeyMap()).containsExactly((byte) 100, \"100 byte\");\n  }\n\n  @Test\n  public void charKeyMap() {\n    assertThat(multibindingComponent.characterKeyMap())\n        .containsExactly(\u0027a\u0027, \"a char\", \u0027\\n\u0027, \"newline char\");\n  }\n\n  @Test\n  public void classKeyMap() {\n    assertThat(multibindingComponent.classKeyMap())\n        .containsExactly(Integer.class, \"integer\", Long.class, \"long\");\n  }\n\n  @Test\n  public void numberClassKeyMap() {\n    assertThat(multibindingComponent.numberClassKeyMap())\n        .containsExactly(BigDecimal.class, \"bigdecimal\", BigInteger.class, \"biginteger\");\n  }\n\n  @Test\n  public void intKeyMap() {\n    assertThat(multibindingComponent.integerKeyMap()).containsExactly(100, \"100 int\");\n  }\n\n  @Test\n  public void longKeyMap() {\n    assertThat(multibindingComponent.longKeyMap()).containsExactly((long) 100, \"100 long\");\n  }\n\n  @Test\n  public void shortKeyMap() {\n    assertThat(multibindingComponent.shortKeyMap()).containsExactly((short) 100, \"100 short\");\n  }\n\n  @Test public void setBindings() {\n    assertThat(multibindingComponent.set())\n        .containsExactly(-90, -17, -1, 5, 6, 832, 1742, -100, -101, -102);\n  }\n\n  @Test\n  public void complexQualifierSet() {\n    assertThat(multibindingComponent.complexQualifierStringSet()).containsExactly(\"foo\");\n  }\n\n  @Test\n  public void emptySet() {\n    assertThat(multibindingComponent.emptySet()).isEmpty();\n  }\n\n  @Test\n  public void emptyQualifiedSet() {\n    assertThat(multibindingComponent.emptyQualifiedSet()).isEmpty();\n  }\n\n  @Test\n  public void emptyMap() {\n    assertThat(multibindingComponent.emptyMap()).isEmpty();\n  }\n\n  @Test\n  public void emptyQualifiedMap() {\n    assertThat(multibindingComponent.emptyQualifiedMap()).isEmpty();\n  }\n\n  @Test\n  public void maybeEmptySet() {\n    assertThat(multibindingComponent.maybeEmptySet()).containsExactly(\"foo\");\n  }\n\n  @Test\n  public void maybeEmptyQualifiedSet() {\n    assertThat(multibindingComponent.maybeEmptyQualifiedSet()).containsExactly(\"qualified foo\");\n  }\n\n  @Test\n  public void maybeEmptyMap() {\n    assertThat(multibindingComponent.maybeEmptyMap()).containsEntry(\"key\", \"foo value\");\n  }\n\n  @Test\n  public void maybeEmptyQualifiedMap() {\n    assertThat(multibindingComponent.maybeEmptyQualifiedMap())\n        .containsEntry(\"key\", \"qualified foo value\");\n  }\n\n  @AutoAnnotation\n  static StringKey testStringKey(String value) {\n    return new AutoAnnotation_MultibindingTest_testStringKey(value);\n  }\n\n  @AutoAnnotation\n  static NestedAnnotationContainer.NestedWrappedKey nestedWrappedKey(Class\u003c?\u003e value) {\n    return new AutoAnnotation_MultibindingTest_nestedWrappedKey(value);\n  }\n\n  @AutoAnnotation\n  static WrappedAnnotationKey testWrappedAnnotationKey(\n      StringKey value, int[] integers, ClassKey[] annotations, Class\u003c? extends Number\u003e[] classes) {\n    return new AutoAnnotation_MultibindingTest_testWrappedAnnotationKey(\n        value, integers, annotations, classes);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\NestedTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class NestedTest {\n  @Test public void nestedFoo() {\n    OuterClassFoo.NestedComponent nestedFoo \u003d DaggerOuterClassFoo_NestedComponent.create();\n    assertThat(nestedFoo.thing()).isNotNull();\n  }\n\n  @Test public void nestedBar() {\n    OuterClassBar.NestedComponent nestedBar \u003d DaggerOuterClassBar_NestedComponent.create();\n    assertThat(nestedBar.injectedThing()).isNotNull();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\NonComponentDependencyTest.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class NonComponentDependencyTest {\n  @Test public void testThing() {\n    NonComponentDependencyComponent component \u003d\n        DaggerNonComponentDependencyComponent.builder()\n            .thingComponent(new NonComponentDependencyComponent.ThingComponentImpl())\n            .build();\n    assertThat(component).isNotNull();\n    assertThat(component.thingTwo()).isNotNull();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\nullables\\NullabilityTest.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage test.nullables;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\n\nimport javax.inject.Provider;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class NullabilityTest {\n  @Test public void testNullability_provides() {\n    NullModule module \u003d new NullModule();\n    NullComponent component \u003d DaggerNullComponent.builder().nullModule(module).build();\n\n    // Can\u0027t construct NullFoo because it depends on Number, and Number was null.\n    try {\n      component.nullFoo();\n      fail();\n    } catch (NullPointerException npe) {\n      assertThat(npe).hasMessage(\"Cannot return null from a non-@Nullable @Provides method\");\n    }\n\n    // set number to non-null so we can create\n    module.numberValue \u003d 1;\n    NullFoo nullFoo \u003d component.nullFoo();\n\n    // Then set it back to null so we can test its providers.\n    module.numberValue \u003d null;\n    validate(true, nullFoo.string, nullFoo.stringProvider, nullFoo.numberProvider);\n    validate(true, nullFoo.methodInjectedString, nullFoo.methodInjectedStringProvider,\n        nullFoo.methodInjectedNumberProvider);\n    validate(true, nullFoo.fieldInjectedString, nullFoo.fieldInjectedStringProvider,\n        nullFoo.fieldInjectedNumberProvider);\n  }\n  \n  @Test public void testNullability_components() {\n    NullComponent nullComponent \u003d new NullComponent() {      \n      @Override public Provider\u003cString\u003e stringProvider() {\n        return new Provider\u003cString\u003e() {\n          @Override public String get() {\n            return null;\n          }\n        };\n      }\n      \n      @Override public String string() {\n        return null;\n      }\n      \n      @Override public Provider\u003cNumber\u003e numberProvider() {\n        return new Provider\u003cNumber\u003e() {\n          @Override public Number get() {\n            return null;\n          }\n        };\n      }\n      \n      @Override public Number number() {\n        return null;\n      }\n      \n      @Override public NullFoo nullFoo() {\n        return null;\n      }\n    };\n    NullComponentWithDependency component \u003d\n        DaggerNullComponentWithDependency.builder().nullComponent(nullComponent).build();\n    validate(false, component.string(), component.stringProvider(), component.numberProvider());\n    \n    // Also validate that the component\u0027s number() method fails\n    try {\n      component.number();\n      fail();\n    } catch (NullPointerException npe) {\n      assertThat(npe).hasMessage(\"Cannot return null from a non-@Nullable component method\");\n    }\n  }\n\n  private void validate(boolean fromProvides,\n      String string,\n      Provider\u003cString\u003e stringProvider,\n      Provider\u003cNumber\u003e numberProvider) {\n    assertThat(string).isNull();\n    assertThat(numberProvider).isNotNull();\n    try {\n      numberProvider.get();\n      fail();\n    } catch(NullPointerException npe) {\n      assertThat(npe).hasMessage(\"Cannot return null from a non-@Nullable \"\n          + (fromProvides ? \"@Provides\" : \"component\") + \" method\");\n    }\n    assertThat(stringProvider.get()).isNull();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\ReusableTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport test.ComponentWithReusableBindings.ChildOne;\nimport test.ComponentWithReusableBindings.ChildTwo;\n\n@RunWith(JUnit4.class)\npublic class ReusableTest {\n  @Test\n  public void testReusable() {\n    ComponentWithReusableBindings parent \u003d DaggerComponentWithReusableBindings.create();\n    ChildOne childOne \u003d parent.childOne();\n    ChildTwo childTwo \u003d parent.childTwo();\n\n    Object reusableInParent \u003d parent.reusableInParent();\n    assertThat(parent.reusableInParent()).isSameAs(reusableInParent);\n    assertThat(childOne.reusableInParent()).isSameAs(reusableInParent);\n    assertThat(childTwo.reusableInParent()).isSameAs(reusableInParent);\n\n    Object reusableFromChildOne \u003d childOne.reusableInChild();\n    assertThat(childOne.reusableInChild()).isSameAs(reusableFromChildOne);\n\n    Object reusableFromChildTwo \u003d childTwo.reusableInChild();\n    assertThat(childTwo.reusableInChild()).isSameAs(reusableFromChildTwo);\n\n    assertThat(reusableFromChildTwo).isNotSameAs(reusableFromChildOne);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\scope\\ScopeTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.scope;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic final class ScopeTest {\n\n  @Test\n  public void testScope() {\n    ScopedComponent component \u003d DaggerScopedComponent.create();\n    assertThat(component.set()).hasSize(4);\n    assertThat(component.set()).isEqualTo(component.set());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\staticprovides\\StaticProvidesTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.staticprovides;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static com.google.common.truth.Truth.assertWithMessage;\n\nimport com.google.common.collect.ImmutableSet;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameter;\nimport org.junit.runners.Parameterized.Parameters;\n\n@RunWith(Parameterized.class)\npublic class StaticProvidesTest {\n  @Parameters\n  public static Collection\u003cObject[]\u003e components() {\n    return Arrays.asList(new Object[][] {\n        {DaggerStaticTestComponent.create()},\n        {DaggerStaticTestComponentWithBuilder.builder().build()},\n        {DaggerStaticTestComponentWithBuilder.builder()\n          .allStaticModule(new AllStaticModule())\n          .someStaticModule(new SomeStaticModule())\n          .build()}});\n  }\n\n  @Parameter\n  public StaticTestComponent component;\n\n  @Test public void setMultibinding() {\n    assertThat(component.getMultiboundStrings()).isEqualTo(ImmutableSet.of(\n        AllStaticModule.class + \".contributeString\",\n        SomeStaticModule.class + \".contributeStringFromAStaticMethod\",\n        SomeStaticModule.class + \".contributeStringFromAnInstanceMethod\"));\n  }\n\n  @Test public void allStaticProvidesModules_noFieldInComponentBuilder() {\n    for (Field field : DaggerStaticTestComponent.Builder.class.getDeclaredFields()) {\n      assertWithMessage(field.getName())\n          .that(field.getType()).isNotEqualTo(AllStaticModule.class);\n    }\n  }\n\n  @Test public void allStaticProvidesModules_deprecatedMethodInComponentBuilder() {\n    for (Method method : DaggerStaticTestComponent.Builder.class.getDeclaredMethods()) {\n      if (Arrays.asList(method.getParameterTypes()).contains(AllStaticModule.class)) {\n        assertWithMessage(method.getName())\n            .that(method.isAnnotationPresent(Deprecated.class))\n            .isTrue();\n      }\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\subcomponent\\hiding\\SubcomponentHidingTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.hiding;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class SubcomponentHidingTest {\n  @Test public void moduleNameHiding() {\n    ParentComponent parent \u003d DaggerParentComponent.create();\n    assertThat(parent.aCommonName().toString()).isEqualTo(\"a\");\n    assertThat(parent.newChildComponent().aCommonName().toString()).isEqualTo(\"a\");\n    assertThat(parent.newChildComponent().bCommonName().toString()).isEqualTo(\"1\");\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\subcomponent\\ModuleWithSubcomponentsTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport dagger.Module;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport test.subcomponent.UsesModuleSubcomponents.ParentIncludesSubcomponentTransitively;\n\n/** Tests for {@link Module#subcomponents()}. */\n@RunWith(JUnit4.class)\npublic class ModuleWithSubcomponentsTest {\n\n  @Test\n  public void subcomponentFromModules() {\n    UsesModuleSubcomponents parent \u003d DaggerUsesModuleSubcomponents.create();\n    assertThat(parent.strings()).containsExactly(\"from parent\");\n    assertThat(parent.usesChild().strings).containsExactly(\"from parent\", \"from child\");\n  }\n\n  @Test\n  public void subcomponentFromModules_transitively() {\n    ParentIncludesSubcomponentTransitively parent \u003d\n        DaggerUsesModuleSubcomponents_ParentIncludesSubcomponentTransitively.create();\n    assertThat(parent.strings()).containsExactly(\"from parent\");\n    assertThat(parent.usesChild().strings).containsExactly(\"from parent\", \"from child\");\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\subcomponent\\pruning\\SubcomponentOnlyRequestedBySiblingTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.pruning;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport dagger.Module;\nimport dagger.Subcomponent;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport test.subcomponent.pruning.ParentDoesntUseSubcomponent.ChildA;\nimport test.subcomponent.pruning.ParentDoesntUseSubcomponent.ChildB;\n\n/**\n * Tests for {@link Subcomponent}s which are included with {@link Module#subcomponents()} but not\n * used directly within the component which adds them.\n *\n * \u003cp\u003eThis tests to make sure that while resolving one subcomponent (A), another subcomponent (B)\n * can be requested if they have a shared ancestor component. If that shared ancestor did not\n * resolve B directly via any of its entry points, B will still be generated since it is requested\n * by a descendant.\n */\n@RunWith(JUnit4.class)\npublic class SubcomponentOnlyRequestedBySiblingTest {\n  @Test\n  public void subcomponentAddedInParent_onlyUsedInSibling() {\n    ParentDoesntUseSubcomponent parent \u003d DaggerParentDoesntUseSubcomponent.create();\n    ChildB childB \u003d parent.childBBuilder().build();\n    assertThat(childB.componentHierarchy())\n        .containsExactly(ParentDoesntUseSubcomponent.class, ChildB.class);\n    assertThat(childB.componentHierarchyFromChildA())\n        .containsExactly(ParentDoesntUseSubcomponent.class, ChildA.class);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\subcomponent\\repeat\\RepeatedModuleTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent.repeat;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic final class RepeatedModuleTest {\n  private ParentComponent parentComponent;\n\n  @Before\n  public void initializeParentComponent() {\n    this.parentComponent \u003d DaggerParentComponent.builder().build();\n  }\n\n  @Test\n  public void repeatedModuleHasSameStateInSubcomponent() {\n    SubcomponentWithRepeatedModule childComponent \u003d\n        parentComponent.newChildComponentBuilder().build();\n    assertThat(parentComponent.state()).isSameAs(childComponent.state());\n  }\n\n  @Test\n  public void repeatedModuleHasSameStateInGrandchildSubcomponent() {\n    SubcomponentWithoutRepeatedModule childComponent \u003d\n        parentComponent.newChildComponentWithoutRepeatedModule();\n    SubcomponentWithRepeatedModule grandchildComponent \u003d\n        childComponent.newGrandchildBuilder().build();\n    assertThat(parentComponent.state()).isSameAs(grandchildComponent.state());\n  }\n\n  @Test\n  public void repeatedModuleBuilderThrowsInSubcomponent() {\n    SubcomponentWithRepeatedModule.Builder childComponentBuilder \u003d\n        parentComponent.newChildComponentBuilder();\n    try {\n      childComponentBuilder.repeatedModule(new RepeatedModule());\n      fail();\n    } catch (UnsupportedOperationException expected) {\n      assertThat(expected)\n          .hasMessage(\n              \"test.subcomponent.repeat.RepeatedModule cannot be set \"\n                  + \"because it is inherited from the enclosing component\");\n    }\n  }\n\n  @Test\n  public void repeatedModuleBuilderThrowsInGrandchildSubcomponent() {\n    SubcomponentWithoutRepeatedModule childComponent \u003d\n        parentComponent.newChildComponentWithoutRepeatedModule();\n    OtherSubcomponentWithRepeatedModule.Builder grandchildComponentBuilder \u003d\n        childComponent.newGrandchildBuilder();\n    try {\n      grandchildComponentBuilder.repeatedModule(new RepeatedModule());\n      fail();\n    } catch (UnsupportedOperationException expected) {\n      assertThat(expected)\n          .hasMessage(\n              \"test.subcomponent.repeat.RepeatedModule cannot be set \"\n                  + \"because it is inherited from the enclosing component\");\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\subcomponent\\SubcomponentMultibindingsTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport test.subcomponent.MultibindingSubcomponents.BoundInChild;\nimport test.subcomponent.MultibindingSubcomponents.BoundInParent;\nimport test.subcomponent.MultibindingSubcomponents.BoundInParentAndChild;\nimport test.subcomponent.MultibindingSubcomponents.ParentWithProvisionHasChildWithProvision;\nimport test.subcomponent.MultibindingSubcomponents.ParentWithProvisionHasChildWithoutProvision;\nimport test.subcomponent.MultibindingSubcomponents.ParentWithoutProvisionHasChildWithProvision;\nimport test.subcomponent.MultibindingSubcomponents.ParentWithoutProvisionHasChildWithoutProvision;\nimport test.subcomponent.MultibindingSubcomponents.RequiresMultibindings;\n\n@RunWith(JUnit4.class)\npublic class SubcomponentMultibindingsTest {\n\n  private static final RequiresMultibindings\u003cBoundInParent\u003e BOUND_IN_PARENT \u003d\n      new RequiresMultibindings\u003c\u003e(\n          ImmutableSet.of(BoundInParent.INSTANCE),\n          ImmutableMap.of(\"parent key\", BoundInParent.INSTANCE));\n\n  private static final RequiresMultibindings\u003cBoundInChild\u003e BOUND_IN_CHILD \u003d\n      new RequiresMultibindings\u003c\u003e(\n          ImmutableSet.of(BoundInChild.INSTANCE),\n          ImmutableMap.of(\"child key\", BoundInChild.INSTANCE));\n\n  private static final RequiresMultibindings\u003cBoundInParentAndChild\u003e BOUND_IN_PARENT_AND_CHILD \u003d\n      new RequiresMultibindings\u003c\u003e(\n          ImmutableSet.of(BoundInParentAndChild.IN_PARENT, BoundInParentAndChild.IN_CHILD),\n          ImmutableMap.of(\n              \"parent key\", BoundInParentAndChild.IN_PARENT,\n              \"child key\", BoundInParentAndChild.IN_CHILD));\n\n  private static final RequiresMultibindings\u003cBoundInParentAndChild\u003e\n      BOUND_IN_PARENT_AND_CHILD_PROVIDED_BY_PARENT \u003d\n          new RequiresMultibindings\u003c\u003e(\n              ImmutableSet.of(BoundInParentAndChild.IN_PARENT),\n              ImmutableMap.of(\"parent key\", BoundInParentAndChild.IN_PARENT));\n\n  private ParentWithoutProvisionHasChildWithoutProvision\n      parentWithoutProvisionHasChildWithoutProvision;\n  private ParentWithoutProvisionHasChildWithProvision parentWithoutProvisionHasChildWithProvision;\n  private ParentWithProvisionHasChildWithoutProvision parentWithProvisionHasChildWithoutProvision;\n  private ParentWithProvisionHasChildWithProvision parentWithProvisionHasChildWithProvision;\n\n  @Before\n  public void setUp() {\n    parentWithoutProvisionHasChildWithoutProvision \u003d\n        DaggerMultibindingSubcomponents_ParentWithoutProvisionHasChildWithoutProvision.create();\n    parentWithoutProvisionHasChildWithProvision \u003d\n        DaggerMultibindingSubcomponents_ParentWithoutProvisionHasChildWithProvision.create();\n    parentWithProvisionHasChildWithoutProvision \u003d\n        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithoutProvision.create();\n    parentWithProvisionHasChildWithProvision \u003d\n        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithProvision.create();\n  }\n\n  @Test\n  public void testParentWithoutProvisionHasChildWithoutProvision() {\n    // Child\n    assertThat(\n            parentWithoutProvisionHasChildWithoutProvision\n                .childWithoutProvision()\n                .grandchild()\n                .requiresMultibindingsBoundInParent())\n        .isEqualTo(BOUND_IN_PARENT);\n\n    // Grandchild\n    assertThat(\n            parentWithoutProvisionHasChildWithoutProvision\n                .childWithoutProvision()\n                .grandchild()\n                .requiresMultibindingsBoundInParentAndChild())\n        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);\n    assertThat(\n            parentWithoutProvisionHasChildWithoutProvision\n                .childWithoutProvision()\n                .grandchild()\n                .requiresMultibindingsBoundInChild())\n        .isEqualTo(BOUND_IN_CHILD);\n\n    /*\n     * Even though the multibinding for Set\u003cRequiresMultiboundObjects\u003e does not itself have a\n     * contribution from the child, it must be pushed down to (not duplicated in) the child because\n     * its contribution depends on multibindings that have one contribution from the parent and one\n     * from the child.\n     *\n     */\n    assertThat(\n            parentWithoutProvisionHasChildWithoutProvision\n                .childWithoutProvision()\n                .grandchild()\n                .setOfRequiresMultibindingsInParentAndChild())\n        .containsExactly(BOUND_IN_PARENT_AND_CHILD);\n  }\n\n  @Test\n  public void testParentWithoutProvisionHasChildWithProvision() {\n    // Child\n    assertThat(\n            parentWithoutProvisionHasChildWithProvision\n                .childWithProvision()\n                .grandchild()\n                .requiresMultibindingsBoundInParent())\n        .isEqualTo(BOUND_IN_PARENT);\n\n    // Grandchild\n    assertThat(\n            parentWithoutProvisionHasChildWithProvision\n                .childWithProvision()\n                .grandchild()\n                .requiresMultibindingsBoundInParentAndChild())\n        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);\n    assertThat(\n            parentWithoutProvisionHasChildWithProvision\n                .childWithProvision()\n                .grandchild()\n                .requiresMultibindingsBoundInChild())\n        .isEqualTo(BOUND_IN_CHILD);\n\n    /*\n     * Even though the multibinding for Set\u003cRequiresMultiboundObjects\u003e does not itself have a\n     * contribution from the child, it must be pushed down to (not duplicated in) the child because\n     * its contribution depends on multibindings that have one contribution from the parent and one\n     * from the child.\n     *\n     */\n    assertThat(\n            parentWithoutProvisionHasChildWithProvision\n                .childWithProvision()\n                .grandchild()\n                .setOfRequiresMultibindingsInParentAndChild())\n        .containsExactly(BOUND_IN_PARENT_AND_CHILD);\n  }\n\n  @Test\n  public void testParentWithProvisionHasChildWithoutProvision() {\n    // Parent\n    assertThat(parentWithProvisionHasChildWithoutProvision.requiresMultibindingsBoundInParent())\n        .isEqualTo(BOUND_IN_PARENT);\n\n    assertThat(\n            parentWithProvisionHasChildWithoutProvision\n                .requiresMultibindingsBoundInParentAndChild())\n        .isEqualTo(BOUND_IN_PARENT_AND_CHILD_PROVIDED_BY_PARENT);\n\n    // Grandchild\n    assertThat(\n            parentWithProvisionHasChildWithoutProvision\n                .childWithoutProvision()\n                .grandchild()\n                .requiresMultibindingsBoundInParent())\n        .isEqualTo(BOUND_IN_PARENT);\n    assertThat(\n            parentWithProvisionHasChildWithoutProvision\n                .childWithoutProvision()\n                .grandchild()\n                .requiresMultibindingsBoundInChild())\n        .isEqualTo(BOUND_IN_CHILD);\n\n    assertThat(\n            parentWithProvisionHasChildWithoutProvision\n                .childWithoutProvision()\n                .grandchild()\n                .requiresMultibindingsBoundInParentAndChild())\n        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);\n\n    /*\n     * Even though the multibinding for Set\u003cRequiresMultiboundObjects\u003e does not itself have a\n     * contribution from the child, it must be pushed down to (not duplicated in) the child because\n     * its contribution depends on multibindings that have one contribution from the parent and one\n     * from the child.\n     *\n     */\n    assertThat(\n            parentWithProvisionHasChildWithoutProvision\n                .childWithoutProvision()\n                .grandchild()\n                .setOfRequiresMultibindingsInParentAndChild())\n        .containsExactly(BOUND_IN_PARENT_AND_CHILD);\n  }\n\n  @Test\n  public void testParentWithProvisionHasChildWithProvision() {\n    // Parent\n    assertThat(parentWithProvisionHasChildWithProvision.requiresMultibindingsBoundInParent())\n        .isEqualTo(BOUND_IN_PARENT);\n\n    // Child\n    assertThat(\n            parentWithProvisionHasChildWithProvision\n                .childWithProvision()\n                .requiresMultibindingsBoundInParent())\n        .isEqualTo(BOUND_IN_PARENT);\n    assertThat(\n            parentWithProvisionHasChildWithProvision\n                .childWithProvision()\n                .requiresMultibindingsBoundInChild())\n        .isEqualTo(BOUND_IN_CHILD);\n    assertThat(\n            parentWithProvisionHasChildWithProvision\n                .childWithProvision()\n                .requiresMultibindingsBoundInParentAndChild())\n        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);\n\n    // https://github.com/google/dagger/issues/401\n    assertThat(\n        DaggerMultibindingSubcomponents_ParentWithProvisionHasChildWithBinds.create()\n            .childWithBinds()\n            .requiresMultibindingsBoundInParentAndChild())\n        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);\n\n    /*\n     * Even though the multibinding for Set\u003cRequiresMultiboundObjects\u003e does not itself have a\n     * contribution from the child, it must be pushed down to (not duplicated in) the child because\n     * its contribution depends on multibindings that have one contribution from the parent and one\n     * from the child.\n     *\n     */\n    assertThat(\n            parentWithProvisionHasChildWithProvision\n                .childWithProvision()\n                .setOfRequiresMultibindingsInParentAndChild())\n        .containsExactly(BOUND_IN_PARENT_AND_CHILD);\n\n    // Grandchild\n    assertThat(\n            parentWithProvisionHasChildWithProvision\n                .childWithProvision()\n                .grandchild()\n                .requiresMultibindingsBoundInParent())\n        .isEqualTo(BOUND_IN_PARENT);\n    assertThat(\n            parentWithProvisionHasChildWithProvision\n                .childWithProvision()\n                .grandchild()\n                .requiresMultibindingsBoundInChild())\n        .isEqualTo(BOUND_IN_CHILD);\n    assertThat(\n            parentWithProvisionHasChildWithProvision\n                .childWithProvision()\n                .grandchild()\n                .requiresMultibindingsBoundInParentAndChild())\n        .isEqualTo(BOUND_IN_PARENT_AND_CHILD);\n\n    /*\n     * Even though the multibinding for Set\u003cRequiresMultiboundObjects\u003e does not itself have a\n     * contribution from the child, it must be pushed down to (not duplicated in) the child because\n     * its contribution depends on multibindings that have one contribution from the parent and one\n     * from the child.\n     *\n     */\n    assertThat(\n            parentWithProvisionHasChildWithProvision\n                .childWithProvision()\n                .grandchild()\n                .setOfRequiresMultibindingsInParentAndChild())\n        .containsExactly(BOUND_IN_PARENT_AND_CHILD);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\functional-tests\\src\\test\\java\\test\\subcomponent\\SubcomponentTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.subcomponent;\n\nimport static com.google.common.collect.Sets.intersection;\nimport static com.google.common.truth.Truth.assertThat;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Set;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\n\n@RunWith(Parameterized.class)\npublic class SubcomponentTest {\n  private static final ParentComponent parentComponent \u003d DaggerParentComponent.create();\n  private static final ParentOfGenericComponent parentOfGenericComponent \u003d\n      DaggerParentOfGenericComponent.create();\n  \n  @Parameters\n  public static Collection\u003cObject[]\u003e parameters() {\n    return Arrays.asList(new Object[][] {\n        { parentComponent, parentComponent.newChildComponent() },\n        { parentComponent, parentComponent.newChildAbstractClassComponent() },\n        { parentOfGenericComponent, parentOfGenericComponent.subcomponent() }});\n  }        \n  \n  private final ParentGetters parentGetters;\n  private final ChildComponent childComponent;\n  \n  public SubcomponentTest(ParentGetters parentGetters, ChildComponent childComponent) {\n    this.parentGetters \u003d parentGetters;\n    this.childComponent \u003d childComponent;\n  }\n  \n\n  @Test\n  public void scopePropagatesUpward_class() {\n    assertThat(childComponent.requiresSingleton().singletonType())\n        .isSameAs(childComponent.requiresSingleton().singletonType());\n    assertThat(childComponent.requiresSingleton().singletonType())\n        .isSameAs(childComponent.newGrandchildComponent().requiresSingleton().singletonType());\n  }\n\n  @Test\n  public void scopePropagatesUpward_provides() {\n    assertThat(childComponent\n        .requiresSingleton().unscopedTypeBoundAsSingleton())\n            .isSameAs(childComponent\n                .requiresSingleton().unscopedTypeBoundAsSingleton());\n    assertThat(childComponent\n        .requiresSingleton().unscopedTypeBoundAsSingleton())\n            .isSameAs(childComponent.newGrandchildComponent()\n                .requiresSingleton().unscopedTypeBoundAsSingleton());\n  }\n\n  @Test\n  public void multibindingContributions() {\n    Set\u003cObject\u003e parentObjectSet \u003d parentGetters.objectSet();\n    assertThat(parentObjectSet).hasSize(2);\n    Set\u003cObject\u003e childObjectSet \u003d childComponent.objectSet();\n    assertThat(childObjectSet).hasSize(3);\n    Set\u003cObject\u003e grandchildObjectSet \u003d\n        childComponent.newGrandchildComponent().objectSet();\n    assertThat(grandchildObjectSet).hasSize(4);\n    assertThat(intersection(parentObjectSet, childObjectSet)).hasSize(1);\n    assertThat(intersection(parentObjectSet, grandchildObjectSet)).hasSize(1);\n    assertThat(intersection(childObjectSet, grandchildObjectSet)).hasSize(1);\n  }\n\n  @Test\n  public void unscopedProviders() {\n    assertThat(parentGetters.getUnscopedTypeProvider())\n        .isSameAs(childComponent.getUnscopedTypeProvider());\n    assertThat(parentGetters.getUnscopedTypeProvider())\n        .isSameAs(childComponent\n            .newGrandchildComponent()\n            .getUnscopedTypeProvider());\n  }\n\n  @Test\n  public void passedModules() {\n    ChildModuleWithState childModuleWithState \u003d new ChildModuleWithState();\n    ChildComponentRequiringModules childComponent1 \u003d\n        parentComponent.newChildComponentRequiringModules(\n            new ChildModuleWithParameters(new Object()),\n            childModuleWithState);\n    ChildComponentRequiringModules childComponent2 \u003d\n        parentComponent.newChildComponentRequiringModules(\n            new ChildModuleWithParameters(new Object()),\n            childModuleWithState);\n    assertThat(childComponent1.getInt()).isEqualTo(0);\n    assertThat(childComponent2.getInt()).isEqualTo(1);\n  }\n\n  @Test\n  public void dependenceisInASubcomponent() {\n    assertThat(childComponent.newGrandchildComponent().needsAnInterface()).isNotNull();\n  }\n\n  @Test\n  public void qualifiedSubcomponentIsBound() {\n    assertThat(parentComponent.unresolvableChildComponentBuilder().build().unboundString())\n        .isEqualTo(\"unbound\");\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\guava-functional-tests\\src\\main\\java\\test\\optional\\a\\OptionalBindingComponentsWithInaccessibleTypes.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.optional.a;\n\nimport dagger.Component;\nimport test.optional.OptionalBindingComponents.ConcreteBindingModule;\nimport test.optional.OptionalBindingComponents.OptionalBindingModule;\nimport test.optional.OptionalBindingComponents.SomeQualifier;\nimport test.optional.OptionalBindingComponents.Values;\n\nfinal class OptionalBindingComponentsWithInaccessibleTypes {\n\n  interface OptionalBindingComponent {\n    Values values();\n\n    @SomeQualifier\n    Values qualifiedValues();\n  }\n\n  @Component(modules \u003d OptionalBindingModule.class)\n  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {}\n\n  @Component(modules \u003d {OptionalBindingModule.class, ConcreteBindingModule.class})\n  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\guava-functional-tests\\src\\main\\java\\test\\optional\\OptionalBindingComponents.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.optional;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport dagger.BindsOptionalOf;\nimport dagger.Component;\nimport dagger.Lazy;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.Subcomponent;\nimport java.lang.annotation.Retention;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport javax.inject.Qualifier;\n\n/**\n * Classes to support {@link OptionalBindingComponentsPresentTest}, {@link\n * OptionalBindingComponentsAbsentTest} and {@link\n * test.optional.a.OptionalBindingComponentsWithInaccessibleTypesTest}.\n */\npublic final class OptionalBindingComponents {\n\n  /** A qualifier. */\n  @Qualifier\n  @Retention(RUNTIME)\n  public @interface SomeQualifier {}\n\n  /** A value object that contains various optionally-bound objects. */\n  @AutoValue\n  public abstract static class Values {\n    abstract Optional\u003cValue\u003e optionalInstance();\n\n    abstract Optional\u003cProvider\u003cValue\u003e\u003e optionalProvider();\n\n    abstract Optional\u003cLazy\u003cValue\u003e\u003e optionalLazy();\n\n    abstract Optional\u003cProvider\u003cLazy\u003cValue\u003e\u003e\u003e optionalLazyProvider();\n  }\n\n  // Default access so that it\u0027s inaccessible to OptionalBindingComponentsWithInaccessibleTypes.\n  enum Value {\n    VALUE,\n    QUALIFIED_VALUE\n  }\n\n  static final class InjectedThing {\n    @Inject\n    InjectedThing() {}\n  }\n\n  /** Binds optionals and {@link Values}. */\n  @Module\n  public abstract static class OptionalBindingModule {\n    @BindsOptionalOf\n    abstract Value value();\n\n    @BindsOptionalOf\n    @SomeQualifier abstract Value qualifiedValue();\n\n    // Valid because it\u0027s qualified.\n    @BindsOptionalOf\n    @SomeQualifier abstract InjectedThing qualifiedInjectedThing();\n\n    @Provides\n    static Values values(\n        Optional\u003cValue\u003e optionalInstance,\n        Optional\u003cProvider\u003cValue\u003e\u003e optionalProvider,\n        Optional\u003cLazy\u003cValue\u003e\u003e optionalLazy,\n        Optional\u003cProvider\u003cLazy\u003cValue\u003e\u003e\u003e optionalLazyProvider) {\n      return new AutoValue_OptionalBindingComponents_Values(\n          optionalInstance, optionalProvider, optionalLazy, optionalLazyProvider);\n    }\n\n    @Provides\n    @SomeQualifier\n    static Values qualifiedValues(\n        @SomeQualifier Optional\u003cValue\u003e optionalInstance,\n        @SomeQualifier Optional\u003cProvider\u003cValue\u003e\u003e optionalProvider,\n        @SomeQualifier Optional\u003cLazy\u003cValue\u003e\u003e optionalLazy,\n        @SomeQualifier Optional\u003cProvider\u003cLazy\u003cValue\u003e\u003e\u003e optionalLazyProvider) {\n      return new AutoValue_OptionalBindingComponents_Values(\n          optionalInstance, optionalProvider, optionalLazy, optionalLazyProvider);\n    }\n  }\n\n  /** Binds {@link Value}. */\n  @Module\n  public abstract static class ConcreteBindingModule {\n    /** @param cycle to demonstrate that optional {@link Provider} injection can break cycles */\n    @Provides\n    static Value value(Optional\u003cProvider\u003cValue\u003e\u003e cycle) {\n      return Value.VALUE;\n    }\n\n    @Provides\n    @SomeQualifier static Value qualifiedValue() {\n      return Value.QUALIFIED_VALUE;\n    }\n  }\n\n  interface OptionalBindingComponent {\n    Values values();\n\n    Optional\u003cValue\u003e optionalInstance();\n\n    Optional\u003cProvider\u003cValue\u003e\u003e optionalProvider();\n\n    Optional\u003cLazy\u003cValue\u003e\u003e optionalLazy();\n\n    Optional\u003cProvider\u003cLazy\u003cValue\u003e\u003e\u003e optionalLazyProvider();\n\n    @SomeQualifier\n    Values qualifiedValues();\n\n    @SomeQualifier\n    Optional\u003cValue\u003e qualifiedOptionalInstance();\n\n    @SomeQualifier\n    Optional\u003cProvider\u003cValue\u003e\u003e qualifiedOptionalProvider();\n\n    @SomeQualifier\n    Optional\u003cLazy\u003cValue\u003e\u003e qualifiedOptionalLazy();\n\n    @SomeQualifier\n    Optional\u003cProvider\u003cLazy\u003cValue\u003e\u003e\u003e qualifiedOptionalLazyProvider();\n  }\n\n  @Component(modules \u003d OptionalBindingModule.class)\n  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {\n    PresentOptionalBindingSubcomponent presentChild();\n  }\n\n  @Component(modules \u003d {OptionalBindingModule.class, ConcreteBindingModule.class})\n  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}\n\n  @Subcomponent(modules \u003d ConcreteBindingModule.class)\n  interface PresentOptionalBindingSubcomponent extends OptionalBindingComponent {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\guava-functional-tests\\src\\test\\java\\test\\optional\\a\\OptionalBindingComponentsWithInaccessibleTypesTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.optional.a;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/** Tests for optional bindings that include types inaccessible to the component. */\n@RunWith(JUnit4.class)\npublic class OptionalBindingComponentsWithInaccessibleTypesTest {\n  @Test\n  public void components() {\n    DaggerOptionalBindingComponentsWithInaccessibleTypes_AbsentOptionalBindingComponent.create();\n    DaggerOptionalBindingComponentsWithInaccessibleTypes_PresentOptionalBindingComponent.create();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\guava-functional-tests\\src\\test\\java\\test\\optional\\OptionalBindingComponentsAbsentTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.optional;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport test.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;\n\n/** Tests for absent optional bindings. */\n@RunWith(JUnit4.class)\npublic final class OptionalBindingComponentsAbsentTest {\n  private AbsentOptionalBindingComponent absent;\n\n  @Before\n  public void setUp() {\n    absent \u003d DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();\n  }\n\n  @Test\n  public void optional() {\n    assertThat(absent.optionalInstance()).isAbsent();\n  }\n\n  @Test\n  public void optionalProvider() {\n    assertThat(absent.optionalProvider()).isAbsent();\n  }\n\n  @Test\n  public void optionalLazy() {\n    assertThat(absent.optionalLazy()).isAbsent();\n  }\n\n  @Test\n  public void optionalLazyProvider() {\n    assertThat(absent.optionalLazyProvider()).isAbsent();\n  }\n\n  @Test\n  public void qualifiedOptional() {\n    assertThat(absent.qualifiedOptionalInstance()).isAbsent();\n  }\n\n  @Test\n  public void qualifiedOptionalProvider() {\n    assertThat(absent.qualifiedOptionalProvider()).isAbsent();\n  }\n\n  @Test\n  public void qualifiedOptionalLazy() {\n    assertThat(absent.qualifiedOptionalLazy()).isAbsent();\n  }\n\n  @Test\n  public void qualifiedOptionalLazyProvider() {\n    assertThat(absent.qualifiedOptionalLazyProvider()).isAbsent();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\guava-functional-tests\\src\\test\\java\\test\\optional\\OptionalBindingComponentsPresentTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.optional;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static test.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;\nimport static test.optional.OptionalBindingComponents.Value.VALUE;\n\nimport com.google.common.collect.ImmutableList;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport test.optional.OptionalBindingComponents.OptionalBindingComponent;\n\n/** Tests for present optional bindings. */\n@RunWith(Parameterized.class)\npublic final class OptionalBindingComponentsPresentTest {\n\n  @Parameters(name \u003d \"{0}\")\n  public static Iterable\u003cObject[]\u003e parameters() {\n    return ImmutableList.copyOf(\n        new Object[][] {\n          {DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create()},\n          {DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create().presentChild()},\n        });\n  }\n\n  private final OptionalBindingComponent component;\n\n  public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {\n    this.component \u003d component;\n  }\n\n  @Test\n  public void optionalProvider() {\n    assertThat(component.optionalProvider().get().get()).isEqualTo(VALUE);\n  }\n\n  @Test\n  public void optionalLazy() {\n    assertThat(component.optionalLazy().get().get()).isEqualTo(VALUE);\n  }\n\n  @Test\n  public void optionalLazyProvider() {\n    assertThat(component.optionalLazyProvider().get().get().get()).isEqualTo(VALUE);\n  }\n\n  @Test\n  public void qualifiedOptional() {\n    assertThat(component.qualifiedOptionalInstance()).hasValue(QUALIFIED_VALUE);\n  }\n\n  @Test\n  public void qualifiedOptionalProvider() {\n    assertThat(component.qualifiedOptionalProvider().get().get()).isEqualTo(QUALIFIED_VALUE);\n  }\n\n  @Test\n  public void qualifiedOptionalLazy() {\n    assertThat(component.qualifiedOptionalLazy().get().get()).isEqualTo(QUALIFIED_VALUE);\n  }\n\n  @Test\n  public void qualifiedOptionalLazyProvider() {\n    assertThat(component.qualifiedOptionalLazyProvider().get().get().get())\n        .isEqualTo(QUALIFIED_VALUE);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\badexecutor\\ComponentDependency.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.badexecutor;\n\nimport com.google.common.util.concurrent.ListenableFuture;\n\ninterface ComponentDependency {\n  ListenableFuture\u003cDouble\u003e doubleDep();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\badexecutor\\SimpleComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.badexecutor;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.ProductionComponent;\nimport producerstest.ExecutorModule;\n\n/**\n * A component that contains entry points that exercise different execution paths, for verifying the\n * behavior when the executor throws a {@link java.util.concurrent.RejectedExecutionException}.\n */\n@ProductionComponent(\n  dependencies \u003d ComponentDependency.class,\n  modules \u003d {ExecutorModule.class, SimpleProducerModule.class}\n)\ninterface SimpleComponent {\n  /** An entry point exposing a producer method with no args. */\n  ListenableFuture\u003cString\u003e noArgStr();\n\n  /** An entry point exposing a producer method that depends on another producer method. */\n  ListenableFuture\u003cInteger\u003e singleArgInt();\n\n  /** An entry point exposing a producer method that depends on a component dependency method. */\n  ListenableFuture\u003cBoolean\u003e singleArgBool();\n\n  /** An entry point exposing a component dependency method. */\n  ListenableFuture\u003cDouble\u003e doubleDep();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\badexecutor\\SimpleProducerModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.badexecutor;\n\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\n\n@ProducerModule\nfinal class SimpleProducerModule {\n  @Produces\n  static String noArgStr() {\n    return \"no arg string\";\n  }\n\n  @Produces\n  static int singleArgInt(String arg) {\n    return arg.length();\n  }\n\n  @Produces\n  static boolean singleArgBool(double arg) {\n    return arg \u003e 0.0;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\binds\\Foo.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.binds;\n\n/**\n * This is the type that will be bound.  We throw in generics just to complicate the test.\n */\ninterface Foo\u003cT\u003e {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\binds\\FooOfStrings.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.binds;\n\n/**\n * This is not marked with {@link javax.inject.Inject @Inject} (like the {@link dagger.Provides\n * @Provides} version in {@link test.bind.FooOfStrings}), to test that {@link dagger.Binds @Binds}\n * properly translate to {@link dagger.internal.codegen.ProductionBinding}s when the right-hand-side\n * of the method is also a production binding. We force this by adding a {@link\n * dagger.producers.Produces @Produces} method to add it to the graph instead of relying on the\n * {@link dagger.internal.codegen.ProvisionBinding} that would be created by default with an {@code\n * @Inject} constructor.\n */\nfinal class FooOfStrings implements Foo\u003cString\u003e {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\binds\\SimpleBindingModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.binds;\n\nimport com.google.common.util.concurrent.MoreExecutors;\nimport dagger.Binds;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntKey;\nimport dagger.multibindings.IntoMap;\nimport dagger.multibindings.IntoSet;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport dagger.producers.Production;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.concurrent.Executor;\nimport javax.inject.Named;\nimport javax.inject.Qualifier;\nimport javax.inject.Singleton;\n\n@ProducerModule(includes \u003d {\n    SimpleBindingModule.ExecutorModule.class,\n    SimpleBindingModule.ProvisionModuleForMap.class\n})\nabstract class SimpleBindingModule {\n  @Binds\n  abstract Object bindObject(FooOfStrings impl);\n\n  @Binds\n  abstract Foo\u003cString\u003e bindFooOfStrings(FooOfStrings impl);\n\n  @Binds\n  abstract Foo\u003c? extends Number\u003e bindFooOfNumbers(Foo\u003cInteger\u003e fooOfIntegers);\n\n  @Binds\n  @Singleton\n  @SomeQualifier\n  abstract Foo\u003cString\u003e bindQualifiedFooOfStrings(FooOfStrings impl);\n\n  @Produces\n  static FooOfStrings produceFooOfStrings() {\n    return new FooOfStrings();\n  }\n\n  @Produces\n  static Foo\u003cInteger\u003e produceFooOfIntegers() {\n    return new Foo\u003cInteger\u003e() {};\n  }\n\n  @Produces\n  static Foo\u003cDouble\u003e produceFooOfDoubles() {\n    return new Foo\u003cDouble\u003e() {};\n  }\n\n  @Binds\n  @IntoSet\n  abstract Foo\u003c? extends Number\u003e bindFooOfIntegersIntoSet(Foo\u003cInteger\u003e fooOfIntegers);\n\n  @Binds\n  @IntoSet\n  abstract Foo\u003c? extends Number\u003e bindFooExtendsNumberIntoSet(Foo\u003cDouble\u003e fooOfDoubles);\n\n  @Binds\n  @ElementsIntoSet\n  abstract Set\u003cObject\u003e bindSetOfFooNumbersToObjects(Set\u003cFoo\u003c? extends Number\u003e\u003e setOfFooNumbers);\n\n  @Binds\n  @IntoSet\n  abstract Object bindFooOfStringsIntoSetOfObjects(FooOfStrings impl);\n\n  @Produces\n  static HashSet\u003cString\u003e produceStringHashSet() {\n    return new HashSet\u003c\u003e(Arrays.asList(\"hash-string1\", \"hash-string2\"));\n  }\n\n  @Produces\n  static TreeSet\u003cCharSequence\u003e produceCharSequenceTreeSet() {\n    return new TreeSet\u003cCharSequence\u003e(Arrays.asList(\"tree-charSequence1\", \"tree-charSequence2\"));\n  }\n\n  @Produces\n  static Collection\u003cCharSequence\u003e produceCharSequenceCollection() {\n    return Arrays.\u003cCharSequence\u003easList(\"list-charSequence\");\n  }\n\n  @Binds\n  @ElementsIntoSet\n  abstract Set\u003cCharSequence\u003e bindHashSetOfStrings(HashSet\u003cString\u003e set);\n\n  @Binds\n  @ElementsIntoSet\n  abstract Set\u003cCharSequence\u003e bindTreeSetOfCharSequences(TreeSet\u003cCharSequence\u003e set);\n\n  @Binds\n  @ElementsIntoSet\n  abstract Set\u003cCharSequence\u003e bindCollectionOfCharSequences(Collection\u003cCharSequence\u003e collection);\n\n  @Qualifier\n  @Retention(RetentionPolicy.RUNTIME)\n  @interface SomeQualifier {}\n\n  @Module\n  static final class ExecutorModule {\n    @Provides @Production\n    static Executor provideExecutor() {\n      return MoreExecutors.directExecutor();\n    }\n  }\n\n  @Binds\n  @IntoMap\n  @IntKey(123)\n  abstract Object bind123ForMap(@Named(\"For-123\") String string);\n\n  @Binds\n  @IntoMap\n  @IntKey(456)\n  abstract Object bind456ForMap(@Named(\"For-456\") String string);\n\n  @Produces\n  @IntoMap\n  @IntKey(789)\n  static Object produce789ForMap() {\n    return \"789-string\";\n  }\n\n  @Module\n  abstract static class ProvisionModuleForMap {\n    @Provides @Named(\"Provision string\") static String provideProvisionString() {\n      return \"provision-string\";\n    }\n\n    @Binds\n    @IntoMap\n    @IntKey(-1)\n    abstract Object bindNegative1ForMap(@Named(\"Provision string\") String string);\n  }\n\n  @Binds\n  @IntoMap\n  @IntKey(123)\n  @SomeQualifier\n  abstract Object bindFooOfStringsIntoQualifiedMap(FooOfStrings fooOfStrings);\n\n  @Produces\n  @Named(\"For-123\")\n  static String produce123String() {\n    return \"123-string\";\n  }\n\n  @Produces\n  @Named(\"For-456\")\n  static String produce456String() {\n    return \"456-string\";\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\binds\\SimpleBindsProductionComponent.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.binds;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport dagger.producers.ProductionComponent;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.inject.Singleton;\nimport producerstest.binds.SimpleBindingModule.SomeQualifier;\n\n@Singleton\n@ProductionComponent(modules \u003d SimpleBindingModule.class)\npublic interface SimpleBindsProductionComponent {\n  ListenableFuture\u003cObject\u003e object();\n\n  ListenableFuture\u003cFoo\u003cString\u003e\u003e fooOfStrings();\n\n  @SomeQualifier\n  ListenableFuture\u003cFoo\u003cString\u003e\u003e qualifiedFooOfStrings();\n\n  ListenableFuture\u003cFoo\u003cInteger\u003e\u003e fooOfIntegers();\n\n  ListenableFuture\u003cSet\u003cFoo\u003c? extends Number\u003e\u003e\u003e foosOfNumbers();\n\n  ListenableFuture\u003cSet\u003cObject\u003e\u003e objects();\n\n  ListenableFuture\u003cSet\u003cCharSequence\u003e\u003e charSequences();\n\n  ListenableFuture\u003cMap\u003cInteger, Object\u003e\u003e integerObjectMap();\n\n  ListenableFuture\u003cMap\u003cInteger, Producer\u003cObject\u003e\u003e\u003e integerProducerOfObjectMap();\n\n  ListenableFuture\u003cMap\u003cInteger, Produced\u003cObject\u003e\u003e\u003e integerProducedOfObjectMap();\n\n  @SomeQualifier ListenableFuture\u003cMap\u003cInteger, Object\u003e\u003e qualifiedIntegerObjectMap();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\builder\\DepComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.builder;\n\nimport com.google.common.util.concurrent.ListenableFuture;\n\ninterface DepComponent {\n  ListenableFuture\u003cDouble\u003e d();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\builder\\IntModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.builder;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\nfinal class IntModule {\n  @Provides\n  static int i() {\n    return 42;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\builder\\StringModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.builder;\n\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\n\n@ProducerModule\nfinal class StringModule {\n  @Produces\n  static String str(int i) {\n    return \"arg: \" + i;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\builder\\TestComponentWithBuilder.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.builder;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.ProductionComponent;\nimport producerstest.ExecutorModule;\n\n@ProductionComponent(\n  modules \u003d {ExecutorModule.class, StringModule.class, IntModule.class},\n  dependencies \u003d DepComponent.class\n)\ninterface TestComponentWithBuilder {\n  ListenableFuture\u003cString\u003e s();\n  ListenableFuture\u003cDouble\u003e d();\n\n  @ProductionComponent.Builder\n  interface Builder {\n    Builder depComponent(DepComponent depComponent);\n    Builder strModule(StringModule strModule);\n    TestComponentWithBuilder build();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\DependedComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nimport dagger.Component;\n\n@Component(modules \u003d DependedModule.class)\ninterface DependedComponent {\n  String getGreeting();\n}\n\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\DependedModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\nfinal class DependedModule {\n  @Provides\n  String provideGreeting() {\n    return \"Hello world!\";\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\DependedProducerModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\n\n@ProducerModule\nfinal class DependedProducerModule {\n\n  @Produces\n  int produceNumberOfGreetings() {\n    return 2;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\DependedProductionComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.ProductionComponent;\n\n@ProductionComponent(modules \u003d {ExecutorModule.class, DependedProducerModule.class})\ninterface DependedProductionComponent {\n  ListenableFuture\u003cInteger\u003e numGreetings();\n}\n\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\DependentComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.ProductionComponent;\nimport java.util.List;\n\n@ProductionComponent(\n  modules \u003d {ExecutorModule.class, DependentProducerModule.class},\n  dependencies \u003d {DependedComponent.class, DependedProductionComponent.class}\n)\ninterface DependentComponent {\n  ListenableFuture\u003cList\u003cString\u003e\u003e greetings();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\DependentProducerModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nimport com.google.common.base.Ascii;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport java.util.List;\n\n@ProducerModule\nfinal class DependentProducerModule {\n  @Produces\n  ListenableFuture\u003cList\u003cString\u003e\u003e greetings(Integer numGreetings, String greeting) {\n    List\u003cString\u003e greetings \u003d ImmutableList.of(\n        String.valueOf(numGreetings), greeting, Ascii.toUpperCase(greeting));\n    return Futures.immediateFuture(greetings);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\ExecutorModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nimport com.google.common.util.concurrent.MoreExecutors;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.producers.Production;\nimport java.util.concurrent.Executor;\n\n/**\n * A module that provides an optionally user-defined executor for a production component, defaulting\n * to the direct executor.\n */\n@Module\npublic final class ExecutorModule {\n  private final Executor executor;\n\n  public ExecutorModule() {\n    this(MoreExecutors.directExecutor());\n  }\n\n  public ExecutorModule(Executor executor) {\n    this.executor \u003d executor;\n  }\n\n  @Provides\n  @Production\n  Executor executor() {\n    return executor;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\monitoring\\MonitoredComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.monitoring;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.ProductionComponent;\nimport producerstest.ExecutorModule;\n\n@ProductionComponent(\n  modules \u003d {ExecutorModule.class, MonitoringModule.class, StubModule.class, ServingModule.class}\n)\ninterface MonitoredComponent {\n  ListenableFuture\u003cString\u003e output();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\monitoring\\MonitoringModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.monitoring;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.IntoSet;\nimport dagger.producers.monitoring.ProductionComponentMonitor;\n\n@Module\nfinal class MonitoringModule {\n  private final ProductionComponentMonitor.Factory monitorFactory;\n\n  MonitoringModule(ProductionComponentMonitor.Factory monitorFactory) {\n    this.monitorFactory \u003d monitorFactory;\n  }\n\n  @Provides\n  @IntoSet\n  ProductionComponentMonitor.Factory monitorFactory() {\n    return monitorFactory;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\monitoring\\ServingModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.monitoring;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport javax.inject.Qualifier;\nimport producerstest.monitoring.StubModule.ForServer1;\nimport producerstest.monitoring.StubModule.ForServer2;\n\n@ProducerModule\nfinal class ServingModule {\n  @Qualifier\n  @interface RequestData {}\n\n  @Qualifier\n  @interface IntermediateData {}\n\n  @Produces\n  @RequestData\n  static String requestData() {\n    return \"Hello, World!\";\n  }\n\n  @Produces\n  @IntermediateData\n  static ListenableFuture\u003cString\u003e callServer1(\n      @RequestData String data, @ForServer1 StringStub stub) {\n    return stub.run(data);\n  }\n\n  @Produces\n  static ListenableFuture\u003cString\u003e callServer2(\n      @IntermediateData String data, @ForServer2 StringStub stub) {\n    return stub.run(data);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\monitoring\\StringStub.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.monitoring;\n\nimport com.google.common.util.concurrent.ListenableFuture;\n\ninterface StringStub {\n  ListenableFuture\u003cString\u003e run(String input);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\monitoring\\StubModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.monitoring;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport javax.inject.Qualifier;\n\n@Module\nfinal class StubModule {\n  @Qualifier\n  @interface ForServer1 {}\n\n  @Qualifier\n  @interface ForServer2 {}\n\n  private final StringStub server1;\n  private final StringStub server2;\n\n  StubModule(StringStub server1, StringStub server2) {\n    this.server1 \u003d server1;\n    this.server2 \u003d server2;\n  }\n\n  @Provides\n  @ForServer1\n  StringStub server1() {\n    return server1;\n  }\n\n  @Provides\n  @ForServer2\n  StringStub server2() {\n    return server2;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\multibindings\\MultibindingComponent.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.multibindings;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport dagger.producers.ProductionComponent;\nimport java.util.Map;\nimport java.util.Set;\nimport producerstest.ExecutorModule;\nimport producerstest.multibindings.Qualifiers.EmptyButDeclaredInModule;\nimport producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;\nimport producerstest.multibindings.Qualifiers.ObjCount;\nimport producerstest.multibindings.Qualifiers.OnlyProvisionMultibindings;\nimport producerstest.multibindings.Qualifiers.PossiblyThrowingMap;\nimport producerstest.multibindings.Qualifiers.PossiblyThrowingSet;\n\n@ProductionComponent(\n  modules \u003d {ExecutorModule.class, MultibindingProducerModule.class, MultibindingModule.class}\n)\ninterface MultibindingComponent {\n  ListenableFuture\u003cSet\u003cString\u003e\u003e strs();\n  ListenableFuture\u003cInteger\u003e strCount();\n\n  ListenableFuture\u003cSet\u003cProduced\u003cString\u003e\u003e\u003e successfulSet();\n\n  @PossiblyThrowingSet\n  ListenableFuture\u003cSet\u003cProduced\u003cString\u003e\u003e\u003e possiblyThrowingSet();\n\n  ListenableFuture\u003cMap\u003cInteger, String\u003e\u003e map();\n\n  ListenableFuture\u003cMap\u003cInteger, Producer\u003cString\u003e\u003e\u003e mapOfProducer();\n\n  ListenableFuture\u003cMap\u003cInteger, Produced\u003cString\u003e\u003e\u003e mapOfProduced();\n\n  @PossiblyThrowingMap\n  ListenableFuture\u003cMap\u003cInteger, String\u003e\u003e possiblyThrowingMap();\n\n  @PossiblyThrowingMap\n  ListenableFuture\u003cMap\u003cInteger, Producer\u003cString\u003e\u003e\u003e possiblyThrowingMapOfProducer();\n\n  @PossiblyThrowingMap\n  ListenableFuture\u003cMap\u003cInteger, Produced\u003cString\u003e\u003e\u003e possiblyThrowingMapOfProduced();\n\n  ListenableFuture\u003cSet\u003cObject\u003e\u003e objs();\n\n  ListenableFuture\u003cSet\u003cProduced\u003cObject\u003e\u003e\u003e producedObjs();\n\n  ListenableFuture\u003cMap\u003cObject, Object\u003e\u003e objMap();\n\n  ListenableFuture\u003cMap\u003cObject, Produced\u003cObject\u003e\u003e\u003e objMapOfProduced();\n\n  ListenableFuture\u003cMap\u003cObject, Producer\u003cObject\u003e\u003e\u003e objMapOfProducer();\n\n  @ObjCount\n  ListenableFuture\u003cInteger\u003e objCount();\n\n  @EmptyButDeclaredInModuleAndProducerModule\n  ListenableFuture\u003cMap\u003cString, Object\u003e\u003e emptyButDeclaredInModuleAndProducerModule();\n\n  @EmptyButDeclaredInModule\n  ListenableFuture\u003cMap\u003cString, Object\u003e\u003e emptyButDeclaredInModule();\n\n  @OnlyProvisionMultibindings\n  ListenableFuture\u003cMap\u003cString, Object\u003e\u003e onlyProvisionMultibindings();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\multibindings\\MultibindingModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.multibindings;\n\nimport com.google.common.collect.ImmutableSet;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntKey;\nimport dagger.multibindings.IntoMap;\nimport dagger.multibindings.IntoSet;\nimport dagger.multibindings.Multibinds;\nimport dagger.multibindings.StringKey;\nimport java.util.Map;\nimport java.util.Set;\nimport producerstest.multibindings.Qualifiers.EmptyButDeclaredInModule;\nimport producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;\nimport producerstest.multibindings.Qualifiers.OnlyProvisionMultibindings;\n\n@Module\nabstract class MultibindingModule {\n  @Provides\n  @IntoSet\n  static String providedStr() {\n    return \"providedStr\";\n  }\n\n  @Provides\n  @ElementsIntoSet\n  static Set\u003cString\u003e providedStrs() {\n    return ImmutableSet.of(\"providedStr1\", \"providedStr2\");\n  }\n\n  @Provides\n  @IntoMap\n  @IntKey(3)\n  static String providedValueFor3() {\n    return \"provided three\";\n  }\n  \n  @Multibinds\n  @EmptyButDeclaredInModuleAndProducerModule\n  abstract Map\u003cString, Object\u003e emptyButDeclaredInModuleAndProducerModule();\n\n  @Multibinds\n  @EmptyButDeclaredInModule\n  abstract Map\u003cString, Object\u003e emptyButDeclaredInModule();\n\n  @Provides\n  @IntoMap\n  @StringKey(\"a\")\n  @OnlyProvisionMultibindings\n  static Object onlyProvisionMultibindings() {\n    return \"only multibinding\";\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\multibindings\\MultibindingProducerModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.multibindings;\n\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntKey;\nimport dagger.multibindings.IntoMap;\nimport dagger.multibindings.IntoSet;\nimport dagger.multibindings.Multibinds;\nimport dagger.producers.Produced;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport java.util.Map;\nimport java.util.Set;\nimport producerstest.multibindings.Qualifiers.EmptyButDeclaredInModuleAndProducerModule;\nimport producerstest.multibindings.Qualifiers.ObjCount;\nimport producerstest.multibindings.Qualifiers.PossiblyThrowingMap;\nimport producerstest.multibindings.Qualifiers.PossiblyThrowingSet;\n\n@ProducerModule\nabstract class MultibindingProducerModule {\n  @Produces\n  @IntoSet\n  static ListenableFuture\u003cString\u003e futureStr() {\n    return Futures.immediateFuture(\"foo\");\n  }\n\n  @Produces\n  @IntoSet\n  static String str() {\n    return \"bar\";\n  }\n\n  @Produces\n  @ElementsIntoSet\n  static ListenableFuture\u003cSet\u003cString\u003e\u003e futureStrs() {\n    return Futures.\u003cSet\u003cString\u003e\u003eimmediateFuture(ImmutableSet.of(\"foo1\", \"foo2\"));\n  }\n\n  @Produces\n  @ElementsIntoSet\n  static Set\u003cListenableFuture\u003cString\u003e\u003e strFutures() {\n    return ImmutableSet.of(Futures.immediateFuture(\"baz1\"), Futures.immediateFuture(\"baz2\"));\n  }\n\n  @Produces\n  @ElementsIntoSet\n  static Set\u003cString\u003e strs() {\n    return ImmutableSet.of(\"bar1\", \"bar2\");\n  }\n\n  @Produces\n  static int strCount(Set\u003cString\u003e strs) {\n    return strs.size();\n  }\n\n  @Produces\n  @IntoSet\n  @PossiblyThrowingSet\n  static String successfulStringForSet() {\n    return \"singleton\";\n  }\n\n  @Produces\n  @ElementsIntoSet\n  @PossiblyThrowingSet\n  static Set\u003cString\u003e successfulStringsForSet() {\n    return ImmutableSet.of(\"double\", \"ton\");\n  }\n\n  @Produces\n  @IntoSet\n  @PossiblyThrowingSet\n  static String throwingStringForSet() {\n    throw new RuntimeException(\"monkey\");\n  }\n\n  @Produces\n  @IntoMap\n  @IntKey(42)\n  static ListenableFuture\u003cString\u003e futureFor42() {\n    return Futures.immediateFuture(\"forty two\");\n  }\n\n  @Produces\n  @IntoMap\n  @IntKey(15)\n  static String valueFor15() {\n    return \"fifteen\";\n  }\n\n  @Produces\n  @IntoMap\n  @PossiblyThrowingMap\n  @IntKey(42)\n  static ListenableFuture\u003cString\u003e successfulFutureFor42() {\n    return Futures.immediateFuture(\"forty two\");\n  }\n\n  @Produces\n  @IntoMap\n  @PossiblyThrowingMap\n  @IntKey(15)\n  static String throwingValueFor15() {\n    throw new RuntimeException(\"monkey\");\n  }\n\n  @Multibinds\n  abstract Set\u003cObject\u003e objs();\n\n  @Multibinds\n  abstract Map\u003cObject, Object\u003e objMap();\n\n  @Produces\n  @ObjCount\n  static int objCount(Set\u003cProduced\u003cObject\u003e\u003e objs, Map\u003cObject, Produced\u003cObject\u003e\u003e objMap) {\n    return objs.size() + objMap.size();\n  }\n  \n  @Multibinds\n  @EmptyButDeclaredInModuleAndProducerModule\n  abstract Map\u003cString, Object\u003e emptyButDeclaredInModuleAndProducerModule();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\multibindings\\Qualifiers.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.multibindings;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport javax.inject.Qualifier;\n\nfinal class Qualifiers {\n  @Documented\n  @Retention(RUNTIME)\n  @Qualifier\n  @interface PossiblyThrowingSet {}\n\n  @Documented\n  @Retention(RUNTIME)\n  @Qualifier\n  @interface PossiblyThrowingMap {}\n\n  @Documented\n  @Retention(RUNTIME)\n  @Qualifier\n  @interface ObjCount {}\n\n  @Documented\n  @Retention(RUNTIME)\n  @Qualifier\n  @interface EmptyButDeclaredInModule {}\n\n  @Documented\n  @Retention(RUNTIME)\n  @Qualifier\n  @interface EmptyButDeclaredInModuleAndProducerModule {}\n\n  @Documented\n  @Retention(RUNTIME)\n  @Qualifier\n  @interface OnlyProvisionMultibindings {}\n\n  private Qualifiers() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\optional\\OptionalBindingComponents.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.optional;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.BindsOptionalOf;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport dagger.producers.Production;\nimport dagger.producers.ProductionComponent;\nimport dagger.producers.ProductionSubcomponent;\nimport java.lang.annotation.Retention;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport javax.inject.Qualifier;\n\n/**\n * Classes to support {@link OptionalBindingComponentsAbsentTest} and {@link\n * OptionalBindingComponentsPresentTest}.\n */\nfinal class OptionalBindingComponents {\n\n  /** A qualifier. */\n  @Qualifier\n  @Retention(RUNTIME)\n  @interface SomeQualifier {}\n\n  /** A value object that contains various optionally-bound objects. */\n  @AutoValue\n  abstract static class Values {\n    abstract Optional\u003cValue\u003e optionalInstance();\n\n    abstract Optional\u003cProducer\u003cValue\u003e\u003e optionalProducer();\n\n    abstract Optional\u003cProduced\u003cValue\u003e\u003e optionalProduced();\n  }\n\n  enum Value {\n    VALUE,\n    QUALIFIED_VALUE\n  }\n\n  @Module\n  static final class ExecutorModule {\n    @Provides\n    @Production\n    static Executor executor() {\n      return Executors.newSingleThreadExecutor();\n    }\n  }\n\n  /** Binds optionals and {@link Values}. */\n  @ProducerModule\n  abstract static class OptionalBindingModule {\n    @BindsOptionalOf\n    abstract Value value();\n\n    @BindsOptionalOf\n    @SomeQualifier\n    abstract Value qualifiedValue();\n\n    @Produces\n    static Values values(\n        Optional\u003cValue\u003e optionalInstance,\n        Optional\u003cProducer\u003cValue\u003e\u003e optionalProducer,\n        Optional\u003cProduced\u003cValue\u003e\u003e optionalProduced) {\n      return new AutoValue_OptionalBindingComponents_Values(\n          optionalInstance, optionalProducer, optionalProduced);\n    }\n\n    @Produces\n    @SomeQualifier\n    static Values qualifiedValues(\n        Optional\u003cValue\u003e optionalInstance,\n        Optional\u003cProducer\u003cValue\u003e\u003e optionalProducer,\n        Optional\u003cProduced\u003cValue\u003e\u003e optionalProduced) {\n      return new AutoValue_OptionalBindingComponents_Values(\n          optionalInstance, optionalProducer, optionalProduced);\n    }\n  }\n\n  /** Binds {@link Value} using {@link Producer}s. */\n  @ProducerModule\n  abstract static class ConcreteBindingProducerModule {\n    @Produces\n    static Value value() {\n      return Value.VALUE;\n    }\n\n    @Produces\n    @SomeQualifier\n    static Value qualifiedValue() {\n      return Value.QUALIFIED_VALUE;\n    }\n  }\n\n  /** Binds {@link Value} using {@link Provider}s. */\n  @Module\n  abstract static class ConcreteBindingModule {\n    @Provides\n    static Value value() {\n      return Value.VALUE;\n    }\n\n    @Provides\n    @SomeQualifier\n    static Value qualifiedValue() {\n      return Value.QUALIFIED_VALUE;\n    }\n  }\n\n  interface OptionalBindingComponent {\n    ListenableFuture\u003cValues\u003e values();\n\n    ListenableFuture\u003cOptional\u003cValue\u003e\u003e optionalInstance();\n\n    ListenableFuture\u003cOptional\u003cProducer\u003cValue\u003e\u003e\u003e optionalProducer();\n\n    ListenableFuture\u003cOptional\u003cProduced\u003cValue\u003e\u003e\u003e optionalProduced();\n\n    @SomeQualifier\n    ListenableFuture\u003cValues\u003e qualifiedValues();\n\n    @SomeQualifier\n    ListenableFuture\u003cOptional\u003cValue\u003e\u003e qualifiedOptionalInstance();\n\n    @SomeQualifier\n    ListenableFuture\u003cOptional\u003cProducer\u003cValue\u003e\u003e\u003e qualifiedOptionalProducer();\n\n    @SomeQualifier\n    ListenableFuture\u003cOptional\u003cProduced\u003cValue\u003e\u003e\u003e qualifiedOptionalProduced();\n  }\n\n  @ProductionComponent(modules \u003d {ExecutorModule.class, OptionalBindingModule.class})\n  interface AbsentOptionalBindingComponent extends OptionalBindingComponent {\n    PresentOptionalBindingSubcomponent presentChild();\n  }\n\n  @ProductionComponent(\n    modules \u003d {\n      ExecutorModule.class,\n      OptionalBindingModule.class,\n      ConcreteBindingProducerModule.class\n    }\n  )\n  interface PresentOptionalBindingComponent extends OptionalBindingComponent {}\n\n  @ProductionSubcomponent(modules \u003d ConcreteBindingProducerModule.class)\n  interface PresentOptionalBindingSubcomponent extends OptionalBindingComponent {}\n\n  @ProductionComponent(\n    modules \u003d {ExecutorModule.class, OptionalBindingModule.class, ConcreteBindingModule.class}\n  )\n  interface PresentOptionalProvisionBindingComponent extends OptionalBindingComponent {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\ProvidesInProducerModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.common.util.concurrent.MoreExecutors;\nimport dagger.Provides;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport dagger.producers.Production;\nimport dagger.producers.ProductionComponent;\nimport java.util.concurrent.Executor;\n\nfinal class ProvidesInProducerModule {\n  @ProducerModule\n  static class OnlyModule {\n    @Provides\n    @Production\n    static Executor provideExecutor() {\n      return MoreExecutors.directExecutor();\n    }\n\n    @Produces\n    static String produceString() {\n      return \"produced\";\n    }\n  }\n\n  @ProductionComponent(modules \u003d OnlyModule.class)\n  interface C {\n    ListenableFuture\u003cString\u003e string();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\provisions\\Provisions.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.provisions;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.Producer;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport dagger.producers.ProductionComponent;\nimport javax.inject.Inject;\nimport javax.inject.Qualifier;\nimport producerstest.ExecutorModule;\n\n/** Tests for requesting provisions from producers. */\nfinal class Provisions {\n  static final class InjectedClass {\n    @Inject InjectedClass() {}\n  }\n\n  static final class WrappedProducer\u003cT\u003e {\n    final Producer\u003cT\u003e producer;\n\n    WrappedProducer(Producer\u003cT\u003e producer) {\n      this.producer \u003d producer;\n    }\n  }\n\n  static final class Output {\n    final Producer\u003cInjectedClass\u003e injectedClass1;\n    final Producer\u003cInjectedClass\u003e injectedClass2;\n\n    Output(Producer\u003cInjectedClass\u003e injectedClass1, Producer\u003cInjectedClass\u003e injectedClass2) {\n      this.injectedClass1 \u003d injectedClass1;\n      this.injectedClass2 \u003d injectedClass2;\n    }\n  }\n\n  @Qualifier @interface First {}\n  @Qualifier @interface Second {}\n\n  @ProducerModule\n  static final class TestModule {\n    @Produces @First static WrappedProducer\u003cInjectedClass\u003e firstProducer(\n        Producer\u003cInjectedClass\u003e injectedClass) {\n      return new WrappedProducer\u003cInjectedClass\u003e(injectedClass);\n    }\n\n    @Produces @Second static WrappedProducer\u003cInjectedClass\u003e secondProducer(\n        Producer\u003cInjectedClass\u003e injectedClass) {\n      return new WrappedProducer\u003cInjectedClass\u003e(injectedClass);\n    }\n\n    @Produces static Output output(\n        @First WrappedProducer\u003cInjectedClass\u003e producer1,\n        @Second WrappedProducer\u003cInjectedClass\u003e producer2) {\n      return new Output(producer1.producer, producer2.producer);\n    }\n  }\n\n  @ProductionComponent(modules \u003d {ExecutorModule.class, TestModule.class})\n  interface TestComponent {\n    ListenableFuture\u003cOutput\u003e output();\n  }\n\n  private Provisions() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\Request.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nimport javax.inject.Inject;\n\nfinal class Request {\n  private final String name;\n\n  @Inject\n  Request() {\n    this.name \u003d \"Request\";\n  }\n\n  String name() {\n    return this.name;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\Response.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nfinal class Response {\n  private final String data;\n\n  Response(String data) {\n    this.data \u003d data;\n  }\n\n  String data() {\n    return this.data;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\ResponseModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\nfinal class ResponseModule {\n  @Provides\n  static int requestNumber() {\n    return 5;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\ResponseProducerModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.Lazy;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport javax.inject.Provider;\nimport javax.inject.Qualifier;\n\n@ProducerModule(includes \u003d ResponseModule.class)\nfinal class ResponseProducerModule {\n  @Qualifier\n  @interface RequestsProducerAndProduced {}\n\n  @Produces\n  static ListenableFuture\u003cString\u003e greeting() {\n    return Futures.immediateFuture(\"Hello\");\n  }\n\n  @Produces\n  @RequestsProducerAndProduced\n  static ListenableFuture\u003cString\u003e intermediateGreeting(\n      // TODO(beder): Allow Producer and Provider of the same type (which would force the binding\n      // to be a provision binding), and add validation for that.\n      @SuppressWarnings(\"unused\") String greeting,\n      Producer\u003cString\u003e greetingProducer,\n      @SuppressWarnings(\"unused\") Produced\u003cString\u003e greetingProduced,\n      @SuppressWarnings(\"unused\") Provider\u003cInteger\u003e requestNumberProvider,\n      @SuppressWarnings(\"unused\") Lazy\u003cInteger\u003e requestNumberLazy) {\n    return greetingProducer.get();\n  }\n\n  @Produces\n  static Response response(\n      @RequestsProducerAndProduced String greeting, Request request, int requestNumber) {\n    return new Response(String.format(\"%s, %s #%d!\", greeting, request.name(), requestNumber));\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\scope\\ScopedModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.scope;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.producers.ProductionScope;\n\n@Module\nfinal class ScopedModule {\n  @Provides\n  @ProductionScope\n  static Object newScopedObject() {\n    return new Object();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\scope\\ScopedObject.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.scope;\n\nimport dagger.producers.ProductionScope;\nimport javax.inject.Inject;\n\n@ProductionScope\nfinal class ScopedObject {\n  @Inject\n  ScopedObject() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\scope\\SetComponent.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.scope;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.ProductionComponent;\nimport java.util.Set;\nimport producerstest.ExecutorModule;\n\n@ProductionComponent(modules \u003d {ExecutorModule.class, ScopedModule.class, SetProducerModule.class})\ninterface SetComponent {\n  ScopedObject scopedObject();\n\n  ListenableFuture\u003cSet\u003cObject\u003e\u003e set();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\scope\\SetProducerModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.scope;\n\nimport dagger.multibindings.IntoSet;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\n\n/**\n * A module that provides two entries into a set; but since the inputs are scoped, the set should\n * only have one value.\n */\n@ProducerModule\nfinal class SetProducerModule {\n  @Produces\n  @IntoSet\n  static Object setValue1(Object value) {\n    return value;\n  }\n\n  @Produces\n  @IntoSet\n  static Object setValue2(Object value) {\n    return value;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\SimpleComponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.ProductionComponent;\n\n@ProductionComponent(modules \u003d {ExecutorModule.class, ResponseProducerModule.class})\ninterface SimpleComponent {\n  ListenableFuture\u003cResponse\u003e response();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\SimpleProducerModule.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage producerstest;\n\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.common.util.concurrent.SettableFuture;\nimport dagger.Lazy;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntoSet;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport java.io.IOException;\nimport java.util.Set;\nimport javax.inject.Provider;\nimport javax.inject.Qualifier;\n\n/**\n * A module that contains various signatures of produces methods. This is not used in any\n * components.\n */\n@ProducerModule\nfinal class SimpleProducerModule {\n  @Qualifier @interface Qual {\n    int value();\n  }\n\n  // Unique bindings.\n\n  @Produces\n  @Qual(-2)\n  static ListenableFuture\u003cString\u003e throwingProducer() {\n    throw new RuntimeException(\"monkey\");\n  }\n\n  @Produces\n  @Qual(-1)\n  static ListenableFuture\u003cString\u003e settableFutureStr(SettableFuture\u003cString\u003e future) {\n    return future;\n  }\n\n  @Produces\n  @Qual(0)\n  static String str() {\n    return \"str\";\n  }\n\n  @Produces\n  @Qual(1)\n  static ListenableFuture\u003cString\u003e futureStr() {\n    return Futures.immediateFuture(\"future str\");\n  }\n\n  @Produces\n  @Qual(2)\n  static String strWithArg(@SuppressWarnings(\"unused\") int i) {\n    return \"str with arg\";\n  }\n\n  @Produces\n  @Qual(3)\n  static ListenableFuture\u003cString\u003e futureStrWithArg(@SuppressWarnings(\"unused\") int i) {\n    return Futures.immediateFuture(\"future str with arg\");\n  }\n\n  @Produces\n  @Qual(4)\n  @SuppressWarnings(\"unused\") // unthrown exception for test\n  static String strThrowingException() throws IOException {\n    return \"str throwing exception\";\n  }\n\n  @Produces\n  @Qual(5)\n  @SuppressWarnings(\"unused\") // unthrown exception for test\n  static ListenableFuture\u003cString\u003e futureStrThrowingException() throws IOException {\n    return Futures.immediateFuture(\"future str throwing exception\");\n  }\n\n  @Produces\n  @Qual(6)\n  @SuppressWarnings(\"unused\") // unthrown exception for test, unused parameter for test\n  static String strWithArgThrowingException(int i) throws IOException {\n    return \"str with arg throwing exception\";\n  }\n\n  @Produces\n  @Qual(7)\n  @SuppressWarnings(\"unused\") // unthrown exception for test, unused parameter for test\n  static ListenableFuture\u003cString\u003e futureStrWithArgThrowingException(int i) throws IOException {\n    return Futures.immediateFuture(\"future str with arg throwing exception\");\n  }\n\n  @Produces\n  @Qual(8)\n  static String strWithArgs(\n      @SuppressWarnings(\"unused\") int i,\n      @SuppressWarnings(\"unused\") Produced\u003cDouble\u003e b,\n      @SuppressWarnings(\"unused\") Producer\u003cObject\u003e c,\n      @SuppressWarnings(\"unused\") Provider\u003cBoolean\u003e d) {\n    return \"str with args\";\n  }\n\n  @Produces\n  @Qual(9)\n  @SuppressWarnings(\"unused\") // unthrown exception for test, unused parameters for test\n  static String strWithArgsThrowingException(\n      int i, Produced\u003cDouble\u003e b, Producer\u003cObject\u003e c, Provider\u003cBoolean\u003e d) throws IOException {\n    return \"str with args throwing exception\";\n  }\n\n  @Produces\n  @Qual(10)\n  static ListenableFuture\u003cString\u003e futureStrWithArgs(\n      @SuppressWarnings(\"unused\") int i,\n      @SuppressWarnings(\"unused\") Produced\u003cDouble\u003e b,\n      @SuppressWarnings(\"unused\") Producer\u003cObject\u003e c,\n      @SuppressWarnings(\"unused\") Provider\u003cBoolean\u003e d) {\n    return Futures.immediateFuture(\"future str with args\");\n  }\n\n  @Produces\n  @Qual(11)\n  @SuppressWarnings(\"unused\") // unthrown exception for test, unused parameter for test\n  static ListenableFuture\u003cString\u003e futureStrWithArgsThrowingException(\n      int i, Produced\u003cDouble\u003e b, Producer\u003cObject\u003e c, Provider\u003cBoolean\u003e d) throws IOException {\n    return Futures.immediateFuture(\"str with args throwing exception\");\n  }\n\n  @Produces\n  @Qual(12)\n  static String strWithFrameworkTypeArgs(\n      @SuppressWarnings(\"unused\") @Qual(1) int i,\n      @SuppressWarnings(\"unused\") @Qual(1) Provider\u003cInteger\u003e iProvider,\n      @SuppressWarnings(\"unused\") @Qual(1) Lazy\u003cInteger\u003e iLazy,\n      @SuppressWarnings(\"unused\") @Qual(2) int j,\n      @SuppressWarnings(\"unused\") @Qual(2) Produced\u003cInteger\u003e jProduced,\n      @SuppressWarnings(\"unused\") @Qual(2) Producer\u003cInteger\u003e jProducer,\n      @SuppressWarnings(\"unused\") @Qual(3) Produced\u003cInteger\u003e kProduced,\n      @SuppressWarnings(\"unused\") @Qual(3) Producer\u003cInteger\u003e kProducer) {\n    return \"str with framework type args\";\n  }\n\n  // Set bindings.\n\n  @Produces\n  @IntoSet\n  static String setOfStrElement() {\n    return \"set of str element\";\n  }\n\n  @Produces\n  @IntoSet\n  @SuppressWarnings(\"unused\") // unthrown exception for test\n  static String setOfStrElementThrowingException() throws IOException {\n    return \"set of str element throwing exception\";\n  }\n\n  @Produces\n  @IntoSet\n  static ListenableFuture\u003cString\u003e setOfStrFutureElement() {\n    return Futures.immediateFuture(\"set of str element\");\n  }\n\n  @Produces\n  @IntoSet\n  @SuppressWarnings(\"unused\") // unthrown exception for test\n  static ListenableFuture\u003cString\u003e setOfStrFutureElementThrowingException() throws IOException {\n    return Futures.immediateFuture(\"set of str element throwing exception\");\n  }\n\n  @Produces\n  @IntoSet\n  static String setOfStrElementWithArg(@SuppressWarnings(\"unused\") int i) {\n    return \"set of str element with arg\";\n  }\n\n  @Produces\n  @IntoSet\n  @SuppressWarnings(\"unused\") // unthrown exception for test, unused parameter for test\n  static String setOfStrElementWithArgThrowingException(int i) throws IOException {\n    return \"set of str element with arg throwing exception\";\n  }\n\n  @Produces\n  @IntoSet\n  static ListenableFuture\u003cString\u003e setOfStrFutureElementWithArg(@SuppressWarnings(\"unused\") int i) {\n    return Futures.immediateFuture(\"set of str element with arg\");\n  }\n\n  @Produces\n  @IntoSet\n  @SuppressWarnings(\"unused\") // unthrown exception for test, unused parameter for test\n  static ListenableFuture\u003cString\u003e setOfStrFutureElementWithArgThrowingException(int i)\n      throws IOException {\n    return Futures.immediateFuture(\"set of str element with arg throwing exception\");\n  }\n\n  @Produces\n  @ElementsIntoSet\n  static Set\u003cString\u003e setOfStrValues() {\n    return ImmutableSet.of(\"set of str 1\", \"set of str 2\");\n  }\n\n  @Produces\n  @ElementsIntoSet\n  @SuppressWarnings(\"unused\") // unthrown exception for test\n  static Set\u003cString\u003e setOfStrValuesThrowingException() throws IOException {\n    return ImmutableSet.of(\"set of str 1\", \"set of str 2 throwing exception\");\n  }\n\n  @Produces\n  @ElementsIntoSet\n  static ListenableFuture\u003cSet\u003cString\u003e\u003e setOfStrFutureValues() {\n    return Futures.\u003cSet\u003cString\u003e\u003eimmediateFuture(ImmutableSet.of(\"set of str 1\", \"set of str 2\"));\n  }\n\n  @Produces\n  @ElementsIntoSet\n  @SuppressWarnings(\"unused\") // unthrown exception for test\n  static ListenableFuture\u003cSet\u003cString\u003e\u003e setOfStrFutureValuesThrowingException() throws IOException {\n    return Futures.\u003cSet\u003cString\u003e\u003eimmediateFuture(\n        ImmutableSet.of(\"set of str 1\", \"set of str 2 throwing exception\"));\n  }\n\n  @Produces\n  @ElementsIntoSet\n  static Set\u003cString\u003e setOfStrValuesWithArg(@SuppressWarnings(\"unused\") int i) {\n    return ImmutableSet.of(\"set of str with arg 1\", \"set of str with arg 2\");\n  }\n\n  @Produces\n  @ElementsIntoSet\n  @SuppressWarnings(\"unused\") // unthrown exception for test, unused parameter for test\n  static Set\u003cString\u003e setOfStrValuesWithArgThrowingException(int i) throws IOException {\n    return ImmutableSet.of(\"set of str with arg 1\", \"set of str with arg 2 throwing exception\");\n  }\n\n  @Produces\n  @ElementsIntoSet\n  static ListenableFuture\u003cSet\u003cString\u003e\u003e setOfStrFutureValuesWithArg(\n      @SuppressWarnings(\"unused\") int i) {\n    return Futures.\u003cSet\u003cString\u003e\u003eimmediateFuture(\n        ImmutableSet.of(\"set of str with arg 1\", \"set of str with arg 2\"));\n  }\n\n  @Produces\n  @ElementsIntoSet\n  @SuppressWarnings(\"unused\") // unthrown exception for test, unused parameter for test\n  static ListenableFuture\u003cSet\u003cString\u003e\u003e setOfStrFutureValuesWithArgThrowingException(int i)\n      throws IOException {\n    return Futures.\u003cSet\u003cString\u003e\u003eimmediateFuture(\n        ImmutableSet.of(\"set of str with arg 1\", \"set of str with arg 2 throwing exception\"));\n  }\n\n  /**\n   * A binding method that might result in a generated factory with conflicting field and parameter\n   * names.\n   */\n  @Produces\n  static Object object(int foo, Provider\u003cString\u003e fooProvider) {\n    return foo + fooProvider.get();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\subcomponent\\ModuleSubcomponentsInterop.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.subcomponent;\n\nimport dagger.Component;\nimport dagger.Module;\nimport dagger.Subcomponent;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.ProductionComponent;\nimport dagger.producers.ProductionSubcomponent;\n\nfinal class ModuleSubcomponentsInterop {\n  @Component(modules \u003d ProvisionTestModule.class)\n  interface ProvisionParent {\n    ProductionChild.Builder productionChild();\n  }\n\n  @Module(subcomponents \u003d ProductionChild.class)\n  static class ProvisionTestModule {}\n\n  @ProductionSubcomponent\n  interface ProductionChild {\n    @ProductionSubcomponent.Builder\n    interface Builder {\n      ProductionChild build();\n    }\n  }\n\n  @ProductionComponent(modules \u003d ProductionTestModule.class)\n  interface ProductionParent {\n    ProvisionChild.Builder provisionBuilder();\n  }\n\n  @ProducerModule(subcomponents \u003d ProvisionChild.class)\n  static class ProductionTestModule {}\n\n  @Subcomponent\n  interface ProvisionChild {\n    @Subcomponent.Builder\n    interface Builder {\n      ProvisionChild build();\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\subcomponent\\MultiPackageSubcomponents.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.subcomponent;\n\nimport dagger.Component;\nimport dagger.Module;\nimport dagger.Provides;\nimport producerstest.subcomponent.sub.ChildComponent;\n\nfinal class MultiPackageSubcomponents {\n  @Component(modules \u003d IntModule.class)\n  interface ParentComponent {\n    ChildComponent.Builder childComponentBuilder();\n  }\n\n  @Module\n  static final class IntModule {\n    @Provides\n    static int i() {\n      return 42;\n    }\n  }\n\n  private MultiPackageSubcomponents() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\subcomponent\\ProductionSubcomponentFromModuleAndFactoryMethod.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.subcomponent;\n\nimport dagger.Module;\nimport dagger.Subcomponent;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.ProductionComponent;\nimport dagger.producers.ProductionSubcomponent;\nimport producerstest.ExecutorModule;\n\n/**\n * Tests for {@link Subcomponent}s which are defined with {@link Module#subcomponents()} and are\n * also requested as component factory methods.\n */\npublic class ProductionSubcomponentFromModuleAndFactoryMethod {\n  @ProductionSubcomponent\n  interface Sub {\n    @ProductionSubcomponent.Builder\n    interface Builder {\n      Sub sub();\n    }\n  }\n\n  @ProducerModule(subcomponents \u003d Sub.class)\n  static class ModuleWithSubcomponent {}\n\n  @ProductionComponent(modules \u003d {ModuleWithSubcomponent.class, ExecutorModule.class})\n  interface ExposesBuilder {\n    Sub.Builder subcomponentBuilder();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\subcomponent\\pruning\\ParentDoesntUseProductionSubcomponent.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.subcomponent.pruning;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.multibindings.IntoSet;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport dagger.producers.ProductionComponent;\nimport dagger.producers.ProductionSubcomponent;\nimport java.util.Set;\nimport javax.inject.Qualifier;\n\n/**\n * Supporting types for {@link ProductionSubcomponentOnlyRequestedBySiblingTest}. {@link ChildA} is\n * a direct child of the top level component, but is only requested within its sibling, not directly\n * from its parent.\n */\n@ProductionComponent(\n  modules \u003d {\n    ParentDoesntUseProductionSubcomponent.ParentModule.class,\n    producerstest.ExecutorModule.class\n  }\n)\ninterface ParentDoesntUseProductionSubcomponent {\n\n  ChildB.Builder childBBuilder();\n\n  @ProductionSubcomponent(modules \u003d ChildAModule.class)\n  interface ChildA {\n    @ProductionSubcomponent.Builder\n    interface Builder {\n      ChildA build();\n    }\n\n    ListenableFuture\u003cSet\u003cClass\u003c?\u003e\u003e\u003e componentHierarchy();\n  }\n\n  @ProductionSubcomponent(modules \u003d ChildBModule.class)\n  interface ChildB {\n    @ProductionSubcomponent.Builder\n    interface Builder {\n      ChildB build();\n    }\n\n    ListenableFuture\u003cSet\u003cClass\u003c?\u003e\u003e\u003e componentHierarchy();\n\n    @FromChildA\n    ListenableFuture\u003cSet\u003cClass\u003c?\u003e\u003e\u003e componentHierarchyFromChildA();\n  }\n\n  @ProducerModule(subcomponents \u003d {ChildA.class, ChildB.class})\n  class ParentModule {\n    @Produces\n    @IntoSet\n    static Class\u003c?\u003e produceComponentType() {\n      return ParentDoesntUseProductionSubcomponent.class;\n    }\n  }\n\n  @ProducerModule\n  class ChildAModule {\n    @Produces\n    @IntoSet\n    static Class\u003c?\u003e produceComponentType() {\n      return ChildA.class;\n    }\n  }\n\n  @ProducerModule\n  class ChildBModule {\n    @Produces\n    @IntoSet\n    static Class\u003c?\u003e produceComponentType() {\n      return ChildB.class;\n    }\n\n    @Produces\n    @FromChildA\n    Set\u003cClass\u003c?\u003e\u003e fromChildA(ChildA.Builder childABuilder) throws Exception {\n      return childABuilder.build().componentHierarchy().get();\n    }\n  }\n\n  @Qualifier\n  @interface FromChildA {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\subcomponent\\sub\\ChildComponent.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.subcomponent.sub;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.ProductionSubcomponent;\nimport producerstest.ExecutorModule;\n\n@ProductionSubcomponent(modules \u003d {ExecutorModule.class, ChildModule.class})\npublic interface ChildComponent {\n  ListenableFuture\u003cString\u003e str();\n\n  @ProductionSubcomponent.Builder\n  interface Builder {\n    ChildComponent build();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\subcomponent\\sub\\ChildModule.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.subcomponent.sub;\n\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\n\n@ProducerModule\nfinal class ChildModule {\n  @Produces\n  static String str(int n) {\n    return \"Hello, World \" + n;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\subcomponent\\SubcomponentsWithBoundExecutor.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.subcomponent;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.Component;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport dagger.producers.Production;\nimport dagger.producers.ProductionComponent;\nimport dagger.producers.ProductionSubcomponent;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport javax.inject.Qualifier;\n\nfinal class SubcomponentsWithBoundExecutor {\n  @Qualifier\n  @interface FromParent {}\n\n  @Qualifier\n  @interface FromChild {}\n\n  @Qualifier\n  @interface FromGrandchild {}\n\n  static final class CountingExecutor implements Executor {\n    private final AtomicInteger executionCount;\n\n    CountingExecutor(AtomicInteger executionCount) {\n      this.executionCount \u003d executionCount;\n    }\n\n    @Override\n    public void execute(Runnable runnable) {\n      executionCount.incrementAndGet();\n      runnable.run();\n    }\n  }\n\n  @Module\n  static final class ExecutorModule {\n    private final AtomicInteger constructionCount;\n    private final AtomicInteger executionCount;\n\n    ExecutorModule(AtomicInteger constructionCount, AtomicInteger executionCount) {\n      this.constructionCount \u003d constructionCount;\n      this.executionCount \u003d executionCount;\n    }\n\n    @Provides\n    @Production\n    Executor executor() {\n      constructionCount.incrementAndGet();\n      return new CountingExecutor(executionCount);\n    }\n  }\n\n  @Module\n  static final class ParentModule {\n    @Provides\n    @FromParent\n    static String fromParent() {\n      return \"parent\";\n    }\n  }\n\n  @Component(modules \u003d {ParentModule.class, ExecutorModule.class})\n  interface ParentComponent {\n    InjectsChildBuilder injectsChildBuilder();\n\n    ChildComponent.Builder newChildComponentBuilder();\n  }\n\n  @ProducerModule\n  static final class ParentProducerModule {\n    @Produces\n    @FromParent\n    static String fromParent() {\n      return \"parentproduction\";\n    }\n  }\n\n  @ProductionComponent(modules \u003d {ParentProducerModule.class, ExecutorModule.class})\n  interface ParentProductionComponent {\n    ChildComponent.Builder newChildComponentBuilder();\n\n    @ProductionComponent.Builder\n    interface Builder {\n      Builder executorModule(ExecutorModule executorModule);\n\n      ParentProductionComponent build();\n    }\n  }\n\n  @ProducerModule\n  static final class ChildProducerModule {\n    @Produces\n    @FromChild\n    static String fromChild(@FromParent String fromParent) {\n      return \"child:\" + fromParent;\n    }\n  }\n\n  @ProductionSubcomponent(modules \u003d ChildProducerModule.class)\n  interface ChildComponent {\n    @FromChild\n    ListenableFuture\u003cString\u003e fromChild();\n\n    GrandchildComponent.Builder newGrandchildComponentBuilder();\n    GrandchildComponentWithoutBuilder newGrandchildComponent();\n\n    @ProductionSubcomponent.Builder\n    interface Builder {\n      ChildComponent build();\n    }\n  }\n\n  static final class InjectsChildBuilder {\n    private final Provider\u003cChildComponent.Builder\u003e childBuilder;\n\n    @Inject\n    InjectsChildBuilder(Provider\u003cChildComponent.Builder\u003e childBuilder) {\n      this.childBuilder \u003d childBuilder;\n    }\n\n    ChildComponent.Builder childBuilder() {\n      return childBuilder.get();\n    }\n  }\n\n  @ProducerModule\n  static final class GrandchildProducerModule {\n    @Produces\n    @FromGrandchild\n    static String fromGranchild(@FromChild String fromChild) {\n      return \"grandchild:\" + fromChild;\n    }\n  }\n\n  @ProductionSubcomponent(modules \u003d GrandchildProducerModule.class)\n  interface GrandchildComponent {\n    @FromGrandchild\n    ListenableFuture\u003cString\u003e fromGrandchild();\n\n    @ProductionSubcomponent.Builder\n    interface Builder {\n      GrandchildComponent build();\n    }\n  }\n\n  @ProductionSubcomponent(modules \u003d GrandchildProducerModule.class)\n  interface GrandchildComponentWithoutBuilder {\n    @FromGrandchild\n    ListenableFuture\u003cString\u003e fromGrandchild();\n  }\n\n  private SubcomponentsWithBoundExecutor() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\main\\java\\producerstest\\subcomponent\\UsesProducerModuleSubcomponents.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.subcomponent;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.multibindings.IntoSet;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport dagger.producers.ProductionComponent;\nimport dagger.producers.ProductionSubcomponent;\nimport java.util.Set;\nimport javax.inject.Qualifier;\nimport producerstest.ExecutorModule;\n\n/** Supporting types for {@link ProducerModuleWithSubcomponentsTest}. */\n@ProductionComponent(\n  modules \u003d UsesProducerModuleSubcomponents.ProducerModuleWithSubcomponents.class\n)\npublic interface UsesProducerModuleSubcomponents {\n\n  ListenableFuture\u003cSet\u003cString\u003e\u003e strings();\n\n  @FromChild\n  ListenableFuture\u003cSet\u003cString\u003e\u003e stringsFromChild();\n\n  @ProducerModule(\n    subcomponents \u003d Child.class,\n    includes \u003d {AlsoIncludesSubcomponents.class, ExecutorModule.class}\n  )\n  class ProducerModuleWithSubcomponents {\n    @Produces\n    @IntoSet\n    static String produceStringInParent() {\n      return \"from parent\";\n    }\n\n    @Produces\n    @FromChild\n    static Set\u003cString\u003e stringsFromChild(Child.Builder childBuilder) throws Exception {\n      return childBuilder.build().strings().get();\n    }\n  }\n\n  @ProducerModule(subcomponents \u003d Child.class)\n  class AlsoIncludesSubcomponents {}\n\n  @ProductionSubcomponent(modules \u003d ChildModule.class)\n  interface Child {\n    ListenableFuture\u003cSet\u003cString\u003e\u003e strings();\n\n    @ProductionSubcomponent.Builder\n    interface Builder {\n      Child build();\n    }\n  }\n\n  @ProducerModule\n  class ChildModule {\n    @Produces\n    @IntoSet\n    static String produceStringInChild() {\n      return \"from child\";\n    }\n  }\n\n  @Qualifier\n  @interface FromChild {}\n\n  @ProducerModule(includes \u003d ProducerModuleWithSubcomponents.class)\n  class OnlyIncludesProducerModuleWithSubcomponents {}\n\n  @ProductionComponent(modules \u003d OnlyIncludesProducerModuleWithSubcomponents.class)\n  interface ParentIncludesProductionSubcomponentTransitively\n      extends UsesProducerModuleSubcomponents {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\badexecutor\\BadExecutorTest.java",
    "code": "\"package producerstest.badexecutor;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\n\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.common.util.concurrent.ListeningExecutorService;\nimport com.google.common.util.concurrent.MoreExecutors;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.RejectedExecutionException;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport producerstest.ExecutorModule;\n\n/** This test verifies behavior when the executor throws {@link RejectedExecutionException}. */\n@RunWith(JUnit4.class)\npublic final class BadExecutorTest {\n  private SimpleComponent component;\n\n  @Before\n  public void setUpComponent() {\n    ComponentDependency dependency \u003d\n        new ComponentDependency() {\n          @Override\n          public ListenableFuture\u003cDouble\u003e doubleDep() {\n            return Futures.immediateFuture(42.0);\n          }\n        };\n    ListeningExecutorService executorService \u003d MoreExecutors.newDirectExecutorService();\n    component \u003d\n        DaggerSimpleComponent.builder()\n            .executorModule(new ExecutorModule(executorService))\n            .componentDependency(dependency)\n            .build();\n    executorService.shutdown();\n  }\n\n  @Test\n  public void rejectNoArgMethod() throws Exception {\n    try {\n      component.noArgStr().get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);\n    }\n  }\n\n  @Test\n  public void rejectSingleArgMethod() throws Exception {\n    try {\n      component.singleArgInt().get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);\n    }\n  }\n\n  @Test\n  public void rejectSingleArgFromComponentDepMethod() throws Exception {\n    try {\n      component.singleArgBool().get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).isInstanceOf(RejectedExecutionException.class);\n    }\n  }\n\n  @Test\n  public void doNotRejectComponentDepMethod() throws Exception {\n    assertThat(component.doubleDep().get()).isWithin(0).of(42.0);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\binds\\BindsProducersTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.binds;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.google.common.collect.ImmutableMap;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport java.util.Map;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class BindsProducersTest {\n\n  private SimpleBindsProductionComponent component;\n\n  @Before\n  public void setUp() {\n    component \u003d DaggerSimpleBindsProductionComponent.create();\n  }\n\n  @Test\n  public void bindDelegates() throws Exception {\n    assertThat(component.object().get()).isInstanceOf(FooOfStrings.class);\n    assertThat(component.fooOfStrings().get()).isInstanceOf(FooOfStrings.class);\n    assertThat(component.fooOfIntegers().get()).isNotNull();\n  }\n\n  @Test\n  public void bindWithScope() throws Exception {\n    assertThat(component.qualifiedFooOfStrings().get())\n        .isSameAs(component.qualifiedFooOfStrings().get());\n  }\n\n  @Test\n  public void multibindings() throws Exception {\n    assertThat(component.foosOfNumbers().get()).hasSize(2);\n    assertThat(component.objects().get()).hasSize(3);\n    assertThat(component.charSequences().get()).hasSize(5);\n\n    assertThat(component.integerObjectMap().get())\n        .containsExactlyEntriesIn(\n            ImmutableMap.of(\n                123, \"123-string\", 456, \"456-string\", 789, \"789-string\", -1, \"provision-string\"));\n\n    Map\u003cInteger, Producer\u003cObject\u003e\u003e integerProducerOfObjectMap \u003d\n        component.integerProducerOfObjectMap().get();\n    assertThat(integerProducerOfObjectMap).hasSize(4);\n    assertThat(integerProducerOfObjectMap.get(123).get().get()).isEqualTo(\"123-string\");\n    assertThat(integerProducerOfObjectMap.get(456).get().get()).isEqualTo(\"456-string\");\n    assertThat(integerProducerOfObjectMap.get(789).get().get()).isEqualTo(\"789-string\");\n    assertThat(integerProducerOfObjectMap.get(-1).get().get()).isEqualTo(\"provision-string\");\n\n    assertThat(component.integerProducedOfObjectMap().get())\n        .containsExactlyEntriesIn(\n            ImmutableMap.of(\n                123, Produced.successful(\"123-string\"),\n                456, Produced.successful(\"456-string\"),\n                789, Produced.successful(\"789-string\"),\n                -1, Produced.successful(\"provision-string\")));\n\n    assertThat(component.qualifiedIntegerObjectMap().get()).hasSize(1);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\builder\\ProductionComponentBuilderTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.builder;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/** Tests for {@link dagger.producers.ProductionComponent.Builder}. */\n@RunWith(JUnit4.class)\npublic final class ProductionComponentBuilderTest {\n\n  @Test\n  public void successfulBuild() throws Exception {\n    TestComponentWithBuilder component \u003d\n        DaggerTestComponentWithBuilder.builder()\n            .depComponent(depComponent(15.3))\n            .strModule(new StringModule())\n            .build();\n    assertThat(component.s().get()).isEqualTo(\"arg: 42\");\n    assertThat(component.d().get()).isWithin(0).of(15.3);\n  }\n\n  @Test\n  public void successfulBuild_withMissingZeroArgModule() throws Exception {\n    TestComponentWithBuilder component \u003d\n        DaggerTestComponentWithBuilder.builder()\n            .depComponent(depComponent(15.3))\n            .build();\n    assertThat(component.s().get()).isEqualTo(\"arg: 42\");\n    assertThat(component.d().get()).isWithin(0).of(15.3);\n  }\n\n  @Test(expected \u003d IllegalStateException.class)\n  public void missingDepComponent() {\n    DaggerTestComponentWithBuilder.builder()\n        .strModule(new StringModule())\n        .build();\n  }\n\n  private static DepComponent depComponent(final double value) {\n    return new DepComponent() {\n      @Override\n      public ListenableFuture\u003cDouble\u003e d() {\n        return Futures.immediateFuture(value);\n      }\n    };\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\DependentTest.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage producerstest;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class DependentTest {\n  @Test public void dependentComponent() throws Exception {\n    DependentComponent dependentComponent \u003d\n        DaggerDependentComponent.builder()\n            .dependedProductionComponent(DaggerDependedProductionComponent.create())\n            .dependedComponent(DaggerDependedComponent.create())\n            .build();\n    assertThat(dependentComponent).isNotNull();\n    assertThat(dependentComponent.greetings().get()).containsExactly(\n        \"2\", \"Hello world!\", \"HELLO WORLD!\");\n  }\n\n  @Test public void reuseBuilderWithDependentComponent() throws Exception {\n    DaggerDependentComponent.Builder dependentComponentBuilder \u003d DaggerDependentComponent.builder();\n\n    DependentComponent componentUsingComponents \u003d\n        dependentComponentBuilder\n            .dependedProductionComponent(DaggerDependedProductionComponent.create())\n            .dependedComponent(DaggerDependedComponent.create())\n            .build();\n\n    DependentComponent componentUsingJavaImpls \u003d dependentComponentBuilder\n        .dependedProductionComponent(new DependedProductionComponent() {\n          @Override public ListenableFuture\u003cInteger\u003e numGreetings() {\n            return Futures.immediateFuture(3);\n          }\n        })\n        .dependedComponent(new DependedComponent() {\n          @Override public String getGreeting() {\n            return \"Goodbye world!\";\n          }\n        })\n        .build();\n\n    assertThat(componentUsingJavaImpls.greetings().get()).containsExactly(\n        \"3\", \"Goodbye world!\", \"GOODBYE WORLD!\");\n    assertThat(componentUsingComponents.greetings().get()).containsExactly(\n        \"2\", \"Hello world!\", \"HELLO WORLD!\");\n\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\monitoring\\MonitoringTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.monitoring;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.common.util.concurrent.SettableFuture;\nimport dagger.producers.monitoring.ProducerMonitor;\nimport dagger.producers.monitoring.ProducerToken;\nimport dagger.producers.monitoring.ProductionComponentMonitor;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\n/** Tests for production components using monitoring. */\n@RunWith(JUnit4.class)\npublic final class MonitoringTest {\n  @Mock private ProductionComponentMonitor.Factory componentMonitorFactory;\n  @Mock private StringStub server1;\n  @Mock private StringStub server2;\n  private SettableFuture\u003cString\u003e server1Future;\n  private SettableFuture\u003cString\u003e server2Future;\n  private FakeProductionComponentMonitor componentMonitor;\n\n  @Before\n  public void setUp() {\n    MockitoAnnotations.initMocks(this);\n    componentMonitor \u003d new FakeProductionComponentMonitor();\n    when(componentMonitorFactory.create(any())).thenReturn(componentMonitor);\n    server1Future \u003d SettableFuture.create();\n    server2Future \u003d SettableFuture.create();\n    when(server1.run(any(String.class))).thenReturn(server1Future);\n    when(server2.run(any(String.class))).thenReturn(server2Future);\n  }\n\n  @Test\n  public void basicMonitoring() throws Exception {\n    MonitoredComponent component \u003d\n        DaggerMonitoredComponent.builder()\n            .monitoringModule(new MonitoringModule(componentMonitorFactory))\n            .stubModule(new StubModule(server1, server2))\n            .build();\n    ListenableFuture\u003cString\u003e output \u003d component.output();\n    assertThat(componentMonitor.monitors).hasSize(3);\n    ImmutableList\u003cMap.Entry\u003cProducerToken, ProducerMonitor\u003e\u003e entries \u003d\n        ImmutableList.copyOf(componentMonitor.monitors.entrySet());\n    assertThat(entries.get(0).getKey().toString()).contains(\"CallServer2\");\n    assertThat(entries.get(1).getKey().toString()).contains(\"CallServer1\");\n    assertThat(entries.get(2).getKey().toString()).contains(\"RequestData\");\n\n    ProducerMonitor callServer2Monitor \u003d entries.get(0).getValue();\n    ProducerMonitor callServer1Monitor \u003d entries.get(1).getValue();\n    ProducerMonitor requestDataMonitor \u003d entries.get(2).getValue();\n\n    InOrder inOrder \u003d inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);\n    inOrder.verify(callServer2Monitor).requested();\n    inOrder.verify(callServer1Monitor).requested();\n    inOrder.verify(requestDataMonitor).requested();\n    inOrder.verify(requestDataMonitor).methodStarting();\n    inOrder.verify(requestDataMonitor).methodFinished();\n    inOrder.verify(requestDataMonitor).succeeded(\"Hello, World!\");\n    inOrder.verify(callServer1Monitor).methodStarting();\n    inOrder.verify(callServer1Monitor).methodFinished();\n    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);\n\n    server1Future.set(\"server 1 response\");\n    inOrder.verify(callServer1Monitor).succeeded(\"server 1 response\");\n    inOrder.verify(callServer2Monitor).methodStarting();\n    inOrder.verify(callServer2Monitor).methodFinished();\n    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);\n\n    server2Future.set(\"server 2 response\");\n    inOrder.verify(callServer2Monitor).succeeded(\"server 2 response\");\n    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);\n    assertThat(output.get()).isEqualTo(\"server 2 response\");\n  }\n\n  @Test\n  public void basicMonitoringWithFailure() throws Exception {\n    MonitoredComponent component \u003d\n        DaggerMonitoredComponent.builder()\n            .monitoringModule(new MonitoringModule(componentMonitorFactory))\n            .stubModule(new StubModule(server1, server2))\n            .build();\n    ListenableFuture\u003cString\u003e output \u003d component.output();\n    assertThat(componentMonitor.monitors).hasSize(3);\n    ImmutableList\u003cMap.Entry\u003cProducerToken, ProducerMonitor\u003e\u003e entries \u003d\n        ImmutableList.copyOf(componentMonitor.monitors.entrySet());\n    assertThat(entries.get(0).getKey().toString()).contains(\"CallServer2\");\n    assertThat(entries.get(1).getKey().toString()).contains(\"CallServer1\");\n    assertThat(entries.get(2).getKey().toString()).contains(\"RequestData\");\n\n    ProducerMonitor callServer2Monitor \u003d entries.get(0).getValue();\n    ProducerMonitor callServer1Monitor \u003d entries.get(1).getValue();\n    ProducerMonitor requestDataMonitor \u003d entries.get(2).getValue();\n\n    InOrder inOrder \u003d inOrder(requestDataMonitor, callServer1Monitor, callServer2Monitor);\n    inOrder.verify(callServer2Monitor).requested();\n    inOrder.verify(callServer1Monitor).requested();\n    inOrder.verify(requestDataMonitor).requested();\n    inOrder.verify(requestDataMonitor).methodStarting();\n    inOrder.verify(requestDataMonitor).methodFinished();\n    inOrder.verify(requestDataMonitor).succeeded(\"Hello, World!\");\n    inOrder.verify(callServer1Monitor).methodStarting();\n    inOrder.verify(callServer1Monitor).methodFinished();\n    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);\n\n    RuntimeException cause \u003d new RuntimeException(\"monkey\");\n    server1Future.setException(cause);\n    inOrder.verify(callServer1Monitor).failed(cause);\n    inOrder.verify(callServer2Monitor).failed(any(Throwable.class));\n    verifyNoMoreInteractions(requestDataMonitor, callServer1Monitor, callServer2Monitor);\n    try {\n      output.get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(Throwables.getRootCause(e)).isSameAs(cause);\n    }\n  }\n\n  private static final class FakeProductionComponentMonitor extends ProductionComponentMonitor {\n    final Map\u003cProducerToken, ProducerMonitor\u003e monitors \u003d new LinkedHashMap\u003c\u003e();\n\n    @Override\n    public ProducerMonitor producerMonitorFor(ProducerToken token) {\n      ProducerMonitor monitor \u003d mock(ProducerMonitor.class);\n      monitors.put(token, monitor);\n      return monitor;\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\multibindings\\MultibindingTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.multibindings;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\n\nimport com.google.common.collect.Iterables;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class MultibindingTest {\n  @Test\n  public void setBinding() throws Exception {\n    MultibindingComponent multibindingComponent \u003d DaggerMultibindingComponent.create();\n    assertThat(multibindingComponent.strs().get())\n        .containsExactly(\n            \"foo\",\n            \"foo1\",\n            \"foo2\",\n            \"baz1\",\n            \"baz2\",\n            \"bar\",\n            \"bar1\",\n            \"bar2\",\n            \"providedStr\",\n            \"providedStr1\",\n            \"providedStr2\");\n    assertThat(multibindingComponent.strCount().get()).isEqualTo(11);\n  }\n\n  @Test\n  public void setBindingOfProduced() throws Exception {\n    MultibindingComponent multibindingComponent \u003d DaggerMultibindingComponent.create();\n    assertThat(multibindingComponent.successfulSet().get())\n        .containsExactly(\n            Produced.successful(\"foo\"),\n            Produced.successful(\"foo1\"),\n            Produced.successful(\"foo2\"),\n            Produced.successful(\"baz1\"),\n            Produced.successful(\"baz2\"),\n            Produced.successful(\"bar\"),\n            Produced.successful(\"bar1\"),\n            Produced.successful(\"bar2\"),\n            Produced.successful(\"providedStr\"),\n            Produced.successful(\"providedStr1\"),\n            Produced.successful(\"providedStr2\"));\n  }\n\n  @Test\n  public void setBindingOfProducedWithFailures() throws Exception {\n    MultibindingComponent multibindingComponent \u003d DaggerMultibindingComponent.create();\n    Set\u003cProduced\u003cString\u003e\u003e possiblyThrowingSet \u003d multibindingComponent.possiblyThrowingSet().get();\n    Set\u003cString\u003e successes \u003d new HashSet\u003c\u003e();\n    Set\u003cExecutionException\u003e failures \u003d new HashSet\u003c\u003e();\n    for (Produced\u003cString\u003e str : possiblyThrowingSet) {\n      try {\n        successes.add(str.get());\n      } catch (ExecutionException e) {\n        failures.add(e);\n      }\n    }\n    assertThat(successes).containsExactly(\"singleton\", \"double\", \"ton\");\n    assertThat(failures).hasSize(1);\n    assertThat(Iterables.getOnlyElement(failures).getCause()).hasMessage(\"monkey\");\n  }\n\n  @Test\n  public void mapBinding() throws Exception {\n    MultibindingComponent multibindingComponent \u003d DaggerMultibindingComponent.create();\n    Map\u003cInteger, String\u003e map \u003d multibindingComponent.map().get();\n    assertThat(map).hasSize(3);\n    assertThat(map).containsEntry(15, \"fifteen\");\n    assertThat(map).containsEntry(42, \"forty two\");\n    assertThat(map).containsEntry(3, \"provided three\");\n  }\n\n  @Test\n  public void mapOfProducerBinding() throws Exception {\n    MultibindingComponent multibindingComponent \u003d DaggerMultibindingComponent.create();\n    Map\u003cInteger, Producer\u003cString\u003e\u003e map \u003d multibindingComponent.mapOfProducer().get();\n    assertThat(map).hasSize(3);\n    assertThat(map).containsKey(15);\n    assertThat(map.get(15).get().get()).isEqualTo(\"fifteen\");\n    assertThat(map).containsKey(42);\n    assertThat(map.get(42).get().get()).isEqualTo(\"forty two\");\n    assertThat(map).containsKey(3);\n    assertThat(map.get(3).get().get()).isEqualTo(\"provided three\");\n  }\n\n  @Test\n  public void mapOfProducedBinding() throws Exception {\n    MultibindingComponent multibindingComponent \u003d DaggerMultibindingComponent.create();\n    Map\u003cInteger, Produced\u003cString\u003e\u003e map \u003d multibindingComponent.mapOfProduced().get();\n    assertThat(map).hasSize(3);\n    assertThat(map).containsKey(15);\n    assertThat(map.get(15).get()).isEqualTo(\"fifteen\");\n    assertThat(map).containsKey(42);\n    assertThat(map.get(42).get()).isEqualTo(\"forty two\");\n    assertThat(map).containsKey(3);\n    assertThat(map.get(3).get()).isEqualTo(\"provided three\");\n  }\n\n  @Test\n  public void mapBindingWithFailures() throws Exception {\n    MultibindingComponent multibindingComponent \u003d DaggerMultibindingComponent.create();\n    try {\n      multibindingComponent.possiblyThrowingMap().get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).hasMessage(\"monkey\");\n    }\n  }\n\n  @Test\n  public void mapOfProducerBindingWithFailures() throws Exception {\n    MultibindingComponent multibindingComponent \u003d DaggerMultibindingComponent.create();\n    Map\u003cInteger, Producer\u003cString\u003e\u003e map \u003d\n        multibindingComponent.possiblyThrowingMapOfProducer().get();\n    assertThat(map).hasSize(2);\n    assertThat(map).containsKey(42);\n    assertThat(map.get(42).get().get()).isEqualTo(\"forty two\");\n    assertThat(map).containsKey(15);\n    ListenableFuture\u003cString\u003e future \u003d map.get(15).get();\n    try {\n      future.get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).hasMessage(\"monkey\");\n    }\n  }\n\n  @Test\n  public void mapOfProducedBindingWithFailures() throws Exception {\n    MultibindingComponent multibindingComponent \u003d DaggerMultibindingComponent.create();\n    Map\u003cInteger, Produced\u003cString\u003e\u003e map \u003d\n        multibindingComponent.possiblyThrowingMapOfProduced().get();\n    assertThat(map).hasSize(2);\n    assertThat(map).containsKey(42);\n    assertThat(map.get(42).get()).isEqualTo(\"forty two\");\n    assertThat(map).containsKey(15);\n    Produced\u003cString\u003e produced \u003d map.get(15);\n    try {\n      produced.get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).hasMessage(\"monkey\");\n    }\n  }\n\n  @Test\n  public void emptySet() throws Exception {\n    MultibindingComponent multibindingComponent \u003d DaggerMultibindingComponent.create();\n    assertThat(multibindingComponent.objs().get()).isEmpty();\n    assertThat(multibindingComponent.producedObjs().get()).isEmpty();\n    assertThat(multibindingComponent.objCount().get()).isEqualTo(0);\n  }\n\n  @Test\n  public void emptyMap() throws Exception {\n    MultibindingComponent multibindingComponent \u003d DaggerMultibindingComponent.create();\n    assertThat(multibindingComponent.objMap().get()).isEmpty();\n    assertThat(multibindingComponent.objMapOfProduced().get()).isEmpty();\n    assertThat(multibindingComponent.objMapOfProducer().get()).isEmpty();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\optional\\OptionalBindingComponentsAbsentTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.optional;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport producerstest.optional.OptionalBindingComponents.AbsentOptionalBindingComponent;\n\n/** Tests for absent optional bindings. */\n@RunWith(JUnit4.class)\npublic final class OptionalBindingComponentsAbsentTest {\n  private AbsentOptionalBindingComponent absent;\n\n  @Before\n  public void setUp() {\n    absent \u003d DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create();\n  }\n\n  @Test\n  public void optional() throws Exception {\n    assertThat(absent.optionalInstance().get()).isAbsent();\n  }\n\n  @Test\n  public void optionalProducer() throws Exception {\n    assertThat(absent.optionalProducer().get()).isAbsent();\n  }\n\n  @Test\n  public void optionalProduced() throws Exception {\n    assertThat(absent.optionalProduced().get()).isAbsent();\n  }\n\n  @Test\n  public void qualifiedOptional() throws Exception {\n    assertThat(absent.qualifiedOptionalInstance().get()).isAbsent();\n  }\n\n  @Test\n  public void qualifiedOptionalProducer() throws Exception {\n    assertThat(absent.qualifiedOptionalProducer().get()).isAbsent();\n  }\n\n  @Test\n  public void qualifiedOptionalProduced() throws Exception {\n    assertThat(absent.qualifiedOptionalProduced().get()).isAbsent();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\optional\\OptionalBindingComponentsPresentTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.optional;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static producerstest.optional.OptionalBindingComponents.Value.QUALIFIED_VALUE;\nimport static producerstest.optional.OptionalBindingComponents.Value.VALUE;\n\nimport com.google.common.collect.ImmutableList;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport producerstest.optional.OptionalBindingComponents.OptionalBindingComponent;\n\n/** Tests for present optional bindings. */\n@RunWith(Parameterized.class)\npublic final class OptionalBindingComponentsPresentTest {\n\n  @Parameters(name \u003d \"{0}\")\n  public static Iterable\u003cObject[]\u003e parameters() {\n    return ImmutableList.copyOf(\n        new Object[][] {\n          {DaggerOptionalBindingComponents_PresentOptionalBindingComponent.create()},\n          {DaggerOptionalBindingComponents_AbsentOptionalBindingComponent.create().presentChild()},\n          {DaggerOptionalBindingComponents_PresentOptionalProvisionBindingComponent.create()}\n        });\n  }\n  \n  private final OptionalBindingComponent component;\n\n  public OptionalBindingComponentsPresentTest(OptionalBindingComponent component) {\n    this.component \u003d component;\n  }\n\n  @Test\n  public void optional() throws Exception {\n    assertThat(component.optionalInstance().get()).hasValue(VALUE);\n  }\n\n  @Test\n  public void optionalProducer() throws Exception {\n    assertThat(component.optionalProducer().get().get().get().get()).isEqualTo(VALUE);\n  }\n\n  @Test\n  public void optionalProduced() throws Exception {\n    assertThat(component.optionalProduced().get().get().get()).isEqualTo(VALUE);\n  }\n\n  @Test\n  public void qualifiedOptional() throws Exception {\n    assertThat(component.qualifiedOptionalInstance().get()).hasValue(QUALIFIED_VALUE);\n  }\n\n  @Test\n  public void qualifiedOptionalProducer() throws Exception {\n    assertThat(component.qualifiedOptionalProducer().get().get().get().get())\n        .isEqualTo(QUALIFIED_VALUE);\n  }\n\n  @Test\n  public void qualifiedOptionalProduced() throws Exception {\n    assertThat(component.qualifiedOptionalProduced().get().get().get()).isEqualTo(QUALIFIED_VALUE);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\ProducerFactoryTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.common.util.concurrent.MoreExecutors;\nimport com.google.common.util.concurrent.SettableFuture;\nimport dagger.producers.Producer;\nimport dagger.producers.monitoring.ProducerMonitor;\nimport dagger.producers.monitoring.ProducerToken;\nimport dagger.producers.monitoring.ProductionComponentMonitor;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport javax.inject.Provider;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.Mockito;\nimport org.mockito.MockitoAnnotations;\n\n@RunWith(JUnit4.class)\npublic class ProducerFactoryTest {\n  @Mock private ProductionComponentMonitor componentMonitor;\n  private ProducerMonitor monitor;\n  private Provider\u003cExecutor\u003e executorProvider;\n  private Provider\u003cProductionComponentMonitor\u003e componentMonitorProvider;\n\n  @Before\n  public void setUpMocks() {\n    MockitoAnnotations.initMocks(this);\n    monitor \u003d Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);\n    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);\n    // TODO(beder): Use Providers.of when available.\n    executorProvider \u003d\n        new Provider\u003cExecutor\u003e() {\n          @Override\n          public Executor get() {\n            return MoreExecutors.directExecutor();\n          }\n        };\n    componentMonitorProvider \u003d\n        new Provider\u003cProductionComponentMonitor\u003e() {\n          @Override\n          public ProductionComponentMonitor get() {\n            return componentMonitor;\n          }\n        };\n  }\n\n  @Test\n  public void noArgMethod() throws Exception {\n    ProducerToken token \u003d ProducerToken.create(SimpleProducerModule_StrFactory.class);\n    Producer\u003cString\u003e producer \u003d\n        new SimpleProducerModule_StrFactory(executorProvider, componentMonitorProvider);\n    assertThat(producer.get().get()).isEqualTo(\"str\");\n    InOrder order \u003d inOrder(componentMonitor, monitor);\n    order.verify(componentMonitor).producerMonitorFor(token);\n    order.verify(monitor).methodStarting();\n    order.verify(monitor).methodFinished();\n    order.verify(monitor).succeeded(\"str\");\n    order.verifyNoMoreInteractions();\n  }\n\n  @Test\n  public void singleArgMethod() throws Exception {\n    SettableFuture\u003cInteger\u003e intFuture \u003d SettableFuture.create();\n    Producer\u003cInteger\u003e intProducer \u003d producerOfFuture(intFuture);\n    Producer\u003cString\u003e producer \u003d\n        new SimpleProducerModule_StrWithArgFactory(\n            executorProvider, componentMonitorProvider, intProducer);\n    assertThat(producer.get().isDone()).isFalse();\n    intFuture.set(42);\n    assertThat(producer.get().get()).isEqualTo(\"str with arg\");\n  }\n\n  @Test\n  public void successMonitor() throws Exception {\n    ProducerToken token \u003d ProducerToken.create(SimpleProducerModule_SettableFutureStrFactory.class);\n\n    SettableFuture\u003cString\u003e strFuture \u003d SettableFuture.create();\n    SettableFuture\u003cSettableFuture\u003cString\u003e\u003e strFutureFuture \u003d SettableFuture.create();\n    Producer\u003cSettableFuture\u003cString\u003e\u003e strFutureProducer \u003d producerOfFuture(strFutureFuture);\n    Producer\u003cString\u003e producer \u003d\n        new SimpleProducerModule_SettableFutureStrFactory(\n            executorProvider, componentMonitorProvider, strFutureProducer);\n    assertThat(producer.get().isDone()).isFalse();\n\n    InOrder order \u003d inOrder(componentMonitor, monitor);\n    order.verify(componentMonitor).producerMonitorFor(token);\n\n    strFutureFuture.set(strFuture);\n    order.verify(monitor).methodStarting();\n    order.verify(monitor).methodFinished();\n    assertThat(producer.get().isDone()).isFalse();\n\n    strFuture.set(\"monkey\");\n    assertThat(producer.get().get()).isEqualTo(\"monkey\");\n    order.verify(monitor).succeeded(\"monkey\");\n\n    order.verifyNoMoreInteractions();\n  }\n\n  @Test\n  public void failureMonitor() throws Exception {\n    ProducerToken token \u003d ProducerToken.create(SimpleProducerModule_SettableFutureStrFactory.class);\n\n    SettableFuture\u003cString\u003e strFuture \u003d SettableFuture.create();\n    SettableFuture\u003cSettableFuture\u003cString\u003e\u003e strFutureFuture \u003d SettableFuture.create();\n    Producer\u003cSettableFuture\u003cString\u003e\u003e strFutureProducer \u003d producerOfFuture(strFutureFuture);\n    Producer\u003cString\u003e producer \u003d\n        new SimpleProducerModule_SettableFutureStrFactory(\n            executorProvider, componentMonitorProvider, strFutureProducer);\n    assertThat(producer.get().isDone()).isFalse();\n\n    InOrder order \u003d inOrder(componentMonitor, monitor);\n    order.verify(componentMonitor).producerMonitorFor(token);\n\n    strFutureFuture.set(strFuture);\n    order.verify(monitor).methodStarting();\n    order.verify(monitor).methodFinished();\n    assertThat(producer.get().isDone()).isFalse();\n\n    Throwable t \u003d new RuntimeException(\"monkey\");\n    strFuture.setException(t);\n    try {\n      producer.get().get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).isSameAs(t);\n      order.verify(monitor).failed(t);\n    }\n\n    order.verifyNoMoreInteractions();\n  }\n\n  @Test\n  public void failureMonitorDueToThrowingProducer() throws Exception {\n    ProducerToken token \u003d ProducerToken.create(SimpleProducerModule_ThrowingProducerFactory.class);\n\n    Producer\u003cString\u003e producer \u003d\n        new SimpleProducerModule_ThrowingProducerFactory(\n            executorProvider, componentMonitorProvider);\n    assertThat(producer.get().isDone()).isTrue();\n\n    InOrder order \u003d inOrder(componentMonitor, monitor);\n    order.verify(componentMonitor).producerMonitorFor(token);\n\n    order.verify(monitor).methodStarting();\n    order.verify(monitor).methodFinished();\n\n    try {\n      producer.get().get();\n      fail();\n    } catch (ExecutionException e) {\n      order.verify(monitor).failed(e.getCause());\n    }\n\n    order.verifyNoMoreInteractions();\n  }\n\n  @Test(expected \u003d NullPointerException.class)\n  public void nullComponentMonitorProvider() throws Exception {\n    new SimpleProducerModule_StrFactory(executorProvider, null);\n  }\n\n  private static \u003cT\u003e Producer\u003cT\u003e producerOfFuture(final ListenableFuture\u003cT\u003e future) {\n    return new Producer\u003cT\u003e() {\n      @Override\n      public ListenableFuture\u003cT\u003e get() {\n        return future;\n      }\n    };\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\provisions\\ProvisionsTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.provisions;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport producerstest.provisions.DaggerProvisions_TestComponent;\nimport producerstest.provisions.Provisions.Output;\nimport producerstest.provisions.Provisions.TestComponent;\n\n@RunWith(JUnit4.class)\npublic final class ProvisionsTest {\n\n  @Test\n  public void provisionsOnlyAreHeldInOneProducer() throws Exception {\n    TestComponent component \u003d DaggerProvisions_TestComponent.create();\n    Output output \u003d component.output().get();\n    assertThat(output.injectedClass1).isSameAs(output.injectedClass2);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\scope\\ScopeTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.scope;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic final class ScopeTest {\n\n  @Test\n  public void scope() throws Exception {\n    SetComponent component \u003d DaggerSetComponent.create();\n    assertThat(component.set().get()).hasSize(1);\n    assertThat(component.scopedObject()).isSameAs(component.scopedObject());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\SimpleTest.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage producerstest;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class SimpleTest {\n  @Test public void testSimpleComponent() throws Exception {\n    SimpleComponent simpleComponent \u003d DaggerSimpleComponent.create();\n    assertThat(simpleComponent).isNotNull();\n    assertThat(simpleComponent.response().get().data()).isEqualTo(\"Hello, Request #5!\");\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\subcomponent\\MultiPackageSubcomponentTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.subcomponent;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport producerstest.subcomponent.MultiPackageSubcomponents.ParentComponent;\nimport producerstest.subcomponent.sub.ChildComponent;\n\n@RunWith(JUnit4.class)\npublic final class MultiPackageSubcomponentTest {\n\n  @Test\n  public void childComponent() throws Exception {\n    ParentComponent parent \u003d DaggerMultiPackageSubcomponents_ParentComponent.create();\n    ChildComponent child \u003d parent.childComponentBuilder().build();\n    assertThat(child.str().get()).isEqualTo(\"Hello, World 42\");\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\subcomponent\\ProducerModuleWithSubcomponentsTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.subcomponent;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport dagger.producers.ProducerModule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport producerstest.subcomponent.UsesProducerModuleSubcomponents.ParentIncludesProductionSubcomponentTransitively;\n\n/** Tests for {@link ProducerModule#subcomponents()}. */\n@RunWith(JUnit4.class)\npublic class ProducerModuleWithSubcomponentsTest {\n\n  @Test\n  public void subcomponentFromModules() throws Exception {\n    UsesProducerModuleSubcomponents parent \u003d DaggerUsesProducerModuleSubcomponents.create();\n    assertThat(parent.strings().get()).containsExactly(\"from parent\");\n    assertThat(parent.stringsFromChild().get()).containsExactly(\"from parent\", \"from child\");\n  }\n\n  @Test\n  public void subcomponentFromModules_transitively() throws Exception {\n    ParentIncludesProductionSubcomponentTransitively parent \u003d\n        DaggerUsesProducerModuleSubcomponents_ParentIncludesProductionSubcomponentTransitively\n            .create();\n    assertThat(parent.strings().get()).containsExactly(\"from parent\");\n    assertThat(parent.stringsFromChild().get()).containsExactly(\"from parent\", \"from child\");\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\subcomponent\\pruning\\ProductionSubcomponentOnlyRequestedBySiblingTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.subcomponent.pruning;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport dagger.producers.ProducerModule;\nimport dagger.producers.ProductionSubcomponent;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport producerstest.subcomponent.pruning.ParentDoesntUseProductionSubcomponent.ChildA;\nimport producerstest.subcomponent.pruning.ParentDoesntUseProductionSubcomponent.ChildB;\n\n/**\n * Tests for {@link ProductionSubcomponent}s which are included with {@link\n * ProducerModule#subcomponents()} but not used directly within the component which adds them.\n *\n * \u003cp\u003eThis tests to make sure that while resolving one subcomponent (A), another subcomponent (B)\n * can be requested if they have a shared ancestor component. If that shared ancestor did not\n * resolve B directly via any of its entry points, B will still be generated since it is requested\n * by a descendant.\n */\n@RunWith(JUnit4.class)\npublic class ProductionSubcomponentOnlyRequestedBySiblingTest {\n  @Test\n  public void subcomponentAddedInParent_onlyUsedInSibling() throws Exception {\n    ParentDoesntUseProductionSubcomponent parent \u003d\n        DaggerParentDoesntUseProductionSubcomponent.create();\n    ChildB childB \u003d parent.childBBuilder().build();\n    assertThat(childB.componentHierarchy().get())\n        .containsExactly(ParentDoesntUseProductionSubcomponent.class, ChildB.class);\n    assertThat(childB.componentHierarchyFromChildA().get())\n        .containsExactly(ParentDoesntUseProductionSubcomponent.class, ChildA.class);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\producers-functional-tests\\src\\test\\java\\producerstest\\subcomponent\\SubcomponentWithBoundExecutorTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage producerstest.subcomponent;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport producerstest.subcomponent.SubcomponentsWithBoundExecutor.ChildComponent;\nimport producerstest.subcomponent.SubcomponentsWithBoundExecutor.ExecutorModule;\nimport producerstest.subcomponent.SubcomponentsWithBoundExecutor.GrandchildComponent;\nimport producerstest.subcomponent.SubcomponentsWithBoundExecutor.GrandchildComponentWithoutBuilder;\nimport producerstest.subcomponent.SubcomponentsWithBoundExecutor.ParentComponent;\nimport producerstest.subcomponent.SubcomponentsWithBoundExecutor.ParentProductionComponent;\n\n@RunWith(JUnit4.class)\npublic final class SubcomponentWithBoundExecutorTest {\n  private ParentComponent parentComponent;\n  private ParentProductionComponent parentProductionComponent;\n  private final AtomicInteger executorConstructionCount \u003d new AtomicInteger();\n  private final AtomicInteger executionCount \u003d new AtomicInteger();\n\n  @Before\n  public void setUp() {\n    parentComponent \u003d\n        DaggerSubcomponentsWithBoundExecutor_ParentComponent.builder()\n            .executorModule(new ExecutorModule(executorConstructionCount, executionCount))\n            .build();\n    parentProductionComponent \u003d\n        DaggerSubcomponentsWithBoundExecutor_ParentProductionComponent.builder()\n            .executorModule(new ExecutorModule(executorConstructionCount, executionCount))\n            .build();\n  }\n\n  @Test\n  public void topLevelComponent_child() throws Exception {\n    ChildComponent child \u003d parentComponent.newChildComponentBuilder().build();\n    assertThat(child.fromChild().get()).isEqualTo(\"child:parent\");\n    assertThat(executorConstructionCount.get()).isEqualTo(1);\n    assertThat(executionCount.get()).isEqualTo(1);\n  }\n\n  @Test\n  public void topLevelComponent_injectsChildBuilder() throws Exception {\n    ChildComponent child \u003d parentComponent.injectsChildBuilder().childBuilder().build();\n    assertThat(child.fromChild().get()).isEqualTo(\"child:parent\");\n    assertThat(executorConstructionCount.get()).isEqualTo(1);\n    assertThat(executionCount.get()).isEqualTo(1);\n  }\n\n  @Test\n  public void topLevelComponent_grandchild() throws Exception {\n    ChildComponent child \u003d parentComponent.newChildComponentBuilder().build();\n    GrandchildComponent grandchild \u003d child.newGrandchildComponentBuilder().build();\n    assertThat(grandchild.fromGrandchild().get()).isEqualTo(\"grandchild:child:parent\");\n    assertThat(executorConstructionCount.get()).isEqualTo(1);\n    assertThat(executionCount.get()).isEqualTo(2);\n  }\n\n  @Test\n  public void topLevelComponent_grandchildWithoutBuilder() throws Exception {\n    ChildComponent child \u003d parentComponent.newChildComponentBuilder().build();\n    GrandchildComponentWithoutBuilder grandchild \u003d child.newGrandchildComponent();\n    assertThat(grandchild.fromGrandchild().get()).isEqualTo(\"grandchild:child:parent\");\n    assertThat(executorConstructionCount.get()).isEqualTo(1);\n    assertThat(executionCount.get()).isEqualTo(2);\n  }\n\n  @Test\n  public void topLevelProductionComponent_child() throws Exception {\n    ChildComponent child \u003d parentProductionComponent.newChildComponentBuilder().build();\n    assertThat(child.fromChild().get()).isEqualTo(\"child:parentproduction\");\n    assertThat(executorConstructionCount.get()).isEqualTo(1);\n    assertThat(executionCount.get()).isEqualTo(2);\n  }\n\n  @Test\n  public void topLevelProductionComponent_grandchild() throws Exception {\n    ChildComponent child \u003d parentProductionComponent.newChildComponentBuilder().build();\n    GrandchildComponent grandchild \u003d child.newGrandchildComponentBuilder().build();\n    assertThat(grandchild.fromGrandchild().get()).isEqualTo(\"grandchild:child:parentproduction\");\n    assertThat(executorConstructionCount.get()).isEqualTo(1);\n    assertThat(executionCount.get()).isEqualTo(3);\n  }\n\n  @Test\n  public void topLevelProductionComponent_grandchildWithoutBuilder() throws Exception {\n    ChildComponent child \u003d parentProductionComponent.newChildComponentBuilder().build();\n    GrandchildComponentWithoutBuilder grandchild \u003d child.newGrandchildComponent();\n    assertThat(grandchild.fromGrandchild().get()).isEqualTo(\"grandchild:child:parentproduction\");\n    assertThat(executorConstructionCount.get()).isEqualTo(1);\n    assertThat(executionCount.get()).isEqualTo(3);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\tck\\src\\main\\java\\test\\tck\\CarModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.tck;\n\nimport dagger.Binds;\nimport dagger.Module;\nimport org.atinject.tck.auto.Car;\nimport org.atinject.tck.auto.Convertible;\n\n@Module\nabstract class CarModule {\n  @Binds\n  abstract Car provideConvertible(Convertible convertible);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\tck\\src\\main\\java\\test\\tck\\CarShop.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.tck;\n\nimport dagger.Component;\nimport javax.inject.Singleton;\nimport org.atinject.tck.auto.Car;\n\n@Singleton\n@Component(\n  modules \u003d {\n    CarModule.class,\n    TireModule.class,\n    SeatModule.class,\n    EngineModule.class,\n    FuelTankModule.class\n  }\n)\npublic interface CarShop {\n  @SuppressWarnings(\"dependency-cycle\")\n  Car make();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\tck\\src\\main\\java\\test\\tck\\EngineModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.tck;\n\nimport dagger.MembersInjector;\nimport dagger.Module;\nimport dagger.Provides;\nimport org.atinject.tck.auto.Engine;\nimport org.atinject.tck.auto.V8Engine;\n\n@Module\npublic class EngineModule {\n  @Provides\n  static Engine provideEngine(MembersInjector\u003cV8Engine\u003e injector) {\n    // This is provided because V8Engine has no @Inject constructor and Dagger requires an @Inject\n    // constructor, however this is a TCK supplied class that we prefer to leave unmodified.\n    V8Engine engine \u003d new V8Engine();\n    injector.injectMembers(engine);\n    return engine;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\tck\\src\\main\\java\\test\\tck\\FuelTankModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.tck;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport org.atinject.tck.auto.FuelTank;\n\n@Module\nclass FuelTankModule {\n  @Provides\n  static FuelTank provideFuelTank() {\n    return new FuelTank();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\tck\\src\\main\\java\\test\\tck\\SeatModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.tck;\n\nimport dagger.Binds;\nimport dagger.Module;\nimport org.atinject.tck.auto.Drivers;\nimport org.atinject.tck.auto.DriversSeat;\nimport org.atinject.tck.auto.Seat;\n\n@Module\nabstract class SeatModule {\n  @Binds\n  @Drivers\n  abstract Seat provideSeat(DriversSeat seat);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\tck\\src\\main\\java\\test\\tck\\TireModule.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.tck;\n\nimport dagger.Binds;\nimport dagger.Module;\nimport javax.inject.Named;\nimport org.atinject.tck.auto.Tire;\nimport org.atinject.tck.auto.accessories.SpareTire;\n\n@Module\nabstract class TireModule {\n  @Binds\n  @Named(\"spare\")\n  abstract Tire provideTire(SpareTire sparetire);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\it\\tck\\src\\test\\java\\test\\tck\\TckTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage test.tck;\n\nimport junit.framework.Test;\nimport org.atinject.tck.Tck;\nimport org.atinject.tck.auto.Car;\nimport org.atinject.tck.auto.Convertible;\n\n/** \n * Test suite to execute the JSR-330 TCK in JUnit.\n */\npublic class TckTest {\n  public static Test suite() {\n    CarShop carShopComponent \u003d DaggerCarShop.create();\n    Car car \u003d carShopComponent.make();\n    Convertible.localConvertible.set((Convertible) car);\n    return Tck.testsFor(car, false, false);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\AbstractComponentWriter.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.CaseFormat.LOWER_CAMEL;\nimport static com.google.common.base.CaseFormat.UPPER_CAMEL;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Verify.verify;\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static com.squareup.javapoet.MethodSpec.constructorBuilder;\nimport static com.squareup.javapoet.MethodSpec.methodBuilder;\nimport static com.squareup.javapoet.TypeSpec.classBuilder;\nimport static dagger.internal.codegen.AbstractComponentWriter.InitializationState.DELEGATED;\nimport static dagger.internal.codegen.AbstractComponentWriter.InitializationState.INITIALIZED;\nimport static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;\nimport static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;\nimport static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;\nimport static dagger.internal.codegen.BindingKey.contribution;\nimport static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;\nimport static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;\nimport static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;\nimport static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;\nimport static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD;\nimport static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;\nimport static dagger.internal.codegen.MapKeys.getMapKeyExpression;\nimport static dagger.internal.codegen.MemberSelect.emptyFrameworkMapFactory;\nimport static dagger.internal.codegen.MemberSelect.emptySetProvider;\nimport static dagger.internal.codegen.MemberSelect.localField;\nimport static dagger.internal.codegen.MemberSelect.noOpMembersInjector;\nimport static dagger.internal.codegen.MemberSelect.staticMethod;\nimport static dagger.internal.codegen.MembersInjectionBinding.Strategy.NO_OP;\nimport static dagger.internal.codegen.Scope.reusableScope;\nimport static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;\nimport static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;\nimport static dagger.internal.codegen.TypeNames.DELEGATE_FACTORY;\nimport static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;\nimport static dagger.internal.codegen.TypeNames.FACTORY;\nimport static dagger.internal.codegen.TypeNames.ILLEGAL_STATE_EXCEPTION;\nimport static dagger.internal.codegen.TypeNames.INSTANCE_FACTORY;\nimport static dagger.internal.codegen.TypeNames.LISTENABLE_FUTURE;\nimport static dagger.internal.codegen.TypeNames.MAP_FACTORY;\nimport static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCED_PRODUCER;\nimport static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;\nimport static dagger.internal.codegen.TypeNames.MAP_PRODUCER;\nimport static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;\nimport static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;\nimport static dagger.internal.codegen.TypeNames.PRODUCER;\nimport static dagger.internal.codegen.TypeNames.PRODUCERS;\nimport static dagger.internal.codegen.TypeNames.SET_FACTORY;\nimport static dagger.internal.codegen.TypeNames.SET_OF_PRODUCED_PRODUCER;\nimport static dagger.internal.codegen.TypeNames.SET_PRODUCER;\nimport static dagger.internal.codegen.TypeNames.SINGLE_CHECK;\nimport static dagger.internal.codegen.TypeNames.STRING;\nimport static dagger.internal.codegen.TypeNames.UNSUPPORTED_OPERATION_EXCEPTION;\nimport static dagger.internal.codegen.TypeSpecs.addSupertype;\nimport static dagger.internal.codegen.Util.componentCanMakeNewInstances;\nimport static dagger.internal.codegen.Util.requiresAPassedInstance;\nimport static javax.lang.model.element.Modifier.ABSTRACT;\nimport static javax.lang.model.element.Modifier.FINAL;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.element.Modifier.PUBLIC;\nimport static javax.lang.model.type.TypeKind.DECLARED;\nimport static javax.lang.model.type.TypeKind.VOID;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport com.squareup.javapoet.FieldSpec;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.ParameterSpec;\nimport com.squareup.javapoet.TypeName;\nimport com.squareup.javapoet.TypeSpec;\nimport com.squareup.javapoet.TypeVariableName;\nimport dagger.internal.DelegateFactory;\nimport dagger.internal.MapFactory;\nimport dagger.internal.MapProviderFactory;\nimport dagger.internal.Preconditions;\nimport dagger.internal.SetFactory;\nimport dagger.internal.codegen.ComponentDescriptor.BuilderSpec;\nimport dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport dagger.producers.internal.MapOfProducerProducer;\nimport dagger.producers.internal.MapProducer;\nimport dagger.producers.internal.SetOfProducedProducer;\nimport dagger.producers.internal.SetProducer;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.inject.Provider;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.Name;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.TypeKind;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\nimport javax.tools.Diagnostic;\n\n/**\n * Creates the implementation class for a component or subcomponent.\n */\nabstract class AbstractComponentWriter {\n  private static final String NOOP_BUILDER_METHOD_JAVADOC \u003d\n      \"This module is declared, but an instance is not used in the component. This method is a \"\n          + \"no-op. For more, see https://google.github.io/dagger/unused-modules.\\n\";\n\n  // TODO(dpb): Make all these fields private after refactoring is complete.\n  protected final Elements elements;\n  protected final Types types;\n  protected final Key.Factory keyFactory;\n  protected final CompilerOptions compilerOptions;\n  protected final ClassName name;\n  protected final BindingGraph graph;\n  protected final ImmutableMap\u003cComponentDescriptor, String\u003e subcomponentNames;\n  private final Map\u003cBindingKey, InitializationState\u003e initializationStates \u003d new HashMap\u003c\u003e();\n  protected final TypeSpec.Builder component;\n  private final UniqueNameSet componentFieldNames \u003d new UniqueNameSet();\n  private final Map\u003cBindingKey, MemberSelect\u003e memberSelects \u003d new HashMap\u003c\u003e();\n  private final Map\u003cBindingKey, MemberSelect\u003e producerFromProviderMemberSelects \u003d new HashMap\u003c\u003e();\n  private final Map\u003cBindingKey, RequestFulfillment\u003e requestFulfillments \u003d Maps.newLinkedHashMap();\n  protected final MethodSpec.Builder constructor \u003d constructorBuilder().addModifiers(PRIVATE);\n  protected Optional\u003cClassName\u003e builderName \u003d Optional.absent();\n  private final OptionalFactories optionalFactories;\n  private boolean done;\n\n  /**\n   * For each component requirement, the builder field. This map is empty for subcomponents that do\n   * not use a builder.\n   */\n  private ImmutableMap\u003cTypeElement, FieldSpec\u003e builderFields \u003d ImmutableMap.of();\n\n  /**\n   * For each component requirement, the member select for the component field that holds it.\n   *\n   * \u003cp\u003eFields are written for all requirements for subcomponents that do not use a builder, and for\n   * any requirement that is reused from a subcomponent of this component.\n   */\n  protected final Map\u003cTypeElement, MemberSelect\u003e componentContributionFields \u003d Maps.newHashMap();\n\n  AbstractComponentWriter(\n      Types types,\n      Elements elements,\n      Key.Factory keyFactory,\n      CompilerOptions compilerOptions,\n      ClassName name,\n      BindingGraph graph,\n      ImmutableMap\u003cComponentDescriptor, String\u003e subcomponentNames,\n      OptionalFactories optionalFactories) {\n    this.types \u003d types;\n    this.elements \u003d elements;\n    this.keyFactory \u003d keyFactory;\n    this.compilerOptions \u003d compilerOptions;\n    this.component \u003d classBuilder(name);\n    this.name \u003d name;\n    this.graph \u003d graph;\n    this.subcomponentNames \u003d subcomponentNames;\n    this.optionalFactories \u003d optionalFactories;\n  }\n\n  protected AbstractComponentWriter(\n      AbstractComponentWriter parent, ClassName name, BindingGraph graph) {\n    this(\n        parent.types,\n        parent.elements,\n        parent.keyFactory,\n        parent.compilerOptions,\n        name,\n        graph,\n        parent.subcomponentNames,\n        parent.optionalFactories);\n  }\n\n  protected final TypeElement componentDefinitionType() {\n    return graph.componentDescriptor().componentDefinitionType();\n  }\n\n  protected final ClassName componentDefinitionTypeName() {\n    return ClassName.get(componentDefinitionType());\n  }\n\n  /**\n   * Returns an expression that evaluates to an instance of the contribution, looking for either a\n   * builder field or a component field.\n   */\n  private CodeBlock getComponentContributionExpression(TypeElement contributionType) {\n    if (builderFields.containsKey(contributionType)) {\n      return CodeBlock.of(\"builder.$N\", builderFields.get(contributionType));\n    } else {\n      Optional\u003cCodeBlock\u003e codeBlock \u003d\n          getOrCreateComponentContributionFieldExpression(contributionType);\n      checkState(codeBlock.isPresent(), \"no builder or component field for %s\", contributionType);\n      return codeBlock.get();\n    }\n  }\n\n  /**\n   * Returns an expression for a component contribution field. Adds a field the first time one is\n   * requested for a contribution type if this component\u0027s builder has a field for it.\n   */\n  protected Optional\u003cCodeBlock\u003e getOrCreateComponentContributionFieldExpression(\n      TypeElement contributionType) {\n    MemberSelect fieldSelect \u003d componentContributionFields.get(contributionType);\n    if (fieldSelect \u003d\u003d null) {\n      if (!builderFields.containsKey(contributionType)) {\n        return Optional.absent();\n      }\n      FieldSpec componentField \u003d\n          componentField(ClassName.get(contributionType), simpleVariableName(contributionType))\n              .addModifiers(PRIVATE, FINAL)\n              .build();\n      component.addField(componentField);\n      constructor.addCode(\n          \"this.$N \u003d builder.$N;\", componentField, builderFields.get(contributionType));\n      fieldSelect \u003d localField(name, componentField.name);\n      componentContributionFields.put(contributionType, fieldSelect);\n    }\n    return Optional.of(fieldSelect.getExpressionFor(name));\n  }\n\n  /**\n   * Creates a {@link FieldSpec.Builder} with a unique name based off of {@code name}.\n   */\n  protected final FieldSpec.Builder componentField(TypeName type, String name) {\n    return FieldSpec.builder(type, componentFieldNames.getUniqueName(name));\n  }\n\n  private CodeBlock getMemberSelectExpression(BindingKey key) {\n    return getMemberSelect(key).getExpressionFor(name);\n  }\n\n  protected MemberSelect getMemberSelect(BindingKey key) {\n    return memberSelects.get(key);\n  }\n\n  /**\n   * Returns the initialization state of the factory field for a binding key in this component.\n   */\n  protected InitializationState getInitializationState(BindingKey bindingKey) {\n    return initializationStates.containsKey(bindingKey)\n        ? initializationStates.get(bindingKey)\n        : UNINITIALIZED;\n  }\n\n  private void setInitializationState(BindingKey bindingKey, InitializationState state) {\n    initializationStates.put(bindingKey, state);\n  }\n\n  /**\n   * Constructs a {@link TypeSpec.Builder} that models the {@link BindingGraph} for this component.\n   * This is only intended to be called once (and will throw on successive invocations). If the\n   * component must be regenerated, use a new instance.\n   */\n  final TypeSpec.Builder write() {\n    checkState(!done, \"ComponentWriter has already been generated.\");\n    decorateComponent();\n    addBuilder();\n    addFactoryMethods();\n    addFrameworkFields();\n    initializeFrameworkTypes();\n    implementInterfaceMethods();\n    addSubcomponents();\n    component.addMethod(constructor.build());\n    if (graph.componentDescriptor().kind().isTopLevel()) {\n      optionalFactories.addMembers(component);\n    }\n    done \u003d true;\n    return component;\n  }\n\n  /**\n   * Adds Javadoc, modifiers, supertypes, and annotations to the component implementation class\n   * declaration.\n   */\n  protected abstract void decorateComponent();\n\n  /**\n   * Adds a builder type.\n   */\n  protected void addBuilder() {\n    builderName \u003d Optional.of(builderName());\n    TypeSpec.Builder componentBuilder \u003d\n        createBuilder(builderName.get().simpleName()).addModifiers(FINAL);\n\n    Optional\u003cBuilderSpec\u003e builderSpec \u003d graph.componentDescriptor().builderSpec();\n    if (builderSpec.isPresent()) {\n      componentBuilder.addModifiers(PRIVATE);\n      addSupertype(componentBuilder, builderSpec.get().builderDefinitionType());\n    } else {\n      componentBuilder\n          .addModifiers(PUBLIC)\n          .addMethod(constructorBuilder().addModifiers(PRIVATE).build());\n    }\n\n    builderFields \u003d addBuilderFields(componentBuilder);\n    addBuildMethod(componentBuilder, builderSpec);\n    addBuilderMethods(componentBuilder, builderSpec);\n    addBuilderClass(componentBuilder.build());\n\n    constructor.addParameter(builderName.get(), \"builder\");\n    constructor.addStatement(\"assert builder !\u003d null\");\n  }\n\n  /**\n   * Adds {@code builder} as a nested builder class. Root components and subcomponents will nest\n   * this in different classes.\n   */\n  protected abstract void addBuilderClass(TypeSpec builder);\n\n  /**\n   * Adds fields for each of the {@linkplain BindingGraph#componentRequirements component\n   * requirements}. Regardless of builder spec, there is always one field per requirement.\n   */\n  private ImmutableMap\u003cTypeElement, FieldSpec\u003e addBuilderFields(TypeSpec.Builder componentBuilder) {\n    UniqueNameSet builderFieldNames \u003d new UniqueNameSet();\n    ImmutableMap.Builder\u003cTypeElement, FieldSpec\u003e builderFields \u003d ImmutableMap.builder();\n    for (TypeElement contributionElement : graph.componentRequirements()) {\n      String contributionName \u003d\n          builderFieldNames.getUniqueName(simpleVariableName(contributionElement));\n      FieldSpec builderField \u003d\n          FieldSpec.builder(ClassName.get(contributionElement), contributionName, PRIVATE).build();\n      componentBuilder.addField(builderField);\n      builderFields.put(contributionElement, builderField);\n    }\n    return builderFields.build();\n  }\n\n  /** Adds the build method to the builder. */\n  private void addBuildMethod(\n      TypeSpec.Builder componentBuilder, Optional\u003cBuilderSpec\u003e builderSpec) {\n    MethodSpec.Builder buildMethod;\n    if (builderSpec.isPresent()) {\n      ExecutableElement specBuildMethod \u003d builderSpec.get().buildMethod();\n      // Note: we don\u0027t use the specBuildMethod.getReturnType() as the return type\n      // because it might be a type variable.  We make use of covariant returns to allow\n      // us to return the component type, which will always be valid.\n      buildMethod \u003d\n          methodBuilder(specBuildMethod.getSimpleName().toString()).addAnnotation(Override.class);\n    } else {\n      buildMethod \u003d methodBuilder(\"build\");\n    }\n    buildMethod.returns(componentDefinitionTypeName()).addModifiers(PUBLIC);\n\n    for (Map.Entry\u003cTypeElement, FieldSpec\u003e builderFieldEntry : builderFields.entrySet()) {\n      FieldSpec builderField \u003d builderFieldEntry.getValue();\n      if (componentCanMakeNewInstances(builderFieldEntry.getKey())) {\n        buildMethod.addCode(\n            \"if ($1N \u003d\u003d null) { this.$1N \u003d new $2T(); }\", builderField, builderField.type);\n      } else if (requiresAPassedInstance(elements, builderFieldEntry.getKey())) {\n        buildMethod.addCode(\n            \"if ($N \u003d\u003d null) { throw new $T($T.class.getCanonicalName() + $S); }\",\n            builderField,\n            ILLEGAL_STATE_EXCEPTION,\n            builderField.type,\n            \" must be set\");\n      }\n    }\n    buildMethod.addStatement(\"return new $T(this)\", name);\n    componentBuilder.addMethod(buildMethod.build());\n  }\n\n  /**\n   * Adds the methods that set each of parameters on the builder. If the {@link BuilderSpec} is\n   * present, it will tailor the methods to match the spec.\n   */\n  private void addBuilderMethods(\n      TypeSpec.Builder componentBuilder, Optional\u003cBuilderSpec\u003e builderSpec) {\n    ImmutableSet\u003cTypeElement\u003e componentRequirements \u003d graph.componentRequirements();\n    if (builderSpec.isPresent()) {\n      UniqueNameSet parameterNames \u003d new UniqueNameSet();\n      for (Map.Entry\u003cTypeElement, ExecutableElement\u003e builderMethodEntry :\n          builderSpec.get().methodMap().entrySet()) {\n        TypeElement builderMethodType \u003d builderMethodEntry.getKey();\n        ExecutableElement specMethod \u003d builderMethodEntry.getValue();\n        MethodSpec.Builder builderMethod \u003d addBuilderMethodFromSpec(specMethod);\n        String parameterName \u003d\n            parameterNames.getUniqueName(\n                Iterables.getOnlyElement(specMethod.getParameters()).getSimpleName());\n        builderMethod.addParameter(ClassName.get(builderMethodType), parameterName);\n        if (componentRequirements.contains(builderMethodType)) {\n          // required type\n          builderMethod.addStatement(\n              \"this.$N \u003d $T.checkNotNull($L)\",\n              builderFields.get(builderMethodType),\n              Preconditions.class,\n              parameterName);\n          addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);\n        } else if (graph.ownedModuleTypes().contains(builderMethodType)) {\n          // owned, but not required\n          builderMethod.addJavadoc(NOOP_BUILDER_METHOD_JAVADOC);\n          addBuilderMethodReturnStatementForSpec(specMethod, builderMethod);\n        } else {\n          // neither owned nor required, so it must be an inherited module\n          builderMethod.addStatement(\n              \"throw new $T($T.format($S, $T.class.getCanonicalName()))\",\n              UNSUPPORTED_OPERATION_EXCEPTION,\n              STRING,\n              \"%s cannot be set because it is inherited from the enclosing component\",\n              ClassName.get(builderMethodType));\n        }\n        componentBuilder.addMethod(builderMethod.build());\n      }\n    } else {\n      for (TypeElement componentRequirement : graph.availableDependencies()) {\n        String componentRequirementName \u003d simpleVariableName(componentRequirement);\n        MethodSpec.Builder builderMethod \u003d\n            methodBuilder(componentRequirementName)\n                .returns(builderName.get())\n                .addModifiers(PUBLIC)\n                .addParameter(ClassName.get(componentRequirement), componentRequirementName);\n        if (componentRequirements.contains(componentRequirement)) {\n          builderMethod.addStatement(\n              \"this.$N \u003d $T.checkNotNull($L)\",\n              builderFields.get(componentRequirement),\n              Preconditions.class,\n              componentRequirementName);\n        } else {\n          builderMethod.addStatement(\"$T.checkNotNull($L)\",\n              Preconditions.class,\n              componentRequirementName);\n          builderMethod.addJavadoc(\"@deprecated \" + NOOP_BUILDER_METHOD_JAVADOC);\n          builderMethod.addAnnotation(Deprecated.class);\n        }\n        builderMethod.addStatement(\"return this\");\n        componentBuilder.addMethod(builderMethod.build());\n      }\n    }\n  }\n\n  private void addBuilderMethodReturnStatementForSpec(\n      ExecutableElement specMethod, MethodSpec.Builder builderMethod) {\n    if (!specMethod.getReturnType().getKind().equals(VOID)) {\n      builderMethod.addStatement(\"return this\");\n    }\n  }\n\n  private MethodSpec.Builder addBuilderMethodFromSpec(ExecutableElement method) {\n    TypeMirror returnType \u003d method.getReturnType();\n    MethodSpec.Builder builderMethod \u003d\n        methodBuilder(method.getSimpleName().toString())\n            .addAnnotation(Override.class)\n            .addModifiers(Sets.difference(method.getModifiers(), ImmutableSet.of(ABSTRACT)));\n    // If the return type is void, we add a method with the void return type.\n    // Otherwise we use the generated builder name and take advantage of covariant returns\n    // (so that we don\u0027t have to worry about setter methods that return type variables).\n    if (!returnType.getKind().equals(TypeKind.VOID)) {\n      builderMethod.returns(builderName.get());\n    }\n    return builderMethod;\n  }\n\n  /**\n   * Creates the builder class.\n   */\n  protected abstract TypeSpec.Builder createBuilder(String builderName);\n\n  protected abstract ClassName builderName();\n\n  /**\n   * Adds component factory methods.\n   */\n  protected abstract void addFactoryMethods();\n\n  private boolean graphHasContributionBinding(Key key) {\n    return graph.resolvedBindings().containsKey(contribution(key));\n  }\n\n  private void addFrameworkFields() {\n    graph.resolvedBindings().values().forEach(this::addField);\n  }\n\n  private void addField(ResolvedBindings resolvedBindings) {\n    BindingKey bindingKey \u003d resolvedBindings.bindingKey();\n\n    // If the binding can be satisfied with a static method call without dependencies or state,\n    // no field is necessary.\n    Optional\u003cMemberSelect\u003e staticMemberSelect \u003d staticMemberSelect(resolvedBindings);\n    if (staticMemberSelect.isPresent()) {\n      memberSelects.put(bindingKey, staticMemberSelect.get());\n      return;\n    }\n\n    // No field needed if there are no owned bindings.\n    if (resolvedBindings.ownedBindings().isEmpty()) {\n      return;\n    }\n\n    // TODO(gak): get rid of the field for unscoped delegated bindings\n\n    FieldSpec frameworkField \u003d addFrameworkField(resolvedBindings, Optional.\u003cClassName\u003eabsent());\n    memberSelects.put(bindingKey, localField(name, frameworkField.name));\n  }\n\n  /**\n   * Adds a field representing the resolved bindings, optionally forcing it to use a particular\n   * framework class (instead of the class the resolved bindings would typically use).\n   */\n  private FieldSpec addFrameworkField(\n      ResolvedBindings resolvedBindings, Optional\u003cClassName\u003e frameworkClass) {\n    boolean useRawType \u003d useRawType(resolvedBindings);\n\n    FrameworkField contributionBindingField \u003d\n        FrameworkField.forResolvedBindings(resolvedBindings, frameworkClass);\n    FieldSpec.Builder contributionField \u003d\n        componentField(\n            useRawType\n                ? contributionBindingField.type().rawType\n                : contributionBindingField.type(),\n            contributionBindingField.name());\n    contributionField.addModifiers(PRIVATE);\n    if (useRawType) {\n      contributionField.addAnnotation(AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES);\n    }\n\n    FieldSpec field \u003d contributionField.build();\n    component.addField(field);\n    return field;\n  }\n\n  private boolean useRawType(ResolvedBindings resolvedBindings) {\n    return useRawType(resolvedBindings.bindingPackage());\n  }\n\n  private boolean useRawType(Binding binding) {\n    return useRawType(binding.bindingPackage());\n  }\n\n  private boolean useRawType(Optional\u003cString\u003e bindingPackage) {\n    return bindingPackage.isPresent() \u0026\u0026 !bindingPackage.get().equals(name.packageName());\n  }\n\n  /**\n   * If {@code resolvedBindings} is an unscoped provision binding with no factory arguments or a\n   * no-op members injection binding, then we don\u0027t need a field to hold its factory. In that case,\n   * this method returns the static member select that returns the factory or no-op members\n   * injector.\n   */\n  private Optional\u003cMemberSelect\u003e staticMemberSelect(ResolvedBindings resolvedBindings) {\n    BindingKey bindingKey \u003d resolvedBindings.bindingKey();\n    switch (bindingKey.kind()) {\n      case CONTRIBUTION:\n        ContributionBinding contributionBinding \u003d resolvedBindings.contributionBinding();\n        if (contributionBinding.factoryCreationStrategy().equals(ENUM_INSTANCE)\n            \u0026\u0026 !contributionBinding.scope().isPresent()) {\n          switch (contributionBinding.bindingKind()) {\n            case SYNTHETIC_MULTIBOUND_MAP:\n              BindingType bindingType \u003d contributionBinding.bindingType();\n              MapType mapType \u003d MapType.from(contributionBinding.key());\n              return Optional.of(\n                  emptyFrameworkMapFactory(\n                      frameworkMapFactoryClassName(bindingType),\n                      mapType.keyType(),\n                      mapType.unwrappedValueType(bindingType.frameworkClass())));\n\n            case SYNTHETIC_MULTIBOUND_SET:\n              return Optional.of(\n                  emptySetFactoryStaticMemberSelect(\n                      contributionBinding.bindingType(), contributionBinding.key()));\n\n            case INJECTION:\n            case PROVISION:\n              if (bindingKey.key().type().getKind().equals(DECLARED)) {\n                ImmutableList\u003cTypeVariableName\u003e typeVariables \u003d\n                    SourceFiles.bindingTypeElementTypeVariableNames(contributionBinding);\n                if (!typeVariables.isEmpty()) {\n                  List\u003c? extends TypeMirror\u003e typeArguments \u003d\n                      ((DeclaredType) bindingKey.key().type()).getTypeArguments();\n                  return Optional.of(MemberSelect.parameterizedFactoryCreateMethod(\n                      generatedClassNameForBinding(contributionBinding), typeArguments));\n                }\n              }\n              // fall through\n\n            default:\n              return Optional.of(\n                  staticMethod(\n                      generatedClassNameForBinding(contributionBinding), CodeBlock.of(\"create()\")));\n          }\n        }\n        break;\n\n      case MEMBERS_INJECTION:\n        Optional\u003cMembersInjectionBinding\u003e membersInjectionBinding \u003d\n            resolvedBindings.membersInjectionBinding();\n        if (membersInjectionBinding.isPresent()\n            \u0026\u0026 membersInjectionBinding.get().injectionStrategy().equals(NO_OP)) {\n          return Optional.of(noOpMembersInjector(membersInjectionBinding.get().key().type()));\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n    }\n    return Optional.absent();\n  }\n\n  /**\n   * A static member select for an empty set factory. Calls {@link SetFactory#empty()}, {@link\n   * SetProducer#empty()}, or {@link SetOfProducedProducer#empty()}, depending on the set\n   * bindings.\n   */\n  private static MemberSelect emptySetFactoryStaticMemberSelect(BindingType bindingType, Key key) {\n    return emptySetProvider(setFactoryClassName(bindingType, key), SetType.from(key));\n  }\n\n  /**\n   * The {@link Set} factory class name appropriate for set bindings.\n   *\n   * \u003cul\u003e\n   * \u003cli\u003e{@link SetFactory} for provision bindings.\n   * \u003cli\u003e{@link SetProducer} for production bindings for {@code Set\u003cT\u003e}.\n   * \u003cli\u003e{@link SetOfProducedProducer} for production bindings for {@code Set\u003cProduced\u003cT\u003e\u003e}.\n   * \u003c/ul\u003e\n   */\n  private static ClassName setFactoryClassName(BindingType bindingType, Key key) {\n    if (bindingType.equals(BindingType.PROVISION)) {\n      return SET_FACTORY;\n    } else {\n      SetType setType \u003d SetType.from(key);\n      return setType.elementsAreTypeOf(Produced.class) ? SET_OF_PRODUCED_PRODUCER : SET_PRODUCER;\n    }\n  }\n\n  /**\n   * The {@link Map}-of-value factory class name appropriate for map bindings.\n   *\n   * \u003cul\u003e\n   * \u003cli\u003e{@link MapFactory} for provision bindings.\n   * \u003cli\u003e{@link MapProducer} for production bindings.\n   * \u003c/ul\u003e\n   */\n  private static ClassName mapFactoryClassName(ContributionBinding binding) {\n    switch (binding.bindingType()) {\n      case PRODUCTION:\n        return MapType.from(binding.key()).valuesAreTypeOf(Produced.class)\n            ? MAP_OF_PRODUCED_PRODUCER : MAP_PRODUCER;\n\n      case PROVISION:\n      case MEMBERS_INJECTION:\n        return MAP_FACTORY;\n\n      default:\n        throw new AssertionError(binding.toString());\n    }\n  }\n\n  /**\n   * The {@link Map}-of-framework factory class name appropriate for map bindings.\n   *\n   * \u003cul\u003e\n   * \u003cli\u003e{@link MapProviderFactory} for provision bindings.\n   * \u003cli\u003e{@link MapOfProducerProducer} for production bindings.\n   * \u003c/ul\u003e\n   */\n  private static ClassName frameworkMapFactoryClassName(BindingType bindingType) {\n    return bindingType.equals(BindingType.PRODUCTION)\n        ? MAP_OF_PRODUCER_PRODUCER : MAP_PROVIDER_FACTORY;\n  }\n\n  // TODO(gak): extract this into a proper factory class\n  private RequestFulfillment createRequestFulfillment(BindingKey bindingKey) {\n    /* TODO(gak): it is super convoluted that we create the member selects separately and then\n     * look them up again this way. Now that we have RequestFulfillment, the next step is to\n     * create it and the MemberSelect and the field on demand rather than in a first pass. */\n    MemberSelect memberSelect \u003d getMemberSelect(bindingKey);\n    ResolvedBindings resolvedBindings \u003d graph.resolvedBindings().get(bindingKey);\n    switch (resolvedBindings.bindingType()) {\n      case MEMBERS_INJECTION:\n        return new MembersInjectorRequestFulfillment(bindingKey, memberSelect);\n      case PRODUCTION:\n        return new ProducerFieldRequestFulfillment(bindingKey, memberSelect);\n      case PROVISION:\n        ProvisionBinding provisionBinding \u003d\n            (ProvisionBinding) resolvedBindings.contributionBinding();\n        ProviderFieldRequestFulfillment providerFieldRequestFulfillment \u003d\n            new ProviderFieldRequestFulfillment(bindingKey, memberSelect);\n        if (provisionBinding.implicitDependencies().isEmpty()\n            \u0026\u0026 !provisionBinding.scope().isPresent()\n            \u0026\u0026 !provisionBinding.requiresModuleInstance()\n            \u0026\u0026 provisionBinding.bindingElement().isPresent()\n            \u0026\u0026 (provisionBinding.bindingKind().equals(INJECTION)\n                || provisionBinding.bindingKind().equals(PROVISION))\n            // TODO(gak): the accessibility limitation here needs to be addressed\n            \u0026\u0026 isElementAccessibleFrom(\n                provisionBinding.bindingElement().get(), name.packageName())) {\n          return new SimpleMethodRequestFulfillment(\n              bindingKey, provisionBinding, providerFieldRequestFulfillment);\n        }\n        return providerFieldRequestFulfillment;\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  private void implementInterfaceMethods() {\n    Set\u003cMethodSignature\u003e interfaceMethods \u003d Sets.newHashSet();\n    for (ComponentMethodDescriptor componentMethod :\n        graph.componentDescriptor().componentMethods()) {\n      if (componentMethod.dependencyRequest().isPresent()) {\n        DependencyRequest interfaceRequest \u003d componentMethod.dependencyRequest().get();\n        ExecutableElement methodElement \u003d\n            MoreElements.asExecutable(componentMethod.methodElement());\n        ExecutableType requestType \u003d\n            MoreTypes.asExecutable(\n                types.asMemberOf(\n                    MoreTypes.asDeclared(componentDefinitionType().asType()), methodElement));\n        MethodSignature signature \u003d\n            MethodSignature.fromExecutableType(\n                methodElement.getSimpleName().toString(), requestType);\n        if (!interfaceMethods.contains(signature)) {\n          interfaceMethods.add(signature);\n          MethodSpec.Builder interfaceMethod \u003d\n              methodSpecForComponentMethod(methodElement, requestType);\n          RequestFulfillment fulfillment \u003d\n              requestFulfillments.computeIfAbsent(\n                  interfaceRequest.bindingKey(), this::createRequestFulfillment);\n          CodeBlock codeBlock \u003d fulfillment.getSnippetForDependencyRequest(interfaceRequest, name);\n          switch (interfaceRequest.kind()) {\n            case MEMBERS_INJECTOR:\n              List\u003c? extends VariableElement\u003e parameters \u003d methodElement.getParameters();\n              if (!parameters.isEmpty()) {\n                Name parameterName \u003d\n                    Iterables.getOnlyElement(methodElement.getParameters()).getSimpleName();\n                interfaceMethod.addStatement(\"$L.injectMembers($L)\", codeBlock, parameterName);\n                if (!requestType.getReturnType().getKind().equals(VOID)) {\n                  interfaceMethod.addStatement(\"return $L\", parameterName);\n                }\n                break;\n              }\n              // fall through\n            default:\n              interfaceMethod.addStatement(\"return $L\", codeBlock);\n              break;\n          }\n          component.addMethod(interfaceMethod.build());\n        }\n      }\n    }\n  }\n\n  private MethodSpec.Builder methodSpecForComponentMethod(\n      ExecutableElement method, ExecutableType methodType) {\n    String methodName \u003d method.getSimpleName().toString();\n    MethodSpec.Builder methodBuilder \u003d MethodSpec.methodBuilder(methodName);\n\n    methodBuilder.addAnnotation(Override.class);\n\n    Set\u003cModifier\u003e modifiers \u003d EnumSet.copyOf(method.getModifiers());\n    modifiers.remove(Modifier.ABSTRACT);\n    methodBuilder.addModifiers(modifiers);\n\n    methodBuilder.returns(TypeName.get(methodType.getReturnType()));\n\n    List\u003c? extends VariableElement\u003e parameters \u003d method.getParameters();\n    List\u003c? extends TypeMirror\u003e resolvedParameterTypes \u003d methodType.getParameterTypes();\n    verify(parameters.size() \u003d\u003d resolvedParameterTypes.size());\n    for (int i \u003d 0; i \u003c parameters.size(); i++) {\n      VariableElement parameter \u003d parameters.get(i);\n      TypeName type \u003d TypeName.get(resolvedParameterTypes.get(i));\n      String name \u003d parameter.getSimpleName().toString();\n      Set\u003cModifier\u003e parameterModifiers \u003d parameter.getModifiers();\n      ParameterSpec.Builder parameterBuilder \u003d\n          ParameterSpec.builder(type, name)\n              .addModifiers(parameterModifiers.toArray(new Modifier[0]));\n      methodBuilder.addParameter(parameterBuilder.build());\n    }\n    for (TypeMirror thrownType : method.getThrownTypes()) {\n      methodBuilder.addException(TypeName.get(thrownType));\n    }\n    return methodBuilder;\n  }\n\n  private void addSubcomponents() {\n    for (BindingGraph subgraph : graph.subgraphs()) {\n      ComponentMethodDescriptor componentMethodDescriptor \u003d\n          graph.componentDescriptor()\n              .subcomponentsByFactoryMethod()\n              .inverse()\n              .get(subgraph.componentDescriptor());\n      SubcomponentWriter subcomponent \u003d\n          new SubcomponentWriter(this, Optional.fromNullable(componentMethodDescriptor), subgraph);\n      component.addType(subcomponent.write().build());\n    }\n  }\n\n  private static final int INITIALIZATIONS_PER_INITIALIZE_METHOD \u003d 100;\n\n  private void initializeFrameworkTypes() {\n    ImmutableList.Builder\u003cCodeBlock\u003e codeBlocks \u003d ImmutableList.builder();\n    for (BindingKey bindingKey : graph.resolvedBindings().keySet()) {\n      codeBlocks.addAll(initializeFrameworkType(bindingKey).asSet());\n    }\n    List\u003cList\u003cCodeBlock\u003e\u003e partitions \u003d\n        Lists.partition(codeBlocks.build(), INITIALIZATIONS_PER_INITIALIZE_METHOD);\n\n    UniqueNameSet methodNames \u003d new UniqueNameSet();\n    for (List\u003cCodeBlock\u003e partition : partitions) {\n      String methodName \u003d methodNames.getUniqueName(\"initialize\");\n      MethodSpec.Builder initializeMethod \u003d\n          methodBuilder(methodName)\n              .addModifiers(PRIVATE)\n              /* TODO(gak): Strictly speaking, we only need the suppression here if we are also\n               * initializing a raw field in this method, but the structure of this code makes it\n               * awkward to pass that bit through.  This will be cleaned up when we no longer\n               * separate fields and initilization as we do now. */\n              .addAnnotation(SUPPRESS_WARNINGS_UNCHECKED)\n              .addCode(CodeBlocks.concat(partition));\n      if (builderName.isPresent()) {\n        initializeMethod.addParameter(builderName.get(), \"builder\", FINAL);\n        constructor.addStatement(\"$L(builder)\", methodName);\n      } else {\n        constructor.addStatement(\"$L()\", methodName);\n      }\n      component.addMethod(initializeMethod.build());\n    }\n  }\n\n  /**\n   * Returns a single code block representing the initialization of the framework type.\n   *\n   * \u003cp\u003eNote that this must be a single code block because initialization code blocks can be invoked\n   * from any place in any order.  By requiring a single code block (often of concatenated code\n   * blocks) we ensure that things like local variables always behave as expected by the\n   * initialization logic.\n   */\n  private Optional\u003cCodeBlock\u003e initializeFrameworkType(BindingKey bindingKey) {\n    // If the field is inherited or the member select is static, don\u0027t initialize.\n    MemberSelect memberSelect \u003d getMemberSelect(bindingKey);\n    if (memberSelect.staticMember() || !memberSelect.owningClass().equals(name)) {\n      return Optional.absent();\n    }\n\n    switch (bindingKey.kind()) {\n      case CONTRIBUTION:\n        return initializeContributionBinding(bindingKey);\n\n      case MEMBERS_INJECTION:\n        return initializeMembersInjectionBinding(bindingKey);\n\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  private Optional\u003cCodeBlock\u003e initializeContributionBinding(BindingKey bindingKey) {\n    ContributionBinding binding \u003d graph.resolvedBindings().get(bindingKey).contributionBinding();\n    /* We have some duplication in the branches below b/c initializeDeferredDependencies must be\n     * called before we get the code block that initializes the member. */\n    switch (binding.factoryCreationStrategy()) {\n      case DELEGATE:\n        CodeBlock delegatingCodeBlock \u003d CodeBlock.of(\n            \"($T) $L\",\n            binding.bindingType().frameworkClass(),\n            getMemberSelect(\n                Iterables.getOnlyElement(binding.dependencies()).bindingKey())\n                    .getExpressionFor(name));\n        return Optional.of(\n            CodeBlocks.concat(\n                ImmutableList.of(\n                    initializeDeferredDependencies(binding),\n                    initializeMember(\n                        bindingKey,\n                        binding.scope().isPresent()\n                            ? decorateForScope(delegatingCodeBlock, binding.scope().get())\n                            : delegatingCodeBlock))));\n      case ENUM_INSTANCE:\n        if (!binding.scope().isPresent()) {\n          return Optional.absent();\n        }\n        // fall through\n      case CLASS_CONSTRUCTOR:\n        return Optional.of(\n            CodeBlocks.concat(\n                ImmutableList.of(\n                    initializeDeferredDependencies(binding),\n                    initializeMember(\n                        bindingKey, initializeFactoryForContributionBinding(binding)))));\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  private Optional\u003cCodeBlock\u003e initializeMembersInjectionBinding(BindingKey bindingKey) {\n    MembersInjectionBinding binding \u003d\n        graph.resolvedBindings().get(bindingKey).membersInjectionBinding().get();\n\n    if (binding.injectionStrategy().equals(MembersInjectionBinding.Strategy.NO_OP)) {\n      return Optional.absent();\n    }\n\n    return Optional.of(\n        CodeBlocks.concat(\n            ImmutableList.of(\n                initializeDeferredDependencies(binding),\n                initializeMember(bindingKey, initializeMembersInjectorForBinding(binding)))));\n  }\n\n  /**\n   * Initializes any dependencies of the given binding that need to be instantiated, i.e., as we get\n   * to them during normal initialization.\n   */\n  private CodeBlock initializeDeferredDependencies(Binding binding) {\n    return CodeBlocks.concat(\n        ImmutableList.of(\n            initializeDelegateFactoriesForUninitializedDependencies(binding),\n            initializeProducersFromProviderDependencies(binding)));\n  }\n\n  /**\n   * Initializes delegate factories for any dependencies of {@code binding} that are uninitialized\n   * because of a dependency cycle.\n   */\n  private CodeBlock initializeDelegateFactoriesForUninitializedDependencies(Binding binding) {\n    ImmutableList.Builder\u003cCodeBlock\u003e initializations \u003d ImmutableList.builder();\n\n    for (BindingKey dependencyKey :\n        FluentIterable.from(binding.implicitDependencies())\n            .transform(DependencyRequest::bindingKey)\n            .toSet()) {\n      if (!getMemberSelect(dependencyKey).staticMember()\n          \u0026\u0026 getInitializationState(dependencyKey).equals(UNINITIALIZED)) {\n        initializations.add(\n            CodeBlock.of(\n                \"this.$L \u003d new $T();\", getMemberSelectExpression(dependencyKey), DELEGATE_FACTORY));\n        setInitializationState(dependencyKey, DELEGATED);\n      }\n    }\n\n    return CodeBlocks.concat(initializations.build());\n  }\n\n  private CodeBlock initializeProducersFromProviderDependencies(Binding binding) {\n    ImmutableList.Builder\u003cCodeBlock\u003e initializations \u003d ImmutableList.builder();\n    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {\n      ResolvedBindings resolvedBindings \u003d\n          graph.resolvedBindings().get(frameworkDependency.bindingKey());\n      if (resolvedBindings.frameworkClass().equals(Provider.class)\n          \u0026\u0026 frameworkDependency.frameworkClass().equals(Producer.class)) {\n        MemberSelect memberSelect \u003d\n            producerFromProviderMemberSelects.get(frameworkDependency.bindingKey());\n        if (memberSelect !\u003d null) {\n          continue;\n        }\n        FieldSpec frameworkField \u003d\n            addFrameworkField(resolvedBindings, Optional.of(PRODUCER));\n        memberSelect \u003d localField(name, frameworkField.name);\n        producerFromProviderMemberSelects.put(frameworkDependency.bindingKey(), memberSelect);\n        initializations.add(\n            CodeBlock.of(\n                \"this.$L \u003d $T.producerFromProvider($L);\",\n                memberSelect.getExpressionFor(name),\n                PRODUCERS,\n                getMemberSelectExpression(frameworkDependency.bindingKey())));\n      }\n    }\n    return CodeBlocks.concat(initializations.build());\n  }\n\n  private CodeBlock initializeMember(BindingKey bindingKey, CodeBlock initializationCodeBlock) {\n    ImmutableList.Builder\u003cCodeBlock\u003e initializations \u003d ImmutableList.builder();\n\n    CodeBlock memberSelect \u003d getMemberSelectExpression(bindingKey);\n    CodeBlock delegateFactoryVariable \u003d delegateFactoryVariableExpression(bindingKey);\n    if (getInitializationState(bindingKey).equals(DELEGATED)) {\n      initializations.add(\n          CodeBlock.of(\n              \"$1T $2L \u003d ($1T) $3L;\", DELEGATE_FACTORY, delegateFactoryVariable, memberSelect));\n    }\n    initializations.add(\n        CodeBlock.of(\"this.$L \u003d $L;\", memberSelect, initializationCodeBlock));\n    if (getInitializationState(bindingKey).equals(DELEGATED)) {\n      initializations.add(\n          CodeBlock.of(\"$L.setDelegatedProvider($L);\", delegateFactoryVariable, memberSelect));\n    }\n    setInitializationState(bindingKey, INITIALIZED);\n\n    return CodeBlocks.concat(initializations.build());\n  }\n\n  private CodeBlock delegateFactoryVariableExpression(BindingKey key) {\n    return CodeBlock.of(\"$LDelegate\", getMemberSelectExpression(key).toString().replace(\u0027.\u0027, \u0027_\u0027));\n  }\n\n  private CodeBlock initializeFactoryForContributionBinding(ContributionBinding binding) {\n    TypeName bindingKeyTypeName \u003d TypeName.get(binding.key().type());\n    switch (binding.bindingKind()) {\n      case COMPONENT:\n        return CodeBlock.of(\n            \"$T.\u003c$T\u003ecreate($L)\",\n            INSTANCE_FACTORY,\n            bindingKeyTypeName,\n            bindingKeyTypeName.equals(componentDefinitionTypeName())\n                ? \"this\"\n                : getComponentContributionExpression(\n                    MoreTypes.asTypeElement(binding.key().type())));\n\n      case COMPONENT_PROVISION:\n        {\n          TypeElement dependencyType \u003d dependencyTypeForBinding(binding);\n          String dependencyVariable \u003d simpleVariableName(dependencyType);\n          CodeBlock callFactoryMethod \u003d\n              CodeBlock.of(\n                  \"$L.$L()\", dependencyVariable, binding.bindingElement().get().getSimpleName());\n          // TODO(sameb): This throws a very vague NPE right now.  The stack trace doesn\u0027t\n          // help to figure out what the method or return type is.  If we include a string\n          // of the return type or method name in the error message, that can defeat obfuscation.\n          // We can easily include the raw type (no generics) + annotation type (no values),\n          // using .class \u0026 String.format -- but that wouldn\u0027t be the whole story.\n          // What should we do?\n          CodeBlock getMethodBody \u003d\n              binding.nullableType().isPresent()\n                      || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)\n                  ? CodeBlock.of(\"return $L;\", callFactoryMethod)\n                  : CodeBlock.of(\"return $T.checkNotNull($L, $S);\",\n                      Preconditions.class,\n                      callFactoryMethod,\n                      CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);\n          return CodeBlock.of(\n              Joiner.on(\u0027\\n\u0027)\n                  .join(\n                      \"new $1T\u003c$2T\u003e() {\",\n                      \"  private final $5T $6L \u003d $3L;\",\n                      \"  $4L@Override public $2T get() {\",\n                      \"    $7L\",\n                      \"  }\",\n                      \"}\"),\n              /* 1 */ FACTORY,\n              /* 2 */ bindingKeyTypeName,\n              /* 3 */ getComponentContributionExpression(dependencyType),\n              /* 4 */ nullableAnnotation(binding.nullableType()),\n              /* 5 */ TypeName.get(dependencyType.asType()),\n              /* 6 */ dependencyVariable,\n              /* 7 */ getMethodBody);\n        }\n\n      case SUBCOMPONENT_BUILDER:\n        String subcomponentName \u003d\n            subcomponentNames.get(\n                graph.componentDescriptor()\n                    .subcomponentsByBuilderType()\n                    .get(MoreTypes.asTypeElement(binding.key().type())));\n        return CodeBlock.of(\n            Joiner.on(\u0027\\n\u0027)\n                .join(\n                    \"new $1T\u003c$2T\u003e() {\",\n                    \"  @Override public $2T get() {\",\n                    \"    return new $3LBuilder();\",\n                    \"  }\",\n                    \"}\"),\n            /* 1 */ FACTORY,\n            /* 2 */ bindingKeyTypeName,\n            /* 3 */ subcomponentName);\n\n      case INJECTION:\n      case PROVISION:\n        {\n          List\u003cCodeBlock\u003e arguments \u003d\n              Lists.newArrayListWithCapacity(binding.dependencies().size() + 1);\n          if (binding.requiresModuleInstance()) {\n            arguments.add(getComponentContributionExpression(binding.contributingModule().get()));\n          }\n          arguments.addAll(getDependencyArguments(binding));\n\n          CodeBlock factoryCreate \u003d\n              CodeBlock.of(\n                  \"$T.create($L)\",\n                  generatedClassNameForBinding(binding),\n                  makeParametersCodeBlock(arguments));\n          return binding.scope().isPresent()\n              ? decorateForScope(factoryCreate, binding.scope().get())\n              : factoryCreate;\n        }\n\n      case COMPONENT_PRODUCTION:\n        {\n          TypeElement dependencyType \u003d dependencyTypeForBinding(binding);\n          return CodeBlock.of(\n              Joiner.on(\u0027\\n\u0027)\n                  .join(\n                      \"new $1T\u003c$2T\u003e() {\",\n                      \"  private final $6T $7L \u003d $4L;\",\n                      \"  @Override public $3T\u003c$2T\u003e get() {\",\n                      \"    return $7L.$5L();\",\n                      \"  }\",\n                      \"}\"),\n              /* 1 */ PRODUCER,\n              /* 2 */ TypeName.get(binding.key().type()),\n              /* 3 */ LISTENABLE_FUTURE,\n              /* 4 */ getComponentContributionExpression(dependencyType),\n              /* 5 */ binding.bindingElement().get().getSimpleName(),\n              /* 6 */ TypeName.get(dependencyType.asType()),\n              /* 7 */ simpleVariableName(dependencyType));\n        }\n\n      case PRODUCTION:\n        {\n          List\u003cCodeBlock\u003e arguments \u003d\n              Lists.newArrayListWithCapacity(binding.implicitDependencies().size() + 2);\n          if (binding.requiresModuleInstance()) {\n            arguments.add(getComponentContributionExpression(binding.contributingModule().get()));\n          }\n          arguments.addAll(getDependencyArguments(binding));\n\n          return CodeBlock.of(\n              \"new $T($L)\",\n              generatedClassNameForBinding(binding),\n              makeParametersCodeBlock(arguments));\n        }\n\n      case SYNTHETIC_MAP:\n        return CodeBlock.of(\n            \"$T.create($L)\",\n            mapFactoryClassName(binding),\n            getMemberSelectExpression(getOnlyElement(binding.dependencies()).bindingKey()));\n\n      case SYNTHETIC_MULTIBOUND_SET:\n        return initializeFactoryForSetMultibinding(binding);\n\n      case SYNTHETIC_MULTIBOUND_MAP:\n        return initializeFactoryForMapMultibinding(binding);\n\n      case SYNTHETIC_OPTIONAL_BINDING:\n        return initializeFactoryForSyntheticOptionalBinding(binding);\n\n      default:\n        throw new AssertionError(binding);\n    }\n  }\n\n  private TypeElement dependencyTypeForBinding(ContributionBinding binding) {\n    return graph.componentDescriptor().dependencyMethodIndex().get(binding.bindingElement().get());\n  }\n\n  private CodeBlock decorateForScope(CodeBlock factoryCreate, Scope scope) {\n      return CodeBlock.of(\n          \"$T.provider($L)\",\n          scope.equals(reusableScope(elements)) ? SINGLE_CHECK : DOUBLE_CHECK,\n          factoryCreate);\n  }\n\n  private CodeBlock nullableAnnotation(Optional\u003cDeclaredType\u003e nullableType) {\n    return nullableType.isPresent()\n        ? CodeBlock.of(\"@$T \", TypeName.get(nullableType.get()))\n        : CodeBlock.of(\"\");\n  }\n\n  private CodeBlock initializeMembersInjectorForBinding(MembersInjectionBinding binding) {\n    switch (binding.injectionStrategy()) {\n      case NO_OP:\n        return CodeBlock.of(\"$T.noOp()\", MEMBERS_INJECTORS);\n      case INJECT_MEMBERS:\n        return CodeBlock.of(\n            \"$T.create($L)\",\n            membersInjectorNameForType(binding.membersInjectedType()),\n            makeParametersCodeBlock(getDependencyArguments(binding)));\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  /**\n   * The expressions that represent factory arguments for the dependencies of a binding.\n   */\n  private ImmutableList\u003cCodeBlock\u003e getDependencyArguments(Binding binding) {\n    ImmutableList.Builder\u003cCodeBlock\u003e parameters \u003d ImmutableList.builder();\n    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {\n      parameters.add(getDependencyArgument(frameworkDependency).getExpressionFor(name));\n    }\n    return parameters.build();\n  }\n\n  /** Returns the member select to use as an argument for a dependency. */\n  private MemberSelect getDependencyArgument(FrameworkDependency frameworkDependency) {\n    BindingKey requestedKey \u003d frameworkDependency.bindingKey();\n    ResolvedBindings resolvedBindings \u003d graph.resolvedBindings().get(requestedKey);\n    if (resolvedBindings.frameworkClass().equals(Provider.class)\n        \u0026\u0026 frameworkDependency.frameworkClass().equals(Producer.class)) {\n      return producerFromProviderMemberSelects.get(requestedKey);\n    } else {\n      return getMemberSelect(requestedKey);\n    }\n  }\n\n  private CodeBlock initializeFactoryForSetMultibinding(ContributionBinding binding) {\n    CodeBlock.Builder builder \u003d\n        CodeBlock.builder().add(\"$T.\", setFactoryClassName(binding.bindingType(), binding.key()));\n    boolean useRawTypes \u003d useRawType(binding);\n    if (!useRawTypes) {\n      SetType setType \u003d SetType.from(binding.key());\n      builder.add(\n          \"\u003c$T\u003e\",\n          setType.elementsAreTypeOf(Produced.class)\n              ? setType.unwrappedElementType(Produced.class)\n              : setType.elementType());\n    }\n    int individualProviders \u003d 0;\n    int setProviders \u003d 0;\n    CodeBlock.Builder builderMethodCalls \u003d CodeBlock.builder();\n    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {\n      ContributionType contributionType \u003d\n          graph.resolvedBindings().get(frameworkDependency.bindingKey()).contributionType();\n      String methodName;\n      String methodNameSuffix \u003d frameworkDependency.frameworkClass().getSimpleName();\n      switch (contributionType) {\n        case SET:\n          individualProviders++;\n          methodName \u003d \"add\" + methodNameSuffix;\n          break;\n        case SET_VALUES:\n          setProviders++;\n          methodName \u003d \"addCollection\" + methodNameSuffix;\n          break;\n        default:\n          throw new AssertionError(frameworkDependency + \" is not a set multibinding\");\n      }\n\n      builderMethodCalls.add(\n          \".$L($L)\",\n          methodName,\n          potentiallyCast(\n              useRawTypes,\n              frameworkDependency.frameworkClass(),\n              getDependencyArgument(frameworkDependency).getExpressionFor(name)));\n    }\n    builder.add(\"builder($L, $L)\", individualProviders, setProviders);\n    builder.add(builderMethodCalls.build());\n    return builder.add(\".build()\").build();\n  }\n\n  private CodeBlock initializeFactoryForMapMultibinding(ContributionBinding binding) {\n    ImmutableSet\u003cFrameworkDependency\u003e frameworkDependencies \u003d\n        FrameworkDependency.frameworkDependenciesForBinding(binding);\n\n    ImmutableList.Builder\u003cCodeBlock\u003e codeBlocks \u003d ImmutableList.builder();\n    MapType mapType \u003d MapType.from(binding.key().type());\n    CodeBlock.Builder builderCall \u003d\n        CodeBlock.builder().add(\"$T.\", frameworkMapFactoryClassName(binding.bindingType()));\n    boolean useRawTypes \u003d useRawType(binding);\n    if (!useRawTypes) {\n      builderCall.add(\"\u003c$T, $T\u003e\", TypeName.get(mapType.keyType()),\n          TypeName.get(mapType.unwrappedValueType(binding.bindingType().frameworkClass())));\n    }\n    builderCall.add(\"builder($L)\", frameworkDependencies.size());\n    codeBlocks.add(builderCall.build());\n\n    for (FrameworkDependency frameworkDependency : frameworkDependencies) {\n      BindingKey bindingKey \u003d frameworkDependency.bindingKey();\n      ContributionBinding contributionBinding \u003d\n          graph.resolvedBindings().get(bindingKey).contributionBinding();\n      CodeBlock value \u003d\n          potentiallyCast(\n              useRawTypes,\n              frameworkDependency.frameworkClass(),\n              getDependencyArgument(frameworkDependency).getExpressionFor(name));\n      if (binding.bindingType().frameworkClass().equals(Producer.class)\n          \u0026\u0026 frameworkDependency.frameworkClass().equals(Provider.class)) {\n        value \u003d CodeBlock.of(\"$T.producerFromProvider($L)\", PRODUCERS, value);\n      }\n      codeBlocks.add(\n          CodeBlock.of(\n              \".put($L, $L)\", getMapKeyExpression(contributionBinding.mapKey().get()), value));\n    }\n    codeBlocks.add(CodeBlock.of(\".build()\"));\n\n    return CodeBlocks.concat(codeBlocks.build());\n  }\n\n  private CodeBlock potentiallyCast(boolean shouldCast, Class\u003c?\u003e classToCast, CodeBlock notCasted) {\n    if (!shouldCast) {\n      return notCasted;\n    }\n    return CodeBlock.of(\"($T) $L\", classToCast, notCasted);\n  }\n\n  /**\n   * Returns an expression that initializes a {@link Provider} or {@link Producer} for an optional\n   * binding.\n   */\n  private CodeBlock initializeFactoryForSyntheticOptionalBinding(ContributionBinding binding) {\n    if (binding.dependencies().isEmpty()) {\n      verify(\n          binding.bindingType().equals(BindingType.PROVISION),\n          \"Absent optional bindings should be provisions: %s\",\n          binding);\n      return optionalFactories.absentOptionalProvider(binding);\n    } else {\n      return optionalFactories.presentOptionalFactory(\n          binding, getOnlyElement(getDependencyArguments(binding)));\n    }\n  }\n\n  private static String simpleVariableName(TypeElement typeElement) {\n    return UPPER_CAMEL.to(LOWER_CAMEL, typeElement.getSimpleName().toString());\n  }\n\n  /**\n   * Initialization state for a factory field.\n   */\n  enum InitializationState {\n    /** The field is {@code null}. */\n    UNINITIALIZED,\n\n    /** The field is set to a {@link DelegateFactory}. */\n    DELEGATED,\n\n    /** The field is set to an undelegated factory. */\n    INITIALIZED;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\Accessibility.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getPackage;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.element.Modifier.PUBLIC;\n\nimport com.google.auto.common.MoreElements;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ElementKind;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.PackageElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.TypeParameterElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.ArrayType;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.NoType;\nimport javax.lang.model.type.NullType;\nimport javax.lang.model.type.PrimitiveType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.type.TypeVariable;\nimport javax.lang.model.type.WildcardType;\nimport javax.lang.model.util.SimpleElementVisitor6;\nimport javax.lang.model.util.SimpleTypeVisitor6;\n\n/**\n * Utility methods for determining whether a {@linkplain TypeMirror type} or an {@linkplain Element\n * element} is accessible given the rules outlined in\n * \u003ca href\u003d\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.6\"\u003esection 6.6 of the\n * Java Language Specification\u003c/a\u003e.\n *\n * \u003cp\u003eThis class only provides an approximation for accessibility.  It does not always yield the\n * same result as the compiler, but will always err on the side of declaring something inaccessible.\n * This ensures that using this class will never result in generating code that will not compile.\n *\n * \u003cp\u003eWhenever compiler independence is not a requirement, the compiler-specific implementation of\n * this functionality should be preferred.  For example,\n * {@link com.sun.source.util.Trees#isAccessible(com.sun.source.tree.Scope, TypeElement)} would be\n * preferable for {@code javac}.\n */\nfinal class Accessibility {\n  /**\n   * Returns true if the given type can be referenced from code in the given package.\n   */\n  static boolean isTypeAccessibleFrom(TypeMirror type, String packageName) {\n    return type.accept(new TypeAccessiblityVisitor(packageName), null);\n  }\n\n  private static final class TypeAccessiblityVisitor extends SimpleTypeVisitor6\u003cBoolean, Void\u003e {\n    final String packageName;\n\n    TypeAccessiblityVisitor(String packageName) {\n      this.packageName \u003d packageName;\n    }\n\n    boolean isAccessible(TypeMirror type) {\n      return type.accept(this, null);\n    }\n\n    @Override\n    public Boolean visitNoType(NoType type, Void p) {\n      return true;\n    }\n\n    @Override\n    public Boolean visitDeclared(DeclaredType type, Void p) {\n      if (!isAccessible(type.getEnclosingType())) {\n        // TODO(gak): investigate this check.  see comment in Binding\n        return false;\n      }\n      if (!isElementAccessibleFrom(type.asElement(), packageName)) {\n        return false;\n      }\n      for (TypeMirror typeArgument : type.getTypeArguments()) {\n        if (!isAccessible(typeArgument)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    @Override\n    public Boolean visitArray(ArrayType type, Void p) {\n      return type.getComponentType().accept(this, null);\n    }\n\n    @Override\n    public Boolean visitPrimitive(PrimitiveType type, Void p) {\n      return true;\n    }\n\n    @Override\n    public Boolean visitNull(NullType type, Void p) {\n      return true;\n    }\n\n    @Override\n    public Boolean visitTypeVariable(TypeVariable type, Void p) {\n      // a _reference_ to a type variable is always accessible\n      return true;\n    }\n\n    @Override\n    public Boolean visitWildcard(WildcardType type, Void p) {\n      if (type.getExtendsBound() !\u003d null \u0026\u0026 !isAccessible(type.getExtendsBound())) {\n        return false;\n      }\n      if (type.getSuperBound() !\u003d null \u0026\u0026 !isAccessible(type.getSuperBound())) {\n        return false;\n      }\n      return true;\n    }\n\n    @Override\n    protected Boolean defaultAction(TypeMirror type, Void p) {\n      throw new IllegalArgumentException(String.format(\n          \"%s of kind %s should not be checked for accessibility\", type, type.getKind()));\n    }\n  }\n\n  /**\n   * Returns true if the given element can be referenced from code in the given package.\n   */\n  //TODO(gak): account for protected\n  static boolean isElementAccessibleFrom(Element element, final String packageName) {\n    return element.accept(new ElementAccessibilityVisitor(packageName), null);\n  }\n\n  /** Returns true if the given element can be referenced from other code in its own package. */\n  static boolean isElementAccessibleFromOwnPackage(Element element) {\n    return isElementAccessibleFrom(\n        element, MoreElements.getPackage(element).getQualifiedName().toString());\n  }\n\n  private static final class ElementAccessibilityVisitor\n      extends SimpleElementVisitor6\u003cBoolean, Void\u003e {\n    final String packageName;\n\n    ElementAccessibilityVisitor(String packageName) {\n      this.packageName \u003d packageName;\n    }\n\n    @Override\n    public Boolean visitPackage(PackageElement element, Void p) {\n      return true;\n    }\n\n    @Override\n    public Boolean visitType(TypeElement element, Void p) {\n      switch (element.getNestingKind()) {\n        case MEMBER:\n          return accessibleMember(element);\n        case TOP_LEVEL:\n          return accessibleModifiers(element);\n        case ANONYMOUS:\n        case LOCAL:\n          return false;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    boolean accessibleMember(Element element) {\n      if (!element.getEnclosingElement().accept(this, null)) {\n        return false;\n      }\n      return accessibleModifiers(element);\n    }\n\n    boolean accessibleModifiers(Element element) {\n      if (element.getModifiers().contains(PUBLIC)) {\n        return true;\n      } else if (element.getModifiers().contains(PRIVATE)) {\n        return false;\n      } else if (getPackage(element).getQualifiedName().contentEquals(packageName)) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    @Override\n    public Boolean visitTypeParameter(TypeParameterElement element, Void p) {\n      throw new IllegalArgumentException(\n          \"It does not make sense to check the accessibility of a type parameter\");\n    }\n\n    @Override\n    public Boolean visitExecutable(ExecutableElement element, Void p) {\n      return accessibleMember(element);\n    }\n\n    @Override\n    public Boolean visitVariable(VariableElement element, Void p) {\n      ElementKind kind \u003d element.getKind();\n      checkArgument(kind.isField(), \"checking a variable that isn\u0027t a field: %s\", kind);\n      return accessibleMember(element);\n    }\n  }\n\n  private Accessibility() {}\n}\n\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\AnnotationCreatorGenerator.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.squareup.javapoet.MethodSpec.constructorBuilder;\nimport static com.squareup.javapoet.MethodSpec.methodBuilder;\nimport static com.squareup.javapoet.TypeSpec.classBuilder;\nimport static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;\nimport static dagger.internal.codegen.SourceFiles.classFileName;\nimport static javax.lang.model.element.Modifier.FINAL;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.element.Modifier.PUBLIC;\nimport static javax.lang.model.element.Modifier.STATIC;\nimport static javax.lang.model.util.ElementFilter.methodsIn;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoAnnotation;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableList;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.TypeName;\nimport com.squareup.javapoet.TypeSpec;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport javax.annotation.processing.Filer;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ElementKind;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.SimpleTypeVisitor6;\n\n/**\n * Generates classes that create annotation instances for an annotation type. The generated class\n * will have a private empty constructor, a static method that creates the annotation type itself,\n * and a static method that creates each annotation type that is nested in the top-level annotation\n * type.\n *\n * \u003cp\u003eSo for an example annotation:\n *\n * \u003cpre\u003e\n *   {@literal @interface} Foo {\n *     String s();\n *     int i();\n *     Bar bar(); // an annotation defined elsewhere\n *   }\n * \u003c/pre\u003e\n *\n * the generated class will look like:\n *\n * \u003cpre\u003e\n *   public final class FooCreator {\n *     private FooCreator() {}\n *\n *     public static Foo createFoo(String s, int i, Bar bar) { … }\n *     public static Bar createBar(…) { … }\n *   }\n * \u003c/pre\u003e\n */\nclass AnnotationCreatorGenerator extends SourceFileGenerator\u003cTypeElement\u003e {\n\n  /**\n   * Returns the name of the generated class that contains the static {@code create} methods for an\n   * annotation type.\n   */\n  static ClassName getAnnotationCreatorClassName(TypeElement annotationType) {\n    ClassName annotationTypeName \u003d ClassName.get(annotationType);\n    return annotationTypeName\n        .topLevelClassName()\n        .peerClass(classFileName(annotationTypeName) + \"Creator\");\n  }\n\n  AnnotationCreatorGenerator(Filer filer, Elements elements) {\n    super(filer, elements);\n  }\n\n  @Override\n  ClassName nameGeneratedType(TypeElement annotationType) {\n    return getAnnotationCreatorClassName(annotationType);\n  }\n\n  @Override\n  Optional\u003c? extends Element\u003e getElementForErrorReporting(TypeElement annotationType) {\n    return Optional.of(annotationType);\n  }\n\n  @Override\n  Optional\u003cTypeSpec.Builder\u003e write(ClassName generatedTypeName, TypeElement annotationType) {\n    TypeSpec.Builder annotationCreatorBuilder \u003d\n        classBuilder(generatedTypeName)\n            .addModifiers(PUBLIC, FINAL)\n            .addMethod(constructorBuilder().addModifiers(PRIVATE).build());\n\n    for (TypeElement annotationElement : annotationsToCreate(annotationType)) {\n      annotationCreatorBuilder.addMethod(buildCreateMethod(generatedTypeName, annotationElement));\n    }\n\n    return Optional.of(annotationCreatorBuilder);\n  }\n\n  private MethodSpec buildCreateMethod(ClassName generatedTypeName, TypeElement annotationElement) {\n    String createMethodName \u003d createMethodName(annotationElement);\n    MethodSpec.Builder createMethod \u003d\n        methodBuilder(createMethodName)\n            .addAnnotation(AutoAnnotation.class)\n            .addModifiers(PUBLIC, STATIC)\n            .returns(TypeName.get(annotationElement.asType()));\n\n    ImmutableList.Builder\u003cCodeBlock\u003e parameters \u003d ImmutableList.builder();\n    for (ExecutableElement annotationMember : methodsIn(annotationElement.getEnclosedElements())) {\n      String parameterName \u003d annotationMember.getSimpleName().toString();\n      TypeName parameterType \u003d TypeName.get(annotationMember.getReturnType());\n      createMethod.addParameter(parameterType, parameterName);\n      parameters.add(CodeBlock.of(\"$L\", parameterName));\n    }\n\n    ClassName autoAnnotationClass \u003d\n        generatedTypeName.peerClass(\n            \"AutoAnnotation_\" + generatedTypeName.simpleName() + \"_\" + createMethodName);\n    createMethod.addStatement(\n        \"return new $T($L)\", autoAnnotationClass, makeParametersCodeBlock(parameters.build()));\n    return createMethod.build();\n  }\n\n  static String createMethodName(TypeElement annotationType) {\n    return \"create\" + annotationType.getSimpleName();\n  }\n\n  /**\n   * Returns the annotation types for which {@code @AutoAnnotation static Foo createFoo(…)} methods\n   * should be written.\n   */\n  protected Set\u003cTypeElement\u003e annotationsToCreate(TypeElement annotationElement) {\n    return nestedAnnotationElements(annotationElement, new LinkedHashSet\u003c\u003e());\n  }\n\n  @CanIgnoreReturnValue\n  private static Set\u003cTypeElement\u003e nestedAnnotationElements(\n      TypeElement annotationElement, Set\u003cTypeElement\u003e annotationElements) {\n    if (annotationElements.add(annotationElement)) {\n      for (ExecutableElement method : methodsIn(annotationElement.getEnclosedElements())) {\n        TRAVERSE_NESTED_ANNOTATIONS.visit(method.getReturnType(), annotationElements);\n      }\n    }\n    return annotationElements;\n  }\n\n  private static final SimpleTypeVisitor6\u003cVoid, Set\u003cTypeElement\u003e\u003e TRAVERSE_NESTED_ANNOTATIONS \u003d\n      new SimpleTypeVisitor6\u003cVoid, Set\u003cTypeElement\u003e\u003e() {\n        @Override\n        public Void visitDeclared(DeclaredType t, Set\u003cTypeElement\u003e p) {\n          TypeElement typeElement \u003d MoreTypes.asTypeElement(t);\n          if (typeElement.getKind() \u003d\u003d ElementKind.ANNOTATION_TYPE) {\n            nestedAnnotationElements(typeElement, p);\n          }\n          return null;\n        }\n      };\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\AnnotationExpression.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;\nimport static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;\nimport static java.util.stream.Collectors.toList;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.collect.ImmutableList;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport com.squareup.javapoet.TypeName;\nimport java.util.List;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.AnnotationValue;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.ArrayType;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.SimpleAnnotationValueVisitor6;\nimport javax.lang.model.util.SimpleTypeVisitor6;\n\n/**\n * Returns an expression creating an instance of the visited annotation type. Its parameter must be\n * a class as generated by {@link AnnotationCreatorGenerator}.\n *\n * \u003cp\u003eNote that {@link AnnotationValue#toString()} is the source-code representation of the value\n * \u003cem\u003ewhen used in an annotation\u003c/em\u003e, which is not always the same as the representation needed\n * when creating the value in a method body.\n *\n * \u003cp\u003eFor example, inside an annotation, a nested array of {@code int}s is simply {@code {1, 2, 3}},\n * but in code it would have to be {@code new int[] {1, 2, 3}}.\n */\nclass AnnotationExpression extends SimpleAnnotationValueVisitor6\u003cCodeBlock, AnnotationValue\u003e {\n\n  private final AnnotationMirror annotation;\n  private final ClassName creatorClass;\n\n  AnnotationExpression(AnnotationMirror annotation) {\n    this.annotation \u003d annotation;\n    this.creatorClass \u003d\n        AnnotationCreatorGenerator.getAnnotationCreatorClassName(\n            MoreTypes.asTypeElement(annotation.getAnnotationType()));\n  }\n\n  /**\n   * Returns an expression that calls static methods on the annotation\u0027s creator class to create an\n   * annotation instance equivalent the annotation passed to the constructor.\n   */\n  CodeBlock getAnnotationInstanceExpression() {\n    return getAnnotationInstanceExpression(annotation);\n  }\n\n  private CodeBlock getAnnotationInstanceExpression(AnnotationMirror annotation) {\n    return CodeBlock.of(\n        \"$T.$L($L)\",\n        creatorClass,\n        AnnotationCreatorGenerator.createMethodName(\n            MoreElements.asType(annotation.getAnnotationType().asElement())),\n        makeParametersCodeBlock(\n            getAnnotationValuesWithDefaults(annotation)\n                .entrySet()\n                .stream()\n                .map(entry -\u003e getValueExpression(entry.getKey().getReturnType(), entry.getValue()))\n                .collect(toList())));\n  }\n\n  /**\n   * Returns an expression that evaluates to a {@code value} of a given type on an {@code\n   * annotation}.\n   */\n  CodeBlock getValueExpression(TypeMirror valueType, AnnotationValue value) {\n    return ARRAY_LITERAL_PREFIX.visit(valueType, this.visit(value, value));\n  }\n\n  @Override\n  public CodeBlock visitEnumConstant(VariableElement c, AnnotationValue p) {\n    return CodeBlock.of(\"$T.$L\", TypeName.get(c.getEnclosingElement().asType()), c.getSimpleName());\n  }\n\n  @Override\n  public CodeBlock visitAnnotation(AnnotationMirror a, AnnotationValue p) {\n    return getAnnotationInstanceExpression(a);\n  }\n\n  @Override\n  public CodeBlock visitType(TypeMirror t, AnnotationValue p) {\n    return CodeBlock.of(\"$T.class\", TypeName.get(t));\n  }\n\n  @Override\n  public CodeBlock visitString(String s, AnnotationValue p) {\n    return CodeBlock.of(\"$S\", s);\n  }\n\n  @Override\n  public CodeBlock visitByte(byte b, AnnotationValue p) {\n    return CodeBlock.of(\"(byte) $L\", b);\n  }\n\n  @Override\n  public CodeBlock visitChar(char c, AnnotationValue p) {\n    return CodeBlock.of(\"$L\", p);\n  }\n\n  @Override\n  public CodeBlock visitDouble(double d, AnnotationValue p) {\n    return CodeBlock.of(\"$LD\", d);\n  }\n\n  @Override\n  public CodeBlock visitFloat(float f, AnnotationValue p) {\n    return CodeBlock.of(\"$LF\", f);\n  }\n\n  @Override\n  public CodeBlock visitLong(long i, AnnotationValue p) {\n    return CodeBlock.of(\"$LL\", i);\n  }\n\n  @Override\n  public CodeBlock visitShort(short s, AnnotationValue p) {\n    return CodeBlock.of(\"(short) $L\", s);\n  }\n\n  @Override\n  protected CodeBlock defaultAction(Object o, AnnotationValue p) {\n    return CodeBlock.of(\"$L\", o);\n  }\n\n  @Override\n  public CodeBlock visitArray(List\u003c? extends AnnotationValue\u003e values, AnnotationValue p) {\n    ImmutableList.Builder\u003cCodeBlock\u003e codeBlocks \u003d ImmutableList.builder();\n    for (AnnotationValue value : values) {\n      codeBlocks.add(this.visit(value, p));\n    }\n    return CodeBlock.of(\"{$L}\", makeParametersCodeBlock(codeBlocks.build()));\n  }\n\n  /**\n   * If the visited type is an array, prefixes the parameter code block with {@code new T[]}, where\n   * {@code T} is the raw array component type.\n   */\n  private static final SimpleTypeVisitor6\u003cCodeBlock, CodeBlock\u003e ARRAY_LITERAL_PREFIX \u003d\n      new SimpleTypeVisitor6\u003cCodeBlock, CodeBlock\u003e() {\n\n        @Override\n        public CodeBlock visitArray(ArrayType t, CodeBlock p) {\n          return CodeBlock.of(\"new $T[] $L\", RAW_TYPE_NAME.visit(t.getComponentType()), p);\n        }\n\n        @Override\n        protected CodeBlock defaultAction(TypeMirror e, CodeBlock p) {\n          return p;\n        }\n      };\n\n  /**\n   * If the visited type is an array, returns the name of its raw component type; otherwise returns\n   * the name of the type itself.\n   */\n  private static final SimpleTypeVisitor6\u003cTypeName, Void\u003e RAW_TYPE_NAME \u003d\n      new SimpleTypeVisitor6\u003cTypeName, Void\u003e() {\n        @Override\n        public TypeName visitDeclared(DeclaredType t, Void p) {\n          return ClassName.get(MoreTypes.asTypeElement(t));\n        }\n\n        @Override\n        protected TypeName defaultAction(TypeMirror e, Void p) {\n          return TypeName.get(e);\n        }\n      };\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\AnnotationSpecs.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.squareup.javapoet.AnnotationSpec;\n\nfinal class AnnotationSpecs {\n\n  static final AnnotationSpec SUPPRESS_WARNINGS_UNCHECKED \u003d suppressWarnings(\"unchecked\");\n  static final AnnotationSpec SUPPRESS_WARNINGS_RAWTYPES \u003d suppressWarnings(\"rawtypes\");\n\n  private static AnnotationSpec suppressWarnings(String value) {\n    return AnnotationSpec.builder(SuppressWarnings.class).addMember(\"value\", \"$S\", value).build();\n  }\n\n  private AnnotationSpecs() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\Binding.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static javax.lang.model.element.Modifier.PUBLIC;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport dagger.internal.codegen.BindingType.HasBindingType;\nimport java.util.List;\nimport java.util.Set;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.Name;\nimport javax.lang.model.element.PackageElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.TypeParameterElement;\nimport javax.lang.model.type.ArrayType;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.type.WildcardType;\nimport javax.lang.model.util.SimpleTypeVisitor6;\nimport javax.lang.model.util.Types;\n\n/**\n * An abstract type for classes representing a Dagger binding.  Particularly, contains the\n * {@link Element} that generated the binding and the {@link DependencyRequest} instances that are\n * required to satisfy the binding, but leaves the specifics of the \u003ci\u003emechanism\u003c/i\u003e of the binding\n * to the subtypes.\n *\n * @author Gregory Kick\n * @since 2.0\n */\nabstract class Binding extends BindingDeclaration implements HasBindingType {\n\n  /** The {@link Key} that is provided by this binding. */\n  @Override\n  public abstract Key key();\n\n  /**\n   * The explicit set of {@link DependencyRequest dependencies} required to satisfy this binding as\n   * defined by the user-defined injection sites.\n   */\n  abstract ImmutableSet\u003cDependencyRequest\u003e dependencies();\n\n  /**\n   * The set of {@link DependencyRequest dependencies} that are added by the framework rather than a\n   * user-defined injection site. This returns an unmodifiable set.\n   */\n  // TODO(gak): this will eventually get migrated to FrameworkDependency\n  Set\u003cDependencyRequest\u003e frameworkDependencies() {\n    return ImmutableSet.of();\n  }\n\n  /**\n   * The set of {@link DependencyRequest dependencies} required to satisfy this binding. This is the\n   * union of {@link #dependencies()} and {@link #frameworkDependencies()}. This returns an\n   * unmodifiable set.\n   */\n  final Set\u003cDependencyRequest\u003e implicitDependencies() {\n    Set\u003cDependencyRequest\u003e frameworkDependencies \u003d frameworkDependencies();\n    return frameworkDependencies.isEmpty()\n        ? dependencies()\n        : Sets.union(frameworkDependencies, dependencies());\n  }\n\n  /**\n   * Returns the name of the package in which this binding must be managed. E.g.: a binding\n   * may reference non-public types.\n   */\n  final Optional\u003cString\u003e bindingPackage() {\n    Set\u003cString\u003e packages \u003d nonPublicPackageUse(key().type());\n    switch (packages.size()) {\n      case 0:\n        return Optional.absent();\n      case 1:\n        return Optional.of(packages.iterator().next());\n      default:\n        throw new IllegalStateException();\n    }\n  }\n\n  private static Set\u003cString\u003e nonPublicPackageUse(TypeMirror typeMirror) {\n    ImmutableSet.Builder\u003cString\u003e packages \u003d ImmutableSet.builder();\n    typeMirror.accept(new SimpleTypeVisitor6\u003cVoid, ImmutableSet.Builder\u003cString\u003e\u003e() {\n      @Override\n      public Void visitArray(ArrayType t, ImmutableSet.Builder\u003cString\u003e p) {\n        return t.getComponentType().accept(this, p);\n      }\n\n      @Override\n      public Void visitDeclared(DeclaredType t, ImmutableSet.Builder\u003cString\u003e p) {\n        for (TypeMirror typeArgument : t.getTypeArguments()) {\n          typeArgument.accept(this, p);\n        }\n        // TODO(gak): address public nested types in non-public types\n        TypeElement typeElement \u003d MoreElements.asType(t.asElement());\n        if (!typeElement.getModifiers().contains(PUBLIC)) {\n          PackageElement elementPackage \u003d MoreElements.getPackage(typeElement);\n          Name qualifiedName \u003d elementPackage.getQualifiedName();\n          p.add(qualifiedName.toString());\n        }\n        // Also make sure enclosing types are visible, otherwise we\u0027re fooled by\n        // class Foo { public class Bar }\n        // (Note: we can\u0027t use t.getEnclosingType() because it doesn\u0027t work!)\n        typeElement.getEnclosingElement().asType().accept(this, p);\n        return null;\n      }\n\n      @Override\n      public Void visitWildcard(WildcardType t, ImmutableSet.Builder\u003cString\u003e p) {\n        if (t.getExtendsBound() !\u003d null) {\n          t.getExtendsBound().accept(this, p);\n        }\n        if (t.getSuperBound() !\u003d null) {\n          t.getSuperBound().accept(this, p);\n        }\n        return null;\n      }\n    }, packages);\n    return packages.build();\n  }\n\n  /**\n   * If this binding\u0027s key\u0027s type parameters are different from those of the\n   * {@link #bindingTypeElement()}, this is the binding for the {@link #bindingTypeElement()}\u0027s\n   * unresolved type.\n   */\n  abstract Optional\u003c? extends Binding\u003e unresolved();\n\n  /**\n   * The scope of this binding.\n   */\n  Optional\u003cScope\u003e scope() {\n    return Optional.absent();\n  }\n\n  // TODO(sameb): Remove the TypeElement parameter and pull it from the TypeMirror.\n  static boolean hasNonDefaultTypeParameters(TypeElement element, TypeMirror type, Types types) {\n    // If the element has no type parameters, nothing can be wrong.\n    if (element.getTypeParameters().isEmpty()) {\n      return false;\n    }\n\n    List\u003cTypeMirror\u003e defaultTypes \u003d Lists.newArrayList();\n    for (TypeParameterElement parameter : element.getTypeParameters()) {\n      defaultTypes.add(parameter.asType());\n    }\n\n    List\u003cTypeMirror\u003e actualTypes \u003d\n        type.accept(\n            new SimpleTypeVisitor6\u003cList\u003cTypeMirror\u003e, Void\u003e() {\n              @Override\n              protected List\u003cTypeMirror\u003e defaultAction(TypeMirror e, Void p) {\n                return ImmutableList.of();\n              }\n\n              @Override\n              public List\u003cTypeMirror\u003e visitDeclared(DeclaredType t, Void p) {\n                return ImmutableList.\u003cTypeMirror\u003ecopyOf(t.getTypeArguments());\n              }\n            },\n            null);\n\n    // The actual type parameter size can be different if the user is using a raw type.\n    if (defaultTypes.size() !\u003d actualTypes.size()) {\n      return true;\n    }\n\n    for (int i \u003d 0; i \u003c defaultTypes.size(); i++) {\n      if (!types.isSameType(defaultTypes.get(i), actualTypes.get(i))) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\BindingDeclaration.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static dagger.internal.codegen.Util.ENCLOSING_TYPE_ELEMENT;\n\nimport com.google.common.base.Optional;\nimport dagger.internal.codegen.Key.HasKey;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.TypeElement;\n\n/** An object that declares or specifies a binding. */\nabstract class BindingDeclaration implements HasKey {\n\n  /**\n   * The {@link Element} that declares the binding. Absent for bindings without identifying\n   * declarations.\n   */\n  abstract Optional\u003cElement\u003e bindingElement();\n\n  /**\n   * The type enclosing the {@link #bindingElement()}, or {@link Optional#absent()} if {@link\n   * #bindingElement()} is absent.\n   */\n  Optional\u003cTypeElement\u003e bindingTypeElement() {\n    return bindingElement().transform(element -\u003e element.accept(ENCLOSING_TYPE_ELEMENT, null));\n  }\n  \n  /**\n   * The installed module class that contributed the {@link #bindingElement()}. May be a subclass of\n   * the class that contains {@link #bindingElement()}. Absent if {@link #bindingElement()} is\n   * absent.\n   */\n  abstract Optional\u003cTypeElement\u003e contributingModule();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\BindingDeclarationFormatter.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;\nimport static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;\nimport static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;\nimport static dagger.internal.codegen.Util.AS_DECLARED_TYPE;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Iterables;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.type.TypeMirror;\n\n/**\n * Formats a {@link BindingDeclaration} into a {@link String} suitable for use in error messages.\n */\nfinal class BindingDeclarationFormatter extends Formatter\u003cBindingDeclaration\u003e {\n  private final MethodSignatureFormatter methodSignatureFormatter;\n\n  BindingDeclarationFormatter(MethodSignatureFormatter methodSignatureFormatter) {\n    this.methodSignatureFormatter \u003d methodSignatureFormatter;\n  }\n\n  @Override\n  public String format(BindingDeclaration bindingDeclaration) {\n    if (bindingDeclaration instanceof SubcomponentDeclaration) {\n      return formatSubcomponentDeclaration((SubcomponentDeclaration) bindingDeclaration);\n    }\n    checkArgument(\n        bindingDeclaration.bindingElement().isPresent(),\n        \"Cannot format bindings without source elements: %s\",\n        bindingDeclaration);\n\n    Element bindingElement \u003d bindingDeclaration.bindingElement().get();\n    switch (bindingElement.asType().getKind()) {\n      case EXECUTABLE:\n        return methodSignatureFormatter.format(\n            MoreElements.asExecutable(bindingElement),\n            bindingDeclaration.contributingModule().transform(AS_DECLARED_TYPE));\n      case DECLARED:\n        return stripCommonTypePrefixes(bindingElement.asType().toString());\n      default:\n        throw new IllegalArgumentException(\"Formatting unsupported for element: \" + bindingElement);\n    }\n  }\n\n  private String formatSubcomponentDeclaration(SubcomponentDeclaration subcomponentDeclaration) {\n    ImmutableList\u003cTypeMirror\u003e moduleSubcomponents \u003d\n        getModuleSubcomponents(subcomponentDeclaration.moduleAnnotation());\n    int index \u003d\n        Iterables.indexOf(\n            moduleSubcomponents,\n            MoreTypes.equivalence()\n                .equivalentTo(subcomponentDeclaration.subcomponentType().asType()));\n    StringBuilder annotationValue \u003d new StringBuilder();\n    if (moduleSubcomponents.size() !\u003d 1) {\n      annotationValue.append(\"{\");\n    }\n    annotationValue.append(\n        formatArgumentInList(\n            index,\n            moduleSubcomponents.size(),\n            subcomponentDeclaration.subcomponentType().getQualifiedName() + \".class\"));\n    if (moduleSubcomponents.size() !\u003d 1) {\n      annotationValue.append(\"}\");\n    }\n\n    return String.format(\n        \"@%s(subcomponents \u003d %s) for %s\",\n        simpleName(subcomponentDeclaration.moduleAnnotation()),\n        annotationValue,\n        subcomponentDeclaration.contributingModule().get());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\BindingGraph.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getAnnotationMirror;\nimport static com.google.auto.common.MoreElements.hasModifiers;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.not;\nimport static com.google.common.base.Verify.verify;\nimport static com.google.common.collect.Iterables.isEmpty;\nimport static dagger.internal.codegen.BindingKey.contribution;\nimport static dagger.internal.codegen.ComponentDescriptor.Kind.PRODUCTION_COMPONENT;\nimport static dagger.internal.codegen.ComponentDescriptor.isComponentContributionMethod;\nimport static dagger.internal.codegen.ComponentDescriptor.isComponentProductionMethod;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;\nimport static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;\nimport static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;\nimport static dagger.internal.codegen.Key.indexByKey;\nimport static dagger.internal.codegen.Scope.reusableScope;\nimport static javax.lang.model.element.Modifier.ABSTRACT;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.base.VerifyException;\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.collect.TreeTraverser;\nimport dagger.Component;\nimport dagger.Reusable;\nimport dagger.Subcomponent;\nimport dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;\nimport dagger.internal.codegen.ContributionBinding.Kind;\nimport dagger.internal.codegen.Key.HasKey;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport dagger.producers.ProductionComponent;\nimport java.util.ArrayDeque;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.util.ElementFilter;\nimport javax.lang.model.util.Elements;\n\n/**\n * The canonical representation of a full-resolved graph.\n *\n * @author Gregory Kick\n */\n@AutoValue\nabstract class BindingGraph {\n  abstract ComponentDescriptor componentDescriptor();\n  abstract ImmutableMap\u003cBindingKey, ResolvedBindings\u003e resolvedBindings();\n  abstract ImmutableSet\u003cBindingGraph\u003e subgraphs();\n\n  /**\n   * Returns the set of modules that are owned by this graph regardless of whether or not any of\n   * their bindings are used in this graph. For graphs representing top-level {@link Component\n   * components}, this set will be the same as\n   * {@linkplain ComponentDescriptor#transitiveModules the component\u0027s transitive modules}. For\n   * {@linkplain Subcomponent subcomponents}, this set will be the transitive modules that are not\n   * owned by any of their ancestors.\n   */\n  abstract ImmutableSet\u003cModuleDescriptor\u003e ownedModules();\n\n  ImmutableSet\u003cTypeElement\u003e ownedModuleTypes() {\n    return FluentIterable.from(ownedModules()).transform(ModuleDescriptor::moduleElement).toSet();\n  }\n\n  private static final TreeTraverser\u003cBindingGraph\u003e SUBGRAPH_TRAVERSER \u003d\n      new TreeTraverser\u003cBindingGraph\u003e() {\n        @Override\n        public Iterable\u003cBindingGraph\u003e children(BindingGraph node) {\n          return node.subgraphs();\n        }\n      };\n\n  /**\n   * The types for which the component needs instances.\n   * \u003cul\u003e\n   * \u003cli\u003ecomponent dependencies\n   * \u003cli\u003e{@linkplain #ownedModules() owned modules} with concrete instance bindings that are used in\n   *     the graph\n   * \u003c/ul\u003e\n   */\n  ImmutableSet\u003cTypeElement\u003e componentRequirements() {\n    return SUBGRAPH_TRAVERSER\n        .preOrderTraversal(this)\n        .transformAndConcat(graph -\u003e graph.resolvedBindings().values())\n        .transformAndConcat(ResolvedBindings::contributionBindings)\n        .filter(ContributionBinding::requiresModuleInstance)\n        .transformAndConcat(bindingDeclaration -\u003e bindingDeclaration.contributingModule().asSet())\n        .filter(in(ownedModuleTypes()))\n        .append(componentDescriptor().dependencies())\n        .toSet();\n  }\n  /**\n   * Returns the {@link ComponentDescriptor}s for this component and its subcomponents.\n   */\n  ImmutableSet\u003cComponentDescriptor\u003e componentDescriptors() {\n    return SUBGRAPH_TRAVERSER\n        .preOrderTraversal(this)\n        .transform(BindingGraph::componentDescriptor)\n        .toSet();\n  }\n\n  ImmutableSet\u003cTypeElement\u003e availableDependencies() {\n    return FluentIterable.from(componentDescriptor().transitiveModuleTypes())\n        .filter(not(hasModifiers(ABSTRACT)))\n        .append(componentDescriptor().dependencies())\n        .toSet();\n  }\n\n  static final class Factory {\n    private final Elements elements;\n    private final InjectBindingRegistry injectBindingRegistry;\n    private final Key.Factory keyFactory;\n    private final ProvisionBinding.Factory provisionBindingFactory;\n    private final ProductionBinding.Factory productionBindingFactory;\n\n    Factory(\n        Elements elements,\n        InjectBindingRegistry injectBindingRegistry,\n        Key.Factory keyFactory,\n        ProvisionBinding.Factory provisionBindingFactory,\n        ProductionBinding.Factory productionBindingFactory) {\n      this.elements \u003d elements;\n      this.injectBindingRegistry \u003d injectBindingRegistry;\n      this.keyFactory \u003d keyFactory;\n      this.provisionBindingFactory \u003d provisionBindingFactory;\n      this.productionBindingFactory \u003d productionBindingFactory;\n    }\n\n    BindingGraph create(ComponentDescriptor componentDescriptor) {\n      return create(Optional.\u003cResolver\u003eabsent(), componentDescriptor);\n    }\n\n    private BindingGraph create(\n        Optional\u003cResolver\u003e parentResolver, ComponentDescriptor componentDescriptor) {\n      ImmutableSet.Builder\u003cContributionBinding\u003e explicitBindingsBuilder \u003d ImmutableSet.builder();\n      ImmutableSet.Builder\u003cDelegateDeclaration\u003e delegatesBuilder \u003d ImmutableSet.builder();\n      ImmutableSet.Builder\u003cOptionalBindingDeclaration\u003e optionalsBuilder \u003d ImmutableSet.builder();\n\n      // binding for the component itself\n      TypeElement componentDefinitionType \u003d componentDescriptor.componentDefinitionType();\n      explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDefinitionType));\n\n      // Collect Component dependencies.\n      Optional\u003cAnnotationMirror\u003e componentMirror \u003d\n          getAnnotationMirror(componentDefinitionType, Component.class)\n              .or(getAnnotationMirror(componentDefinitionType, ProductionComponent.class));\n      ImmutableSet\u003cTypeElement\u003e componentDependencyTypes \u003d componentMirror.isPresent()\n          ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror.get()))\n          : ImmutableSet.\u003cTypeElement\u003eof();\n      for (TypeElement componentDependency : componentDependencyTypes) {\n        explicitBindingsBuilder.add(provisionBindingFactory.forComponent(componentDependency));\n        List\u003cExecutableElement\u003e dependencyMethods \u003d\n            ElementFilter.methodsIn(elements.getAllMembers(componentDependency));\n        for (ExecutableElement method : dependencyMethods) {\n          // MembersInjection methods aren\u0027t \"provided\" explicitly, so ignore them.\n          if (isComponentContributionMethod(elements, method)) {\n            explicitBindingsBuilder.add(\n                componentDescriptor.kind().equals(PRODUCTION_COMPONENT)\n                        \u0026\u0026 isComponentProductionMethod(elements, method)\n                    ? productionBindingFactory.forComponentMethod(method)\n                    : provisionBindingFactory.forComponentMethod(method));\n          }\n        }\n      }\n\n      for (Map.Entry\u003cComponentMethodDescriptor, ComponentDescriptor\u003e\n          componentMethodAndSubcomponent :\n              componentDescriptor.subcomponentsByBuilderMethod().entrySet()) {\n        ComponentMethodDescriptor componentMethod \u003d componentMethodAndSubcomponent.getKey();\n        ComponentDescriptor subcomponentDescriptor \u003d componentMethodAndSubcomponent.getValue();\n        if (!componentDescriptor.subcomponentsFromModules().contains(subcomponentDescriptor)) {\n          explicitBindingsBuilder.add(\n              provisionBindingFactory.forSubcomponentBuilderMethod(\n                  componentMethod.methodElement(),\n                  componentDescriptor.componentDefinitionType()));\n        }\n      }\n\n      ImmutableSet.Builder\u003cMultibindingDeclaration\u003e multibindingDeclarations \u003d\n          ImmutableSet.builder();\n      ImmutableSet.Builder\u003cSubcomponentDeclaration\u003e subcomponentDeclarations \u003d\n          ImmutableSet.builder();\n\n      // Collect transitive module bindings and multibinding declarations.\n      for (ModuleDescriptor moduleDescriptor : componentDescriptor.transitiveModules()) {\n        explicitBindingsBuilder.addAll(moduleDescriptor.bindings());\n        multibindingDeclarations.addAll(moduleDescriptor.multibindingDeclarations());\n        subcomponentDeclarations.addAll(moduleDescriptor.subcomponentDeclarations());\n        delegatesBuilder.addAll(moduleDescriptor.delegateDeclarations());\n        optionalsBuilder.addAll(moduleDescriptor.optionalDeclarations());\n      }\n\n      final Resolver requestResolver \u003d\n          new Resolver(\n              parentResolver,\n              componentDescriptor,\n              indexByKey(explicitBindingsBuilder.build()),\n              indexByKey(multibindingDeclarations.build()),\n              indexByKey(subcomponentDeclarations.build()),\n              indexByKey(delegatesBuilder.build()),\n              indexByKey(optionalsBuilder.build()));\n      for (ComponentMethodDescriptor componentMethod : componentDescriptor.componentMethods()) {\n        Optional\u003cDependencyRequest\u003e componentMethodRequest \u003d componentMethod.dependencyRequest();\n        if (componentMethodRequest.isPresent()) {\n          requestResolver.resolve(componentMethodRequest.get().bindingKey());\n        }\n      }\n\n      // Resolve all bindings for subcomponents, creating subgraphs for all subcomponents that have\n      // been detected during binding resolution. If a binding for a subcomponent is never resolved,\n      // no BindingGraph will be created for it and no implementation will be generated. This is\n      // done in a queue since resolving one subcomponent might resolve a key for a subcomponent\n      // from a parent graph. This is done until no more new subcomponents are resolved.\n      Set\u003cComponentDescriptor\u003e resolvedSubcomponents \u003d new HashSet\u003c\u003e();\n      ImmutableSet.Builder\u003cBindingGraph\u003e subgraphs \u003d ImmutableSet.builder();\n      for (ComponentDescriptor subcomponent :\n          Iterables.consumingIterable(requestResolver.subcomponentsToResolve)) {\n        if (resolvedSubcomponents.add(subcomponent)) {\n          subgraphs.add(create(Optional.of(requestResolver), subcomponent));\n        }\n      }\n\n      for (ResolvedBindings resolvedBindings : requestResolver.getResolvedBindings().values()) {\n        verify(\n            resolvedBindings.owningComponent().equals(componentDescriptor),\n            \"%s is not owned by %s\",\n            resolvedBindings,\n            componentDescriptor);\n      }\n\n      return new AutoValue_BindingGraph(\n          componentDescriptor,\n          requestResolver.getResolvedBindings(),\n          subgraphs.build(),\n          requestResolver.getOwnedModules());\n    }\n\n    private final class Resolver {\n      final Optional\u003cResolver\u003e parentResolver;\n      final ComponentDescriptor componentDescriptor;\n      final ImmutableSetMultimap\u003cKey, ContributionBinding\u003e explicitBindings;\n      final ImmutableSet\u003cContributionBinding\u003e explicitBindingsSet;\n      final ImmutableSetMultimap\u003cKey, ContributionBinding\u003e explicitMultibindings;\n      final ImmutableSetMultimap\u003cKey, MultibindingDeclaration\u003e multibindingDeclarations;\n      final ImmutableSetMultimap\u003cKey, SubcomponentDeclaration\u003e subcomponentDeclarations;\n      final ImmutableSetMultimap\u003cKey, DelegateDeclaration\u003e delegateDeclarations;\n      final ImmutableSetMultimap\u003cKey, OptionalBindingDeclaration\u003e optionalBindingDeclarations;\n      final ImmutableSetMultimap\u003cKey, DelegateDeclaration\u003e delegateMultibindingDeclarations;\n      final Map\u003cBindingKey, ResolvedBindings\u003e resolvedBindings;\n      final Deque\u003cBindingKey\u003e cycleStack \u003d new ArrayDeque\u003c\u003e();\n      final Cache\u003cBindingKey, Boolean\u003e dependsOnLocalMultibindingsCache \u003d\n          CacheBuilder.newBuilder().build();\n      final Cache\u003cBinding, Boolean\u003e bindingDependsOnLocalMultibindingsCache \u003d\n          CacheBuilder.newBuilder().build();\n      final Queue\u003cComponentDescriptor\u003e subcomponentsToResolve \u003d new ArrayDeque\u003c\u003e();\n\n      Resolver(\n          Optional\u003cResolver\u003e parentResolver,\n          ComponentDescriptor componentDescriptor,\n          ImmutableSetMultimap\u003cKey, ContributionBinding\u003e explicitBindings,\n          ImmutableSetMultimap\u003cKey, MultibindingDeclaration\u003e multibindingDeclarations,\n          ImmutableSetMultimap\u003cKey, SubcomponentDeclaration\u003e subcomponentDeclarations,\n          ImmutableSetMultimap\u003cKey, DelegateDeclaration\u003e delegateDeclarations,\n          ImmutableSetMultimap\u003cKey, OptionalBindingDeclaration\u003e optionalBindingDeclarations) {\n        this.parentResolver \u003d checkNotNull(parentResolver);\n        this.componentDescriptor \u003d checkNotNull(componentDescriptor);\n        this.explicitBindings \u003d checkNotNull(explicitBindings);\n        this.explicitBindingsSet \u003d ImmutableSet.copyOf(explicitBindings.values());\n        this.multibindingDeclarations \u003d checkNotNull(multibindingDeclarations);\n        this.subcomponentDeclarations \u003d checkNotNull(subcomponentDeclarations);\n        this.delegateDeclarations \u003d checkNotNull(delegateDeclarations);\n        this.optionalBindingDeclarations \u003d checkNotNull(optionalBindingDeclarations);\n        this.resolvedBindings \u003d Maps.newLinkedHashMap();\n        this.explicitMultibindings \u003d\n            multibindingContributionsByMultibindingKey(explicitBindingsSet);\n        this.delegateMultibindingDeclarations \u003d\n            multibindingContributionsByMultibindingKey(delegateDeclarations.values());\n        subcomponentsToResolve.addAll(componentDescriptor.subcomponentsFromEntryPoints());\n      }\n\n      /**\n       * Returns the bindings for the given {@link BindingKey}.\n       *\n       * \u003cp\u003eFor {@link BindingKey.Kind#CONTRIBUTION} requests, returns all of:\n       *\n       * \u003cul\u003e\n       * \u003cli\u003eAll explicit bindings for:\n       *     \u003cul\u003e\n       *     \u003cli\u003ethe requested key\n       *     \u003cli\u003e{@code Set\u003cT\u003e} if the requested key\u0027s type is {@code Set\u003cProduced\u003cT\u003e\u003e}\n       *     \u003cli\u003e{@code Map\u003cK, Provider\u003cV\u003e\u003e} if the requested key\u0027s type is {@code Map\u003cK,\n       *         Producer\u003cV\u003e\u003e}.\n       *     \u003c/ul\u003e\n       *\n       * \u003cli\u003eA synthetic binding that depends on {@code Map\u003cK, Producer\u003cV\u003e\u003e} if the requested key\u0027s\n       *     type is {@code Map\u003cK, V\u003e} and there are some explicit bindings for {@code Map\u003cK,\n       *     Producer\u003cV\u003e\u003e}.\n       * \u003cli\u003eA synthetic binding that depends on {@code Map\u003cK, Provider\u003cV\u003e\u003e} if the requested key\u0027s\n       *     type is {@code Map\u003cK, V\u003e} and there are some explicit bindings for {@code Map\u003cK,\n       *     Provider\u003cV\u003e\u003e} but no explicit bindings for {@code Map\u003cK, Producer\u003cV\u003e\u003e}.\n       * \u003cli\u003eAn implicit {@link Inject @Inject}-annotated constructor binding if there is one and\n       *     there are no explicit bindings or synthetic bindings.\n       * \u003c/ul\u003e\n       *\n       * \u003cp\u003eFor {@link BindingKey.Kind#MEMBERS_INJECTION} requests, returns the {@link\n       * MembersInjectionBinding} for the type.\n       */\n      ResolvedBindings lookUpBindings(BindingKey bindingKey) {\n        Key requestKey \u003d bindingKey.key();\n        switch (bindingKey.kind()) {\n          case CONTRIBUTION:\n            Set\u003cContributionBinding\u003e contributionBindings \u003d new LinkedHashSet\u003c\u003e();\n            ImmutableSet.Builder\u003cContributionBinding\u003e multibindingContributionsBuilder \u003d\n                ImmutableSet.builder();\n            ImmutableSet.Builder\u003cMultibindingDeclaration\u003e multibindingDeclarationsBuilder \u003d\n                ImmutableSet.builder();\n            ImmutableSet.Builder\u003cSubcomponentDeclaration\u003e subcomponentDeclarationsBuilder \u003d\n                ImmutableSet.builder();\n            ImmutableSet.Builder\u003cOptionalBindingDeclaration\u003e optionalBindingDeclarationsBuilder \u003d\n                ImmutableSet.builder();\n\n            for (Key key : keysMatchingRequest(requestKey)) {\n              contributionBindings.addAll(getExplicitBindings(key));\n              multibindingContributionsBuilder.addAll(getExplicitMultibindings(key));\n              multibindingDeclarationsBuilder.addAll(getMultibindingDeclarations(key));\n              subcomponentDeclarationsBuilder.addAll(getSubcomponentDeclarations(key));\n              optionalBindingDeclarationsBuilder.addAll(getOptionalBindingDeclarations(key));\n            }\n\n            ImmutableSet\u003cContributionBinding\u003e multibindingContributions \u003d\n                multibindingContributionsBuilder.build();\n            ImmutableSet\u003cMultibindingDeclaration\u003e multibindingDeclarations \u003d\n                multibindingDeclarationsBuilder.build();\n            ImmutableSet\u003cSubcomponentDeclaration\u003e subcomponentDeclarations \u003d\n                subcomponentDeclarationsBuilder.build();\n            ImmutableSet\u003cOptionalBindingDeclaration\u003e optionalBindingDeclarations \u003d\n                optionalBindingDeclarationsBuilder.build();\n\n            contributionBindings.addAll(syntheticMapOfValuesBinding(requestKey).asSet());\n            contributionBindings.addAll(\n                syntheticMultibinding(\n                        requestKey, multibindingContributions, multibindingDeclarations)\n                    .asSet());\n            Optional\u003cProvisionBinding\u003e subcomponentBuilderBinding \u003d\n                syntheticSubcomponentBuilderBinding(subcomponentDeclarations);\n            if (subcomponentBuilderBinding.isPresent()) {\n              contributionBindings.add(subcomponentBuilderBinding.get());\n              addSubcomponentToOwningResolver(subcomponentBuilderBinding.get());\n            }\n            contributionBindings.addAll(\n                syntheticOptionalBinding(requestKey, optionalBindingDeclarations).asSet());\n\n            /* If there are no bindings, add the implicit @Inject-constructed binding if there is\n             * one. */\n            if (contributionBindings.isEmpty()) {\n              contributionBindings.addAll(\n                  injectBindingRegistry.getOrFindProvisionBinding(requestKey).asSet());\n            }\n\n            return ResolvedBindings.forContributionBindings(\n                bindingKey,\n                componentDescriptor,\n                indexBindingsByOwningComponent(\n                    bindingKey, ImmutableSet.copyOf(contributionBindings)),\n                multibindingDeclarations,\n                subcomponentDeclarations,\n                optionalBindingDeclarations);\n\n          case MEMBERS_INJECTION:\n            // no explicit deps for members injection, so just look it up\n            Optional\u003cMembersInjectionBinding\u003e binding \u003d\n                injectBindingRegistry.getOrFindMembersInjectionBinding(requestKey);\n            return binding.isPresent()\n                ? ResolvedBindings.forMembersInjectionBinding(\n                    bindingKey, componentDescriptor, binding.get())\n                : ResolvedBindings.noBindings(bindingKey, componentDescriptor);\n\n          default:\n            throw new AssertionError();\n        }\n      }\n\n      /**\n       * When a binding is resolved for a {@link SubcomponentDeclaration}, adds corresponding\n       * {@link ComponentDescriptor subcomponent} to a queue in the owning component\u0027s resolver.\n       * The queue will be used to detect which subcomponents need to be resolved.\n       */\n      private void addSubcomponentToOwningResolver(ProvisionBinding subcomponentBuilderBinding) {\n        checkArgument(subcomponentBuilderBinding.bindingKind().equals(Kind.SUBCOMPONENT_BUILDER));\n        Resolver owningResolver \u003d getOwningResolver(subcomponentBuilderBinding).get();\n\n        TypeElement builderType \u003d MoreTypes.asTypeElement(subcomponentBuilderBinding.key().type());\n        owningResolver.subcomponentsToResolve.add(\n            owningResolver.componentDescriptor.subcomponentsByBuilderType().get(builderType));\n      }\n\n      private Iterable\u003cKey\u003e keysMatchingRequest(Key requestKey) {\n        return ImmutableSet.\u003cKey\u003ebuilder()\n            .add(requestKey)\n            .addAll(keyFactory.unwrapSetKey(requestKey, Produced.class).asSet())\n            .addAll(keyFactory.rewrapMapKey(requestKey, Producer.class, Provider.class).asSet())\n            .addAll(keyFactory.rewrapMapKey(requestKey, Provider.class, Producer.class).asSet())\n            .build();\n      }\n\n      /**\n       * If {@code key} is a {@code Map\u003cK, V\u003e} or {@code Map\u003cK, Produced\u003cV\u003e\u003e}, and there are any\n       * multibinding contributions or declarations that apply to that map, returns a synthetic\n       * binding for the {@code key} that depends on an {@linkplain #syntheticMultibinding(Key,\n       * Iterable, Iterable) underlying synthetic multibinding}.\n       *\n       * \u003cp\u003eThe returned binding has the same {@link BindingType} as the underlying synthetic\n       * multibinding.\n       */\n      private Optional\u003cContributionBinding\u003e syntheticMapOfValuesBinding(final Key key) {\n        return syntheticMultibinding(\n                key,\n                multibindingContributionsForValueMap(key),\n                multibindingDeclarationsForValueMap(key))\n            .transform(\n                syntheticMultibinding -\u003e {\n                  switch (syntheticMultibinding.bindingType()) {\n                    case PROVISION:\n                      return provisionBindingFactory.syntheticMapOfValuesBinding(key);\n\n                    case PRODUCTION:\n                      return productionBindingFactory.syntheticMapOfValuesOrProducedBinding(key);\n\n                    default:\n                      throw new VerifyException(syntheticMultibinding.toString());\n                  }\n                });\n      }\n\n      /**\n       * If {@code requestKey} is for {@code Map\u003cK, V\u003e} or {@code Map\u003cK, Produced\u003cV\u003e\u003e}, returns all\n       * multibinding contributions whose key is for {@code Map\u003cK, Provider\u003cV\u003e\u003e} or {@code Map\u003cK,\n       * Producer\u003cV\u003e\u003e} with the same qualifier and {@code K} and {@code V}.\n       */\n      private FluentIterable\u003cContributionBinding\u003e multibindingContributionsForValueMap(\n          Key requestKey) {\n        return keyFactory\n            .implicitFrameworkMapKeys(requestKey)\n            .transformAndConcat(this::getExplicitMultibindings);\n      }\n\n      /**\n       * If {@code requestKey} is for {@code Map\u003cK, V\u003e} or {@code Map\u003cK, Produced\u003cV\u003e\u003e}, returns all\n       * multibinding declarations whose key is for {@code Map\u003cK, Provider\u003cV\u003e\u003e} or {@code Map\u003cK,\n       * Producer\u003cV\u003e\u003e} with the same qualifier and {@code K} and {@code V}.\n       */\n      private FluentIterable\u003cMultibindingDeclaration\u003e multibindingDeclarationsForValueMap(\n          Key requestKey) {\n        return keyFactory\n            .implicitFrameworkMapKeys(requestKey)\n            .transformAndConcat(this::getMultibindingDeclarations);\n      }\n\n      /**\n       * Returns a synthetic binding that depends on individual multibinding contributions.\n       *\n       * \u003cp\u003eIf there are no {@code multibindingContributions} or {@code multibindingDeclarations},\n       * returns {@link Optional#absent()}.\n       *\n       * \u003cp\u003eIf there are production {@code multibindingContributions} or the request is for any of\n       * the following types, returns a {@link ProductionBinding}.\n       *\n       * \u003cul\u003e\n       * \u003cli\u003e{@code Set\u003cProduced\u003cT\u003e\u003e}\n       * \u003cli\u003e{@code Map\u003cK, Producer\u003cV\u003e\u003e}\n       * \u003cli\u003e{@code Map\u003cK, Produced\u003cV\u003e\u003e}\n       * \u003c/ul\u003e\n       *\n       * Otherwise, returns a {@link ProvisionBinding}.\n       */\n      private Optional\u003c? extends ContributionBinding\u003e syntheticMultibinding(\n          Key key,\n          Iterable\u003cContributionBinding\u003e multibindingContributions,\n          Iterable\u003cMultibindingDeclaration\u003e multibindingDeclarations) {\n        if (isEmpty(multibindingContributions) \u0026\u0026 isEmpty(multibindingDeclarations)) {\n          return Optional.absent();\n        } else if (multibindingsRequireProduction(multibindingContributions, key)) {\n          return Optional.of(\n              productionBindingFactory.syntheticMultibinding(key, multibindingContributions));\n        } else {\n          return Optional.of(\n              provisionBindingFactory.syntheticMultibinding(key, multibindingContributions));\n        }\n      }\n\n      private boolean multibindingsRequireProduction(\n          Iterable\u003cContributionBinding\u003e multibindingContributions, Key requestKey) {\n        if (MapType.isMap(requestKey)) {\n          MapType mapType \u003d MapType.from(requestKey);\n          if (mapType.valuesAreTypeOf(Producer.class) || mapType.valuesAreTypeOf(Produced.class)) {\n            return true;\n          }\n        } else if (SetType.isSet(requestKey)\n            \u0026\u0026 SetType.from(requestKey).elementsAreTypeOf(Produced.class)) {\n          return true;\n        }\n        return Iterables.any(multibindingContributions,\n            hasBindingType -\u003e hasBindingType.bindingType().equals(BindingType.PRODUCTION));\n      }\n\n      private Optional\u003cProvisionBinding\u003e syntheticSubcomponentBuilderBinding(\n          ImmutableSet\u003cSubcomponentDeclaration\u003e subcomponentDeclarations) {\n        return subcomponentDeclarations.isEmpty()\n            ? Optional.\u003cProvisionBinding\u003eabsent()\n            : Optional.of(\n            provisionBindingFactory.syntheticSubcomponentBuilder(subcomponentDeclarations));\n      }\n\n      /**\n       * Returns a synthetic binding for {@code @Qualifier Optional\u003cType\u003e} if there are any {@code\n       * optionalBindingDeclarations}.\n       *\n       * \u003cp\u003eIf there are no bindings for the underlying key (the key for dependency requests for\n       * {@code Type}), returns a provision binding that always returns {@link Optional#absent()}.\n       *\n       * \u003cp\u003eIf there are any production bindings for the underlying key, returns a production\n       * binding. Otherwise returns a provision binding.\n       */\n      private Optional\u003c? extends ContributionBinding\u003e syntheticOptionalBinding(\n          Key key, ImmutableSet\u003cOptionalBindingDeclaration\u003e optionalBindingDeclarations) {\n        if (optionalBindingDeclarations.isEmpty()) {\n          return Optional.absent();\n        }\n        ResolvedBindings underlyingKeyBindings \u003d\n            lookUpBindings(contribution(keyFactory.unwrapOptional(key).get()));\n        if (underlyingKeyBindings.isEmpty()) {\n          return Optional.of(provisionBindingFactory.syntheticAbsentBinding(key));\n        } else if (underlyingKeyBindings.bindingTypes().contains(BindingType.PRODUCTION)) {\n          return Optional.of(productionBindingFactory.syntheticPresentBinding(key));\n        } else {\n          return Optional.of(provisionBindingFactory.syntheticPresentBinding(key));\n        }\n      }\n\n      private ImmutableSet\u003cContributionBinding\u003e createDelegateBindings(\n          ImmutableSet\u003cDelegateDeclaration\u003e delegateDeclarations) {\n        ImmutableSet.Builder\u003cContributionBinding\u003e builder \u003d ImmutableSet.builder();\n        for (DelegateDeclaration delegateDeclaration : delegateDeclarations) {\n          builder.add(createDelegateBinding(delegateDeclaration));\n        }\n        return builder.build();\n      }\n\n      /**\n       * Creates one (and only one) delegate binding for a delegate declaration, based on the\n       * resolved bindings of the right-hand-side of a {@link dagger.Binds} method. If there are\n       * duplicate bindings for the dependency key, there should still be only one binding for the\n       * delegate key.\n       */\n      private ContributionBinding createDelegateBinding(DelegateDeclaration delegateDeclaration) {\n        BindingKey delegateBindingKey \u003d delegateDeclaration.delegateRequest().bindingKey();\n\n        if (cycleStack.contains(delegateBindingKey)) {\n          return provisionBindingFactory.missingDelegate(delegateDeclaration);\n        }\n\n        ResolvedBindings resolvedDelegate;\n        try {\n          cycleStack.push(delegateBindingKey);\n          resolvedDelegate \u003d lookUpBindings(delegateBindingKey);\n        } finally {\n          cycleStack.pop();\n        }\n        if (resolvedDelegate.contributionBindings().isEmpty()) {\n          // This is guaranteed to result in a missing binding error, so it doesn\u0027t matter if the\n          // binding is a Provision or Production, except if it is a @IntoMap method, in which\n          // case the key will be of type Map\u003cK, Provider\u003cV\u003e\u003e, which will be \"upgraded\" into a\n          // Map\u003cK, Producer\u003cV\u003e\u003e if it\u0027s requested in a ProductionComponent. This may result in a\n          // strange error, that the RHS needs to be provided with an @Inject or @Provides\n          // annotated method, but a user should be able to figure out if a @Produces annotation\n          // is needed.\n          // TODO(gak): revisit how we model missing delegates if/when we clean up how we model\n          // binding declarations\n          return provisionBindingFactory.missingDelegate(delegateDeclaration);\n        }\n        // It doesn\u0027t matter which of these is selected, since they will later on produce a\n        // duplicate binding error.\n        // TODO(ronshapiro): Once compile-testing has a CompilationResult, add a test which asserts\n        // that a duplicate binding for the RHS does not result in a duplicate binding for the LHS.\n        ContributionBinding explicitDelegate \u003d\n            resolvedDelegate.contributionBindings().iterator().next();\n        switch (explicitDelegate.bindingType()) {\n          case PRODUCTION:\n            return productionBindingFactory.delegate(\n                delegateDeclaration, (ProductionBinding) explicitDelegate);\n          case PROVISION:\n            return provisionBindingFactory.delegate(\n                delegateDeclaration, (ProvisionBinding) explicitDelegate);\n          default:\n            throw new AssertionError(\"bindingType: \" + explicitDelegate);\n        }\n      }\n\n      private ImmutableSetMultimap\u003cComponentDescriptor, ContributionBinding\u003e\n          indexBindingsByOwningComponent(\n              BindingKey bindingKey, Iterable\u003c? extends ContributionBinding\u003e bindings) {\n        ImmutableSetMultimap.Builder\u003cComponentDescriptor, ContributionBinding\u003e index \u003d\n            ImmutableSetMultimap.builder();\n        for (ContributionBinding binding : bindings) {\n          index.put(getOwningComponent(bindingKey, binding), binding);\n        }\n        return index.build();\n      }\n\n      /**\n       * Returns the component that should contain the framework field for {@code binding}.\n       *\n       * \u003cp\u003eIf {@code binding} is either not bound in an ancestor component or depends on\n       * multibinding contributions in this component, returns this component.\n       *\n       * \u003cp\u003eOtherwise, resolves {@code request} in this component\u0027s parent in order to resolve any\n       * multibinding contributions in the parent, and returns the parent-resolved {@link\n       * ResolvedBindings#owningComponent(ContributionBinding)}.\n       */\n      private ComponentDescriptor getOwningComponent(\n          BindingKey bindingKey, ContributionBinding binding) {\n        if (isResolvedInParent(bindingKey, binding)\n            \u0026\u0026 !new MultibindingDependencies().dependsOnLocalMultibindings(binding)) {\n          ResolvedBindings parentResolvedBindings \u003d\n              parentResolver.get().resolvedBindings.get(bindingKey);\n          return parentResolvedBindings.owningComponent(binding);\n        } else {\n          return componentDescriptor;\n        }\n      }\n\n      /**\n       * Returns {@code true} if {@code binding} is owned by an ancestor. If so, {@linkplain\n       * #resolve resolves} the {@link BindingKey} in this component\u0027s parent. Don\u0027t resolve\n       * directly in the owning component in case it depends on multibindings in any of its\n       * descendants.\n       */\n      private boolean isResolvedInParent(BindingKey bindingKey, ContributionBinding binding) {\n        Optional\u003cResolver\u003e owningResolver \u003d getOwningResolver(binding);\n        if (owningResolver.isPresent() \u0026\u0026 !owningResolver.get().equals(this)) {\n          parentResolver.get().resolve(bindingKey);\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      private Optional\u003cResolver\u003e getOwningResolver(ContributionBinding binding) {\n        if (binding.scope().isPresent() \u0026\u0026 binding.scope().get().equals(reusableScope(elements))) {\n          for (Resolver requestResolver : getResolverLineage().reverse()) {\n            // If a @Reusable binding was resolved in an ancestor, use that component.\n            if (requestResolver.resolvedBindings.containsKey(\n                BindingKey.contribution(binding.key()))) {\n              return Optional.of(requestResolver);\n            }\n          }\n          // If a @Reusable binding was not resolved in any ancestor, resolve it here.\n          return Optional.absent();\n        }\n\n        for (Resolver requestResolver : getResolverLineage().reverse()) {\n          if (requestResolver.explicitBindingsSet.contains(binding)\n              || requestResolver.subcomponentDeclarations.containsKey(binding.key())) {\n            return Optional.of(requestResolver);\n          }\n        }\n\n        // look for scope separately.  we do this for the case where @Singleton can appear twice\n        // in the † compatibility mode\n        Optional\u003cScope\u003e bindingScope \u003d binding.scope();\n        if (bindingScope.isPresent()) {\n          for (Resolver requestResolver : getResolverLineage().reverse()) {\n            if (requestResolver.componentDescriptor.scopes().contains(bindingScope.get())) {\n              return Optional.of(requestResolver);\n            }\n          }\n        }\n        return Optional.absent();\n      }\n\n      /** Returns the resolver lineage from parent to child. */\n      private ImmutableList\u003cResolver\u003e getResolverLineage() {\n        List\u003cResolver\u003e resolverList \u003d Lists.newArrayList();\n        for (Optional\u003cResolver\u003e currentResolver \u003d Optional.of(this);\n            currentResolver.isPresent();\n            currentResolver \u003d currentResolver.get().parentResolver) {\n          resolverList.add(currentResolver.get());\n        }\n        return ImmutableList.copyOf(Lists.reverse(resolverList));\n      }\n\n      /**\n       * Returns the explicit {@link ContributionBinding}s that match the {@code requestKey} from\n       * this and all ancestor resolvers.\n       */\n      private ImmutableSet\u003cContributionBinding\u003e getExplicitBindings(Key requestKey) {\n        ImmutableSet.Builder\u003cContributionBinding\u003e bindings \u003d ImmutableSet.builder();\n        for (Resolver resolver : getResolverLineage()) {\n          bindings.addAll(resolver.getLocalExplicitBindings(requestKey));\n        }\n        return bindings.build();\n      }\n\n      /**\n       * Returns the explicit {@link ContributionBinding}s that match the {@code requestKey} from\n       * this resolver.\n       */\n      private ImmutableSet\u003cContributionBinding\u003e getLocalExplicitBindings(Key requestKey) {\n        return new ImmutableSet.Builder\u003cContributionBinding\u003e()\n            .addAll(explicitBindings.get(requestKey))\n            .addAll(\n                createDelegateBindings(\n                    delegateDeclarations.get(keyFactory.convertToDelegateKey(requestKey))))\n            .build();\n      }\n\n      /**\n       * Returns the explicit multibinding contributions that contribute to the map or set requested\n       * by {@code requestKey} from this and all ancestor resolvers.\n       */\n      private ImmutableSet\u003cContributionBinding\u003e getExplicitMultibindings(Key requestKey) {\n        ImmutableSet.Builder\u003cContributionBinding\u003e multibindings \u003d ImmutableSet.builder();\n        Key delegateDeclarationKey \u003d keyFactory.convertToDelegateKey(requestKey);\n        for (Resolver resolver : getResolverLineage()) {\n          multibindings.addAll(resolver.explicitMultibindings.get(requestKey));\n          if (!MapType.isMap(requestKey) || MapType.from(requestKey).valuesAreFrameworkType()) {\n            // There are no @Binds @IntoMap delegate declarations for Map\u003cK, V\u003e requests. All\n            // @IntoMap requests must be for Map\u003cK, Framework\u003cV\u003e\u003e.\n            multibindings.addAll(\n                createDelegateBindings(\n                    resolver.delegateMultibindingDeclarations.get(delegateDeclarationKey)));\n          }\n        }\n        return multibindings.build();\n      }\n\n      /**\n       * Returns the {@link MultibindingDeclaration}s that match the {@code key} from this and all\n       * ancestor resolvers.\n       */\n      private ImmutableSet\u003cMultibindingDeclaration\u003e getMultibindingDeclarations(Key key) {\n        ImmutableSet.Builder\u003cMultibindingDeclaration\u003e multibindingDeclarations \u003d\n            ImmutableSet.builder();\n        for (Resolver resolver : getResolverLineage()) {\n          multibindingDeclarations.addAll(resolver.multibindingDeclarations.get(key));\n        }\n        return multibindingDeclarations.build();\n      }\n\n      /**\n       * Returns the {@link SubcomponentDeclaration}s that match the {@code key} from this and all\n       * ancestor resolvers.\n       */\n      private ImmutableSet\u003cSubcomponentDeclaration\u003e getSubcomponentDeclarations(Key key) {\n        ImmutableSet.Builder\u003cSubcomponentDeclaration\u003e subcomponentDeclarations \u003d\n            ImmutableSet.builder();\n        for (Resolver resolver : getResolverLineage()) {\n          subcomponentDeclarations.addAll(resolver.subcomponentDeclarations.get(key));\n        }\n        return subcomponentDeclarations.build();\n      }\n      /**\n       * Returns the {@link OptionalBindingDeclaration}s that match the {@code key} from this and\n       * all ancestor resolvers.\n       */\n      private ImmutableSet\u003cOptionalBindingDeclaration\u003e getOptionalBindingDeclarations(Key key) {\n        Optional\u003cKey\u003e unwrapped \u003d keyFactory.unwrapOptional(key);\n        if (!unwrapped.isPresent()) {\n          return ImmutableSet.of();\n        }\n        ImmutableSet.Builder\u003cOptionalBindingDeclaration\u003e declarations \u003d ImmutableSet.builder();\n        for (Resolver resolver : getResolverLineage()) {\n          declarations.addAll(resolver.optionalBindingDeclarations.get(unwrapped.get()));\n        }\n        return declarations.build();\n      }\n\n      private Optional\u003cResolvedBindings\u003e getPreviouslyResolvedBindings(\n          final BindingKey bindingKey) {\n        Optional\u003cResolvedBindings\u003e result \u003d Optional.fromNullable(resolvedBindings.get(bindingKey));\n        if (result.isPresent()) {\n          return result;\n        } else if (parentResolver.isPresent()) {\n          return parentResolver.get().getPreviouslyResolvedBindings(bindingKey);\n        } else {\n          return Optional.absent();\n        }\n      }\n\n      void resolve(BindingKey bindingKey) {\n        // If we find a cycle, stop resolving. The original request will add it with all of the\n        // other resolved deps.\n        if (cycleStack.contains(bindingKey)) {\n          return;\n        }\n\n        // If the binding was previously resolved in this (sub)component, don\u0027t resolve it again.\n        if (resolvedBindings.containsKey(bindingKey)) {\n          return;\n        }\n\n        /* If the binding was previously resolved in a supercomponent, then we may be able to avoid\n         * resolving it here and just depend on the supercomponent resolution.\n         *\n         * 1. If it depends on multibindings with contributions from this subcomponent, then we have\n         *    to resolve it in this subcomponent so that it sees the local contributions.\n         *\n         * 2. If there are any explicit bindings in this component, they may conflict with those in\n         *    the supercomponent, so resolve them here so that conflicts can be caught.\n         *\n         * 3. If the previously resolved binding is an optional binding, and there are any explicit\n         *    bindings for the underlying key in this component, resolve here so that absent\n         *    bindings in the parent can be overridden by present bindings here.\n         */\n        if (getPreviouslyResolvedBindings(bindingKey).isPresent()) {\n          /* Resolve in the parent in case there are multibinding contributions or conflicts in some\n           * component between this one and the previously-resolved one. */\n          parentResolver.get().resolve(bindingKey);\n          if (!new MultibindingDependencies().dependsOnLocalMultibindings(bindingKey)\n              \u0026\u0026 getLocalExplicitBindings(bindingKey.key()).isEmpty()\n              \u0026\u0026 !hasLocallyPresentOptionalBinding(bindingKey)) {\n            /* Cache the inherited parent component\u0027s bindings in case resolving at the parent found\n             * bindings in some component between this one and the previously-resolved one. */\n            ResolvedBindings inheritedBindings \u003d\n                getPreviouslyResolvedBindings(bindingKey).get().asInheritedIn(componentDescriptor);\n            resolvedBindings.put(bindingKey, inheritedBindings);\n            return;\n          }\n        }\n\n        cycleStack.push(bindingKey);\n        try {\n          ResolvedBindings bindings \u003d lookUpBindings(bindingKey);\n          for (Binding binding : bindings.ownedBindings()) {\n            for (DependencyRequest dependency : binding.implicitDependencies()) {\n              resolve(dependency.bindingKey());\n            }\n          }\n          resolvedBindings.put(bindingKey, bindings);\n        } finally {\n          cycleStack.pop();\n        }\n      }\n\n      ImmutableMap\u003cBindingKey, ResolvedBindings\u003e getResolvedBindings() {\n        ImmutableMap.Builder\u003cBindingKey, ResolvedBindings\u003e resolvedBindingsBuilder \u003d\n            ImmutableMap.builder();\n        resolvedBindingsBuilder.putAll(resolvedBindings);\n        if (parentResolver.isPresent()) {\n          Collection\u003cResolvedBindings\u003e bindingsResolvedInParent \u003d\n              Maps.difference(parentResolver.get().getResolvedBindings(), resolvedBindings)\n                  .entriesOnlyOnLeft()\n                  .values();\n          for (ResolvedBindings resolvedInParent : bindingsResolvedInParent) {\n            resolvedBindingsBuilder.put(\n                resolvedInParent.bindingKey(),\n                resolvedInParent.asInheritedIn(componentDescriptor));\n          }\n        }\n        return resolvedBindingsBuilder.build();\n      }\n\n      ImmutableSet\u003cModuleDescriptor\u003e getInheritedModules() {\n        return parentResolver.isPresent()\n            ? Sets.union(\n                    parentResolver.get().getInheritedModules(),\n                    parentResolver.get().componentDescriptor.transitiveModules())\n                .immutableCopy()\n            : ImmutableSet.\u003cModuleDescriptor\u003eof();\n      }\n\n      ImmutableSet\u003cModuleDescriptor\u003e getOwnedModules() {\n        return Sets.difference(componentDescriptor.transitiveModules(), getInheritedModules())\n            .immutableCopy();\n      }\n\n      /**\n       * Returns {@code true} if {@code bindingKey} was previously resolved to an optional binding\n       * for which there is an explicit present binding in this component.\n       */\n      private boolean hasLocallyPresentOptionalBinding(BindingKey bindingKey) {\n        return Iterables.any(\n            getPreviouslyResolvedBindings(bindingKey).get().contributionBindings(),\n            binding -\u003e\n                binding.bindingKind().equals(SYNTHETIC_OPTIONAL_BINDING)\n                    \u0026\u0026 !getLocalExplicitBindings(keyFactory.unwrapOptional(binding.key()).get())\n                        .isEmpty());\n      }\n\n      private final class MultibindingDependencies {\n        private final Set\u003cObject\u003e cycleChecker \u003d new HashSet\u003c\u003e();\n\n        /**\n         * Returns {@code true} if {@code bindingKey} previously resolved to multibindings with\n         * contributions declared within this component\u0027s modules, or if any of its unscoped\n         * dependencies depend on such local multibindings.\n         *\n         * \u003cp\u003eWe don\u0027t care about scoped dependencies because they will never depend on\n         * multibindings with contributions from subcomponents.\n         *\n         * @throws IllegalArgumentException if {@link #getPreviouslyResolvedBindings(BindingKey)} is\n         *     absent\n         */\n        boolean dependsOnLocalMultibindings(final BindingKey bindingKey) {\n          checkArgument(\n              getPreviouslyResolvedBindings(bindingKey).isPresent(),\n              \"no previously resolved bindings in %s for %s\",\n              Resolver.this,\n              bindingKey);\n          // Don\u0027t recur infinitely if there are valid cycles in the dependency graph.\n          // http://b/23032377\n          if (!cycleChecker.add(bindingKey)) {\n            return false;\n          }\n          try {\n            return dependsOnLocalMultibindingsCache.get(\n                bindingKey,\n                () -\u003e {\n                  ResolvedBindings previouslyResolvedBindings \u003d\n                      getPreviouslyResolvedBindings(bindingKey).get();\n                  if (isMultibindingsWithLocalContributions(previouslyResolvedBindings)) {\n                    return true;\n                  }\n\n                  for (Binding binding : previouslyResolvedBindings.bindings()) {\n                    if (dependsOnLocalMultibindings(binding)) {\n                      return true;\n                    }\n                  }\n                  return false;\n                });\n          } catch (ExecutionException e) {\n            throw new AssertionError(e);\n          }\n        }\n\n        /**\n         * Returns {@code true} if {@code binding} is unscoped (or has {@link Reusable @Reusable}\n         * scope) and depends on multibindings with contributions declared within this component\u0027s\n         * modules, or if any of its unscoped or {@link Reusable @Reusable} scoped dependencies\n         * depend on such local multibindings.\n         *\n         * \u003cp\u003eWe don\u0027t care about non-reusable scoped dependencies because they will never depend on\n         * multibindings with contributions from subcomponents.\n         */\n        boolean dependsOnLocalMultibindings(final Binding binding) {\n          if (!cycleChecker.add(binding)) {\n            return false;\n          }\n          try {\n            return bindingDependsOnLocalMultibindingsCache.get(\n                binding,\n                () -\u003e {\n                  if ((!binding.scope().isPresent()\n                          || binding.scope().get().equals(reusableScope(elements)))\n                      // TODO(beder): Figure out what happens with production subcomponents.\n                      \u0026\u0026 !binding.bindingType().equals(BindingType.PRODUCTION)) {\n                    for (DependencyRequest dependency : binding.implicitDependencies()) {\n                      if (dependsOnLocalMultibindings(dependency.bindingKey())) {\n                        return true;\n                      }\n                    }\n                  }\n                  return false;\n                });\n          } catch (ExecutionException e) {\n            throw new AssertionError(e);\n          }\n        }\n\n        private boolean isMultibindingsWithLocalContributions(ResolvedBindings resolvedBindings) {\n          Key key \u003d resolvedBindings.key();\n          return resolvedBindings.contributionBindings()\n              .stream()\n              .map(ContributionBinding::bindingKind)\n              .anyMatch(SYNTHETIC_MULTIBOUND_KINDS::contains)\n              \u0026\u0026 !getExplicitMultibindings(key)\n              .equals(parentResolver.get().getExplicitMultibindings(key));\n        }\n      }\n    }\n\n    /**\n     * A multimap of those {@code declarations} that are multibinding contribution declarations,\n     * indexed by the key of the set or map to which they contribute.\n     */\n    static \u003cT extends HasKey\u003e\n        ImmutableSetMultimap\u003cKey, T\u003e multibindingContributionsByMultibindingKey(\n            Iterable\u003cT\u003e declarations) {\n      ImmutableSetMultimap.Builder\u003cKey, T\u003e builder \u003d ImmutableSetMultimap.builder();\n      for (T declaration : declarations) {\n        if (declaration.key().multibindingContributionIdentifier().isPresent()) {\n          builder.put(declaration.key().withoutMultibindingContributionIdentifier(), declaration);\n        }\n      }\n      return builder.build();\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\BindingGraphValidator.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getAnnotationMirror;\nimport static com.google.auto.common.MoreTypes.asDeclared;\nimport static com.google.auto.common.MoreTypes.asExecutable;\nimport static com.google.auto.common.MoreTypes.asTypeElements;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Verify.verify;\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static com.google.common.collect.Iterables.indexOf;\nimport static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;\nimport static dagger.internal.codegen.BindingType.PRODUCTION;\nimport static dagger.internal.codegen.BindingType.PROVISION;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getComponentAnnotation;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;\nimport static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;\nimport static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MAP;\nimport static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_KINDS;\nimport static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_MULTIBOUND_MAP;\nimport static dagger.internal.codegen.ContributionBinding.Kind.SYNTHETIC_OPTIONAL_BINDING;\nimport static dagger.internal.codegen.ContributionBinding.indexMapBindingsByAnnotationType;\nimport static dagger.internal.codegen.ContributionBinding.indexMapBindingsByMapKey;\nimport static dagger.internal.codegen.ErrorMessages.CANNOT_INJECT_WILDCARD_TYPE;\nimport static dagger.internal.codegen.ErrorMessages.CONTAINS_DEPENDENCY_CYCLE_FORMAT;\nimport static dagger.internal.codegen.ErrorMessages.DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT;\nimport static dagger.internal.codegen.ErrorMessages.DUPLICATE_BINDINGS_FOR_KEY_FORMAT;\nimport static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;\nimport static dagger.internal.codegen.ErrorMessages.INDENT;\nimport static dagger.internal.codegen.ErrorMessages.MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE;\nimport static dagger.internal.codegen.ErrorMessages.MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT;\nimport static dagger.internal.codegen.ErrorMessages.PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT;\nimport static dagger.internal.codegen.ErrorMessages.PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT;\nimport static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT;\nimport static dagger.internal.codegen.ErrorMessages.REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;\nimport static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_FORMAT;\nimport static dagger.internal.codegen.ErrorMessages.REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;\nimport static dagger.internal.codegen.ErrorMessages.duplicateMapKeysError;\nimport static dagger.internal.codegen.ErrorMessages.inconsistentMapKeyAnnotationsError;\nimport static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;\nimport static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;\nimport static dagger.internal.codegen.Scope.reusableScope;\nimport static dagger.internal.codegen.Util.componentCanMakeNewInstances;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.Collectors.toSet;\nimport static javax.tools.Diagnostic.Kind.ERROR;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Equivalence;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Iterators;\nimport com.google.common.collect.LinkedHashMultiset;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.Ordering;\nimport com.google.common.collect.Sets;\nimport com.squareup.javapoet.TypeName;\nimport dagger.Component;\nimport dagger.Lazy;\nimport dagger.MapKey;\nimport dagger.internal.codegen.ComponentDescriptor.BuilderSpec;\nimport dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;\nimport dagger.internal.codegen.ContributionType.HasContributionType;\nimport java.util.ArrayDeque;\nimport java.util.Collection;\nimport java.util.Deque;\nimport java.util.Formatter;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nimport javax.inject.Provider;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.ArrayType;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.PrimitiveType;\nimport javax.lang.model.type.TypeKind;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.SimpleTypeVisitor6;\nimport javax.lang.model.util.Types;\n\n/** Reports errors in the shape of the binding graph. */\nfinal class BindingGraphValidator {\n\n  private final Elements elements;\n  private final Types types;\n  private final CompilerOptions compilerOptions;\n  private final InjectValidator injectValidator;\n  private final InjectBindingRegistry injectBindingRegistry;\n  private final BindingDeclarationFormatter bindingDeclarationFormatter;\n  private final MethodSignatureFormatter methodSignatureFormatter;\n  private final DependencyRequestFormatter dependencyRequestFormatter;\n  private final KeyFormatter keyFormatter;\n  private final Key.Factory keyFactory;\n\n  BindingGraphValidator(\n      Elements elements,\n      Types types,\n      CompilerOptions compilerOptions,\n      InjectValidator injectValidator,\n      InjectBindingRegistry injectBindingRegistry,\n      BindingDeclarationFormatter bindingDeclarationFormatter,\n      MethodSignatureFormatter methodSignatureFormatter,\n      DependencyRequestFormatter dependencyRequestFormatter,\n      KeyFormatter keyFormatter,\n      Key.Factory keyFactory) {\n    this.elements \u003d elements;\n    this.types \u003d types;\n    this.compilerOptions \u003d compilerOptions;\n    this.injectValidator \u003d injectValidator;\n    this.injectBindingRegistry \u003d injectBindingRegistry;\n    this.bindingDeclarationFormatter \u003d bindingDeclarationFormatter;\n    this.methodSignatureFormatter \u003d methodSignatureFormatter;\n    this.dependencyRequestFormatter \u003d dependencyRequestFormatter;\n    this.keyFormatter \u003d keyFormatter;\n    this.keyFactory \u003d keyFactory;\n  }\n\n  /** A dependency path from an entry point. */\n  static final class DependencyPath {\n    private final Deque\u003cResolvedRequest\u003e path \u003d new ArrayDeque\u003c\u003e();\n    private final LinkedHashMultiset\u003cBindingKey\u003e keyPath \u003d LinkedHashMultiset.create();\n    private final Set\u003cDependencyRequest\u003e resolvedDependencyRequests \u003d new HashSet\u003c\u003e();\n\n    /** The entry point. */\n    Element entryPointElement() {\n      return path.getFirst().dependencyRequest().requestElement().get();\n    }\n\n    /** The current dependency request, which is a transitive dependency of the entry point. */\n    DependencyRequest currentDependencyRequest() {\n      return path.getLast().dependencyRequest();\n    }\n\n    /**\n     * The resolved bindings for the {@linkplain #currentDependencyRequest() current dependency\n     * request.\n     */\n    ResolvedBindings currentResolvedBindings() {\n      return path.getLast().resolvedBindings();\n    }\n\n    /**\n     * The binding that depends on the {@linkplain #currentDependencyRequest() current request}.\n     *\n     * @throws IllegalStateException if there are fewer than two requests in the path\n     */\n    ResolvedBindings previousResolvedBindings() {\n      checkState(size() \u003e 1);\n      return Iterators.get(path.descendingIterator(), 1).resolvedBindings();\n    }\n\n    /**\n     * {@code true} if there is a dependency cycle, which means that the\n     * {@linkplain #currentDependencyRequest() current request}\u0027s binding key occurs earlier in the\n     * path.\n     */\n    boolean hasCycle() {\n      return keyPath.count(currentDependencyRequest().bindingKey()) \u003e 1;\n    }\n\n    /**\n     * If there is a cycle, the segment of the path that represents the cycle. The first request\u0027s\n     * and the last request\u0027s binding keys are equal. The last request is the {@linkplain\n     * #currentDependencyRequest() current request}.\n     *\n     * @throws IllegalStateException if {@link #hasCycle()} is {@code false}\n     */\n    FluentIterable\u003cResolvedRequest\u003e cycle() {\n      checkState(hasCycle(), \"no cycle\");\n      return resolvedRequests()\n          .skip(indexOf(keyPath, Predicates.equalTo(currentDependencyRequest().bindingKey())));\n    }\n\n    /**\n     * Makes {@code request} the current request. Be sure to call {@link #pop()} to back up to the\n     * previous request in the path.\n     */\n    void push(DependencyRequest request, ResolvedBindings resolvedBindings) {\n      path.add(\n          ResolvedRequest.create(\n              request,\n              resolvedBindings,\n              path.isEmpty()\n                  ? Optional.\u003cResolvedBindings\u003eabsent()\n                  : Optional.of(currentResolvedBindings())));\n      keyPath.add(request.bindingKey());\n    }\n\n    /** Makes the previous request the current request. */\n    void pop() {\n      verify(keyPath.remove(path.removeLast().dependencyRequest().bindingKey()));\n    }\n\n    /**\n     * Adds the {@linkplain #currentDependencyRequest() current request} to a set of visited\n     * requests, and returns {@code true} if the set didn\u0027t already contain it.\n     */\n    boolean visitCurrentDependencyRequest() {\n      return resolvedDependencyRequests.add(currentDependencyRequest());\n    }\n\n    int size() {\n      return path.size();\n    }\n\n    /** Returns the resolved dependency requests in this path, starting with the entry point. */\n    FluentIterable\u003cResolvedRequest\u003e resolvedRequests() {\n      return FluentIterable.from(path);\n    }\n  }\n\n  private final class Validation {\n    final BindingGraph subject;\n    final ValidationReport.Builder\u003cTypeElement\u003e reportBuilder;\n    final Optional\u003cValidation\u003e parent;\n    final ImmutableMap\u003cComponentDescriptor, BindingGraph\u003e subgraphsByComponentDescriptor;\n\n    Validation(BindingGraph subject, Optional\u003cValidation\u003e parent) {\n      this.subject \u003d subject;\n      this.reportBuilder \u003d\n          ValidationReport.about(subject.componentDescriptor().componentDefinitionType());\n      this.parent \u003d parent;\n      this.subgraphsByComponentDescriptor \u003d\n          Maps.uniqueIndex(subject.subgraphs(), BindingGraph::componentDescriptor);\n    }\n\n    Validation(BindingGraph topLevelGraph) {\n      this(topLevelGraph, Optional.\u003cValidation\u003eabsent());\n    }\n\n    BindingGraph topLevelGraph() {\n      return parent.isPresent() ? parent.get().topLevelGraph() : subject;\n    }\n\n    ValidationReport.Builder\u003cTypeElement\u003e topLevelReport() {\n      return parent.isPresent() ? parent.get().topLevelReport() : reportBuilder;\n    }\n\n    ValidationReport\u003cTypeElement\u003e buildReport() {\n      return reportBuilder.build();\n    }\n\n    void validateSubgraph() {\n      validateComponentScope();\n      validateDependencyScopes();\n      validateComponentHierarchy();\n      validateBuilders();\n\n      for (ComponentMethodDescriptor componentMethod :\n           subject.componentDescriptor().componentMethods()) {\n        Optional\u003cDependencyRequest\u003e entryPoint \u003d componentMethod.dependencyRequest();\n        if (entryPoint.isPresent()) {\n          traverseDependencyRequest(entryPoint.get(), new DependencyPath());\n        }\n      }\n\n      for (Map.Entry\u003cComponentMethodDescriptor, ComponentDescriptor\u003e entry :\n          subject.componentDescriptor().subcomponentsByFactoryMethod().entrySet()) {\n        validateSubcomponentFactoryMethod(\n            entry.getKey().methodElement(), subgraphsByComponentDescriptor.get(entry.getValue()));\n      }\n\n      for (BindingGraph subgraph : subject.subgraphs()) {\n        Validation subgraphValidation \u003d new Validation(subgraph, Optional.of(this));\n        subgraphValidation.validateSubgraph();\n        reportBuilder.addSubreport(subgraphValidation.buildReport());\n      }\n    }\n\n    private void validateSubcomponentFactoryMethod(\n        ExecutableElement factoryMethod, BindingGraph subgraph) {\n      Set\u003cTypeElement\u003e missingModules \u003d subgraph.componentRequirements()\n          .stream()\n          .filter(componentRequirement -\u003e !subgraphFactoryMethodParameters(factoryMethod)\n              .contains(componentRequirement))\n          .filter(moduleType -\u003e !componentCanMakeNewInstances(moduleType))\n          .collect(toSet());\n      if (!missingModules.isEmpty()) {\n        reportBuilder.addError(\n            String.format(\n                \"%s requires modules which have no visible default constructors. \"\n                    + \"Add the following modules as parameters to this method: %s\",\n                subgraph.componentDescriptor().componentDefinitionType().getQualifiedName(),\n                missingModules.stream().map(Object::toString).collect(joining(\", \"))),\n            factoryMethod);\n      }\n    }\n\n    private ImmutableSet\u003cTypeElement\u003e subgraphFactoryMethodParameters(\n        ExecutableElement factoryMethod) {\n      DeclaredType componentType \u003d\n          asDeclared(subject.componentDescriptor().componentDefinitionType().asType());\n      ExecutableType factoryMethodType \u003d\n          asExecutable(types.asMemberOf(componentType, factoryMethod));\n      return asTypeElements(factoryMethodType.getParameterTypes());\n    }\n\n    /**\n     * Traverse the resolved dependency requests, validating resolved bindings, and reporting any\n     * cycles found.\n     *\n     * @param request the current dependency request\n     */\n    private void traverseDependencyRequest(DependencyRequest request, DependencyPath path) {\n      path.push(request, resolvedBindings(request));\n      try {\n        if (path.hasCycle()) {\n          reportCycle(path);\n          return;\n        }\n\n        if (path.visitCurrentDependencyRequest()) {\n          validateResolvedBindings(path);\n\n          // Validate all dependencies within the component that owns the binding.\n          for (Map.Entry\u003cComponentDescriptor, ? extends Binding\u003e entry :\n              path.currentResolvedBindings().bindingsByComponent()) {\n            Validation validation \u003d validationForComponent(entry.getKey());\n            Binding binding \u003d entry.getValue();\n            for (DependencyRequest nextRequest : binding.implicitDependencies()) {\n              validation.traverseDependencyRequest(nextRequest, path);\n            }\n          }\n        }\n      } finally {\n        path.pop();\n      }\n    }\n\n    private ResolvedBindings resolvedBindings(DependencyRequest request) {\n      BindingKey bindingKey \u003d request.bindingKey();\n      ResolvedBindings resolvedBindings \u003d subject.resolvedBindings().get(bindingKey);\n      return resolvedBindings \u003d\u003d null\n          ? ResolvedBindings.noBindings(bindingKey, subject.componentDescriptor())\n          : resolvedBindings;\n    }\n\n    private Validation validationForComponent(ComponentDescriptor component) {\n      if (component.equals(subject.componentDescriptor())) {\n        return this;\n      } else if (parent.isPresent()) {\n        return parent.get().validationForComponent(component);\n      } else {\n        throw new IllegalArgumentException(\n            String.format(\n                \"unknown component %s within %s\",\n                component.componentDefinitionType(),\n                subject.componentDescriptor().componentDefinitionType()));\n      }\n    }\n\n    /**\n     * Reports errors if the set of bindings resolved is inconsistent with the type of the binding.\n     */\n    private void validateResolvedBindings(DependencyPath path) {\n      ResolvedBindings resolvedBindings \u003d path.currentResolvedBindings();\n      if (resolvedBindings.isEmpty()) {\n        reportMissingBinding(path);\n        return;\n      }\n\n      switch (resolvedBindings.bindingKey().kind()) {\n        case CONTRIBUTION:\n          if (Iterables.any(\n              resolvedBindings.bindings(), MEMBERS_INJECTION::isOfType)) {\n            // TODO(dpb): How could this ever happen, even in an invalid graph?\n            throw new AssertionError(\n                \"contribution binding keys should never have members injection bindings\");\n          }\n          validateNullability(path, resolvedBindings.contributionBindings());\n          if (resolvedBindings.contributionBindings().size() \u003e 1) {\n            reportDuplicateBindings(path);\n            return;\n          }\n          ContributionBinding contributionBinding \u003d resolvedBindings.contributionBinding();\n          if (contributionBinding.bindingKind().equals(INJECTION)) {\n            TypeMirror type \u003d contributionBinding.key().type();\n            ValidationReport\u003cTypeElement\u003e report \u003d\n                injectValidator.validateType(MoreTypes.asTypeElement(type));\n            if (!report.isClean()) {\n              reportBuilder.addSubreport(report);\n              return;\n            }\n          }\n          if (contributionBinding.bindingType().equals(PRODUCTION)\n              \u0026\u0026 doesPathRequireProvisionOnly(path)) {\n            reportProviderMayNotDependOnProducer(path);\n            return;\n          }\n          if (compilerOptions.usesProducers()) {\n            Key productionImplementationExecutorKey \u003d\n                keyFactory.forProductionImplementationExecutor();\n            // only forbid depending on the production executor if it\u0027s not the Dagger-specific\n            // binding to the implementation\n            if (!contributionBinding.key().equals(productionImplementationExecutorKey)) {\n              Key productionExecutorKey \u003d keyFactory.forProductionExecutor();\n              for (DependencyRequest request : contributionBinding.dependencies()) {\n                if (request.key().equals(productionExecutorKey)\n                    || request.key().equals(productionImplementationExecutorKey)) {\n                  reportDependsOnProductionExecutor(path);\n                  return;\n                }\n              }\n            }\n          }\n          if (contributionBinding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP)) {\n            validateMapKeys(path, contributionBinding);\n          }\n          break;\n        case MEMBERS_INJECTION:\n          if (!Iterables.all(resolvedBindings.bindings(), MEMBERS_INJECTION::isOfType)) {\n            // TODO(dpb): How could this ever happen, even in an invalid graph?\n            throw new AssertionError(\n                \"members injection binding keys should never have contribution bindings\");\n          }\n          if (resolvedBindings.bindings().size() \u003e 1) {\n            reportDuplicateBindings(path);\n            return;\n          }\n          validateMembersInjectionBinding(resolvedBindings.membersInjectionBinding().get(), path);\n          return;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    /**\n     * Returns an object that contains all the same bindings as {@code resolvedBindings}, except\n     * that any {@link ContributionBinding}s without {@linkplain Binding#bindingElement() binding\n     * elements} are replaced by the contribution bindings and multibinding declarations of their\n     * dependencies.\n     *\n     * \u003cp\u003eFor example, if:\n     *\n     * \u003cul\u003e\n     * \u003cli\u003eThe bindings for {@code key1} are {@code A} and {@code B}, with multibinding declaration\n     *     {@code X}.\n     * \u003cli\u003e{@code B} is a binding without a binding element that has a dependency on {@code key2}.\n     * \u003cli\u003eThe bindings for {@code key2} are {@code C} and {@code D}, with multibinding declaration\n     *     {@code Y}.\n     * \u003c/ul\u003e\n     *\n     * then {@code inlineContributionsWithoutBindingElements(bindingsForKey1)} has bindings {@code\n     * A}, {@code C}, and {@code D}, with multibinding declarations {@code X} and {@code Y}.\n     *\n     * \u003cp\u003eThe replacement is repeated until all of the bindings have elements.\n     */\n    private ResolvedBindings inlineContributionsWithoutBindingElements(\n        ResolvedBindings resolvedBinding) {\n      if (Iterables.all(resolvedBinding.bindings(),\n          bindingDeclaration -\u003e bindingDeclaration.bindingElement().isPresent())) {\n        return resolvedBinding;\n      }\n\n      ImmutableSetMultimap.Builder\u003cComponentDescriptor, ContributionBinding\u003e contributions \u003d\n          ImmutableSetMultimap.builder();\n      ImmutableSet.Builder\u003cMultibindingDeclaration\u003e multibindingDeclarations \u003d\n          ImmutableSet.builder();\n      ImmutableSet.Builder\u003cSubcomponentDeclaration\u003e subcomponentDeclarations \u003d\n          ImmutableSet.builder();\n      ImmutableSet.Builder\u003cOptionalBindingDeclaration\u003e optionalBindingDeclarations \u003d\n          ImmutableSet.builder();\n\n      Queue\u003cResolvedBindings\u003e queue \u003d new ArrayDeque\u003c\u003e();\n      queue.add(resolvedBinding);\n\n      for (ResolvedBindings queued \u003d queue.poll(); queued !\u003d null; queued \u003d queue.poll()) {\n        multibindingDeclarations.addAll(queued.multibindingDeclarations());\n        subcomponentDeclarations.addAll(queued.subcomponentDeclarations());\n        optionalBindingDeclarations.addAll(queued.optionalBindingDeclarations());\n        for (Map.Entry\u003cComponentDescriptor, ContributionBinding\u003e bindingEntry :\n            queued.allContributionBindings().entries()) {\n          BindingGraph owningGraph \u003d validationForComponent(bindingEntry.getKey()).subject;\n          ContributionBinding binding \u003d bindingEntry.getValue();\n          if (binding.bindingElement().isPresent()) {\n            contributions.put(bindingEntry);\n          } else {\n            for (DependencyRequest dependency : binding.dependencies()) {\n              queue.add(owningGraph.resolvedBindings().get(dependency.bindingKey()));\n            }\n          }\n        }\n      }\n      return ResolvedBindings.forContributionBindings(\n          resolvedBinding.bindingKey(),\n          resolvedBinding.owningComponent(),\n          contributions.build(),\n          multibindingDeclarations.build(),\n          subcomponentDeclarations.build(),\n          optionalBindingDeclarations.build());\n    }\n\n    private ImmutableListMultimap\u003cContributionType, BindingDeclaration\u003e declarationsByType(\n        ResolvedBindings resolvedBinding) {\n      ResolvedBindings inlined \u003d inlineContributionsWithoutBindingElements(resolvedBinding);\n      return new ImmutableListMultimap.Builder\u003cContributionType, BindingDeclaration\u003e()\n          .putAll(Multimaps\n              .index(inlined.contributionBindings(), HasContributionType::contributionType))\n          .putAll(Multimaps\n              .index(inlined.multibindingDeclarations(), HasContributionType::contributionType))\n          .build();\n    }\n\n    /**\n     * Ensures that if the current request isn\u0027t nullable, then each contribution is also not\n     * nullable.\n     */\n    private void validateNullability(DependencyPath path, Set\u003cContributionBinding\u003e bindings) {\n      if (path.currentDependencyRequest().isNullable()) {\n        return;\n      }\n\n      // Note: the method signature will include the @Nullable in it!\n      /* TODO(sameb): Sometimes javac doesn\u0027t include the Element in its output.\n       * (Maybe this happens if the code was already compiled before this point?)\n       * ... we manually print out the request in that case, otherwise the error\n       * message is kind of useless. */\n      String typeName \u003d TypeName.get(path.currentDependencyRequest().key().type()).toString();\n\n      for (ContributionBinding binding : bindings) {\n        if (binding.nullableType().isPresent()) {\n          reportBuilder.addItem(\n              nullableToNonNullable(typeName, bindingDeclarationFormatter.format(binding))\n                  + \"\\n at: \"\n                  + dependencyRequestFormatter.toDependencyTrace(path),\n              compilerOptions.nullableValidationKind(),\n              path.entryPointElement());\n        }\n      }\n    }\n\n    private void validateMapKeys(\n        DependencyPath path, ContributionBinding binding) {\n      checkArgument(binding.bindingKind().equals(SYNTHETIC_MULTIBOUND_MAP),\n          \"binding must be a synthetic multibound map: %s\",\n          binding);\n      ImmutableSet.Builder\u003cContributionBinding\u003e multibindingContributionsBuilder \u003d\n          ImmutableSet.builder();\n      for (DependencyRequest dependency : binding.dependencies()) {\n        multibindingContributionsBuilder.add(\n            subject.resolvedBindings().get(dependency.bindingKey()).contributionBinding());\n      }\n      ImmutableSet\u003cContributionBinding\u003e multibindingContributions \u003d\n          multibindingContributionsBuilder.build();\n      validateMapKeySet(path, multibindingContributions);\n      validateMapKeyAnnotationTypes(path, multibindingContributions);\n    }\n\n    /**\n     * Reports errors if {@code mapBindings} has more than one binding for the same map key.\n     */\n    private void validateMapKeySet(DependencyPath path, Set\u003cContributionBinding\u003e mapBindings) {\n      for (Collection\u003cContributionBinding\u003e mapBindingsForMapKey :\n          indexMapBindingsByMapKey(mapBindings).asMap().values()) {\n        if (mapBindingsForMapKey.size() \u003e 1) {\n          reportDuplicateMapKeys(path, mapBindingsForMapKey);\n        }\n      }\n    }\n\n    /**\n     * Reports errors if {@code mapBindings} uses more than one {@link MapKey} annotation type.\n     */\n    private void validateMapKeyAnnotationTypes(\n        DependencyPath path, Set\u003cContributionBinding\u003e contributionBindings) {\n      ImmutableSetMultimap\u003cEquivalence.Wrapper\u003cDeclaredType\u003e, ContributionBinding\u003e\n          mapBindingsByAnnotationType \u003d indexMapBindingsByAnnotationType(contributionBindings);\n      if (mapBindingsByAnnotationType.keySet().size() \u003e 1) {\n        reportInconsistentMapKeyAnnotations(path, mapBindingsByAnnotationType);\n      }\n    }\n\n    /** Reports errors if a members injection binding is invalid. */\n    private void validateMembersInjectionBinding(\n        final MembersInjectionBinding binding, final DependencyPath path) {\n      binding\n          .key()\n          .type()\n          .accept(\n              new SimpleTypeVisitor6\u003cVoid, Void\u003e() {\n                @Override\n                protected Void defaultAction(TypeMirror e, Void p) {\n                  reportBuilder.addError(\n                      \"Invalid members injection request.\", binding.membersInjectedType());\n                  return null;\n                }\n\n                @Override\n                public Void visitDeclared(DeclaredType type, Void ignored) {\n                  // If the key has type arguments, validate that each type argument is declared.\n                  // Otherwise the type argument may be a wildcard (or other type), and we can\u0027t\n                  // resolve that to actual types.  If the arg was an array, validate the type\n                  // of the array.\n                  for (TypeMirror arg : type.getTypeArguments()) {\n                    boolean declared;\n                    switch (arg.getKind()) {\n                      case ARRAY:\n                        declared \u003d\n                            MoreTypes.asArray(arg)\n                                .getComponentType()\n                                .accept(\n                                    new SimpleTypeVisitor6\u003cBoolean, Void\u003e() {\n                                      @Override\n                                      protected Boolean defaultAction(TypeMirror e, Void p) {\n                                        return false;\n                                      }\n\n                                      @Override\n                                      public Boolean visitDeclared(DeclaredType t, Void p) {\n                                        for (TypeMirror arg : t.getTypeArguments()) {\n                                          if (!arg.accept(this, null)) {\n                                            return false;\n                                          }\n                                        }\n                                        return true;\n                                      }\n\n                                      @Override\n                                      public Boolean visitArray(ArrayType t, Void p) {\n                                        return t.getComponentType().accept(this, null);\n                                      }\n\n                                      @Override\n                                      public Boolean visitPrimitive(PrimitiveType t, Void p) {\n                                        return true;\n                                      }\n                                    },\n                                    null);\n                        break;\n                      case DECLARED:\n                        declared \u003d true;\n                        break;\n                      default:\n                        declared \u003d false;\n                    }\n                    if (!declared) {\n                      reportBuilder.addError(\n                          String.format(\n                              MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE,\n                              arg.toString(),\n                              type.toString(),\n                              dependencyRequestFormatter.toDependencyTrace(path)),\n                          path.entryPointElement());\n                      return null;\n                    }\n                  }\n\n                  TypeElement element \u003d MoreElements.asType(type.asElement());\n                  // Also validate that the key is not the erasure of a generic type.\n                  // If it is, that means the user referred to Foo\u003cT\u003e as just \u0027Foo\u0027,\n                  // which we don\u0027t allow.  (This is a judgement call -- we *could*\n                  // allow it and instantiate the type bounds... but we don\u0027t.)\n                  if (!MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()\n                      \u0026\u0026 types.isSameType(types.erasure(element.asType()), type)) {\n                    reportBuilder.addError(\n                        String.format(\n                            ErrorMessages.MEMBERS_INJECTION_WITH_RAW_TYPE,\n                            type.toString(),\n                            dependencyRequestFormatter.toDependencyTrace(path)),\n                        path.entryPointElement());\n                  }\n                  return null;\n                }\n              },\n              null);\n    }\n\n    /**\n     * Validates that component dependencies do not form a cycle.\n     */\n    private void validateComponentHierarchy() {\n      ComponentDescriptor descriptor \u003d subject.componentDescriptor();\n      TypeElement componentType \u003d descriptor.componentDefinitionType();\n      validateComponentHierarchy(componentType, componentType, new ArrayDeque\u003cTypeElement\u003e());\n    }\n\n    /**\n     * Recursive method to validate that component dependencies do not form a cycle.\n     */\n    private void validateComponentHierarchy(\n        TypeElement rootComponent,\n        TypeElement componentType,\n        Deque\u003cTypeElement\u003e componentStack) {\n\n      if (componentStack.contains(componentType)) {\n        // Current component has already appeared in the component chain.\n        StringBuilder message \u003d new StringBuilder();\n        message.append(rootComponent.getQualifiedName());\n        message.append(\" contains a cycle in its component dependencies:\\n\");\n        componentStack.push(componentType);\n        appendIndentedComponentsList(message, componentStack);\n        componentStack.pop();\n        reportBuilder.addItem(\n            message.toString(),\n            compilerOptions.scopeCycleValidationType().diagnosticKind().get(),\n            rootComponent,\n            getComponentAnnotation(rootComponent).get());\n      } else {\n        Optional\u003cAnnotationMirror\u003e componentAnnotation \u003d getComponentAnnotation(componentType);\n        if (componentAnnotation.isPresent()) {\n          componentStack.push(componentType);\n\n          ImmutableSet\u003cTypeElement\u003e dependencies \u003d\n              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get()));\n          for (TypeElement dependency : dependencies) {\n            validateComponentHierarchy(rootComponent, dependency, componentStack);\n          }\n\n          componentStack.pop();\n        }\n      }\n    }\n\n    /**\n     * Validates that among the dependencies are at most one scoped dependency,\n     * that there are no cycles within the scoping chain, and that singleton\n     * components have no scoped dependencies.\n     */\n    private void validateDependencyScopes() {\n      ComponentDescriptor descriptor \u003d subject.componentDescriptor();\n      ImmutableSet\u003cScope\u003e scopes \u003d descriptor.scopes();\n      ImmutableSet\u003cTypeElement\u003e scopedDependencies \u003d scopedTypesIn(descriptor.dependencies());\n      if (!scopes.isEmpty()) {\n        Scope singletonScope \u003d Scope.singletonScope(elements);\n        // Dagger 1.x scope compatibility requires this be suppress-able.\n        if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()\n            \u0026\u0026 scopes.contains(singletonScope)) {\n          // Singleton is a special-case representing the longest lifetime, and therefore\n          // @Singleton components may not depend on scoped components\n          if (!scopedDependencies.isEmpty()) {\n            StringBuilder message \u003d new StringBuilder(\n                \"This @Singleton component cannot depend on scoped components:\\n\");\n            appendIndentedComponentsList(message, scopedDependencies);\n            reportBuilder.addItem(\n                message.toString(),\n                compilerOptions.scopeCycleValidationType().diagnosticKind().get(),\n                descriptor.componentDefinitionType(),\n                descriptor.componentAnnotation());\n          }\n        } else if (scopedDependencies.size() \u003e 1) {\n          // Scoped components may depend on at most one scoped component.\n          StringBuilder message \u003d new StringBuilder();\n          for (Scope scope : scopes) {\n            message.append(scope.getReadableSource()).append(\u0027 \u0027);\n          }\n          message\n              .append(descriptor.componentDefinitionType().getQualifiedName())\n              .append(\" depends on more than one scoped component:\\n\");\n          appendIndentedComponentsList(message, scopedDependencies);\n          reportBuilder.addError(\n              message.toString(),\n              descriptor.componentDefinitionType(),\n              descriptor.componentAnnotation());\n        } else {\n          // Dagger 1.x scope compatibility requires this be suppress-able.\n          if (!compilerOptions.scopeCycleValidationType().equals(ValidationType.NONE)) {\n            validateScopeHierarchy(descriptor.componentDefinitionType(),\n                descriptor.componentDefinitionType(),\n                new ArrayDeque\u003cImmutableSet\u003cScope\u003e\u003e(),\n                new ArrayDeque\u003cTypeElement\u003e());\n          }\n        }\n      } else {\n        // Scopeless components may not depend on scoped components.\n        if (!scopedDependencies.isEmpty()) {\n          StringBuilder message \u003d\n              new StringBuilder(descriptor.componentDefinitionType().getQualifiedName())\n                  .append(\" (unscoped) cannot depend on scoped components:\\n\");\n          appendIndentedComponentsList(message, scopedDependencies);\n          reportBuilder.addError(\n              message.toString(),\n              descriptor.componentDefinitionType(),\n              descriptor.componentAnnotation());\n        }\n      }\n    }\n\n    private void validateBuilders() {\n      ComponentDescriptor componentDesc \u003d subject.componentDescriptor();\n      if (!componentDesc.builderSpec().isPresent()) {\n        // If no builder, nothing to validate.\n        return;\n      }\n\n      Set\u003cTypeElement\u003e availableDependencies \u003d subject.availableDependencies();\n      Set\u003cTypeElement\u003e requiredDependencies \u003d\n          Sets.filter(availableDependencies, input -\u003e !componentCanMakeNewInstances(input));\n      final BuilderSpec spec \u003d componentDesc.builderSpec().get();\n      Map\u003cTypeElement, ExecutableElement\u003e allSetters \u003d spec.methodMap();\n\n      ErrorMessages.ComponentBuilderMessages msgs \u003d\n          ErrorMessages.builderMsgsFor(subject.componentDescriptor().kind());\n      Set\u003cTypeElement\u003e extraSetters \u003d Sets.difference(allSetters.keySet(), availableDependencies);\n      if (!extraSetters.isEmpty()) {\n        Collection\u003cExecutableElement\u003e excessMethods \u003d\n            Maps.filterKeys(allSetters, Predicates.in(extraSetters)).values();\n        Iterable\u003cString\u003e formatted \u003d\n            FluentIterable.from(excessMethods)\n                .transform(\n                    method -\u003e\n                        methodSignatureFormatter.format(\n                            method,\n                            Optional.of(\n                                MoreTypes.asDeclared(spec.builderDefinitionType().asType()))));\n        reportBuilder.addError(\n            String.format(msgs.extraSetters(), formatted), spec.builderDefinitionType());\n      }\n\n      Set\u003cTypeElement\u003e missingSetters \u003d Sets.difference(requiredDependencies, allSetters.keySet());\n      if (!missingSetters.isEmpty()) {\n        reportBuilder.addError(\n            String.format(msgs.missingSetters(), missingSetters), spec.builderDefinitionType());\n      }\n    }\n\n    /**\n     * Validates that scopes do not participate in a scoping cycle - that is to say, scoped\n     * components are in a hierarchical relationship terminating with Singleton.\n     *\n     * \u003cp\u003eAs a side-effect, this means scoped components cannot have a dependency cycle between\n     * themselves, since a component\u0027s presence within its own dependency path implies a cyclical\n     * relationship between scopes. However, cycles in component dependencies are explicitly\n     * checked in {@link #validateComponentHierarchy()}.\n     */\n    private void validateScopeHierarchy(TypeElement rootComponent,\n        TypeElement componentType,\n        Deque\u003cImmutableSet\u003cScope\u003e\u003e scopeStack,\n        Deque\u003cTypeElement\u003e scopedDependencyStack) {\n      ImmutableSet\u003cScope\u003e scopes \u003d Scope.scopesOf(componentType);\n      if (stackOverlaps(scopeStack, scopes)) {\n        scopedDependencyStack.push(componentType);\n        // Current scope has already appeared in the component chain.\n        StringBuilder message \u003d new StringBuilder();\n        message.append(rootComponent.getQualifiedName());\n        message.append(\" depends on scoped components in a non-hierarchical scope ordering:\\n\");\n        appendIndentedComponentsList(message, scopedDependencyStack);\n        if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {\n          reportBuilder.addItem(\n              message.toString(),\n              compilerOptions.scopeCycleValidationType().diagnosticKind().get(),\n              rootComponent,\n              getComponentAnnotation(rootComponent).get());\n        }\n        scopedDependencyStack.pop();\n      } else {\n        // TODO(beder): transitively check scopes of production components too.\n        Optional\u003cAnnotationMirror\u003e componentAnnotation \u003d\n            getAnnotationMirror(componentType, Component.class);\n        if (componentAnnotation.isPresent()) {\n          ImmutableSet\u003cTypeElement\u003e scopedDependencies \u003d scopedTypesIn(\n              MoreTypes.asTypeElements(getComponentDependencies(componentAnnotation.get())));\n          if (scopedDependencies.size() \u003d\u003d 1) {\n            // empty can be ignored (base-case), and \u003e 1 is a different error reported separately.\n            scopeStack.push(scopes);\n            scopedDependencyStack.push(componentType);\n            validateScopeHierarchy(rootComponent, getOnlyElement(scopedDependencies),\n                scopeStack, scopedDependencyStack);\n            scopedDependencyStack.pop();\n            scopeStack.pop();\n          }\n        } // else: we skip component dependencies which are not components\n      }\n    }\n\n    private \u003cT\u003e boolean stackOverlaps(Deque\u003cImmutableSet\u003cT\u003e\u003e stack, ImmutableSet\u003cT\u003e set) {\n      for (ImmutableSet\u003cT\u003e entry : stack) {\n        if (!Sets.intersection(entry, set).isEmpty()) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    /**\n     * Validates that the scope (if any) of this component are compatible with the scopes of the\n     * bindings available in this component\n     */\n    void validateComponentScope() {\n      ImmutableMap\u003cBindingKey, ResolvedBindings\u003e resolvedBindings \u003d subject.resolvedBindings();\n      ImmutableSet\u003cScope\u003e componentScopes \u003d subject.componentDescriptor().scopes();\n      ImmutableSet.Builder\u003cString\u003e incompatiblyScopedMethodsBuilder \u003d ImmutableSet.builder();\n      Scope reusableScope \u003d reusableScope(elements);\n      for (ResolvedBindings bindings : resolvedBindings.values()) {\n        for (ContributionBinding contributionBinding : bindings.ownedContributionBindings()) {\n          Optional\u003cScope\u003e bindingScope \u003d contributionBinding.scope();\n          if (bindingScope.isPresent()\n              \u0026\u0026 !bindingScope.get().equals(reusableScope)\n              \u0026\u0026 !componentScopes.contains(bindingScope.get())) {\n            // Scoped components cannot reference bindings to @Provides methods or @Inject\n            // types decorated by a different scope annotation. Unscoped components cannot\n            // reference to scoped @Provides methods or @Inject types decorated by any\n            // scope annotation.\n            switch (contributionBinding.bindingKind()) {\n              case SYNTHETIC_DELEGATE_BINDING:\n              case PROVISION:\n                incompatiblyScopedMethodsBuilder.add(\n                    methodSignatureFormatter.format(\n                        MoreElements.asExecutable(contributionBinding.bindingElement().get())));\n                break;\n              case INJECTION:\n                incompatiblyScopedMethodsBuilder.add(\n                    bindingScope.get().getReadableSource()\n                        + \" class \"\n                        + contributionBinding.bindingTypeElement().get().getQualifiedName());\n                break;\n              default:\n                throw new IllegalStateException();\n            }\n          }\n        }\n      }\n\n      ImmutableSet\u003cString\u003e incompatiblyScopedMethods \u003d incompatiblyScopedMethodsBuilder.build();\n      if (!incompatiblyScopedMethods.isEmpty()) {\n        TypeElement componentType \u003d subject.componentDescriptor().componentDefinitionType();\n        StringBuilder message \u003d new StringBuilder(componentType.getQualifiedName());\n        if (!componentScopes.isEmpty()) {\n          message.append(\" scoped with \");\n          for (Scope scope : componentScopes) {\n            message.append(scope.getReadableSource()).append(\u0027 \u0027);\n          }\n          message.append(\"may not reference bindings with different scopes:\\n\");\n        } else {\n          message.append(\" (unscoped) may not reference scoped bindings:\\n\");\n        }\n        for (String method : incompatiblyScopedMethods) {\n          message.append(ErrorMessages.INDENT).append(method).append(\"\\n\");\n        }\n        reportBuilder.addError(\n            message.toString(), componentType, subject.componentDescriptor().componentAnnotation());\n      }\n    }\n\n    @SuppressWarnings(\"resource\") // Appendable is a StringBuilder.\n    // TODO(b/29509141): Clarify the error.\n    private void reportProviderMayNotDependOnProducer(DependencyPath path) {\n      StringBuilder errorMessage \u003d new StringBuilder();\n      if (path.size() \u003d\u003d 1) {\n        new Formatter(errorMessage)\n            .format(\n                PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,\n                formatCurrentDependencyRequestKey(path));\n      } else {\n        FluentIterable\u003cContributionBinding\u003e dependentProvisions \u003d\n            provisionsDependingOnLatestRequest(path);\n        // TODO(beder): Consider displaying all dependent provisions in the error message. If we\n        // do that, should we display all productions that depend on them also?\n        new Formatter(errorMessage)\n            .format(\n                PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT,\n                dependentProvisions.iterator().next().key());\n      }\n      reportBuilder.addError(errorMessage.toString(), path.entryPointElement());\n    }\n\n    /**\n     * Descriptive portion of the error message for when the given request has no binding.\n     * Currently, the only other portions of the message are the dependency path, line number and\n     * filename. Not static because it uses the instance field types.\n     */\n    private StringBuilder requiresErrorMessageBase(DependencyPath path) {\n      Key key \u003d path.currentDependencyRequest().key();\n      String requiresErrorMessageFormat;\n      // TODO(dpb): Check for wildcard injection somewhere else first?\n      if (key.type().getKind().equals(TypeKind.WILDCARD)) {\n        requiresErrorMessageFormat \u003d CANNOT_INJECT_WILDCARD_TYPE;\n      } else {\n        boolean requiresProvision \u003d doesPathRequireProvisionOnly(path);\n        if (!key.isValidImplicitProvisionKey(types)) {\n          requiresErrorMessageFormat \u003d requiresProvision\n              ? REQUIRES_PROVIDER_FORMAT\n              : REQUIRES_PROVIDER_OR_PRODUCER_FORMAT;\n        } else {\n          requiresErrorMessageFormat \u003d requiresProvision\n              ? REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT\n              : REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT;\n        }\n      }\n      StringBuilder errorMessage \u003d\n          new StringBuilder(\n              String.format(requiresErrorMessageFormat, formatCurrentDependencyRequestKey(path)));\n      if (key.isValidMembersInjectionKey()) {\n        Optional\u003cMembersInjectionBinding\u003e membersInjectionBinding \u003d\n            injectBindingRegistry.getOrFindMembersInjectionBinding(key);\n        if (membersInjectionBinding.isPresent()\n            \u0026\u0026 !membersInjectionBinding.get().injectionSites().isEmpty()) {\n          errorMessage.append(\" \");\n          errorMessage.append(ErrorMessages.MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION);\n        }\n      }\n      return errorMessage.append(\u0027\\n\u0027);\n    }\n\n    private void reportMissingBinding(DependencyPath path) {\n      StringBuilder errorMessage \u003d\n          requiresErrorMessageBase(path).append(dependencyRequestFormatter.toDependencyTrace(path));\n      for (String suggestion :\n          MissingBindingSuggestions.forKey(\n              topLevelGraph(), path.currentDependencyRequest().bindingKey())) {\n        errorMessage.append(\u0027\\n\u0027).append(suggestion);\n      }\n      reportBuilder.addError(errorMessage.toString(), path.entryPointElement());\n    }\n\n    @SuppressWarnings(\"resource\") // Appendable is a StringBuilder.\n    private void reportDependsOnProductionExecutor(DependencyPath path) {\n      reportBuilder.addError(\n          String.format(\n              DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT, formatCurrentDependencyRequestKey(path)),\n          path.entryPointElement());\n    }\n\n    @SuppressWarnings(\"resource\") // Appendable is a StringBuilder.\n    private void reportDuplicateBindings(DependencyPath path) {\n      ResolvedBindings resolvedBindings \u003d path.currentResolvedBindings();\n      if (FluentIterable.from(resolvedBindings.contributionBindings())\n          .transform(ContributionBinding::bindingKind)\n          // TODO(dpb): Kill with fire.\n          .anyMatch(\n              kind -\u003e SYNTHETIC_MULTIBOUND_KINDS.contains(kind) || SYNTHETIC_MAP.equals(kind))) {\n        // If any of the duplicate bindings results from multibinding contributions or declarations,\n        // report the conflict using those contributions and declarations.\n        reportMultipleContributionTypes(path);\n        return;\n      }\n      StringBuilder builder \u003d new StringBuilder();\n      new Formatter(builder)\n          .format(DUPLICATE_BINDINGS_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey(path));\n      ResolvedBindings inlined \u003d inlineContributionsWithoutBindingElements(resolvedBindings);\n      ImmutableSet\u003cContributionBinding\u003e duplicateBindings \u003d inlined.contributionBindings();\n      Set\u003cBindingDeclaration\u003e conflictingDeclarations \u003d\n          Sets.union(duplicateBindings, inlined.subcomponentDeclarations());\n      bindingDeclarationFormatter.formatIndentedList(\n          builder, conflictingDeclarations, 1, DUPLICATE_SIZE_LIMIT);\n      owningReportBuilder(duplicateBindings).addError(builder.toString(), path.entryPointElement());\n    }\n\n    /**\n     * Returns the report builder for the rootmost component that contains any of the duplicate\n     * bindings.\n     */\n    private ValidationReport.Builder\u003cTypeElement\u003e owningReportBuilder(\n        Iterable\u003cContributionBinding\u003e duplicateBindings) {\n      ImmutableSet.Builder\u003cComponentDescriptor\u003e owningComponentsBuilder \u003d ImmutableSet.builder();\n      for (ContributionBinding binding : duplicateBindings) {\n        ResolvedBindings resolvedBindings \u003d\n            subject.resolvedBindings().get(BindingKey.contribution(binding.key()));\n        owningComponentsBuilder.addAll(\n            resolvedBindings.allContributionBindings().inverse().get(binding));\n      }\n      ImmutableSet\u003cComponentDescriptor\u003e owningComponents \u003d owningComponentsBuilder.build();\n      for (Validation validation : validationPath()) {\n        if (owningComponents.contains(validation.subject.componentDescriptor())) {\n          return validation.reportBuilder;\n        }\n      }\n      throw new AssertionError(\n          \"cannot find owning component for duplicate bindings: \" + duplicateBindings);\n    }\n\n    /**\n     * The path from the {@link Validation} of the root graph down to this {@link Validation}.\n     */\n    private ImmutableList\u003cValidation\u003e validationPath() {\n      ImmutableList.Builder\u003cValidation\u003e validationPath \u003d ImmutableList.builder();\n      for (Optional\u003cValidation\u003e validation \u003d Optional.of(this);\n          validation.isPresent();\n          validation \u003d validation.get().parent) {\n        validationPath.add(validation.get());\n      }\n      return validationPath.build().reverse();\n    }\n\n    @SuppressWarnings(\"resource\") // Appendable is a StringBuilder.\n    private void reportMultipleContributionTypes(DependencyPath path) {\n      StringBuilder builder \u003d new StringBuilder();\n      new Formatter(builder)\n          .format(\n              MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT, formatCurrentDependencyRequestKey(path));\n      ResolvedBindings resolvedBindings \u003d path.currentResolvedBindings();\n      ImmutableListMultimap\u003cContributionType, BindingDeclaration\u003e declarationsByType \u003d\n          declarationsByType(resolvedBindings);\n      verify(\n          declarationsByType.keySet().size() \u003e 1,\n          \"expected multiple contribution types for %s: %s\",\n          resolvedBindings.bindingKey(),\n          declarationsByType);\n      for (ContributionType contributionType :\n          Ordering.natural().immutableSortedCopy(declarationsByType.keySet())) {\n        builder.append(INDENT);\n        builder.append(formatContributionType(contributionType));\n        builder.append(\" bindings and declarations:\");\n        bindingDeclarationFormatter.formatIndentedList(\n            builder, declarationsByType.get(contributionType), 2, DUPLICATE_SIZE_LIMIT);\n        builder.append(\u0027\\n\u0027);\n      }\n      reportBuilder.addError(builder.toString(), path.entryPointElement());\n    }\n\n    private void reportDuplicateMapKeys(\n        DependencyPath path, Collection\u003cContributionBinding\u003e mapBindings) {\n      StringBuilder builder \u003d new StringBuilder();\n      builder.append(duplicateMapKeysError(formatCurrentDependencyRequestKey(path)));\n      bindingDeclarationFormatter.formatIndentedList(builder, mapBindings, 1, DUPLICATE_SIZE_LIMIT);\n      reportBuilder.addError(builder.toString(), path.entryPointElement());\n    }\n\n    private void reportInconsistentMapKeyAnnotations(\n        DependencyPath path,\n        Multimap\u003cEquivalence.Wrapper\u003cDeclaredType\u003e, ContributionBinding\u003e\n            mapBindingsByAnnotationType) {\n      StringBuilder builder \u003d\n          new StringBuilder(\n              inconsistentMapKeyAnnotationsError(formatCurrentDependencyRequestKey(path)));\n      for (Map.Entry\u003cEquivalence.Wrapper\u003cDeclaredType\u003e, Collection\u003cContributionBinding\u003e\u003e entry :\n          mapBindingsByAnnotationType.asMap().entrySet()) {\n        DeclaredType annotationType \u003d entry.getKey().get();\n        Collection\u003cContributionBinding\u003e bindings \u003d entry.getValue();\n\n        builder\n            .append(\u0027\\n\u0027)\n            .append(INDENT)\n            .append(annotationType)\n            .append(\u0027:\u0027);\n\n        bindingDeclarationFormatter.formatIndentedList(builder, bindings, 2, DUPLICATE_SIZE_LIMIT);\n      }\n      reportBuilder.addError(builder.toString(), path.entryPointElement());\n    }\n\n    private void reportCycle(DependencyPath path) {\n      if (!providersBreakingCycle(path).isEmpty()) {\n        return;\n      }\n      // TODO(cgruber): Provide a hint for the start and end of the cycle.\n      TypeElement componentType \u003d\n          MoreElements.asType(path.entryPointElement().getEnclosingElement());\n      reportBuilder.addItem(\n          String.format(\n              CONTAINS_DEPENDENCY_CYCLE_FORMAT,\n              componentType.getQualifiedName(),\n              path.entryPointElement().getSimpleName(),\n              dependencyRequestFormatter.toDependencyTrace(path)),\n          ERROR,\n          path.entryPointElement());\n    }\n\n    /**\n     * Returns any steps in a dependency cycle that \"break\" the cycle. These are any {@link\n     * Provider}, {@link Lazy}, or {@code Map\u003cK, Provider\u003cV\u003e\u003e} requests after the first request in\n     * the cycle.\n     *\n     * \u003cp\u003eIf an implicit {@link Provider} dependency on {@code Map\u003cK, Provider\u003cV\u003e\u003e} is immediately\n     * preceded by a dependency on {@code Map\u003cK, V\u003e}, which means that the map\u0027s {@link Provider}s\u0027\n     * {@link Provider#get() get()} methods are called during provision and so the cycle is not\n     * really broken.\n     *\n     * \u003cp\u003eA request for an instance of {@code Optional} breaks the cycle if a request for the {@code\n     * Optional}\u0027s type parameter would.\n     */\n    private ImmutableSet\u003cDependencyRequest\u003e providersBreakingCycle(DependencyPath path) {\n      return path.cycle()\n          .skip(1)\n          .filter(\n              new Predicate\u003cResolvedRequest\u003e() {\n                @Override\n                public boolean apply(ResolvedRequest resolvedRequest) {\n                  DependencyRequest dependencyRequest \u003d resolvedRequest.dependencyRequest();\n                  if (dependencyRequest.requestElement().isPresent()) {\n                    // Non-synthetic request\n                    return breaksCycle(dependencyRequest.key().type(), dependencyRequest.kind());\n                  } else if (!resolvedRequest.dependentOptionalBindingDeclarations().isEmpty()) {\n                    // Synthetic request from a @BindsOptionalOf: test the type inside the Optional.\n                    // Optional\u003cProvider or Lazy or Provider of Lazy\u003e breaks the cycle.\n                    TypeMirror requestedOptionalType \u003d\n                        resolvedRequest.dependentBindings().get().key().type();\n                    DependencyRequest.KindAndType kindAndType \u003d\n                        DependencyRequest.extractKindAndType(\n                            OptionalType.from(requestedOptionalType).valueType());\n                    return breaksCycle(kindAndType.type(), kindAndType.kind());\n                  } else {\n                    // Other synthetic requests.\n                    return false;\n                  }\n                }\n\n                private boolean breaksCycle(\n                    TypeMirror requestedType, DependencyRequest.Kind requestKind) {\n                  switch (requestKind) {\n                    case PROVIDER:\n                    case LAZY:\n                    case PROVIDER_OF_LAZY:\n                      return true;\n\n                    case INSTANCE:\n                      return MapType.isMap(requestedType)\n                          \u0026\u0026 MapType.from(requestedType).valuesAreTypeOf(Provider.class);\n\n                    default:\n                      return false;\n                  }\n                }\n              })\n          .transform(ResolvedRequest::dependencyRequest)\n          .toSet();\n    }\n  }\n\n  ValidationReport\u003cTypeElement\u003e validate(BindingGraph subject) {\n    Validation validation \u003d new Validation(subject);\n    validation.validateSubgraph();\n    return validation.buildReport();\n  }\n\n  /**\n   * Append and format a list of indented component types (with their scope annotations)\n   */\n  private void appendIndentedComponentsList(StringBuilder message, Iterable\u003cTypeElement\u003e types) {\n    for (TypeElement scopedComponent : types) {\n      message.append(INDENT);\n      for (Scope scope : Scope.scopesOf(scopedComponent)) {\n        message.append(scope.getReadableSource()).append(\u0027 \u0027);\n      }\n      message.append(stripCommonTypePrefixes(scopedComponent.getQualifiedName().toString()))\n          .append(\u0027\\n\u0027);\n    }\n  }\n\n  /**\n   * Returns a set of type elements containing only those found in the input set that have\n   * a scoping annotation.\n   */\n  private ImmutableSet\u003cTypeElement\u003e scopedTypesIn(Set\u003cTypeElement\u003e types) {\n    return FluentIterable.from(types).filter(type -\u003e !Scope.scopesOf(type).isEmpty()).toSet();\n  }\n\n  /**\n   * Returns whether the given dependency path would require the most recent request to be resolved\n   * by only provision bindings.\n   */\n  private boolean doesPathRequireProvisionOnly(DependencyPath path) {\n    if (path.size() \u003d\u003d 1) {\n      // if this is an entry-point, then we check the request\n      switch (path.currentDependencyRequest().kind()) {\n        case INSTANCE:\n        case PROVIDER:\n        case LAZY:\n        case MEMBERS_INJECTOR:\n          return true;\n        case PRODUCER:\n        case PRODUCED:\n        case FUTURE:\n          return false;\n        default:\n          throw new AssertionError();\n      }\n    }\n    // otherwise, the second-most-recent bindings determine whether the most recent one must be a\n    // provision\n    return !provisionsDependingOnLatestRequest(path).isEmpty();\n  }\n\n  /**\n   * Returns any provision bindings resolved for the second-most-recent request in the given path;\n   * that is, returns those provision bindings that depend on the latest request in the path.\n   */\n  private FluentIterable\u003cContributionBinding\u003e provisionsDependingOnLatestRequest(\n      final DependencyPath path) {\n    return FluentIterable.from(path.previousResolvedBindings().bindings())\n        .filter(PROVISION::isOfType)\n        .filter(binding -\u003e binding.implicitDependencies().contains(path.currentDependencyRequest()))\n        .filter(ContributionBinding.class);\n  }\n\n  private String formatContributionType(ContributionType type) {\n    switch (type) {\n      case MAP:\n        return \"Map\";\n      case SET:\n      case SET_VALUES:\n        return \"Set\";\n      case UNIQUE:\n        return \"Unique\";\n      default:\n        throw new IllegalStateException(\"Unknown binding type: \" + type);\n    }\n  }\n\n  private String formatCurrentDependencyRequestKey(DependencyPath path) {\n    return keyFormatter.format(path.currentDependencyRequest().key());\n  }\n\n  @AutoValue\n  abstract static class ResolvedRequest {\n\n    abstract DependencyRequest dependencyRequest();\n\n    abstract ResolvedBindings resolvedBindings();\n\n    /**\n     * The {@link #resolvedBindings()} of the previous entry in the {@link DependencyPath}. One of\n     * these bindings depends directly on {@link #dependencyRequest()}.\n     */\n    abstract Optional\u003cResolvedBindings\u003e dependentBindings();\n\n    /**\n     * If the binding that depends on {@link #dependencyRequest()} is a synthetic optional binding,\n     * returns its {@code @BindsOptionalOf} methods.\n     */\n    ImmutableSet\u003cOptionalBindingDeclaration\u003e dependentOptionalBindingDeclarations() {\n      if (dependentBindings().isPresent()) {\n        ResolvedBindings dependentBindings \u003d dependentBindings().get();\n        for (ContributionBinding dependentBinding : dependentBindings.contributionBindings()) {\n          if (dependentBinding.bindingKind().equals(SYNTHETIC_OPTIONAL_BINDING)\n              \u0026\u0026 dependentBinding.dependencies().contains(dependencyRequest())) {\n            return dependentBindings.optionalBindingDeclarations();\n          }\n        }\n      }\n      return ImmutableSet.\u003cOptionalBindingDeclaration\u003eof();\n    }\n\n    private static ResolvedRequest create(\n        DependencyRequest request,\n        ResolvedBindings resolvedBindings,\n        Optional\u003cResolvedBindings\u003e dependentBindings) {\n      return new AutoValue_BindingGraphValidator_ResolvedRequest(\n          request, resolvedBindings, dependentBindings);\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\BindingKey.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.auto.value.AutoValue;\n\n/**\n * A value object that pairs a {@link Key} with the style of its binding (i.e., whether it\u0027s a\n * members injector or normal contribution).\n *\n *  @author Gregory Kick\n *  @since 2.0\n */\n@AutoValue\nabstract class BindingKey {\n  /** The style of binding that makes a {@link Key} available. */\n  enum Kind {\n    CONTRIBUTION, MEMBERS_INJECTION;\n  }\n\n  static BindingKey contribution(Key key) {\n    return new AutoValue_BindingKey(Kind.CONTRIBUTION, key);\n  }\n\n  static BindingKey membersInjection(Key key) {\n    return new AutoValue_BindingKey(Kind.MEMBERS_INJECTION, key);\n  }\n\n  abstract Kind kind();\n  abstract Key key();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\BindingMethodValidator.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getAnnotationMirror;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_ABSTRACT;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_MAP_HAS_MAP_KEY;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RETURN_SET;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_ANY;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_MULTIPLE_MAP_KEYS;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_NO_MAP_KEY;\nimport static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM;\nimport static dagger.internal.codegen.ErrorMessages.MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD;\nimport static dagger.internal.codegen.InjectionAnnotations.getQualifiers;\nimport static dagger.internal.codegen.MapKeys.getMapKeys;\nimport static dagger.internal.codegen.Util.isAnyAnnotationPresent;\nimport static javax.lang.model.element.Modifier.ABSTRACT;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.type.TypeKind.ARRAY;\nimport static javax.lang.model.type.TypeKind.DECLARED;\nimport static javax.lang.model.type.TypeKind.TYPEVAR;\nimport static javax.lang.model.type.TypeKind.VOID;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport dagger.MapKey;\nimport dagger.Provides;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntoMap;\nimport dagger.producers.Produces;\nimport java.lang.annotation.Annotation;\nimport javax.annotation.OverridingMethodsMustInvokeSuper;\nimport javax.annotation.processing.Messager;\nimport javax.inject.Qualifier;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.type.TypeKind;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/** A validator for methods that represent binding declarations. */\nabstract class BindingMethodValidator {\n\n  private final Elements elements;\n  private final Types types;\n  private final Class\u003c? extends Annotation\u003e methodAnnotation;\n  private final ImmutableSet\u003c? extends Class\u003c? extends Annotation\u003e\u003e enclosingElementAnnotations;\n  private final Abstractness abstractness;\n  private final ExceptionSuperclass exceptionSuperclass;\n  private final LoadingCache\u003cExecutableElement, ValidationReport\u003cExecutableElement\u003e\u003e cache \u003d\n      CacheBuilder.newBuilder()\n          .build(\n              new CacheLoader\u003cExecutableElement, ValidationReport\u003cExecutableElement\u003e\u003e() {\n                @Override\n                public ValidationReport\u003cExecutableElement\u003e load(ExecutableElement method) {\n                  ValidationReport.Builder\u003cExecutableElement\u003e builder \u003d\n                      ValidationReport.about(method);\n                  checkMethod(builder);\n                  return builder.build();\n                }\n              });\n  private final AllowsMultibindings allowsMultibindings;\n\n  /**\n   * Creates a validator object.\n   *\n   * @param methodAnnotation the annotation on a method that identifies it as a binding method\n   * @param enclosingElementAnnotation the method must be declared in a class or interface annotated\n   *     with this annotation\n   */\n  protected BindingMethodValidator(\n      Elements elements,\n      Types types,\n      Class\u003c? extends Annotation\u003e methodAnnotation,\n      Class\u003c? extends Annotation\u003e enclosingElementAnnotation,\n      Abstractness abstractness,\n      ExceptionSuperclass exceptionSuperclass,\n      AllowsMultibindings allowsMultibindings) {\n    this(\n        elements,\n        types,\n        methodAnnotation,\n        ImmutableSet.of(enclosingElementAnnotation),\n        abstractness,\n        exceptionSuperclass,\n        allowsMultibindings);\n  }\n\n  /**\n   * Creates a validator object.\n   *\n   * @param methodAnnotation the annotation on a method that identifies it as a binding method\n   * @param enclosingElementAnnotations the method must be declared in a class or interface\n   *     annotated with one of these annotations\n   */\n  protected BindingMethodValidator(\n      Elements elements,\n      Types types,\n      Class\u003c? extends Annotation\u003e methodAnnotation,\n      Iterable\u003c? extends Class\u003c? extends Annotation\u003e\u003e enclosingElementAnnotations,\n      Abstractness abstractness,\n      ExceptionSuperclass exceptionSuperclass,\n      AllowsMultibindings allowsMultibindings) {\n    this.elements \u003d elements;\n    this.types \u003d types;\n    this.methodAnnotation \u003d methodAnnotation;\n    this.enclosingElementAnnotations \u003d ImmutableSet.copyOf(enclosingElementAnnotations);\n    this.abstractness \u003d abstractness;\n    this.exceptionSuperclass \u003d exceptionSuperclass;\n    this.allowsMultibindings \u003d allowsMultibindings;\n  }\n  \n  /** The annotation that identifies methods validated by this object. */\n  Class\u003c? extends Annotation\u003e methodAnnotation() {\n    return methodAnnotation;\n  }\n\n  /** Returns a {@link ValidationReport} for {@code method}. */\n  final ValidationReport\u003cExecutableElement\u003e validate(ExecutableElement method) {\n    return cache.getUnchecked(method);\n  }\n\n  /** Prints validation reports to {@code messager}, and returns valid methods. */\n  final ImmutableSet\u003cExecutableElement\u003e validate(\n      Messager messager, Iterable\u003c? extends ExecutableElement\u003e methods) {\n    ImmutableSet.Builder\u003cExecutableElement\u003e validMethods \u003d ImmutableSet.builder();\n    for (ExecutableElement method : methods) {\n      ValidationReport\u003cExecutableElement\u003e report \u003d validate(method);\n      report.printMessagesTo(messager);\n      if (report.isClean()) {\n        validMethods.add(method);\n      }\n    }\n    return validMethods.build();\n  }\n\n  /** Checks the method for validity. Adds errors to {@code builder}. */\n  @OverridingMethodsMustInvokeSuper\n  protected void checkMethod(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    checkEnclosingElement(builder);\n    checkTypeParameters(builder);\n    checkNotPrivate(builder);\n    checkAbstractness(builder);\n    checkReturnType(builder);\n    checkThrows(builder);\n    checkQualifiers(builder);\n    checkMapKeys(builder);\n    checkMultibindings(builder);\n  }\n\n  /**\n   * Adds an error if the method is not declared in a class or interface annotated with one of the\n   * {@link #enclosingElementAnnotations}.\n   */\n  // TODO(b/28861722): Make private once @Multibindings is deleted.\n  protected void checkEnclosingElement(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    if (!isAnyAnnotationPresent(\n        builder.getSubject().getEnclosingElement(), enclosingElementAnnotations)) {\n      builder.addError(\n          formatErrorMessage(\n              BINDING_METHOD_NOT_IN_MODULE,\n              FluentIterable.from(enclosingElementAnnotations)\n                  .transform(Class::getSimpleName)\n                  .join(Joiner.on(\" or @\"))));\n    }\n  }\n\n  /** Adds an error if the method is generic. */\n  private void checkTypeParameters(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    if (!builder.getSubject().getTypeParameters().isEmpty()) {\n      builder.addError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));\n    }\n  }\n\n  /** Adds an error if the method is private. */\n  private void checkNotPrivate(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    if (builder.getSubject().getModifiers().contains(PRIVATE)) {\n      builder.addError(formatErrorMessage(BINDING_METHOD_PRIVATE));\n    }\n  }\n\n  /** Adds an error if the method is abstract but must not be, or is not and must be. */\n  private void checkAbstractness(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    boolean isAbstract \u003d builder.getSubject().getModifiers().contains(ABSTRACT);\n    switch (abstractness) {\n      case MUST_BE_ABSTRACT:\n        if (!isAbstract) {\n          builder.addError(formatErrorMessage(BINDING_METHOD_NOT_ABSTRACT));\n        }\n        break;\n\n      case MUST_BE_CONCRETE:\n        if (isAbstract) {\n          builder.addError(formatErrorMessage(BINDING_METHOD_ABSTRACT));\n        }\n        break;\n\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  /**\n   * Adds an error if the return type is not appropriate for the method.\n   *\n   * \u003cp\u003eAdds an error if the method doesn\u0027t return a primitive, array, declared type, or type\n   * variable.\n   *\n   * \u003cp\u003eIf the method is not a multibinding contribution, adds an error if it returns a framework\n   * type.\n   *\n   * \u003cp\u003eIf the method is a {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES}\n   * contribution, adds an error if the method doesn\u0027t return a {@code Set\u003cT\u003e} for some {@code T}\n   */\n  protected void checkReturnType(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    switch (ContributionType.fromBindingMethod(builder.getSubject())) {\n      case UNIQUE:\n        /* Validate that a unique binding is not attempting to bind a framework type. This\n         * validation is only appropriate for unique bindings because multibindings may collect\n         * framework types.  E.g. Set\u003cProvider\u003cFoo\u003e\u003e is perfectly reasonable. */\n        checkFrameworkType(builder);\n        // fall through\n\n      case SET:\n      case MAP:\n        checkKeyType(builder, builder.getSubject().getReturnType());\n        break;\n\n      case SET_VALUES:\n        checkSetValuesType(builder);\n        break;\n\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  /**\n   * Adds an error if {@code keyType} is not a primitive, declared type, array, or type variable.\n   */\n  protected void checkKeyType(\n      ValidationReport.Builder\u003cExecutableElement\u003e builder, TypeMirror keyType) {\n    TypeKind kind \u003d keyType.getKind();\n    if (kind.equals(VOID)) {\n      builder.addError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));\n    } else if (!(kind.isPrimitive()\n        || kind.equals(DECLARED)\n        || kind.equals(ARRAY)\n        || kind.equals(TYPEVAR))) {\n      builder.addError(badReturnTypeMessage());\n    }\n  }\n\n  /** The error message when a non-{@code void} binding method returns a bad type. */\n  protected String badReturnTypeMessage() {\n    return formatErrorMessage(BINDING_METHOD_RETURN_TYPE);\n  }\n\n  /**\n   * Adds an error if an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method\n   * doesn\u0027t return a {@code Set\u003cT\u003e} for a reasonable {@code T}.\n   */\n  // TODO(gak): should we allow \"covariant return\" for set values?\n  protected void checkSetValuesType(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    checkSetValuesType(builder, builder.getSubject().getReturnType());\n  }\n\n  /** Adds an error if {@code type} is not a {@code Set\u003cT\u003e} for a reasonable {@code T}. */\n  protected final void checkSetValuesType(\n      ValidationReport.Builder\u003cExecutableElement\u003e builder, TypeMirror type) {\n    if (!SetType.isSet(type)) {\n      builder.addError(badSetValuesTypeMessage());\n    } else {\n      SetType setType \u003d SetType.from(type);\n      if (setType.isRawType()) {\n        builder.addError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));\n      } else {\n        checkKeyType(builder, setType.elementType());\n      }\n    }\n  }\n\n  /**\n   * Adds an error if the method declares throws anything but an {@link Error} or an appropriate\n   * subtype of {@link Exception}.\n   */\n  private void checkThrows(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    exceptionSuperclass.checkThrows(this, builder);\n  }\n\n  /** Adds an error if the method has more than one {@linkplain Qualifier qualifier} annotation. */\n  protected void checkQualifiers(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    ImmutableSet\u003c? extends AnnotationMirror\u003e qualifiers \u003d getQualifiers(builder.getSubject());\n    if (qualifiers.size() \u003e 1) {\n      for (AnnotationMirror qualifier : qualifiers) {\n        builder.addError(BINDING_METHOD_MULTIPLE_QUALIFIERS, builder.getSubject(), qualifier);\n      }\n    }\n  }\n\n  /**\n   * Adds an error if an {@link IntoMap @IntoMap} or {@code MAP} method doesn\u0027t have exactly one\n   * {@link MapKey @MapKey} annotation, or if a method that is neither {@link IntoMap @IntoMap} nor\n   * {@code MAP} has any.\n   */\n  protected void checkMapKeys(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    if (!allowsMultibindings.allowsMultibindings()) {\n      return;\n    }\n    ImmutableSet\u003c? extends AnnotationMirror\u003e mapKeys \u003d getMapKeys(builder.getSubject());\n    if (ContributionType.fromBindingMethod(builder.getSubject()).equals(ContributionType.MAP)) {\n      switch (mapKeys.size()) {\n        case 0:\n          builder.addError(formatErrorMessage(BINDING_METHOD_WITH_NO_MAP_KEY));\n          break;\n        case 1:\n          break;\n        default:\n          builder.addError(formatErrorMessage(BINDING_METHOD_WITH_MULTIPLE_MAP_KEYS));\n          break;\n      }\n    } else if (!mapKeys.isEmpty()) {\n      builder.addError(formatErrorMessage(BINDING_METHOD_NOT_MAP_HAS_MAP_KEY));\n    }\n  }\n\n  /**\n   * Adds errors if the method has more than one {@linkplain MultibindingAnnotations multibinding\n   * annotation} or if it has a multibinding annotation and its {@link Provides} or {@link Produces}\n   * annotation has a {@code type} parameter.\n   */\n  protected void checkMultibindings(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    if (!allowsMultibindings.allowsMultibindings()) {\n      return;\n    }\n    ImmutableSet\u003cAnnotationMirror\u003e multibindingAnnotations \u003d\n        MultibindingAnnotations.forMethod(builder.getSubject());\n    if (multibindingAnnotations.size() \u003e 1) {\n      for (AnnotationMirror annotation : multibindingAnnotations) {\n        builder.addError(\n            formatErrorMessage(MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD),\n            builder.getSubject(),\n            annotation);\n      }\n    }\n\n    AnnotationMirror bindingAnnotationMirror \u003d\n        getAnnotationMirror(builder.getSubject(), methodAnnotation).get();\n    boolean usesProvidesType \u003d false;\n    for (ExecutableElement member : bindingAnnotationMirror.getElementValues().keySet()) {\n      usesProvidesType |\u003d member.getSimpleName().contentEquals(\"type\");\n    }\n    if (usesProvidesType \u0026\u0026 !multibindingAnnotations.isEmpty()) {\n      builder.addError(\n          formatErrorMessage(MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM),\n          builder.getSubject());\n    }\n  }\n\n  /** Adds an error if the method returns a {@linkplain FrameworkTypes framework type}. */\n  protected void checkFrameworkType(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    if (FrameworkTypes.isFrameworkType(builder.getSubject().getReturnType())) {\n      builder.addError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));\n    }\n  }\n\n  /**\n   * Formats an error message whose first {@code %s} parameter should be replaced with the simple\n   * name of the method annotation.\n   */\n  protected String formatErrorMessage(String format, Object... otherParameters) {\n    return otherParameters.length \u003d\u003d 0\n        ? String.format(format, methodAnnotation.getSimpleName())\n        : String.format(\n            format, Lists.asList(methodAnnotation.getSimpleName(), otherParameters).toArray());\n  }\n\n  /**\n   * The error message when an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method\n   * returns a bad type.\n   */\n  protected String badSetValuesTypeMessage() {\n    return formatErrorMessage(BINDING_METHOD_SET_VALUES_RETURN_SET);\n  }\n\n  /** An abstract/concrete restriction on methods. */\n  protected enum Abstractness {\n    MUST_BE_ABSTRACT,\n    MUST_BE_CONCRETE\n  }\n\n  /**\n   * The exception class that all {@code throws}-declared throwables must extend, other than\n   * {@link Error}.\n   */\n  protected enum ExceptionSuperclass {\n    /** Methods may not declare any throwable types. */\n    NO_EXCEPTIONS {\n      @Override\n      protected void checkThrows(\n          BindingMethodValidator validator, ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n        if (!builder.getSubject().getThrownTypes().isEmpty()) {\n          builder.addError(validator.formatErrorMessage(BINDING_METHOD_THROWS_ANY));\n          return;\n        }\n      }\n    },\n\n    /** Methods may throw checked or unchecked exceptions or errors. */\n    EXCEPTION(Exception.class, BINDING_METHOD_THROWS),\n\n    /** Methods may throw unchecked exceptions or errors. */\n    RUNTIME_EXCEPTION(RuntimeException.class, BINDING_METHOD_THROWS_CHECKED),\n    ;\n\n    private final Class\u003c? extends Exception\u003e superclass;\n    private final String errorMessage;\n\n    private ExceptionSuperclass() {\n      this(null, null);\n    }\n\n    private ExceptionSuperclass(Class\u003c? extends Exception\u003e superclass, String errorMessage) {\n      this.superclass \u003d superclass;\n      this.errorMessage \u003d errorMessage;\n    }\n\n    /**\n     * Adds an error if the method declares throws anything but an {@link Error} or an appropriate\n     * subtype of {@link Exception}.\n     *\n     * \u003cp\u003eThis method is overridden in {@link #NONE}.\n     */\n    protected void checkThrows(\n        BindingMethodValidator validator, ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n      TypeMirror exceptionSupertype \u003d\n          validator.elements.getTypeElement(superclass.getCanonicalName()).asType();\n      TypeMirror errorType \u003d\n          validator.elements.getTypeElement(Error.class.getCanonicalName()).asType();\n      for (TypeMirror thrownType : builder.getSubject().getThrownTypes()) {\n        if (!validator.types.isSubtype(thrownType, exceptionSupertype)\n            \u0026\u0026 !validator.types.isSubtype(thrownType, errorType)) {\n          builder.addError(validator.formatErrorMessage(errorMessage));\n          break;\n        }\n      }\n    }\n  }\n\n  /** Whether to check multibinding annotations. */\n  protected enum AllowsMultibindings {\n    /**\n     * This method disallows multibinding annotations, so don\u0027t bother checking for their validity.\n     * {@link MultibindingAnnotationsProcessingStep} will add errors if the method has any\n     * multibinding annotations.\n     */\n    NO_MULTIBINDINGS,\n\n    /** This method allows multibinding annotations, so validate them. */\n    ALLOWS_MULTIBINDINGS,\n    ;\n\n    private boolean allowsMultibindings() {\n      return this \u003d\u003d ALLOWS_MULTIBINDINGS;\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\BindingType.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Sets;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.ParameterizedTypeName;\nimport com.squareup.javapoet.TypeName;\nimport dagger.MembersInjector;\nimport dagger.producers.Producer;\nimport javax.inject.Provider;\n\n/**\n * Whether a binding or declaration is for provision, production, or a {@link MembersInjector}.\n */\nenum BindingType {\n  /** A binding with this type is a {@link ProvisionBinding}. */\n  PROVISION(Provider.class),\n\n  /** A binding with this type is a {@link MembersInjectionBinding}. */\n  MEMBERS_INJECTION(MembersInjector.class),\n\n  /** A binding with this type is a {@link ProductionBinding}. */\n  PRODUCTION(Producer.class),\n  ;\n\n  boolean isOfType(HasBindingType hasBindingType) {\n    return this.equals(hasBindingType.bindingType());\n  }\n\n  static final ImmutableSet\u003cBindingType\u003e CONTRIBUTION_TYPES \u003d\n      Sets.immutableEnumSet(PROVISION, PRODUCTION);\n\n  /** An object that is associated with a {@link BindingType}. */\n  interface HasBindingType {\n    /** The binding type of this object. */\n    BindingType bindingType();\n  }\n\n  private final Class\u003c?\u003e frameworkClass;\n\n  BindingType(Class\u003c?\u003e frameworkClass) {\n    this.frameworkClass \u003d frameworkClass;\n  }\n\n  /** The framework class associated with bindings of this type. */\n  Class\u003c?\u003e frameworkClass() {\n    return frameworkClass;\n  }\n\n  /** Returns the {@link #frameworkClass()} parameterized with a type. */\n  ParameterizedTypeName frameworkClassOf(TypeName valueType) {\n    return ParameterizedTypeName.get(ClassName.get(frameworkClass()), valueType);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\BindingTypeMapper.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static dagger.internal.codegen.BindingType.CONTRIBUTION_TYPES;\nimport static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;\nimport static dagger.internal.codegen.BindingType.PRODUCTION;\nimport static dagger.internal.codegen.BindingType.PROVISION;\n\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableSet;\nimport dagger.producers.Producer;\nimport javax.inject.Provider;\n\n/**\n * A mapper for associating a {@link DependencyRequest.Kind} to a {@link BindingType}, dependent on\n * the type of code to be generated (e.g., for {@link Provider} or {@link Producer}).\n */\nenum BindingTypeMapper {\n  FOR_PROVIDER() {\n    @Override public BindingType getBindingType(DependencyRequest.Kind requestKind) {\n      switch (requestKind) {\n        case INSTANCE:\n        case PROVIDER:\n        case PROVIDER_OF_LAZY:\n        case LAZY:\n          return PROVISION;\n        case MEMBERS_INJECTOR:\n          return MEMBERS_INJECTION;\n        case PRODUCED:\n        case PRODUCER:\n          throw new IllegalArgumentException(requestKind.toString());\n        default:\n          throw new AssertionError(requestKind);\n      }\n    }\n  },\n  FOR_PRODUCER() {\n    @Override public BindingType getBindingType(DependencyRequest.Kind requestKind) {\n      switch (requestKind) {\n        case INSTANCE:\n        case PRODUCED:\n        case PRODUCER:\n          return PRODUCTION;\n        case PROVIDER:\n        case PROVIDER_OF_LAZY:\n        case LAZY:\n          return PROVISION;\n        case MEMBERS_INJECTOR:\n          return MEMBERS_INJECTION;\n        default:\n          throw new AssertionError(requestKind);\n      }\n    }\n  };\n\n  static BindingTypeMapper forBindingType(BindingType bindingType) {\n    return bindingType.equals(PRODUCTION) ? FOR_PRODUCER : FOR_PROVIDER;\n  }\n\n  abstract BindingType getBindingType(DependencyRequest.Kind requestKind);\n\n  /**\n   * Returns the {@link BindingType} to use for a collection of requests of the same\n   * {@link BindingKey}. This allows factories to only take a single argument for multiple requests\n   * of the same key.\n   */\n  BindingType getBindingType(Iterable\u003cDependencyRequest\u003e requests) {\n    ImmutableSet\u003cBindingType\u003e classes \u003d\n        FluentIterable.from(requests).transform(request -\u003e getBindingType(request.kind())).toSet();\n    if (classes.size() \u003d\u003d 1) {\n      return getOnlyElement(classes);\n    } else if (classes.equals(CONTRIBUTION_TYPES)) {\n      return PROVISION;\n    } else {\n      throw new IllegalArgumentException(\"Bad set of framework classes: \" + classes);\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\BindingVariableNamer.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.CaseFormat.LOWER_CAMEL;\nimport static com.google.common.base.CaseFormat.UPPER_CAMEL;\nimport static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;\n\nimport java.util.Iterator;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.SimpleTypeVisitor6;\n\n/**\n * Suggests a variable name for a type based on a {@link Binding}. Prefer\n * {@link DependencyVariableNamer} for cases where a specific {@link DependencyRequest} is present.\n *\n * @author Gregory Kick\n * @since 2.0\n */\nfinal class BindingVariableNamer {\n\n  private BindingVariableNamer() {}\n\n  static String name(Binding binding) {\n    StringBuilder builder \u003d new StringBuilder();\n\n    Key key \u003d binding.key();\n    if (key.qualifier().isPresent()) {\n      // TODO(gak): Use a better name for fields with qualifiers with members.\n      builder.append(key.qualifier().get().getAnnotationType().asElement().getSimpleName());\n    }\n\n    TypeMirror type \u003d typeToName(binding);\n    type.accept(\n        new SimpleTypeVisitor6\u003cVoid, StringBuilder\u003e() {\n          @Override\n          public Void visitDeclared(DeclaredType declaredType, StringBuilder builder) {\n            Element element \u003d declaredType.asElement();\n            if (isSubcomponentBuilder(element)) {\n              // Most Subcomponent builders are named \"Builder\", so add their associated\n              // Subcomponent type so that they\u0027re not all \"builderProvider{N}\"\n              builder.append(element.getEnclosingElement().getSimpleName());\n            }\n            builder.append(element.getSimpleName());\n            Iterator\u003c? extends TypeMirror\u003e argumentIterator \u003d\n                declaredType.getTypeArguments().iterator();\n            if (argumentIterator.hasNext()) {\n              builder.append(\"Of\");\n              TypeMirror first \u003d argumentIterator.next();\n              first.accept(this, builder);\n              while (argumentIterator.hasNext()) {\n                builder.append(\"And\");\n                argumentIterator.next().accept(this, builder);\n              }\n            }\n            return null;\n          }\n        },\n        builder);\n\n    return UPPER_CAMEL.to(LOWER_CAMEL, builder.toString());\n  }\n\n  private static TypeMirror typeToName(Binding binding) {\n    if (binding instanceof ContributionBinding\n        \u0026\u0026 ((ContributionBinding) binding).contributionType().equals(ContributionType.SET)) {\n      return SetType.from(binding.key().type()).elementType();\n    }\n    return binding.key().type();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\BindsMethodValidator.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;\nimport static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;\nimport static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;\nimport static dagger.internal.codegen.ErrorMessages.BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET;\nimport static dagger.internal.codegen.ErrorMessages.BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport dagger.Binds;\nimport dagger.Module;\nimport dagger.producers.ProducerModule;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.ElementFilter;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/**\n * A validator for {@link Binds} methods.\n */\nfinal class BindsMethodValidator extends BindingMethodValidator {\n  private final Types types;\n  private final Elements elements;\n\n  BindsMethodValidator(Elements elements, Types types) {\n    super(\n        elements,\n        types,\n        Binds.class,\n        ImmutableSet.of(Module.class, ProducerModule.class),\n        MUST_BE_ABSTRACT,\n        RUNTIME_EXCEPTION,\n        ALLOWS_MULTIBINDINGS);\n    this.types \u003d types;\n    this.elements \u003d elements;\n  }\n\n  @Override\n  protected void checkMethod(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    super.checkMethod(builder);\n    checkParameters(builder);\n  }\n\n  private void checkParameters(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    ExecutableElement method \u003d builder.getSubject();\n    List\u003c? extends VariableElement\u003e parameters \u003d method.getParameters();\n    if (parameters.size() \u003d\u003d 1) {\n      VariableElement parameter \u003d getOnlyElement(parameters);\n      TypeMirror leftHandSide \u003d method.getReturnType();\n      TypeMirror rightHandSide \u003d parameter.asType();\n      ContributionType contributionType \u003d ContributionType.fromBindingMethod(method);\n      switch (contributionType) {\n        case SET_VALUES:\n          if (!SetType.isSet(leftHandSide)) {\n            builder.addError(BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET);\n          } else {\n            validateTypesAreAssignable(\n                builder,\n                rightHandSide,\n                methodParameterType(MoreTypes.asDeclared(leftHandSide), \"addAll\"));\n          }\n          break;\n        case SET:\n          DeclaredType parameterizedSetType \u003d types.getDeclaredType(setElement(), leftHandSide);\n          validateTypesAreAssignable(\n              builder,\n              rightHandSide,\n              methodParameterType(parameterizedSetType, \"add\"));\n          break;\n        case MAP:\n          DeclaredType parameterizedMapType \u003d\n              types.getDeclaredType(mapElement(), unboundedWildcard(), leftHandSide);\n          validateTypesAreAssignable(\n              builder,\n              rightHandSide,\n              methodParameterTypes(parameterizedMapType, \"put\").get(1));\n          break;\n        case UNIQUE:\n          validateTypesAreAssignable(builder, rightHandSide, leftHandSide);\n          break;\n        default:\n          throw new AssertionError(\n              String.format(\n                  \"Unknown contribution type (%s) for method: %s\", contributionType, method));\n      }\n    } else {\n      builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);\n    }\n  }\n\n  private ImmutableList\u003cTypeMirror\u003e methodParameterTypes(DeclaredType type, String methodName) {\n    ImmutableList.Builder\u003cExecutableElement\u003e methodsForName \u003d ImmutableList.builder();\n    for (ExecutableElement method :\n        ElementFilter.methodsIn(MoreElements.asType(type.asElement()).getEnclosedElements())) {\n      if (method.getSimpleName().contentEquals(methodName)) {\n        methodsForName.add(method);\n      }\n    }\n    ExecutableElement method \u003d getOnlyElement(methodsForName.build());\n    return ImmutableList.\u003cTypeMirror\u003ecopyOf(\n        MoreTypes.asExecutable(types.asMemberOf(type, method)).getParameterTypes());\n  }\n\n  private TypeMirror methodParameterType(DeclaredType type, String methodName) {\n    return getOnlyElement(methodParameterTypes(type, methodName));\n  }\n\n  private void validateTypesAreAssignable(\n      ValidationReport.Builder\u003cExecutableElement\u003e builder,\n      TypeMirror rightHandSide,\n      TypeMirror leftHandSide) {\n    if (!types.isAssignable(rightHandSide, leftHandSide)) {\n      builder.addError(BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER);\n    }\n  }\n\n  private TypeElement setElement() {\n    return elements.getTypeElement(Set.class.getName());\n  }\n\n  private TypeElement mapElement() {\n    return elements.getTypeElement(Map.class.getName());\n  }\n\n  private TypeMirror unboundedWildcard() {\n    return types.getWildcardType(null, null);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\BindsOptionalOfMethodValidator.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;\nimport static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;\nimport static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;\nimport static dagger.internal.codegen.ErrorMessages.BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER;\nimport static dagger.internal.codegen.ErrorMessages.BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE;\nimport static dagger.internal.codegen.InjectionAnnotations.getQualifiers;\nimport static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;\nimport static dagger.internal.codegen.Key.isValidImplicitProvisionKey;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableSet;\nimport dagger.BindsOptionalOf;\nimport dagger.Module;\nimport dagger.producers.ProducerModule;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/** A validator for {@link BindsOptionalOf} methods. */\nfinal class BindsOptionalOfMethodValidator extends BindingMethodValidator {\n\n  private final Types types;\n\n  BindsOptionalOfMethodValidator(Elements elements, Types types) {\n    super(\n        elements,\n        types,\n        BindsOptionalOf.class,\n        ImmutableSet.of(Module.class, ProducerModule.class),\n        MUST_BE_ABSTRACT,\n        NO_EXCEPTIONS,\n        NO_MULTIBINDINGS);\n    this.types \u003d types;\n  }\n\n  @Override\n  protected void checkMethod(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    super.checkMethod(builder);\n    checkParameters(builder);\n  }\n\n  @Override\n  protected void checkKeyType(\n      ValidationReport.Builder\u003cExecutableElement\u003e builder, TypeMirror keyType) {\n    super.checkKeyType(builder, keyType);\n    if (isValidImplicitProvisionKey(\n            FluentIterable.from(getQualifiers(builder.getSubject())).first(), keyType, types)\n        \u0026\u0026 !injectedConstructors(MoreElements.asType(MoreTypes.asDeclared(keyType).asElement()))\n            .isEmpty()) {\n      builder.addError(BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE);\n    }\n  }\n\n  private void checkParameters(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    if (!builder.getSubject().getParameters().isEmpty()) {\n      builder.addError(BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER);\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\BuilderValidator.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static javax.lang.model.element.Modifier.ABSTRACT;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.element.Modifier.STATIC;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.base.Equivalence;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.LinkedHashMultimap;\nimport com.google.common.collect.Multimap;\nimport java.lang.annotation.Annotation;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.TypeKind;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.ElementFilter;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/**\n * Validates {@link dagger.Component.Builder} annotations.\n *\n * @author sameb@google.com (Sam Berlin)\n */\nclass BuilderValidator {\n  private final Elements elements;\n  private final Types types;\n\n  BuilderValidator(Elements elements, Types types) {\n    this.elements \u003d elements;\n    this.types \u003d types;\n  }\n\n  public ValidationReport\u003cTypeElement\u003e validate(TypeElement subject) {\n    ValidationReport.Builder\u003cTypeElement\u003e builder \u003d ValidationReport.about(subject);\n\n    ComponentDescriptor.Kind componentKind \u003d\n        ComponentDescriptor.Kind.forAnnotatedBuilderElement(subject).get();\n\n    Element componentElement \u003d subject.getEnclosingElement();\n    ErrorMessages.ComponentBuilderMessages msgs \u003d ErrorMessages.builderMsgsFor(componentKind);\n    Class\u003c? extends Annotation\u003e componentAnnotation \u003d componentKind.annotationType();\n    Class\u003c? extends Annotation\u003e builderAnnotation \u003d componentKind.builderAnnotationType();\n    checkArgument(subject.getAnnotation(builderAnnotation) !\u003d null);\n\n    if (!isAnnotationPresent(componentElement, componentAnnotation)) {\n      builder.addError(msgs.mustBeInComponent(), subject);\n    }\n\n    switch (subject.getKind()) {\n      case CLASS:\n        List\u003c? extends Element\u003e allElements \u003d subject.getEnclosedElements();\n        List\u003cExecutableElement\u003e cxtors \u003d ElementFilter.constructorsIn(allElements);\n        if (cxtors.size() !\u003d 1 || getOnlyElement(cxtors).getParameters().size() !\u003d 0) {\n          builder.addError(msgs.cxtorOnlyOneAndNoArgs(), subject);\n        }\n        break;\n      case INTERFACE:\n        break;\n      default:\n        // If not the correct type, exit early since the rest of the messages will be bogus.\n        builder.addError(msgs.mustBeClassOrInterface(), subject);\n        return builder.build();\n    }\n\n    if (!subject.getTypeParameters().isEmpty()) {\n      builder.addError(msgs.generics(), subject);\n    }\n\n    Set\u003cModifier\u003e modifiers \u003d subject.getModifiers();\n    if (modifiers.contains(PRIVATE)) {\n      builder.addError(msgs.isPrivate(), subject);\n    }\n    if (!modifiers.contains(STATIC)) {\n      builder.addError(msgs.mustBeStatic(), subject);\n    }\n    // Note: Must be abstract, so no need to check for final.\n    if (!modifiers.contains(ABSTRACT)) {\n      builder.addError(msgs.mustBeAbstract(), subject);\n    }\n\n    ExecutableElement buildMethod \u003d null;\n    Multimap\u003cEquivalence.Wrapper\u003cTypeMirror\u003e, ExecutableElement\u003e methodsPerParam \u003d\n        LinkedHashMultimap.create();\n    for (ExecutableElement method : Util.getUnimplementedMethods(elements, subject)) {\n      ExecutableType resolvedMethodType \u003d\n          MoreTypes.asExecutable(types.asMemberOf(MoreTypes.asDeclared(subject.asType()), method));\n      TypeMirror returnType \u003d resolvedMethodType.getReturnType();\n      if (method.getParameters().size() \u003d\u003d 0) {\n        // If this is potentially a build() method, validate it returns the correct type.\n        if (types.isSameType(returnType, componentElement.asType())) {\n          if (buildMethod !\u003d null) {\n            // If we found more than one build-like method, fail.\n            error(builder, method, msgs.twoBuildMethods(), msgs.inheritedTwoBuildMethods(),\n                buildMethod);\n          }\n        } else {\n          error(builder, method, msgs.buildMustReturnComponentType(),\n              msgs.inheritedBuildMustReturnComponentType());\n        }\n        // We set the buildMethod regardless of the return type to reduce error spam.\n        buildMethod \u003d method;\n      } else if (method.getParameters().size() \u003e 1) {\n        // If this is a setter, make sure it has one arg.\n        error(builder, method, msgs.methodsMustTakeOneArg(), msgs.inheritedMethodsMustTakeOneArg());\n      } else if (returnType.getKind() !\u003d TypeKind.VOID\n          \u0026\u0026 !types.isSubtype(subject.asType(), returnType)) {\n        // If this correctly had one arg, make sure the return types are valid.\n        error(builder, method, msgs.methodsMustReturnVoidOrBuilder(),\n            msgs.inheritedMethodsMustReturnVoidOrBuilder());\n      } else {\n        // If the return types are valid, record the method.\n        methodsPerParam.put(\n            MoreTypes.equivalence().\u003cTypeMirror\u003ewrap(\n                Iterables.getOnlyElement(resolvedMethodType.getParameterTypes())),\n            method);\n      }\n\n      if (!method.getTypeParameters().isEmpty()) {\n        error(builder, method, msgs.methodsMayNotHaveTypeParameters(),\n            msgs.inheritedMethodsMayNotHaveTypeParameters());\n      }\n    }\n\n    if (buildMethod \u003d\u003d null) {\n      builder.addError(msgs.missingBuildMethod(), subject);\n    }\n\n    // Go back through each recorded method per param type.  If we had more than one method\n    // for a given param, fail.\n    for (Map.Entry\u003cEquivalence.Wrapper\u003cTypeMirror\u003e, Collection\u003cExecutableElement\u003e\u003e entry :\n        methodsPerParam.asMap().entrySet()) {\n      if (entry.getValue().size() \u003e 1) {\n        TypeMirror type \u003d entry.getKey().get();\n        builder.addError(String.format(msgs.manyMethodsForType(), type, entry.getValue()), subject);\n      }\n    }\n\n    // Note: there\u0027s more validation in BindingGraphValidator,\n    // specifically to make sure the setter methods mirror the deps.\n\n    return builder.build();\n  }\n\n  /**\n   * Generates one of two error messages. If the method is enclosed in the subject, we target the\n   * error to the method itself. Otherwise we target the error to the subject and list the method as\n   * an argumnent. (Otherwise we have no way of knowing if the method is being compiled in this pass\n   * too, so javac might not be able to pinpoint it\u0027s line of code.)\n   */\n  /*\n   * For Component.Builder, the prototypical example would be if someone had:\n   *    libfoo: interface SharedBuilder { void badSetter(A a, B b); }\n   *    libbar: BarComponent { BarBuilder extends SharedBuilder } }\n   * ... the compiler only validates BarBuilder when compiling libbar, but it fails because\n   * of libfoo\u0027s SharedBuilder (which could have been compiled in a previous pass).\n   * So we can\u0027t point to SharedBuilder#badSetter as the subject of the BarBuilder validation\n   * failure.\n   *\n   * This check is a little more strict than necessary -- ideally we\u0027d check if method\u0027s enclosing\n   * class was included in this compile run.  But that\u0027s hard, and this is close enough.\n   */\n  private void error(\n      ValidationReport.Builder\u003cTypeElement\u003e builder,\n      ExecutableElement method,\n      String enclosedError,\n      String inheritedError,\n      Object... extraArgs) {\n    if (method.getEnclosingElement().equals(builder.getSubject())) {\n      builder.addError(String.format(enclosedError, extraArgs), method);\n    } else {\n      Object[] newArgs \u003d new Object[extraArgs.length + 1];\n      newArgs[0] \u003d method;\n      System.arraycopy(extraArgs, 0, newArgs, 1, extraArgs.length);\n      builder.addError(String.format(inheritedError, newArgs));\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\CodeBlocks.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.common.collect.FluentIterable;\nimport com.squareup.javapoet.CodeBlock;\nimport java.util.Iterator;\nimport javax.lang.model.type.TypeMirror;\n\nfinal class CodeBlocks {\n\n  /**\n   * Returns a comma-separated version of {@code codeBlocks} as one unified {@link CodeBlock}.\n   */\n  static CodeBlock makeParametersCodeBlock(Iterable\u003cCodeBlock\u003e codeBlocks) {\n    return join(codeBlocks, \", \");\n  }\n\n  /**\n   * Returns one unified {@link CodeBlock} which joins each item in {@code codeBlocks} with a\n   * newline.\n   */\n  static CodeBlock concat(Iterable\u003cCodeBlock\u003e codeBlocks) {\n    return join(codeBlocks, \"\\n\");\n  }\n\n  static CodeBlock.Builder join(\n      CodeBlock.Builder builder, Iterable\u003cCodeBlock\u003e codeBlocks, String delimiter) {\n    Iterator\u003cCodeBlock\u003e iterator \u003d codeBlocks.iterator();\n    while (iterator.hasNext()) {\n      builder.add(iterator.next());\n      if (iterator.hasNext()) {\n        builder.add(delimiter);\n      }\n    }\n    return builder;\n  }\n\n  static CodeBlock join(Iterable\u003cCodeBlock\u003e codeBlocks, String delimiter) {\n    return join(CodeBlock.builder(), codeBlocks, delimiter).build();\n  }\n\n  static FluentIterable\u003cCodeBlock\u003e toCodeBlocks(Iterable\u003c? extends TypeMirror\u003e typeMirrors) {\n    return FluentIterable.from(typeMirrors).transform(typeMirror -\u003e CodeBlock.of(\"$T\", typeMirror));\n  }\n\n  static CodeBlock stringLiteral(String toWrap) {\n    return CodeBlock.of(\"$S\", toWrap);\n  }\n\n  private CodeBlocks() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\CompilerOptions.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Ascii;\nimport com.google.common.collect.ImmutableSet;\nimport dagger.producers.Produces;\nimport java.util.EnumSet;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.annotation.processing.ProcessingEnvironment;\nimport javax.lang.model.util.Elements;\nimport javax.tools.Diagnostic;\n\n/** A collection of options that dictate how the compiler will run. */\n@AutoValue\nabstract class CompilerOptions {\n  abstract boolean usesProducers();\n  abstract boolean writeProducerNameInToken();\n  abstract Diagnostic.Kind nullableValidationKind();\n  abstract Diagnostic.Kind privateMemberValidationKind();\n  abstract Diagnostic.Kind staticMemberValidationKind();\n  abstract boolean ignorePrivateAndStaticInjectionForComponent();\n  abstract ValidationType scopeCycleValidationType();\n\n  static Builder builder() {\n    return new AutoValue_CompilerOptions.Builder();\n  }\n\n  static CompilerOptions create(ProcessingEnvironment processingEnv, Elements elements) {\n    return builder()\n        .usesProducers(elements.getTypeElement(Produces.class.getCanonicalName()) !\u003d null)\n        .writeProducerNameInToken(\n            writeProducerNameInToken(processingEnv).equals(FeatureStatus.ENABLED))\n        .nullableValidationKind(nullableValidationType(processingEnv).diagnosticKind().get())\n        .privateMemberValidationKind(\n            privateMemberValidationType(processingEnv).diagnosticKind().get())\n        .staticMemberValidationKind(\n            staticMemberValidationType(processingEnv).diagnosticKind().get())\n        .ignorePrivateAndStaticInjectionForComponent(\n            ignorePrivateAndStaticInjectionForComponent(processingEnv)\n                .equals(FeatureStatus.DISABLED))\n        .scopeCycleValidationType(scopeValidationType(processingEnv))\n        .build();\n  }\n\n  @AutoValue.Builder\n  interface Builder {\n    Builder usesProducers(boolean usesProduces);\n    Builder writeProducerNameInToken(boolean writeProducerNameInToken);\n    Builder nullableValidationKind(Diagnostic.Kind kind);\n    Builder privateMemberValidationKind(Diagnostic.Kind kind);\n    Builder staticMemberValidationKind(Diagnostic.Kind kind);\n    Builder ignorePrivateAndStaticInjectionForComponent(\n        boolean ignorePrivateAndStaticInjectionForComponent);\n    Builder scopeCycleValidationType(ValidationType type);\n    CompilerOptions build();\n  }\n\n  static final String WRITE_PRODUCER_NAME_IN_TOKEN_KEY \u003d \"dagger.writeProducerNameInToken\";\n\n  static final String DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY \u003d\n      \"dagger.disableInterComponentScopeValidation\";\n\n  static final String NULLABLE_VALIDATION_KEY \u003d \"dagger.nullableValidation\";\n\n  static final String PRIVATE_MEMBER_VALIDATION_TYPE_KEY \u003d \"dagger.privateMemberValidation\";\n\n  static final String STATIC_MEMBER_VALIDATION_TYPE_KEY \u003d \"dagger.staticMemberValidation\";\n\n  /**\n   * If true, Dagger will generate factories and components even if some members-injected types\n   * have private or static {@code @Inject}-annotated members.\n   *\n   * \u003cp\u003eThis defaults to false, and should only ever be enabled by the TCK tests. Disabling this\n   * validation could lead to generating code that does not compile.\n   */\n  static final String IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT \u003d\n      \"dagger.ignorePrivateAndStaticInjectionForComponent\";\n\n  static final ImmutableSet\u003cString\u003e SUPPORTED_OPTIONS \u003d ImmutableSet.of(\n        WRITE_PRODUCER_NAME_IN_TOKEN_KEY,\n        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,\n        NULLABLE_VALIDATION_KEY,\n        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,\n        STATIC_MEMBER_VALIDATION_TYPE_KEY,\n        IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT);\n\n  private static FeatureStatus writeProducerNameInToken(ProcessingEnvironment processingEnv) {\n    return valueOf(\n        processingEnv,\n        WRITE_PRODUCER_NAME_IN_TOKEN_KEY,\n        FeatureStatus.DISABLED,\n        EnumSet.allOf(FeatureStatus.class));\n  }\n\n  private static ValidationType scopeValidationType(ProcessingEnvironment processingEnv) {\n    return valueOf(\n        processingEnv,\n        DISABLE_INTER_COMPONENT_SCOPE_VALIDATION_KEY,\n        ValidationType.ERROR,\n        EnumSet.allOf(ValidationType.class));\n  }\n\n  private static ValidationType nullableValidationType(ProcessingEnvironment processingEnv) {\n    return valueOf(\n        processingEnv,\n        NULLABLE_VALIDATION_KEY,\n        ValidationType.ERROR,\n        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));\n  }\n\n  private static ValidationType privateMemberValidationType(ProcessingEnvironment processingEnv) {\n    return valueOf(\n        processingEnv,\n        PRIVATE_MEMBER_VALIDATION_TYPE_KEY,\n        ValidationType.ERROR,\n        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));\n  }\n\n  private static ValidationType staticMemberValidationType(ProcessingEnvironment processingEnv) {\n    return valueOf(\n        processingEnv,\n        STATIC_MEMBER_VALIDATION_TYPE_KEY,\n        ValidationType.ERROR,\n        EnumSet.of(ValidationType.ERROR, ValidationType.WARNING));\n  }\n\n  private static FeatureStatus ignorePrivateAndStaticInjectionForComponent(\n      ProcessingEnvironment processingEnv) {\n    return valueOf(\n        processingEnv,\n        IGNORE_PRIVATE_AND_STATIC_INJECTION_FOR_COMPONENT,\n        FeatureStatus.DISABLED,\n        EnumSet.allOf(FeatureStatus.class));\n  }\n\n  private static \u003cT extends Enum\u003cT\u003e\u003e T valueOf(\n      ProcessingEnvironment processingEnv, String key, T defaultValue, Set\u003cT\u003e validValues) {\n    Map\u003cString, String\u003e options \u003d processingEnv.getOptions();\n    if (options.containsKey(key)) {\n      try {\n        T type \u003d\n            Enum.valueOf(defaultValue.getDeclaringClass(), Ascii.toUpperCase(options.get(key)));\n        if (!validValues.contains(type)) {\n          throw new IllegalArgumentException(); // let handler below print out good msg.\n        }\n        return type;\n      } catch (IllegalArgumentException e) {\n        processingEnv\n            .getMessager()\n            .printMessage(\n                Diagnostic.Kind.ERROR,\n                \"Processor option -A\"\n                    + key\n                    + \" may only have the values \"\n                    + validValues\n                    + \" (case insensitive), found: \"\n                    + options.get(key));\n      }\n    }\n    return defaultValue;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ComponentDescriptor.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getAnnotationMirror;\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Verify.verify;\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;\nimport static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponent;\nimport static dagger.internal.codegen.ConfigurationAnnotations.isSubcomponentBuilder;\nimport static dagger.internal.codegen.InjectionAnnotations.getQualifier;\nimport static javax.lang.model.type.TypeKind.DECLARED;\nimport static javax.lang.model.type.TypeKind.VOID;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableBiMap;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Sets;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.squareup.javapoet.ClassName;\nimport dagger.Component;\nimport dagger.Lazy;\nimport dagger.MembersInjector;\nimport dagger.Module;\nimport dagger.Subcomponent;\nimport dagger.producers.ProductionComponent;\nimport dagger.producers.ProductionSubcomponent;\nimport java.lang.annotation.Annotation;\nimport java.util.EnumSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.inject.Provider;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.ElementFilter;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/**\n * The logical representation of a {@link Component} or {@link ProductionComponent} definition.\n *\n * @author Gregory Kick\n * @since 2.0\n */\n@AutoValue\nabstract class ComponentDescriptor {\n  ComponentDescriptor() {}\n\n  enum Kind {\n    COMPONENT(Component.class, Component.Builder.class, true),\n    SUBCOMPONENT(Subcomponent.class, Subcomponent.Builder.class, false),\n    PRODUCTION_COMPONENT(ProductionComponent.class, ProductionComponent.Builder.class, true),\n    PRODUCTION_SUBCOMPONENT(\n        ProductionSubcomponent.class, ProductionSubcomponent.Builder.class, false);\n\n    private final Class\u003c? extends Annotation\u003e annotationType;\n    private final Class\u003c? extends Annotation\u003e builderType;\n    private final boolean isTopLevel;\n\n    /**\n     * Returns the kind of an annotated element if it is annotated with one of the\n     * {@linkplain #annotationType() annotation types}.\n     *\n     * @throws IllegalArgumentException if the element is annotated with more than one of the\n     *     annotation types\n     */\n    static Optional\u003cKind\u003e forAnnotatedElement(TypeElement element) {\n      Set\u003cKind\u003e kinds \u003d EnumSet.noneOf(Kind.class);\n      for (Kind kind : values()) {\n        if (MoreElements.isAnnotationPresent(element, kind.annotationType())) {\n          kinds.add(kind);\n        }\n      }\n      checkArgument(\n          kinds.size() \u003c\u003d 1, \"%s cannot be annotated with more than one of %s\", element, kinds);\n      return Optional.fromNullable(getOnlyElement(kinds, null));\n    }\n\n    /**\n     * Returns the kind of an annotated element if it is annotated with one of the\n     * {@linkplain #builderAnnotationType() annotation types}.\n     *\n     * @throws IllegalArgumentException if the element is annotated with more than one of the\n     *     annotation types\n     */\n    static Optional\u003cKind\u003e forAnnotatedBuilderElement(TypeElement element) {\n      Set\u003cKind\u003e kinds \u003d EnumSet.noneOf(Kind.class);\n      for (Kind kind : values()) {\n        if (MoreElements.isAnnotationPresent(element, kind.builderAnnotationType())) {\n          kinds.add(kind);\n        }\n      }\n      checkArgument(\n          kinds.size() \u003c\u003d 1, \"%s cannot be annotated with more than one of %s\", element, kinds);\n      return Optional.fromNullable(getOnlyElement(kinds, null));\n    }\n\n    Kind(\n        Class\u003c? extends Annotation\u003e annotationType,\n        Class\u003c? extends Annotation\u003e builderType,\n        boolean isTopLevel) {\n      this.annotationType \u003d annotationType;\n      this.builderType \u003d builderType;\n      this.isTopLevel \u003d isTopLevel;\n    }\n\n    Class\u003c? extends Annotation\u003e annotationType() {\n      return annotationType;\n    }\n\n    Class\u003c? extends Annotation\u003e builderAnnotationType() {\n      return builderType;\n    }\n\n    ImmutableSet\u003cModuleDescriptor.Kind\u003e moduleKinds() {\n      switch (this) {\n        case COMPONENT:\n        case SUBCOMPONENT:\n          return Sets.immutableEnumSet(ModuleDescriptor.Kind.MODULE);\n        case PRODUCTION_COMPONENT:\n        case PRODUCTION_SUBCOMPONENT:\n          return Sets.immutableEnumSet(\n              ModuleDescriptor.Kind.MODULE, ModuleDescriptor.Kind.PRODUCER_MODULE);\n        default:\n          throw new AssertionError(this);\n      }\n    }\n\n    ImmutableSet\u003cKind\u003e subcomponentKinds() {\n      switch (this) {\n        case COMPONENT:\n        case SUBCOMPONENT:\n          return ImmutableSet.of(SUBCOMPONENT, PRODUCTION_SUBCOMPONENT);\n        case PRODUCTION_COMPONENT:\n        case PRODUCTION_SUBCOMPONENT:\n          return ImmutableSet.of(PRODUCTION_SUBCOMPONENT);\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    boolean isTopLevel() {\n      return isTopLevel;\n    }\n\n    boolean isProducer() {\n      switch (this) {\n        case COMPONENT:\n        case SUBCOMPONENT:\n          return false;\n        case PRODUCTION_COMPONENT:\n        case PRODUCTION_SUBCOMPONENT:\n          return true;\n        default:\n          throw new AssertionError();\n      }\n    }\n  }\n\n  abstract Kind kind();\n\n  abstract AnnotationMirror componentAnnotation();\n\n  /**\n   * The type (interface or abstract class) that defines the component. This is the element to which\n   * the {@link Component} annotation was applied.\n   */\n  abstract TypeElement componentDefinitionType();\n\n  /**\n   * The set of component dependencies listed in {@link Component#dependencies}.\n   */\n  abstract ImmutableSet\u003cTypeElement\u003e dependencies();\n\n  /**\n   * The set of {@link ModuleDescriptor modules} declared directly in {@link Component#modules}.\n   * Use {@link #transitiveModules} to get the full set of modules available upon traversing\n   * {@link Module#includes}.\n   */\n  abstract ImmutableSet\u003cModuleDescriptor\u003e modules();\n\n  /**\n   * Returns the set of {@link ModuleDescriptor modules} declared in {@link Component#modules} and\n   * those reachable by traversing {@link Module#includes}.\n   *\n   * \u003cp\u003eNote that for subcomponents this \u003cem\u003ewill not\u003c/em\u003e include descriptors for any modules that\n   * are declared in parent components.\n   */\n  abstract ImmutableSet\u003cModuleDescriptor\u003e transitiveModules();\n\n  ImmutableSet\u003cTypeElement\u003e transitiveModuleTypes() {\n    return FluentIterable.from(transitiveModules())\n        .transform(ModuleDescriptor::moduleElement)\n        .toSet();\n  }\n\n  private static ImmutableSet\u003cModuleDescriptor\u003e transitiveModules(\n      Iterable\u003cModuleDescriptor\u003e topLevelModules) {\n    Set\u003cModuleDescriptor\u003e transitiveModules \u003d new LinkedHashSet\u003c\u003e();\n    for (ModuleDescriptor module : topLevelModules) {\n      addTransitiveModules(transitiveModules, module);\n    }\n    return ImmutableSet.copyOf(transitiveModules);\n  }\n\n  private static void addTransitiveModules(\n      Set\u003cModuleDescriptor\u003e transitiveModules, ModuleDescriptor module) {\n    if (transitiveModules.add(module)) {\n      for (ModuleDescriptor includedModule : module.includedModules()) {\n        addTransitiveModules(transitiveModules, includedModule);\n      }\n    }\n  }\n\n  /**\n   * An index of the type to which this component holds a reference (the type listed in\n   * {@link Component#dependencies} or {@link ProductionComponent#dependencies} as opposed to the\n   * enclosing type) for each method from a component dependency that can be used for binding.\n   */\n  abstract ImmutableMap\u003cExecutableElement, TypeElement\u003e dependencyMethodIndex();\n\n  /**\n   * The scopes of the component.\n   */\n  abstract ImmutableSet\u003cScope\u003e scopes();\n\n  /**\n   * All {@link Subcomponent}s which are direct children of this component. This includes\n   * subcomponents installed from {@link Module#subcomponents()} as well as subcomponent {@linkplain\n   * #subcomponentsByFactoryMethod() factory methods} and {@linkplain\n   * #subcomponentsByBuilderMethod() builder methods}.\n   */\n  ImmutableSet\u003cComponentDescriptor\u003e subcomponents() {\n    return ImmutableSet.\u003cComponentDescriptor\u003ebuilder()\n        .addAll(subcomponentsByFactoryMethod().values())\n        .addAll(subcomponentsByBuilderMethod().values())\n        .addAll(subcomponentsFromModules())\n        .build();\n  }\n\n  /**\n   * All {@linkplain Subcomponent direct child} components that are declared by a {@linkplain\n   * Module#subcomponents() module\u0027s subcomponents}.\n   */\n  abstract ImmutableSet\u003cComponentDescriptor\u003e subcomponentsFromModules();\n\n  /**\n   * All {@linkplain Subcomponent direct child} components that are declared by a subcomponent\n   * factory method.\n   */\n  abstract ImmutableBiMap\u003cComponentMethodDescriptor, ComponentDescriptor\u003e\n      subcomponentsByFactoryMethod();\n\n  /**\n   * All {@linkplain Subcomponent direct child} components that are declared by a subcomponent\n   * builder method.\n   */\n  abstract ImmutableBiMap\u003cComponentMethodDescriptor, ComponentDescriptor\u003e\n    subcomponentsByBuilderMethod();\n\n  /**\n   * All {@linkplain Subcomponent direct child} components that are declared by an entry point\n   * method. This is equivalent to the set of values from {@link #subcomponentsByFactoryMethod()}\n   * and {@link #subcomponentsByBuilderMethod().\n   */\n  ImmutableSet\u003cComponentDescriptor\u003e subcomponentsFromEntryPoints() {\n    return ImmutableSet.\u003cComponentDescriptor\u003ebuilder()\n        .addAll(subcomponentsByFactoryMethod().values())\n        .addAll(subcomponentsByBuilderMethod().values())\n        .build();\n  }\n\n  // TODO(ronshapiro): convert this to use @Memoized\n  private ImmutableBiMap\u003cTypeElement, ComponentDescriptor\u003e subcomponentsByBuilderType;\n\n  ImmutableBiMap\u003cTypeElement, ComponentDescriptor\u003e subcomponentsByBuilderType() {\n    if (subcomponentsByBuilderType \u003d\u003d null) {\n      subcomponentsByBuilderType \u003d computeSubcomponentsByBuilderType();\n    }\n    return subcomponentsByBuilderType;\n  }\n\n  private ImmutableBiMap\u003cTypeElement, ComponentDescriptor\u003e computeSubcomponentsByBuilderType() {\n    ImmutableBiMap.Builder\u003cTypeElement, ComponentDescriptor\u003e subcomponentsByBuilderType \u003d\n        ImmutableBiMap.builder();\n    for (ComponentDescriptor subcomponent : subcomponents()) {\n      if (subcomponent.builderSpec().isPresent()) {\n        subcomponentsByBuilderType.put(\n            subcomponent.builderSpec().get().builderDefinitionType(), subcomponent);\n      }\n    }\n    return subcomponentsByBuilderType.build();\n  }\n\n  abstract ImmutableSet\u003cComponentMethodDescriptor\u003e componentMethods();\n\n  // TODO(gak): Consider making this non-optional and revising the\n  // interaction between the spec \u0026 generation\n  abstract Optional\u003cBuilderSpec\u003e builderSpec();\n\n  /** A function that returns all {@link #scopes()} of its input. */\n  @AutoValue\n  abstract static class ComponentMethodDescriptor {\n    abstract ComponentMethodKind kind();\n    abstract Optional\u003cDependencyRequest\u003e dependencyRequest();\n    abstract ExecutableElement methodElement();\n\n    static ComponentMethodDescriptor create(\n        ComponentMethodKind kind,\n        Optional\u003cDependencyRequest\u003e dependencyRequest,\n        ExecutableElement methodElement) {\n      return new AutoValue_ComponentDescriptor_ComponentMethodDescriptor(\n          kind, dependencyRequest, methodElement);\n    }\n\n    static ComponentMethodDescriptor forProvision(\n        ExecutableElement methodElement, DependencyRequest dependencyRequest) {\n      return create(ComponentMethodKind.PROVISION, Optional.of(dependencyRequest), methodElement);\n    }\n\n    static ComponentMethodDescriptor forMembersInjection(\n        ExecutableElement methodElement, DependencyRequest dependencyRequest) {\n      return create(\n          ComponentMethodKind.MEMBERS_INJECTION, Optional.of(dependencyRequest), methodElement);\n    }\n\n    static ComponentMethodDescriptor forSubcomponent(\n        ComponentMethodKind kind, ExecutableElement methodElement) {\n      return create(kind, Optional.\u003cDependencyRequest\u003eabsent(), methodElement);\n    }\n\n    static ComponentMethodDescriptor forSubcomponentBuilder(\n        ComponentMethodKind kind,\n        DependencyRequest dependencyRequestForBuilder,\n        ExecutableElement methodElement) {\n      return create(kind, Optional.of(dependencyRequestForBuilder), methodElement);\n    }\n  }\n\n  enum ComponentMethodKind {\n    PROVISION,\n    PRODUCTION,\n    MEMBERS_INJECTION,\n    SUBCOMPONENT,\n    SUBCOMPONENT_BUILDER,\n    PRODUCTION_SUBCOMPONENT,\n    PRODUCTION_SUBCOMPONENT_BUILDER;\n\n    boolean isSubcomponentKind() {\n      return this \u003d\u003d SUBCOMPONENT || this \u003d\u003d PRODUCTION_SUBCOMPONENT;\n    }\n\n    /**\n     * Returns the component kind associated with this component method, if it exists. Otherwise,\n     * throws.\n     */\n    Kind componentKind() {\n      switch (this) {\n        case SUBCOMPONENT:\n        case SUBCOMPONENT_BUILDER:\n          return Kind.SUBCOMPONENT;\n        case PRODUCTION_SUBCOMPONENT:\n        case PRODUCTION_SUBCOMPONENT_BUILDER:\n          return Kind.PRODUCTION_SUBCOMPONENT;\n        default:\n          throw new IllegalStateException(\"no component associated with method \" + this);\n      }\n    }\n  }\n\n  @AutoValue\n  abstract static class BuilderSpec {\n    abstract TypeElement builderDefinitionType();\n    abstract Map\u003cTypeElement, ExecutableElement\u003e methodMap();\n    abstract ExecutableElement buildMethod();\n    abstract TypeMirror componentType();\n  }\n\n  static final class Factory {\n    private final Elements elements;\n    private final Types types;\n    private final DependencyRequest.Factory dependencyRequestFactory;\n    private final ModuleDescriptor.Factory moduleDescriptorFactory;\n\n    Factory(\n        Elements elements,\n        Types types,\n        DependencyRequest.Factory dependencyRequestFactory,\n        ModuleDescriptor.Factory moduleDescriptorFactory) {\n      this.elements \u003d elements;\n      this.types \u003d types;\n      this.dependencyRequestFactory \u003d dependencyRequestFactory;\n      this.moduleDescriptorFactory \u003d moduleDescriptorFactory;\n    }\n\n    /**\n     * Returns a component descriptor for a type annotated with either {@link Component @Component}\n     * or {@link ProductionComponent @ProductionComponent}.\n     */\n    ComponentDescriptor forComponent(TypeElement componentDefinitionType) {\n      Optional\u003cKind\u003e kind \u003d Kind.forAnnotatedElement(componentDefinitionType);\n      checkArgument(\n          kind.isPresent() \u0026\u0026 kind.get().isTopLevel(),\n          \"%s must be annotated with @Component or @ProductionComponent\",\n          componentDefinitionType);\n      return create(componentDefinitionType, kind.get(), Optional.\u003cKind\u003eabsent());\n    }\n\n    private ComponentDescriptor create(\n        TypeElement componentDefinitionType, Kind kind, Optional\u003cKind\u003e parentKind) {\n      DeclaredType declaredComponentType \u003d MoreTypes.asDeclared(componentDefinitionType.asType());\n      AnnotationMirror componentMirror \u003d\n          getAnnotationMirror(componentDefinitionType, kind.annotationType()).get();\n      ImmutableSet\u003cTypeElement\u003e componentDependencyTypes \u003d\n          kind.isTopLevel()\n              ? MoreTypes.asTypeElements(getComponentDependencies(componentMirror))\n              : ImmutableSet.\u003cTypeElement\u003eof();\n\n      ImmutableMap.Builder\u003cExecutableElement, TypeElement\u003e dependencyMethodIndex \u003d\n          ImmutableMap.builder();\n\n      for (TypeElement componentDependency : componentDependencyTypes) {\n        List\u003cExecutableElement\u003e dependencyMethods \u003d\n            ElementFilter.methodsIn(elements.getAllMembers(componentDependency));\n        for (ExecutableElement dependencyMethod : dependencyMethods) {\n          if (isComponentContributionMethod(elements, dependencyMethod)) {\n            dependencyMethodIndex.put(dependencyMethod, componentDependency);\n          }\n        }\n      }\n\n      ImmutableSet.Builder\u003cModuleDescriptor\u003e modulesBuilder \u003d ImmutableSet.builder();\n      for (TypeMirror componentModulesType : getComponentModules(componentMirror)) {\n        modulesBuilder.add(\n            moduleDescriptorFactory.create(MoreTypes.asTypeElement(componentModulesType)));\n      }\n      if (kind.equals(Kind.PRODUCTION_COMPONENT)\n          || (kind.equals(Kind.PRODUCTION_SUBCOMPONENT)\n              \u0026\u0026 parentKind.isPresent()\n              \u0026\u0026 (parentKind.get().equals(Kind.COMPONENT)\n                  || parentKind.get().equals(Kind.SUBCOMPONENT)))) {\n        modulesBuilder.add(descriptorForMonitoringModule(componentDefinitionType));\n        modulesBuilder.add(descriptorForProductionExecutorModule(componentDefinitionType));\n      }\n      ImmutableSet\u003cModuleDescriptor\u003e modules \u003d modulesBuilder.build();\n      ImmutableSet\u003cModuleDescriptor\u003e transitiveModules \u003d transitiveModules(modules);\n      ImmutableSet.Builder\u003cComponentDescriptor\u003e subcomponentsFromModules \u003d ImmutableSet.builder();\n      for (ModuleDescriptor module : transitiveModules) {\n        for (SubcomponentDeclaration subcomponentDeclaration : module.subcomponentDeclarations()) {\n          TypeElement subcomponent \u003d subcomponentDeclaration.subcomponentType();\n          subcomponentsFromModules.add(\n              create(\n                  subcomponent, Kind.forAnnotatedElement(subcomponent).get(), Optional.of(kind)));\n        }\n      }\n      ImmutableSet\u003cExecutableElement\u003e unimplementedMethods \u003d\n          Util.getUnimplementedMethods(elements, componentDefinitionType);\n\n      ImmutableSet.Builder\u003cComponentMethodDescriptor\u003e componentMethodsBuilder \u003d\n          ImmutableSet.builder();\n\n      ImmutableBiMap.Builder\u003cComponentMethodDescriptor, ComponentDescriptor\u003e\n          subcomponentsByFactoryMethod \u003d ImmutableBiMap.builder();\n      ImmutableBiMap.Builder\u003cComponentMethodDescriptor, ComponentDescriptor\u003e\n          subcomponentsByBuilderMethod \u003d ImmutableBiMap.builder();\n      for (ExecutableElement componentMethod : unimplementedMethods) {\n        ExecutableType resolvedMethod \u003d\n            MoreTypes.asExecutable(types.asMemberOf(declaredComponentType, componentMethod));\n        ComponentMethodDescriptor componentMethodDescriptor \u003d\n            getDescriptorForComponentMethod(componentDefinitionType, kind, componentMethod);\n        componentMethodsBuilder.add(componentMethodDescriptor);\n        switch (componentMethodDescriptor.kind()) {\n          case SUBCOMPONENT:\n          case PRODUCTION_SUBCOMPONENT:\n            subcomponentsByFactoryMethod.put(\n                componentMethodDescriptor,\n                create(\n                    MoreElements.asType(MoreTypes.asElement(resolvedMethod.getReturnType())),\n                    componentMethodDescriptor.kind().componentKind(),\n                    Optional.of(kind)));\n            break;\n          case SUBCOMPONENT_BUILDER:\n          case PRODUCTION_SUBCOMPONENT_BUILDER:\n            subcomponentsByBuilderMethod.put(\n                componentMethodDescriptor,\n                create(\n                    MoreElements.asType(\n                        MoreTypes.asElement(resolvedMethod.getReturnType()).getEnclosingElement()),\n                    componentMethodDescriptor.kind().componentKind(),\n                    Optional.of(kind)));\n            break;\n          default: // nothing special to do for other methods.\n        }\n      }\n\n      ImmutableList\u003cDeclaredType\u003e enclosedBuilders \u003d kind.builderAnnotationType() \u003d\u003d null\n          ? ImmutableList.\u003cDeclaredType\u003eof()\n          : enclosedBuilders(componentDefinitionType, kind.builderAnnotationType());\n      Optional\u003cDeclaredType\u003e builderType \u003d\n          Optional.fromNullable(getOnlyElement(enclosedBuilders, null));\n      Optional\u003cBuilderSpec\u003e builderSpec \u003d createBuilderSpec(builderType);\n\n      ImmutableSet\u003cScope\u003e scopes \u003d Scope.scopesOf(componentDefinitionType);\n      if (kind.isProducer()) {\n        scopes \u003d FluentIterable.from(scopes).append(Scope.productionScope(elements)).toSet();\n      }\n\n      return new AutoValue_ComponentDescriptor(\n          kind,\n          componentMirror,\n          componentDefinitionType,\n          componentDependencyTypes,\n          modules,\n          transitiveModules,\n          dependencyMethodIndex.build(),\n          scopes,\n          subcomponentsFromModules.build(),\n          subcomponentsByFactoryMethod.build(),\n          subcomponentsByBuilderMethod.build(),\n          componentMethodsBuilder.build(),\n          builderSpec);\n    }\n\n    private ComponentMethodDescriptor getDescriptorForComponentMethod(\n        TypeElement componentElement, Kind componentKind, ExecutableElement componentMethod) {\n      ExecutableType resolvedComponentMethod \u003d\n          MoreTypes.asExecutable(\n              types.asMemberOf(MoreTypes.asDeclared(componentElement.asType()), componentMethod));\n      TypeMirror returnType \u003d resolvedComponentMethod.getReturnType();\n      if (returnType.getKind().equals(DECLARED)) {\n        if (MoreTypes.isTypeOf(Provider.class, returnType)\n            || MoreTypes.isTypeOf(Lazy.class, returnType)) {\n          return ComponentMethodDescriptor.forProvision(\n              componentMethod,\n              dependencyRequestFactory.forComponentProvisionMethod(\n                  componentMethod, resolvedComponentMethod));\n        } else if (MoreTypes.isTypeOf(MembersInjector.class, returnType)) {\n          return ComponentMethodDescriptor.forMembersInjection(\n              componentMethod,\n              dependencyRequestFactory.forComponentMembersInjectionMethod(\n                  componentMethod, resolvedComponentMethod));\n        } else if (!getQualifier(componentMethod).isPresent()) {\n          Element returnTypeElement \u003d MoreTypes.asElement(returnType);\n          if (isSubcomponent(returnTypeElement)) {\n            return ComponentMethodDescriptor.forSubcomponent(\n                isAnnotationPresent(returnTypeElement, Subcomponent.class)\n                    ? ComponentMethodKind.SUBCOMPONENT\n                    : ComponentMethodKind.PRODUCTION_SUBCOMPONENT,\n                componentMethod);\n          } else if (isSubcomponentBuilder(returnTypeElement)) {\n            DependencyRequest dependencyRequest \u003d\n                dependencyRequestFactory.forComponentProvisionMethod(\n                    componentMethod, resolvedComponentMethod);\n            return ComponentMethodDescriptor.forSubcomponentBuilder(\n                isAnnotationPresent(returnTypeElement, Subcomponent.Builder.class)\n                    ? ComponentMethodKind.SUBCOMPONENT_BUILDER\n                    : ComponentMethodKind.PRODUCTION_SUBCOMPONENT_BUILDER,\n                dependencyRequest,\n                componentMethod);\n          }\n        }\n      }\n\n      // a typical provision method\n      if (componentMethod.getParameters().isEmpty()\n          \u0026\u0026 !componentMethod.getReturnType().getKind().equals(VOID)) {\n        switch (componentKind) {\n          case COMPONENT:\n          case SUBCOMPONENT:\n            return ComponentMethodDescriptor.forProvision(\n                componentMethod,\n                dependencyRequestFactory.forComponentProvisionMethod(\n                    componentMethod, resolvedComponentMethod));\n          case PRODUCTION_COMPONENT:\n          case PRODUCTION_SUBCOMPONENT:\n            return ComponentMethodDescriptor.forProvision(\n                componentMethod,\n                dependencyRequestFactory.forComponentProductionMethod(\n                    componentMethod, resolvedComponentMethod));\n          default:\n            throw new AssertionError();\n        }\n      }\n\n      List\u003c? extends TypeMirror\u003e parameterTypes \u003d resolvedComponentMethod.getParameterTypes();\n      if (parameterTypes.size() \u003d\u003d 1\n          \u0026\u0026 (returnType.getKind().equals(VOID)\n              || MoreTypes.equivalence().equivalent(returnType, parameterTypes.get(0)))) {\n        return ComponentMethodDescriptor.forMembersInjection(\n            componentMethod,\n            dependencyRequestFactory.forComponentMembersInjectionMethod(\n                componentMethod, resolvedComponentMethod));\n      }\n\n      throw new IllegalArgumentException(\"not a valid component method: \" + componentMethod);\n    }\n\n    private Optional\u003cBuilderSpec\u003e createBuilderSpec(Optional\u003cDeclaredType\u003e builderType) {\n      if (!builderType.isPresent()) {\n        return Optional.absent();\n      }\n      TypeElement element \u003d MoreTypes.asTypeElement(builderType.get());\n      ImmutableSet\u003cExecutableElement\u003e methods \u003d Util.getUnimplementedMethods(elements, element);\n      ImmutableMap.Builder\u003cTypeElement, ExecutableElement\u003e map \u003d ImmutableMap.builder();\n      ExecutableElement buildMethod \u003d null;\n      for (ExecutableElement method : methods) {\n        if (method.getParameters().isEmpty()) {\n          buildMethod \u003d method;\n        } else {\n          ExecutableType resolved \u003d\n              MoreTypes.asExecutable(types.asMemberOf(builderType.get(), method));\n          map.put(MoreTypes.asTypeElement(getOnlyElement(resolved.getParameterTypes())), method);\n        }\n      }\n      verify(buildMethod !\u003d null); // validation should have ensured this.\n      return Optional.\u003cBuilderSpec\u003eof(new AutoValue_ComponentDescriptor_BuilderSpec(element,\n          map.build(), buildMethod, element.getEnclosingElement().asType()));\n    }\n\n    /**\n     * Returns a descriptor for a generated module that handles monitoring for production\n     * components. This module is generated in the {@link MonitoringModuleProcessingStep}.\n     *\n     * @throws TypeNotPresentException if the module has not been generated yet. This will cause the\n     *     processor to retry in a later processing round.\n     */\n    private ModuleDescriptor descriptorForMonitoringModule(TypeElement componentDefinitionType) {\n      ClassName monitoringModuleName \u003d\n          SourceFiles.generatedMonitoringModuleName(componentDefinitionType);\n      String generatedMonitorModuleName \u003d monitoringModuleName.toString();\n      TypeElement monitoringModule \u003d elements.getTypeElement(generatedMonitorModuleName);\n      if (monitoringModule \u003d\u003d null) {\n        throw new TypeNotPresentException(generatedMonitorModuleName, null);\n      }\n      return moduleDescriptorFactory.create(monitoringModule);\n    }\n\n    /**\n     * Returns a descriptor for a generated module that handles the producer executor for production\n     * components. This module is generated in the {@link ProductionExecutorModuleProcessingStep}.\n     *\n     * @throws TypeNotPresentException if the module has not been generated yet. This will cause the\n     *     processor to retry in a later processing round.\n     */\n    // TODO(beder): Replace this with a single class when the producers client library exists.\n    private ModuleDescriptor descriptorForProductionExecutorModule(\n        TypeElement componentDefinitionType) {\n      ClassName productionExecutorModuleName \u003d\n          SourceFiles.generatedProductionExecutorModuleName(componentDefinitionType);\n      String generatedProductionExecutorModuleName \u003d productionExecutorModuleName.toString();\n      TypeElement productionExecutorModule \u003d\n          elements.getTypeElement(generatedProductionExecutorModuleName);\n      if (productionExecutorModule \u003d\u003d null) {\n        throw new TypeNotPresentException(generatedProductionExecutorModuleName, null);\n      }\n      return moduleDescriptorFactory.create(productionExecutorModule);\n    }\n  }\n\n  static boolean isComponentContributionMethod(Elements elements, ExecutableElement method) {\n    return method.getParameters().isEmpty()\n        \u0026\u0026 !method.getReturnType().getKind().equals(VOID)\n        \u0026\u0026 !elements.getTypeElement(Object.class.getCanonicalName())\n            .equals(method.getEnclosingElement());\n  }\n\n  static boolean isComponentProductionMethod(Elements elements, ExecutableElement method) {\n    return isComponentContributionMethod(elements, method)\n        \u0026\u0026 MoreTypes.isTypeOf(ListenableFuture.class, method.getReturnType());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ComponentGenerator.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.TypeSpec;\nimport dagger.Component;\nimport javax.annotation.processing.Filer;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/**\n * Generates the implementation of the abstract types annotated with {@link Component}.\n *\n * @author Gregory Kick\n * @since 2.0\n */\nfinal class ComponentGenerator extends SourceFileGenerator\u003cBindingGraph\u003e {\n  private final Types types;\n  private final Elements elements;\n  private final Key.Factory keyFactory;\n  private final CompilerOptions compilerOptions;\n\n  ComponentGenerator(\n      Filer filer,\n      Elements elements,\n      Types types,\n      Key.Factory keyFactory,\n      CompilerOptions compilerOptions) {\n    super(filer, elements);\n    this.types \u003d types;\n    this.elements \u003d elements;\n    this.keyFactory \u003d keyFactory;\n    this.compilerOptions \u003d compilerOptions;\n  }\n\n  @Override\n  ClassName nameGeneratedType(BindingGraph input) {\n    ClassName componentDefinitionClassName \u003d\n        ClassName.get(input.componentDescriptor().componentDefinitionType());\n    String componentName \u003d\n        \"Dagger\" + Joiner.on(\u0027_\u0027).join(componentDefinitionClassName.simpleNames());\n    return componentDefinitionClassName.topLevelClassName().peerClass(componentName);\n  }\n\n  @Override\n  Optional\u003c? extends Element\u003e getElementForErrorReporting(BindingGraph input) {\n    return Optional.of(input.componentDescriptor().componentDefinitionType());\n  }\n\n  @Override\n  Optional\u003cTypeSpec.Builder\u003e write(ClassName componentName, BindingGraph input) {\n    return Optional.of(\n        new ComponentWriter(types, elements, keyFactory, compilerOptions, componentName, input)\n            .write());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ComponentHierarchyValidator.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Functions.constant;\nimport static com.google.common.base.Predicates.and;\nimport static com.google.common.base.Predicates.equalTo;\nimport static com.google.common.base.Predicates.in;\nimport static com.google.common.base.Predicates.not;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.base.Predicate;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.LinkedHashMultimap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.collect.Sets;\nimport dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;\nimport java.util.Map;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.util.Elements;\n\n/** Validates the relationships between parent components and subcomponents. */\nfinal class ComponentHierarchyValidator {\n  private final CompilerOptions compilerOptions;\n  private final Elements elements;\n\n  ComponentHierarchyValidator(CompilerOptions compilerOptions, Elements elements) {\n    this.compilerOptions \u003d compilerOptions;\n    this.elements \u003d elements;\n  }\n\n  ValidationReport\u003cTypeElement\u003e validate(ComponentDescriptor componentDescriptor) {\n    ValidationReport.Builder\u003cTypeElement\u003e report \u003d\n        ValidationReport.about(componentDescriptor.componentDefinitionType());\n    validateSubcomponentMethods(\n        report,\n        componentDescriptor,\n        Maps.toMap(\n            componentDescriptor.transitiveModuleTypes(),\n            constant(componentDescriptor.componentDefinitionType())));\n\n    if (compilerOptions.scopeCycleValidationType().diagnosticKind().isPresent()) {\n      validateScopeHierarchy(\n          report, componentDescriptor, LinkedHashMultimap.\u003cComponentDescriptor, Scope\u003ecreate());\n    }\n    return report.build();\n  }\n\n  private void validateSubcomponentMethods(\n      ValidationReport.Builder\u003c?\u003e report,\n      ComponentDescriptor componentDescriptor,\n      ImmutableMap\u003cTypeElement, TypeElement\u003e existingModuleToOwners) {\n    for (Map.Entry\u003cComponentMethodDescriptor, ComponentDescriptor\u003e subcomponentEntry :\n        componentDescriptor.subcomponentsByFactoryMethod().entrySet()) {\n      ComponentMethodDescriptor subcomponentMethodDescriptor \u003d subcomponentEntry.getKey();\n      ComponentDescriptor subcomponentDescriptor \u003d subcomponentEntry.getValue();\n      // validate the way that we create subcomponents\n      for (VariableElement factoryMethodParameter :\n          subcomponentMethodDescriptor.methodElement().getParameters()) {\n        TypeElement moduleType \u003d MoreTypes.asTypeElement(factoryMethodParameter.asType());\n        TypeElement originatingComponent \u003d existingModuleToOwners.get(moduleType);\n        if (originatingComponent !\u003d null) {\n          /* Factory method tries to pass a module that is already present in the parent.\n           * This is an error. */\n          report.addError(\n              String.format(\n                  \"%s is present in %s. A subcomponent cannot use an instance of a \"\n                      + \"module that differs from its parent.\",\n                  moduleType.getSimpleName(), originatingComponent.getQualifiedName()),\n              factoryMethodParameter);\n        }\n      }\n      validateSubcomponentMethods(\n          report,\n          subcomponentDescriptor,\n          new ImmutableMap.Builder\u003cTypeElement, TypeElement\u003e()\n              .putAll(existingModuleToOwners)\n              .putAll(\n                  Maps.toMap(\n                      Sets.difference(\n                          subcomponentDescriptor.transitiveModuleTypes(),\n                          existingModuleToOwners.keySet()),\n                      constant(subcomponentDescriptor.componentDefinitionType())))\n              .build());\n    }\n  }\n\n  /**\n   * Checks that components do not have any scopes that are also applied on any of their ancestors.\n   */\n  private void validateScopeHierarchy(\n      ValidationReport.Builder\u003cTypeElement\u003e report,\n      ComponentDescriptor subject,\n      SetMultimap\u003cComponentDescriptor, Scope\u003e scopesByComponent) {\n    scopesByComponent.putAll(subject, subject.scopes());\n\n    for (ComponentDescriptor child : subject.subcomponents()) {\n      validateScopeHierarchy(report, child, scopesByComponent);\n    }\n\n    scopesByComponent.removeAll(subject);\n\n    Predicate\u003cScope\u003e subjectScopes \u003d\n        subject.kind().isProducer()\n            // TODO(beder): validate that @ProductionScope is only applied on production components\n            ? and(in(subject.scopes()), not(equalTo(Scope.productionScope(elements))))\n            : in(subject.scopes());\n    SetMultimap\u003cComponentDescriptor, Scope\u003e overlappingScopes \u003d\n        Multimaps.filterValues(scopesByComponent, subjectScopes);\n    if (!overlappingScopes.isEmpty()) {\n      StringBuilder error \u003d\n          new StringBuilder()\n              .append(subject.componentDefinitionType().getQualifiedName())\n              .append(\" has conflicting scopes:\");\n      for (Map.Entry\u003cComponentDescriptor, Scope\u003e entry : overlappingScopes.entries()) {\n        Scope scope \u003d entry.getValue();\n        error.append(\"\\n  \")\n            .append(entry.getKey().componentDefinitionType().getQualifiedName())\n            .append(\" also has \")\n            .append(scope.getReadableSource());\n      }\n      report.addItem(\n          error.toString(),\n          compilerOptions.scopeCycleValidationType().diagnosticKind().get(),\n          subject.componentDefinitionType());\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ComponentProcessingStep.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;\nimport com.google.auto.common.MoreElements;\nimport com.google.common.base.Predicates;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.collect.SetMultimap;\nimport dagger.Component;\nimport dagger.Subcomponent;\nimport dagger.internal.codegen.ComponentDescriptor.Factory;\nimport dagger.internal.codegen.ComponentValidator.ComponentValidationReport;\nimport dagger.producers.ProductionComponent;\nimport dagger.producers.ProductionSubcomponent;\nimport java.lang.annotation.Annotation;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.annotation.processing.Messager;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.TypeElement;\nimport javax.tools.Diagnostic.Kind;\n\n/**\n * A {@link ProcessingStep} that is responsible for dealing with a component or production component\n * as part of the {@link ComponentProcessor}.\n *\n * @author Gregory Kick\n */\nfinal class ComponentProcessingStep implements ProcessingStep {\n  private final ComponentDescriptor.Kind componentKind;\n  private final Messager messager;\n  private final ComponentValidator componentValidator;\n  private final ComponentValidator subcomponentValidator;\n  private final BuilderValidator builderValidator;\n  private final ComponentHierarchyValidator componentHierarchyValidator;\n  private final BindingGraphValidator bindingGraphValidator;\n  private final ComponentDescriptor.Factory componentDescriptorFactory;\n  private final BindingGraph.Factory bindingGraphFactory;\n  private final ComponentGenerator componentGenerator;\n\n  ComponentProcessingStep(\n      ComponentDescriptor.Kind componentKind,\n      Messager messager,\n      ComponentValidator componentValidator,\n      ComponentValidator subcomponentValidator,\n      BuilderValidator builderValidator,\n      ComponentHierarchyValidator componentHierarchyValidator,\n      BindingGraphValidator bindingGraphValidator,\n      Factory componentDescriptorFactory,\n      BindingGraph.Factory bindingGraphFactory,\n      ComponentGenerator componentGenerator) {\n    this.componentKind \u003d componentKind;\n    this.messager \u003d messager;\n    this.componentValidator \u003d componentValidator;\n    this.subcomponentValidator \u003d subcomponentValidator;\n    this.builderValidator \u003d builderValidator;\n    this.componentHierarchyValidator \u003d componentHierarchyValidator;\n    this.bindingGraphValidator \u003d bindingGraphValidator;\n    this.componentDescriptorFactory \u003d componentDescriptorFactory;\n    this.bindingGraphFactory \u003d bindingGraphFactory;\n    this.componentGenerator \u003d componentGenerator;\n  }\n\n  @Override\n  public Set\u003cClass\u003c? extends Annotation\u003e\u003e annotations() {\n    return ImmutableSet.of(\n        Component.class,\n        Component.Builder.class,\n        ProductionComponent.class,\n        ProductionComponent.Builder.class,\n        Subcomponent.class,\n        Subcomponent.Builder.class,\n        ProductionSubcomponent.class,\n        ProductionSubcomponent.Builder.class);\n  }\n\n  @Override\n  public final ImmutableSet\u003cElement\u003e process(\n      SetMultimap\u003cClass\u003c? extends Annotation\u003e, Element\u003e elementsByAnnotation) {\n    ImmutableSet.Builder\u003cElement\u003e rejectedElements \u003d ImmutableSet.builder();\n\n    Map\u003cElement, ValidationReport\u003cTypeElement\u003e\u003e builderReportsByComponent \u003d\n        processBuilders(elementsByAnnotation.get(componentKind.builderAnnotationType()));\n    Set\u003cElement\u003e subcomponentBuilderElements \u003d\n        getElementsFromAnnotations(\n            elementsByAnnotation,\n            FluentIterable.from(componentKind.subcomponentKinds())\n                .transform(ComponentDescriptor.Kind::builderAnnotationType)\n                .toSet());\n    Map\u003cElement, ValidationReport\u003cTypeElement\u003e\u003e builderReportsBySubcomponent \u003d\n        processBuilders(subcomponentBuilderElements);\n    Set\u003cElement\u003e subcomponentElements \u003d\n        getElementsFromAnnotations(\n            elementsByAnnotation,\n            FluentIterable.from(componentKind.subcomponentKinds())\n                .transform(ComponentDescriptor.Kind::annotationType)\n                .toSet());\n    Map\u003cElement, ValidationReport\u003cTypeElement\u003e\u003e reportsBySubcomponent \u003d\n        processSubcomponents(subcomponentElements, subcomponentBuilderElements);\n\n    for (Element element : elementsByAnnotation.get(componentKind.annotationType())) {\n      TypeElement componentTypeElement \u003d MoreElements.asType(element);\n      try {\n        ComponentValidationReport validationReport \u003d\n            componentValidator.validate(\n                componentTypeElement, subcomponentElements, subcomponentBuilderElements);\n        validationReport.report().printMessagesTo(messager);\n        if (isClean(\n            validationReport,\n            builderReportsByComponent,\n            reportsBySubcomponent,\n            builderReportsBySubcomponent)) {\n          ComponentDescriptor componentDescriptor \u003d\n              componentDescriptorFactory.forComponent(componentTypeElement);\n          ValidationReport\u003cTypeElement\u003e hierarchyReport \u003d\n              componentHierarchyValidator.validate(componentDescriptor);\n          hierarchyReport.printMessagesTo(messager);\n          if (hierarchyReport.isClean()) {\n            BindingGraph bindingGraph \u003d bindingGraphFactory.create(componentDescriptor);\n            ValidationReport\u003cTypeElement\u003e graphReport \u003d\n                bindingGraphValidator.validate(bindingGraph);\n            graphReport.printMessagesTo(messager);\n            if (graphReport.isClean()) {\n              generateComponent(bindingGraph);\n            }\n          }\n        }\n      } catch (TypeNotPresentException e) {\n        rejectedElements.add(componentTypeElement);\n      }\n    }\n    return rejectedElements.build();\n  }\n\n  private void generateComponent(BindingGraph bindingGraph) {\n    componentGenerator.generate(bindingGraph, messager);\n  }\n\n  private ImmutableSet\u003cElement\u003e getElementsFromAnnotations(\n      final SetMultimap\u003cClass\u003c? extends Annotation\u003e, Element\u003e elementsByAnnotation,\n      ImmutableSet\u003c? extends Class\u003c? extends Annotation\u003e\u003e annotations) {\n    return ImmutableSet.copyOf(\n        Multimaps.filterKeys(elementsByAnnotation, Predicates.in(annotations)).values());\n  }\n\n  private Map\u003cElement, ValidationReport\u003cTypeElement\u003e\u003e processBuilders(\n      Set\u003c? extends Element\u003e builderElements) {\n    Map\u003cElement, ValidationReport\u003cTypeElement\u003e\u003e builderReportsByComponent \u003d Maps.newHashMap();\n    for (Element element : builderElements) {\n      ValidationReport\u003cTypeElement\u003e report \u003d\n          builderValidator.validate(MoreElements.asType(element));\n      report.printMessagesTo(messager);\n      builderReportsByComponent.put(element.getEnclosingElement(), report);\n    }\n    return builderReportsByComponent;\n  }\n\n  private Map\u003cElement, ValidationReport\u003cTypeElement\u003e\u003e processSubcomponents(\n      Set\u003c? extends Element\u003e subcomponentElements,\n      Set\u003c? extends Element\u003e subcomponentBuilderElements) {\n    Map\u003cElement, ValidationReport\u003cTypeElement\u003e\u003e reportsBySubcomponent \u003d Maps.newHashMap();\n    for (Element element : subcomponentElements) {\n      ComponentValidationReport report \u003d subcomponentValidator.validate(\n          MoreElements.asType(element), subcomponentElements, subcomponentBuilderElements);\n      report.report().printMessagesTo(messager);\n      reportsBySubcomponent.put(element, report.report());\n    }\n    return reportsBySubcomponent;\n  }\n\n  /**\n   * Returns true if the component\u0027s report is clean, its builder report is clean, and all\n   * referenced subcomponent reports \u0026 subcomponent builder reports are clean.\n   */\n  private boolean isClean(ComponentValidationReport report,\n      Map\u003cElement, ValidationReport\u003cTypeElement\u003e\u003e builderReportsByComponent,\n      Map\u003cElement, ValidationReport\u003cTypeElement\u003e\u003e reportsBySubcomponent,\n      Map\u003cElement, ValidationReport\u003cTypeElement\u003e\u003e builderReportsBySubcomponent) {\n    Element component \u003d report.report().subject();\n    ValidationReport\u003c?\u003e componentReport \u003d report.report();\n    if (!componentReport.isClean()) {\n      return false;\n    }\n    ValidationReport\u003c?\u003e builderReport \u003d builderReportsByComponent.get(component);\n    if (builderReport !\u003d null \u0026\u0026 !builderReport.isClean()) {\n      return false;\n    }\n    for (Element element : report.referencedSubcomponents()) {\n      ValidationReport\u003c?\u003e subcomponentBuilderReport \u003d builderReportsBySubcomponent.get(element);\n      if (subcomponentBuilderReport !\u003d null \u0026\u0026 !subcomponentBuilderReport.isClean()) {\n        return false;\n      }\n      ValidationReport\u003c?\u003e subcomponentReport \u003d reportsBySubcomponent.get(element);\n      if (subcomponentReport !\u003d null \u0026\u0026 !subcomponentReport.isClean()) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ComponentProcessor.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static dagger.internal.codegen.ModuleProcessingStep.moduleProcessingStep;\nimport static dagger.internal.codegen.ModuleProcessingStep.producerModuleProcessingStep;\n\nimport com.google.auto.common.BasicAnnotationProcessor;\nimport com.google.auto.service.AutoService;\nimport com.google.common.collect.ImmutableList;\nimport java.util.Set;\nimport javax.annotation.processing.Filer;\nimport javax.annotation.processing.Messager;\nimport javax.annotation.processing.Processor;\nimport javax.annotation.processing.RoundEnvironment;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/**\n * The annotation processor responsible for generating the classes that drive the Dagger 2.0\n * implementation.\n *\n * TODO(gak): give this some better documentation\n *\n * @author Gregory Kick\n * @since 2.0\n */\n@AutoService(Processor.class)\npublic final class ComponentProcessor extends BasicAnnotationProcessor {\n  private InjectBindingRegistry injectBindingRegistry;\n  private FactoryGenerator factoryGenerator;\n  private MembersInjectorGenerator membersInjectorGenerator;\n\n  @Override\n  public SourceVersion getSupportedSourceVersion() {\n    return SourceVersion.latestSupported();\n  }\n\n  @Override\n  public Set\u003cString\u003e getSupportedOptions() {\n    return CompilerOptions.SUPPORTED_OPTIONS;\n  }\n\n  @Override\n  protected Iterable\u003c? extends ProcessingStep\u003e initSteps() {\n    Messager messager \u003d processingEnv.getMessager();\n    Types types \u003d processingEnv.getTypeUtils();\n    Elements elements \u003d processingEnv.getElementUtils();\n    Filer filer \u003d processingEnv.getFiler();\n\n    CompilerOptions compilerOptions \u003d CompilerOptions.create(processingEnv, elements);\n\n    MethodSignatureFormatter methodSignatureFormatter \u003d new MethodSignatureFormatter(types);\n    BindingDeclarationFormatter bindingDeclarationFormatter \u003d\n        new BindingDeclarationFormatter(methodSignatureFormatter);\n    DependencyRequestFormatter dependencyRequestFormatter \u003d\n        new DependencyRequestFormatter(types, elements);\n    KeyFormatter keyFormatter \u003d new KeyFormatter();\n\n    InjectValidator injectValidator \u003d new InjectValidator(types, elements, compilerOptions);\n    InjectValidator injectValidatorWhenGeneratingCode \u003d injectValidator.whenGeneratingCode();\n    ModuleValidator moduleValidator \u003d\n        new ModuleValidator(types, elements, methodSignatureFormatter);\n    BuilderValidator builderValidator \u003d new BuilderValidator(elements, types);\n    ComponentValidator subcomponentValidator \u003d\n        ComponentValidator.createForSubcomponent(\n            elements, types, moduleValidator, builderValidator);\n    ComponentValidator componentValidator \u003d\n        ComponentValidator.createForComponent(\n            elements, types, moduleValidator, subcomponentValidator, builderValidator);\n    MapKeyValidator mapKeyValidator \u003d new MapKeyValidator();\n    ProvidesMethodValidator providesMethodValidator \u003d new ProvidesMethodValidator(elements, types);\n    ProducesMethodValidator producesMethodValidator \u003d new ProducesMethodValidator(elements, types);\n    BindsMethodValidator bindsMethodValidator \u003d new BindsMethodValidator(elements, types);\n    MultibindsMethodValidator multibindsMethodValidator \u003d\n        new MultibindsMethodValidator(elements, types);\n    MultibindingsMethodValidator multibindingsMethodValidator \u003d\n        new MultibindingsMethodValidator(elements, types);\n    BindsOptionalOfMethodValidator bindsOptionalOfMethodValidator \u003d\n        new BindsOptionalOfMethodValidator(elements, types);\n\n    Key.Factory keyFactory \u003d new Key.Factory(types, elements);\n\n    MultibindingsValidator multibindingsValidator \u003d\n        new MultibindingsValidator(\n            elements,\n            keyFactory,\n            keyFormatter,\n            methodSignatureFormatter,\n            multibindingsMethodValidator);\n\n    this.factoryGenerator \u003d\n        new FactoryGenerator(filer, elements, compilerOptions, injectValidatorWhenGeneratingCode);\n    this.membersInjectorGenerator \u003d\n        new MembersInjectorGenerator(filer, elements, injectValidatorWhenGeneratingCode);\n    ComponentGenerator componentGenerator \u003d\n        new ComponentGenerator(filer, elements, types, keyFactory, compilerOptions);\n    ProducerFactoryGenerator producerFactoryGenerator \u003d\n        new ProducerFactoryGenerator(filer, elements, compilerOptions);\n    MonitoringModuleGenerator monitoringModuleGenerator \u003d\n        new MonitoringModuleGenerator(filer, elements);\n    ProductionExecutorModuleGenerator productionExecutorModuleGenerator \u003d\n        new ProductionExecutorModuleGenerator(filer, elements);\n\n    DependencyRequest.Factory dependencyRequestFactory \u003d\n        new DependencyRequest.Factory(keyFactory);\n    ProvisionBinding.Factory provisionBindingFactory \u003d\n        new ProvisionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);\n    ProductionBinding.Factory productionBindingFactory \u003d\n        new ProductionBinding.Factory(types, keyFactory, dependencyRequestFactory);\n    MultibindingDeclaration.Factory multibindingDeclarationFactory \u003d\n        new MultibindingDeclaration.Factory(elements, types, keyFactory);\n    SubcomponentDeclaration.Factory subcomponentDeclarationFactory \u003d\n        new SubcomponentDeclaration.Factory(keyFactory);\n\n    MembersInjectionBinding.Factory membersInjectionBindingFactory \u003d\n        new MembersInjectionBinding.Factory(elements, types, keyFactory, dependencyRequestFactory);\n\n    DelegateDeclaration.Factory bindingDelegateDeclarationFactory \u003d\n        new DelegateDeclaration.Factory(types, keyFactory, dependencyRequestFactory);\n    OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory \u003d\n        new OptionalBindingDeclaration.Factory(keyFactory);\n\n    this.injectBindingRegistry \u003d\n        new InjectBindingRegistry(\n            elements,\n            types,\n            messager,\n            injectValidator,\n            keyFactory,\n            provisionBindingFactory,\n            membersInjectionBindingFactory);\n\n    ModuleDescriptor.Factory moduleDescriptorFactory \u003d\n        new ModuleDescriptor.Factory(\n            elements,\n            provisionBindingFactory,\n            productionBindingFactory,\n            multibindingDeclarationFactory,\n            bindingDelegateDeclarationFactory,\n            subcomponentDeclarationFactory,\n            optionalBindingDeclarationFactory);\n\n    ComponentDescriptor.Factory componentDescriptorFactory \u003d new ComponentDescriptor.Factory(\n        elements, types, dependencyRequestFactory, moduleDescriptorFactory);\n\n    BindingGraph.Factory bindingGraphFactory \u003d\n        new BindingGraph.Factory(\n            elements,\n            injectBindingRegistry,\n            keyFactory,\n            provisionBindingFactory,\n            productionBindingFactory);\n\n    AnnotationCreatorGenerator annotationCreatorGenerator \u003d\n        new AnnotationCreatorGenerator(filer, elements);\n    UnwrappedMapKeyGenerator unwrappedMapKeyGenerator \u003d\n        new UnwrappedMapKeyGenerator(filer, elements);\n    ComponentHierarchyValidator componentHierarchyValidator \u003d\n        new ComponentHierarchyValidator(compilerOptions, elements);\n    BindingGraphValidator bindingGraphValidator \u003d\n        new BindingGraphValidator(\n            elements,\n            types,\n            compilerOptions,\n            injectValidatorWhenGeneratingCode,\n            injectBindingRegistry,\n            bindingDeclarationFormatter,\n            methodSignatureFormatter,\n            dependencyRequestFormatter,\n            keyFormatter,\n            keyFactory);\n\n    return ImmutableList.of(\n        new MapKeyProcessingStep(\n            messager, types, mapKeyValidator, annotationCreatorGenerator, unwrappedMapKeyGenerator),\n        new InjectProcessingStep(injectBindingRegistry),\n        new MonitoringModuleProcessingStep(messager, monitoringModuleGenerator),\n        new ProductionExecutorModuleProcessingStep(messager, productionExecutorModuleGenerator),\n        new MultibindingsProcessingStep(messager, multibindingsValidator),\n        new MultibindingAnnotationsProcessingStep(messager),\n        moduleProcessingStep(\n            messager,\n            moduleValidator,\n            provisionBindingFactory,\n            factoryGenerator,\n            providesMethodValidator,\n            bindsMethodValidator,\n            multibindsMethodValidator,\n            bindsOptionalOfMethodValidator),\n        new ComponentProcessingStep(\n            ComponentDescriptor.Kind.COMPONENT,\n            messager,\n            componentValidator,\n            subcomponentValidator,\n            builderValidator,\n            componentHierarchyValidator,\n            bindingGraphValidator,\n            componentDescriptorFactory,\n            bindingGraphFactory,\n            componentGenerator),\n        producerModuleProcessingStep(\n            messager,\n            moduleValidator,\n            provisionBindingFactory,\n            factoryGenerator,\n            providesMethodValidator,\n            productionBindingFactory,\n            producerFactoryGenerator,\n            producesMethodValidator,\n            bindsMethodValidator,\n            multibindsMethodValidator,\n            bindsOptionalOfMethodValidator),\n        new ComponentProcessingStep(\n            ComponentDescriptor.Kind.PRODUCTION_COMPONENT,\n            messager,\n            componentValidator,\n            subcomponentValidator,\n            builderValidator,\n            componentHierarchyValidator,\n            bindingGraphValidator,\n            componentDescriptorFactory,\n            bindingGraphFactory,\n            componentGenerator));\n  }\n\n  @Override\n  protected void postRound(RoundEnvironment roundEnv) {\n    if (!roundEnv.processingOver()) {\n      try {\n        injectBindingRegistry.generateSourcesForRequiredBindings(\n            factoryGenerator, membersInjectorGenerator);\n      } catch (SourceFileGenerationException e) {\n        e.printMessageTo(processingEnv.getMessager());\n      }\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ComponentValidator.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getAnnotationMirror;\nimport static dagger.internal.codegen.ConfigurationAnnotations.enclosedBuilders;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getComponentDependencies;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getComponentModules;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getTransitiveModules;\nimport static dagger.internal.codegen.ConfigurationAnnotations.validateComponentDependencies;\nimport static dagger.internal.codegen.ErrorMessages.COMPONENT_ANNOTATED_REUSABLE;\nimport static javax.lang.model.element.ElementKind.CLASS;\nimport static javax.lang.model.element.ElementKind.INTERFACE;\nimport static javax.lang.model.element.Modifier.ABSTRACT;\nimport static javax.lang.model.type.TypeKind.VOID;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.LinkedHashMultimap;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.collect.Sets;\nimport dagger.Component;\nimport dagger.Reusable;\nimport dagger.internal.codegen.ComponentDescriptor.Kind;\nimport dagger.producers.ProductionComponent;\nimport java.lang.annotation.Annotation;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.ElementFilter;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.SimpleTypeVisitor6;\nimport javax.lang.model.util.Types;\n\n/**\n * Performs superficial validation of the contract of the {@link Component} and\n * {@link ProductionComponent} annotations.\n *\n * @author Gregory Kick\n */\nfinal class ComponentValidator {\n  private final Elements elements;\n  private final Types types;\n  private final ModuleValidator moduleValidator;\n  private final ComponentValidator subcomponentValidator;\n  private final BuilderValidator subcomponentBuilderValidator;\n\n  private ComponentValidator(Elements elements,\n      Types types,\n      ModuleValidator moduleValidator,\n      BuilderValidator subcomponentBuilderValidator) {\n    this.elements \u003d elements;\n    this.types \u003d types;\n    this.moduleValidator \u003d moduleValidator;\n    this.subcomponentValidator \u003d this;\n    this.subcomponentBuilderValidator \u003d subcomponentBuilderValidator;\n  }\n\n  private ComponentValidator(Elements elements,\n      Types types,\n      ModuleValidator moduleValidator,\n      ComponentValidator subcomponentValidator,\n      BuilderValidator subcomponentBuilderValidator) {\n    this.elements \u003d elements;\n    this.types \u003d types;\n    this.moduleValidator \u003d moduleValidator;\n    this.subcomponentValidator \u003d subcomponentValidator;\n    this.subcomponentBuilderValidator \u003d subcomponentBuilderValidator;\n  }\n\n  static ComponentValidator createForComponent(Elements elements,\n      Types types,\n      ModuleValidator moduleValidator,\n      ComponentValidator subcomponentValidator,\n      BuilderValidator subcomponentBuilderValidator) {\n    return new ComponentValidator(\n        elements, types, moduleValidator, subcomponentValidator, subcomponentBuilderValidator);\n  }\n\n  static ComponentValidator createForSubcomponent(Elements elements,\n      Types types,\n      ModuleValidator moduleValidator,\n      BuilderValidator subcomponentBuilderValidator) {\n    return new ComponentValidator(elements, types, moduleValidator, subcomponentBuilderValidator);\n  }\n\n  @AutoValue\n  static abstract class ComponentValidationReport {\n    abstract Set\u003cElement\u003e referencedSubcomponents();\n    abstract ValidationReport\u003cTypeElement\u003e report();\n  }\n\n  /**\n   * Validates the given component subject. Also validates any referenced subcomponents that aren\u0027t\n   * already included in the {@code validatedSubcomponents} set.\n   */\n  public ComponentValidationReport validate(final TypeElement subject,\n      Set\u003c? extends Element\u003e validatedSubcomponents,\n      Set\u003c? extends Element\u003e validatedSubcomponentBuilders) {\n    ValidationReport.Builder\u003cTypeElement\u003e builder \u003d ValidationReport.about(subject);\n\n    ComponentDescriptor.Kind componentKind \u003d\n        ComponentDescriptor.Kind.forAnnotatedElement(subject).get();\n\n    if (!subject.getKind().equals(INTERFACE)\n        \u0026\u0026 !(subject.getKind().equals(CLASS) \u0026\u0026 subject.getModifiers().contains(ABSTRACT))) {\n      builder.addError(\n          String.format(\n              \"@%s may only be applied to an interface or abstract class\",\n              componentKind.annotationType().getSimpleName()),\n          subject);\n    }\n\n    ImmutableList\u003cDeclaredType\u003e builders \u003d\n        enclosedBuilders(subject, componentKind.builderAnnotationType());\n    if (builders.size() \u003e 1) {\n      builder.addError(\n          String.format(ErrorMessages.builderMsgsFor(componentKind).moreThanOne(), builders),\n          subject);\n    }\n\n    Optional\u003cAnnotationMirror\u003e reusableAnnotation \u003d getAnnotationMirror(subject, Reusable.class);\n    if (reusableAnnotation.isPresent()) {\n      builder.addError(COMPONENT_ANNOTATED_REUSABLE, subject, reusableAnnotation.get());\n    }\n\n    DeclaredType subjectType \u003d MoreTypes.asDeclared(subject.asType());\n\n    // TODO(gak): This should use Util.findLocalAndInheritedMethods, otherwise\n    // it can return a logical method multiple times (including overrides, etc.)\n    List\u003c? extends Element\u003e members \u003d elements.getAllMembers(subject);\n    SetMultimap\u003cElement, ExecutableElement\u003e referencedSubcomponents \u003d LinkedHashMultimap.create();\n    for (ExecutableElement method : ElementFilter.methodsIn(members)) {\n      if (method.getModifiers().contains(ABSTRACT)) {\n        ExecutableType resolvedMethod \u003d\n            MoreTypes.asExecutable(types.asMemberOf(subjectType, method));\n        List\u003c? extends TypeMirror\u003e parameterTypes \u003d resolvedMethod.getParameterTypes();\n        List\u003c? extends VariableElement\u003e parameters \u003d method.getParameters();\n        TypeMirror returnType \u003d resolvedMethod.getReturnType();\n\n        // abstract methods are ones we have to implement, so they each need to be validated\n        // first, check the return type.  if it\u0027s a subcomponent, validate that method as such.\n        Optional\u003cAnnotationMirror\u003e subcomponentAnnotation \u003d\n            checkForAnnotations(\n                returnType,\n                FluentIterable.from(componentKind.subcomponentKinds())\n                    .transform(Kind::annotationType)\n                    .toSet());\n        Optional\u003cAnnotationMirror\u003e subcomponentBuilderAnnotation \u003d\n            checkForAnnotations(\n                returnType,\n                FluentIterable.from(componentKind.subcomponentKinds())\n                    .transform(Kind::builderAnnotationType)\n                    .toSet());\n        if (subcomponentAnnotation.isPresent()) {\n          referencedSubcomponents.put(MoreTypes.asElement(returnType), method);\n          validateSubcomponentMethod(\n              builder,\n              ComponentDescriptor.Kind.forAnnotatedElement(MoreTypes.asTypeElement(returnType))\n                  .get(),\n              method,\n              parameters,\n              parameterTypes,\n              returnType,\n              subcomponentAnnotation);\n        } else if (subcomponentBuilderAnnotation.isPresent()) {\n          referencedSubcomponents.put(MoreTypes.asElement(returnType).getEnclosingElement(),\n              method);\n          validateSubcomponentBuilderMethod(builder,\n              method,\n              parameters,\n              returnType,\n              validatedSubcomponentBuilders);\n        } else {\n          // if it\u0027s not a subcomponent...\n          switch (parameters.size()) {\n            case 0:\n              // no parameters means that it is a provision method\n              // basically, there are no restrictions here.  \\o/\n              break;\n            case 1:\n              // one parameter means that it\u0027s a members injection method\n              TypeMirror onlyParameter \u003d Iterables.getOnlyElement(parameterTypes);\n              if (!(returnType.getKind().equals(VOID)\n                  || types.isSameType(returnType, onlyParameter))) {\n                builder.addError(\n                    \"Members injection methods may only return the injected type or void.\", method);\n              }\n              break;\n            default:\n              // this isn\u0027t any method that we know how to implement...\n              builder.addError(\n                  \"This method isn\u0027t a valid provision method, members injection method or \"\n                      + \"subcomponent factory method. Dagger cannot implement this method\",\n                  method);\n              break;\n          }\n        }\n      }\n    }\n\n    for (Map.Entry\u003cElement, Collection\u003cExecutableElement\u003e\u003e entry :\n        referencedSubcomponents.asMap().entrySet()) {\n      if (entry.getValue().size() \u003e 1) {\n        builder.addError(\n            String.format(\n                ErrorMessages.SubcomponentBuilderMessages.INSTANCE.moreThanOneRefToSubcomponent(),\n                entry.getKey(),\n                entry.getValue()),\n            subject);\n      }\n    }\n\n    AnnotationMirror componentMirror \u003d\n        getAnnotationMirror(subject, componentKind.annotationType()).get();\n    if (componentKind.isTopLevel()) {\n      validateComponentDependencies(builder, getComponentDependencies(componentMirror));\n    }\n    ImmutableList\u003cTypeMirror\u003e moduleTypes \u003d getComponentModules(componentMirror);\n    moduleValidator.validateReferencedModules(\n        subject, builder, moduleTypes, componentKind.moduleKinds());\n\n    // Make sure we validate any subcomponents we\u0027re referencing, unless we know we validated\n    // them already in this pass.\n    // TODO(sameb): If subcomponents refer to each other and both aren\u0027t in\n    //              \u0027validatedSubcomponents\u0027 (e.g, both aren\u0027t compiled in this pass),\n    //              then this can loop forever.\n    ImmutableSet.Builder\u003cElement\u003e allSubcomponents \u003d\n        ImmutableSet.\u003cElement\u003ebuilder().addAll(referencedSubcomponents.keySet());\n    for (Element subcomponent :\n        Sets.difference(referencedSubcomponents.keySet(), validatedSubcomponents)) {\n      ComponentValidationReport subreport \u003d subcomponentValidator.validate(\n          MoreElements.asType(subcomponent), validatedSubcomponents, validatedSubcomponentBuilders);\n      builder.addItems(subreport.report().items());\n      allSubcomponents.addAll(subreport.referencedSubcomponents());\n    }\n\n    return new AutoValue_ComponentValidator_ComponentValidationReport(allSubcomponents.build(),\n        builder.build());\n  }\n\n  private void validateSubcomponentMethod(\n      final ValidationReport.Builder\u003cTypeElement\u003e builder,\n      final ComponentDescriptor.Kind subcomponentKind,\n      ExecutableElement method,\n      List\u003c? extends VariableElement\u003e parameters,\n      List\u003c? extends TypeMirror\u003e parameterTypes,\n      TypeMirror returnType,\n      Optional\u003cAnnotationMirror\u003e subcomponentAnnotation) {\n    ImmutableSet\u003cTypeElement\u003e moduleTypes \u003d\n        MoreTypes.asTypeElements(getComponentModules(subcomponentAnnotation.get()));\n\n    // TODO(gak): This logic maybe/probably shouldn\u0027t live here as it requires us to traverse\n    // subcomponents and their modules separately from how it is done in ComponentDescriptor and\n    // ModuleDescriptor\n    @SuppressWarnings(\"deprecation\")\n    ImmutableSet\u003cTypeElement\u003e transitiveModules \u003d\n        getTransitiveModules(types, elements, moduleTypes);\n\n    Set\u003cTypeElement\u003e variableTypes \u003d Sets.newHashSet();\n\n    for (int i \u003d 0; i \u003c parameterTypes.size(); i++) {\n      VariableElement parameter \u003d parameters.get(i);\n      TypeMirror parameterType \u003d parameterTypes.get(i);\n      Optional\u003cTypeElement\u003e moduleType \u003d\n          parameterType.accept(\n              new SimpleTypeVisitor6\u003cOptional\u003cTypeElement\u003e, Void\u003e() {\n                @Override\n                protected Optional\u003cTypeElement\u003e defaultAction(TypeMirror e, Void p) {\n                  return Optional.absent();\n                }\n\n                @Override\n                public Optional\u003cTypeElement\u003e visitDeclared(DeclaredType t, Void p) {\n                  for (ModuleDescriptor.Kind moduleKind : subcomponentKind.moduleKinds()) {\n                    if (MoreElements.isAnnotationPresent(\n                        t.asElement(), moduleKind.moduleAnnotation())) {\n                      return Optional.of(MoreTypes.asTypeElement(t));\n                    }\n                  }\n                  return Optional.absent();\n                }\n              },\n              null);\n      if (moduleType.isPresent()) {\n        if (variableTypes.contains(moduleType.get())) {\n          builder.addError(\n              String.format(\n                  \"A module may only occur once an an argument in a Subcomponent factory \"\n                      + \"method, but %s was already passed.\",\n                  moduleType.get().getQualifiedName()),\n              parameter);\n        }\n        if (!transitiveModules.contains(moduleType.get())) {\n          builder.addError(\n              String.format(\n                  \"%s is present as an argument to the %s factory method, but is not one of the\"\n                      + \" modules used to implement the subcomponent.\",\n                  moduleType.get().getQualifiedName(),\n                  MoreTypes.asTypeElement(returnType).getQualifiedName()),\n              method);\n        }\n        variableTypes.add(moduleType.get());\n      } else {\n        builder.addError(\n            String.format(\n                \"Subcomponent factory methods may only accept modules, but %s is not.\",\n                parameterType),\n            parameter);\n      }\n    }\n  }\n\n  private void validateSubcomponentBuilderMethod(ValidationReport.Builder\u003cTypeElement\u003e builder,\n      ExecutableElement method, List\u003c? extends VariableElement\u003e parameters, TypeMirror returnType,\n      Set\u003c? extends Element\u003e validatedSubcomponentBuilders) {\n\n    if (!parameters.isEmpty()) {\n      builder.addError(\n          ErrorMessages.SubcomponentBuilderMessages.INSTANCE.builderMethodRequiresNoArgs(), method);\n    }\n\n    // If we haven\u0027t already validated the subcomponent builder itself, validate it now.\n    TypeElement builderElement \u003d MoreTypes.asTypeElement(returnType);\n    if (!validatedSubcomponentBuilders.contains(builderElement)) {\n      // TODO(sameb): The builder validator right now assumes the element is being compiled\n      // in this pass, which isn\u0027t true here.  We should change error messages to spit out\n      // this method as the subject and add the original subject to the message output.\n      builder.addItems(subcomponentBuilderValidator.validate(builderElement).items());\n    }\n  }\n\n  private Optional\u003cAnnotationMirror\u003e checkForAnnotations(\n      TypeMirror type, final Set\u003c? extends Class\u003c? extends Annotation\u003e\u003e annotations) {\n    return type.accept(\n        new SimpleTypeVisitor6\u003cOptional\u003cAnnotationMirror\u003e, Void\u003e() {\n          @Override\n          protected Optional\u003cAnnotationMirror\u003e defaultAction(TypeMirror e, Void p) {\n            return Optional.absent();\n          }\n\n          @Override\n          public Optional\u003cAnnotationMirror\u003e visitDeclared(DeclaredType t, Void p) {\n            for (Class\u003c? extends Annotation\u003e annotation : annotations) {\n              Optional\u003cAnnotationMirror\u003e mirror \u003d\n                  MoreElements.getAnnotationMirror(t.asElement(), annotation);\n              if (mirror.isPresent()) {\n                return mirror;\n              }\n            }\n            return Optional.absent();\n          }\n        },\n        null);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ComponentWriter.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.squareup.javapoet.MethodSpec.methodBuilder;\nimport static com.squareup.javapoet.TypeSpec.classBuilder;\nimport static dagger.internal.codegen.TypeSpecs.addSupertype;\nimport static dagger.internal.codegen.Util.requiresAPassedInstance;\nimport static javax.lang.model.element.Modifier.FINAL;\nimport static javax.lang.model.element.Modifier.PUBLIC;\nimport static javax.lang.model.element.Modifier.STATIC;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableBiMap;\nimport com.google.common.collect.ImmutableListMultimap;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Multimaps;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.TypeSpec;\nimport java.util.Collection;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport javax.lang.model.element.Name;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/**\n * Creates the implementation class for a component.\n */\nfinal class ComponentWriter extends AbstractComponentWriter {\n\n  ComponentWriter(\n      Types types,\n      Elements elements,\n      Key.Factory keyFactory,\n      CompilerOptions compilerOptions,\n      ClassName name,\n      BindingGraph graph) {\n    super(\n        types,\n        elements,\n        keyFactory,\n        compilerOptions,\n        name,\n        graph,\n        new UniqueSubcomponentNamesGenerator(graph).generate(),\n        new OptionalFactories());\n  }\n\n  /**\n   * Generates a map of unique simple names for all subcomponents, keyed by their {@link\n   * ComponentDescriptor}.\n   */\n  private static class UniqueSubcomponentNamesGenerator {\n\n    private static final Splitter QUALIFIED_NAME_SPLITTER \u003d Splitter.on(\u0027.\u0027);\n    private static final Joiner QUALIFIED_NAME_JOINER \u003d Joiner.on(\u0027_\u0027);\n\n    private final BindingGraph graph;\n    private final ImmutableListMultimap\u003cString, ComponentDescriptor\u003e\n        componentDescriptorsBySimpleName;\n    private final ImmutableListMultimap\u003cComponentDescriptor, String\u003e componentQualifiedNamePieces;\n\n    private UniqueSubcomponentNamesGenerator(BindingGraph graph) {\n      this.graph \u003d graph;\n      componentDescriptorsBySimpleName \u003d\n          Multimaps.index(\n              graph.componentDescriptors(),\n              componentDescriptor -\u003e\n                  componentDescriptor.componentDefinitionType().getSimpleName().toString());\n      componentQualifiedNamePieces \u003d qualifiedNames(graph.componentDescriptors());\n    }\n\n    private ImmutableBiMap\u003cComponentDescriptor, String\u003e generate() {\n      Map\u003cComponentDescriptor, String\u003e subcomponentImplSimpleNames \u003d new LinkedHashMap\u003c\u003e();\n      for (Entry\u003cString, Collection\u003cComponentDescriptor\u003e\u003e componentEntry :\n          componentDescriptorsBySimpleName.asMap().entrySet()) {\n        Collection\u003cComponentDescriptor\u003e components \u003d componentEntry.getValue();\n        subcomponentImplSimpleNames.putAll(disambiguateConflictingSimpleNames(components));\n      }\n      subcomponentImplSimpleNames.remove(graph.componentDescriptor());\n      return ImmutableBiMap.copyOf(subcomponentImplSimpleNames);\n    }\n\n    private ImmutableBiMap\u003cComponentDescriptor, String\u003e disambiguateConflictingSimpleNames(\n        Collection\u003cComponentDescriptor\u003e components) {\n      Map\u003cString, ComponentDescriptor\u003e generatedSimpleNames \u003d new LinkedHashMap\u003c\u003e();\n      // The ending condition is when there is a unique simple name generated for every element\n      // in components. The sizes should be equivalent (with one generated name per component).\n      for (int levels \u003d 0; generatedSimpleNames.size() !\u003d components.size(); levels++) {\n        generatedSimpleNames.clear();\n        for (ComponentDescriptor component : components) {\n          List\u003cString\u003e pieces \u003d componentQualifiedNamePieces.get(component);\n          String simpleName \u003d\n              QUALIFIED_NAME_JOINER.join(\n                  pieces.subList(Math.max(0, pieces.size() - levels - 1), pieces.size()));\n          ComponentDescriptor conflict \u003d generatedSimpleNames.put(simpleName, component);\n          if (conflict !\u003d null) {\n            // if the map previously contained an entry for the same simple name, stop early since\n            // 2+ subcomponent descriptors will have the same simple name\n            break;\n          }\n        }\n      }\n      return ImmutableBiMap.copyOf(generatedSimpleNames).inverse();\n    }\n\n    private static ImmutableListMultimap\u003cComponentDescriptor, String\u003e qualifiedNames(\n        Iterable\u003cComponentDescriptor\u003e componentDescriptors) {\n      ImmutableListMultimap.Builder\u003cComponentDescriptor, String\u003e builder \u003d\n          ImmutableListMultimap.builder();\n      for (ComponentDescriptor component : componentDescriptors) {\n        Name qualifiedName \u003d component.componentDefinitionType().getQualifiedName();\n        builder.putAll(component, QUALIFIED_NAME_SPLITTER.split(qualifiedName));\n      }\n      return builder.build();\n    }\n  }\n\n  @Override\n  protected void decorateComponent() {\n    component.addModifiers(PUBLIC, FINAL);\n    addSupertype(component, componentDefinitionType());\n  }\n\n  @Override\n  protected ClassName builderName() {\n    return name.nestedClass(\"Builder\");\n  }\n\n  @Override\n  protected TypeSpec.Builder createBuilder(String builderSimpleName) {\n    TypeSpec.Builder builder \u003d classBuilder(builderSimpleName).addModifiers(STATIC);\n\n    // Only top-level components have the factory builder() method.\n    // Mirror the user\u0027s builder API type if they had one.\n    MethodSpec builderFactoryMethod \u003d\n        methodBuilder(\"builder\")\n            .addModifiers(PUBLIC, STATIC)\n            .returns(\n                graph.componentDescriptor().builderSpec().isPresent()\n                    ? ClassName.get(\n                        graph.componentDescriptor().builderSpec().get().builderDefinitionType())\n                    : builderName.get())\n            .addStatement(\"return new $T()\", builderName.get())\n            .build();\n    component.addMethod(builderFactoryMethod);\n    return builder;\n  }\n\n  @Override\n  protected void addBuilderClass(TypeSpec builder) {\n    component.addType(builder);\n  }\n\n  @Override\n  protected void addFactoryMethods() {\n    if (canInstantiateAllRequirements()) {\n      CharSequence buildMethodName \u003d\n          graph.componentDescriptor().builderSpec().isPresent()\n              ? graph.componentDescriptor().builderSpec().get().buildMethod().getSimpleName()\n              : \"build\";\n      component.addMethod(\n          methodBuilder(\"create\")\n              .returns(componentDefinitionTypeName())\n              .addModifiers(PUBLIC, STATIC)\n              .addStatement(\"return builder().$L()\", buildMethodName)\n              .build());\n    }\n  }\n\n  /** {@code true} if all of the graph\u0027s required dependencies can be automatically constructed. */\n  private boolean canInstantiateAllRequirements() {\n    return !Iterables.any(\n        graph.componentRequirements(), dependency -\u003e requiresAPassedInstance(elements, dependency));\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ConfigurationAnnotations.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.AnnotationMirrors.getAnnotationValue;\nimport static com.google.auto.common.MoreElements.getAnnotationMirror;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static dagger.internal.codegen.Util.isAnyAnnotationPresent;\nimport static javax.lang.model.util.ElementFilter.typesIn;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Sets;\nimport dagger.Component;\nimport dagger.Module;\nimport dagger.Subcomponent;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.ProductionComponent;\nimport dagger.producers.ProductionSubcomponent;\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayDeque;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Set;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.AnnotationValue;\nimport javax.lang.model.element.AnnotationValueVisitor;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeKind;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.SimpleAnnotationValueVisitor6;\nimport javax.lang.model.util.SimpleTypeVisitor6;\nimport javax.lang.model.util.Types;\n\n/**\n * Utility methods related to dagger configuration annotations (e.g.: {@link Component}\n * and {@link Module}).\n *\n * @author Gregory Kick\n */\nfinal class ConfigurationAnnotations {\n\n  static Optional\u003cAnnotationMirror\u003e getComponentAnnotation(TypeElement component) {\n    return getAnnotationMirror(component, Component.class)\n        .or(getAnnotationMirror(component, ProductionComponent.class));\n  }\n\n  static Optional\u003cAnnotationMirror\u003e getSubcomponentAnnotation(TypeElement subcomponent) {\n    return getAnnotationMirror(subcomponent, Subcomponent.class)\n        .or(getAnnotationMirror(subcomponent, ProductionSubcomponent.class));\n  }\n\n  static boolean isSubcomponent(Element element) {\n    return isAnyAnnotationPresent(element, Subcomponent.class, ProductionSubcomponent.class);\n  }\n\n  static Optional\u003cTypeElement\u003e getSubcomponentBuilder(TypeElement subcomponent) {\n    checkArgument(isSubcomponent(subcomponent));\n    for (TypeElement nestedType : typesIn(subcomponent.getEnclosedElements())) {\n      if (isSubcomponentBuilder(nestedType)) {\n        return Optional.of(nestedType);\n      }\n    }\n    return Optional.absent();\n  }\n\n  static boolean isSubcomponentBuilder(Element element) {\n    return isAnyAnnotationPresent(\n        element, Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);\n  }\n\n  private static final String MODULES_ATTRIBUTE \u003d \"modules\";\n\n  static ImmutableList\u003cTypeMirror\u003e getComponentModules(AnnotationMirror componentAnnotation) {\n    checkNotNull(componentAnnotation);\n    return convertClassArrayToListOfTypes(componentAnnotation, MODULES_ATTRIBUTE);\n  }\n\n  private static final String DEPENDENCIES_ATTRIBUTE \u003d \"dependencies\";\n\n  static ImmutableList\u003cTypeMirror\u003e getComponentDependencies(AnnotationMirror componentAnnotation) {\n    checkNotNull(componentAnnotation);\n    return convertClassArrayToListOfTypes(componentAnnotation, DEPENDENCIES_ATTRIBUTE);\n  }\n\n  static Optional\u003cAnnotationMirror\u003e getModuleAnnotation(TypeElement moduleElement) {\n    return getAnnotationMirror(moduleElement, Module.class)\n        .or(getAnnotationMirror(moduleElement, ProducerModule.class));\n  }\n\n  private static final String INCLUDES_ATTRIBUTE \u003d \"includes\";\n\n  static ImmutableList\u003cTypeMirror\u003e getModuleIncludes(AnnotationMirror moduleAnnotation) {\n    checkNotNull(moduleAnnotation);\n    return convertClassArrayToListOfTypes(moduleAnnotation, INCLUDES_ATTRIBUTE);\n  }\n\n  private static final String SUBCOMPONENTS_ATTRIBUTE \u003d \"subcomponents\";\n\n  static ImmutableList\u003cTypeMirror\u003e getModuleSubcomponents(AnnotationMirror moduleAnnotation) {\n    checkNotNull(moduleAnnotation);\n    return convertClassArrayToListOfTypes(moduleAnnotation, SUBCOMPONENTS_ATTRIBUTE);\n  }\n\n  private static final String INJECTS_ATTRIBUTE \u003d \"injects\";\n\n  static ImmutableList\u003cTypeMirror\u003e getModuleInjects(AnnotationMirror moduleAnnotation) {\n    checkNotNull(moduleAnnotation);\n    return convertClassArrayToListOfTypes(moduleAnnotation, INJECTS_ATTRIBUTE);\n  }\n\n  /** Returns the first type that specifies this\u0027 nullability, or absent if none. */\n  static Optional\u003cDeclaredType\u003e getNullableType(Element element) {\n    List\u003c? extends AnnotationMirror\u003e mirrors \u003d element.getAnnotationMirrors();\n    for (AnnotationMirror mirror : mirrors) {\n      if (mirror.getAnnotationType().asElement().getSimpleName().contentEquals(\"Nullable\")) {\n        return Optional.of(mirror.getAnnotationType());\n      }\n    }\n    return Optional.absent();\n  }\n\n  /**\n   * Extracts the list of types that is the value of the annotation member {@code elementName} of\n   * {@code annotationMirror}.\n   *\n   * @throws IllegalArgumentException if no such member exists on {@code annotationMirror}, or it\n   *     exists but is not an array\n   * @throws TypeNotPresentException if any of the values cannot be converted to a type\n   */\n  static ImmutableList\u003cTypeMirror\u003e convertClassArrayToListOfTypes(\n      AnnotationMirror annotationMirror, String elementName) {\n    return TO_LIST_OF_TYPES.visit(getAnnotationValue(annotationMirror, elementName), elementName);\n  }\n\n  static \u003cT extends Element\u003e void validateComponentDependencies(\n      ValidationReport.Builder\u003cT\u003e report, Iterable\u003cTypeMirror\u003e types) {\n    validateTypesAreDeclared(report, types, \"component dependency\");\n  }\n\n  private static \u003cT extends Element\u003e void validateTypesAreDeclared(\n      final ValidationReport.Builder\u003cT\u003e report, Iterable\u003cTypeMirror\u003e types, final String typeName) {\n    for (TypeMirror type : types) {\n      type.accept(new SimpleTypeVisitor6\u003cVoid, Void\u003e(){\n        @Override\n        protected Void defaultAction(TypeMirror e, Void aVoid) {\n          report.addError(String.format(\"%s is not a valid %s type\", e, typeName));\n          return null;\n        }\n\n        @Override\n        public Void visitDeclared(DeclaredType t, Void aVoid) {\n          // Declared types are valid\n          return null;\n        }\n      }, null);\n    }\n  }\n\n  private static final AnnotationValueVisitor\u003cImmutableList\u003cTypeMirror\u003e, String\u003e TO_LIST_OF_TYPES \u003d\n      new SimpleAnnotationValueVisitor6\u003cImmutableList\u003cTypeMirror\u003e, String\u003e() {\n        @Override\n        public ImmutableList\u003cTypeMirror\u003e visitArray(\n            List\u003c? extends AnnotationValue\u003e vals, String elementName) {\n          return FluentIterable.from(vals).transform(TO_TYPE::visit).toList();\n        }\n\n        @Override\n        protected ImmutableList\u003cTypeMirror\u003e defaultAction(Object o, String elementName) {\n          throw new IllegalArgumentException(elementName + \" is not an array: \" + o);\n        }\n      };\n\n  /**\n   * Returns the value named {@code elementName} from {@code annotation}, which must be a member\n   * that contains a single type.\n   */\n  static TypeMirror typeValue(AnnotationMirror annotation, String elementName) {\n    return TO_TYPE.visit(getAnnotationValue(annotation, elementName));\n  }\n\n  private static final AnnotationValueVisitor\u003cTypeMirror, Void\u003e TO_TYPE \u003d\n      new SimpleAnnotationValueVisitor6\u003cTypeMirror, Void\u003e() {\n        @Override\n        public TypeMirror visitType(TypeMirror t, Void p) {\n          return t;\n        }\n\n        @Override\n        protected TypeMirror defaultAction(Object o, Void p) {\n          throw new TypeNotPresentException(o.toString(), null);\n        }\n      };\n\n  /**\n   * Returns the full set of modules transitively {@linkplain Module#includes included} from the\n   * given seed modules.  If a module is malformed and a type listed in {@link Module#includes}\n   * is not annotated with {@link Module}, it is ignored.\n   *\n   * @deprecated Use {@link ComponentDescriptor#transitiveModules}.\n   */\n  @Deprecated\n  static ImmutableSet\u003cTypeElement\u003e getTransitiveModules(\n      Types types, Elements elements, Iterable\u003cTypeElement\u003e seedModules) {\n    TypeMirror objectType \u003d elements.getTypeElement(Object.class.getCanonicalName()).asType();\n    Queue\u003cTypeElement\u003e moduleQueue \u003d new ArrayDeque\u003c\u003e();\n    Iterables.addAll(moduleQueue, seedModules);\n    Set\u003cTypeElement\u003e moduleElements \u003d Sets.newLinkedHashSet();\n    for (TypeElement moduleElement \u003d moduleQueue.poll();\n        moduleElement !\u003d null;\n        moduleElement \u003d moduleQueue.poll()) {\n      Optional\u003cAnnotationMirror\u003e moduleMirror \u003d getModuleAnnotation(moduleElement);\n      if (moduleMirror.isPresent()) {\n        ImmutableSet.Builder\u003cTypeElement\u003e moduleDependenciesBuilder \u003d ImmutableSet.builder();\n        moduleDependenciesBuilder.addAll(\n            MoreTypes.asTypeElements(getModuleIncludes(moduleMirror.get())));\n        // (note: we don\u0027t recurse on the parent class because we don\u0027t want the parent class as a\n        // root that the component depends on, and also because we want the dependencies rooted\n        // against this element, not the parent.)\n        addIncludesFromSuperclasses(types, moduleElement, moduleDependenciesBuilder, objectType);\n        ImmutableSet\u003cTypeElement\u003e moduleDependencies \u003d moduleDependenciesBuilder.build();\n        moduleElements.add(moduleElement);\n        for (TypeElement dependencyType : moduleDependencies) {\n          if (!moduleElements.contains(dependencyType)) {\n            moduleQueue.add(dependencyType);\n          }\n        }\n      }\n    }\n    return ImmutableSet.copyOf(moduleElements);\n  }\n\n  /** Returns the enclosed elements annotated with the given annotation type. */\n  static ImmutableList\u003cDeclaredType\u003e enclosedBuilders(TypeElement typeElement,\n      final Class\u003c? extends Annotation\u003e annotation) {\n    final ImmutableList.Builder\u003cDeclaredType\u003e builders \u003d ImmutableList.builder();\n    for (TypeElement element : typesIn(typeElement.getEnclosedElements())) {\n      if (MoreElements.isAnnotationPresent(element, annotation)) {\n        builders.add(MoreTypes.asDeclared(element.asType()));\n      }\n    }\n    return builders.build();\n  }\n\n  /** Traverses includes from superclasses and adds them into the builder. */\n  private static void addIncludesFromSuperclasses(Types types, TypeElement element,\n      ImmutableSet.Builder\u003cTypeElement\u003e builder, TypeMirror objectType) {\n    // Also add the superclass to the queue, in case any @Module definitions were on that.\n    TypeMirror superclass \u003d element.getSuperclass();\n    while (!types.isSameType(objectType, superclass)\n        \u0026\u0026 superclass.getKind().equals(TypeKind.DECLARED)) {\n      element \u003d MoreElements.asType(types.asElement(superclass));\n      Optional\u003cAnnotationMirror\u003e moduleMirror \u003d getModuleAnnotation(element);\n      if (moduleMirror.isPresent()) {\n        builder.addAll(MoreTypes.asTypeElements(getModuleIncludes(moduleMirror.get())));\n      }\n      superclass \u003d element.getSuperclass();\n    }\n  }\n\n  private ConfigurationAnnotations() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ContributionBinding.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.collect.Sets.immutableEnumSet;\nimport static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.CLASS_CONSTRUCTOR;\nimport static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.DELEGATE;\nimport static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;\nimport static dagger.internal.codegen.MapKeys.unwrapValue;\nimport static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;\nimport static javax.lang.model.element.Modifier.ABSTRACT;\nimport static javax.lang.model.element.Modifier.STATIC;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.base.Equivalence;\nimport com.google.common.base.Equivalence.Wrapper;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport dagger.Component;\nimport dagger.MapKey;\nimport dagger.Provides;\nimport dagger.internal.codegen.ContributionType.HasContributionType;\nimport dagger.producers.Produces;\nimport java.util.Set;\nimport javax.inject.Inject;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.AnnotationValue;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeMirror;\n\n/**\n * An abstract class for a value object representing the mechanism by which a {@link Key} can be\n * contributed to a dependency graph.\n *\n * @author Jesse Beder\n * @since 2.0\n */\nabstract class ContributionBinding extends Binding implements HasContributionType {\n\n  /** Returns the type that specifies this\u0027 nullability, absent if not nullable. */\n  abstract Optional\u003cDeclaredType\u003e nullableType();\n\n  abstract Optional\u003cEquivalence.Wrapper\u003cAnnotationMirror\u003e\u003e wrappedMapKey();\n\n  final Optional\u003cAnnotationMirror\u003e mapKey() {\n    return unwrapOptionalEquivalence(wrappedMapKey());\n  }\n\n  /**\n   * The kind of contribution this binding represents. Defines which elements can specify this kind\n   * of contribution.\n   */\n  enum Kind {\n    /**\n     * The synthetic binding for {@code Map\u003cK, V\u003e} that depends on either\n     * {@code Map\u003cK, Provider\u003cV\u003e\u003e} or {@code Map\u003cK, Producer\u003cV\u003e\u003e}.\n     */\n    SYNTHETIC_MAP,\n\n    /**\n     * A synthetic binding for a multibound set that depends on the individual multibinding\n     * {@link Provides @Provides} or {@link Produces @Produces} methods.\n     */\n    SYNTHETIC_MULTIBOUND_SET,\n\n    /**\n     * A synthetic binding for a multibound map that depends on the individual multibinding\n     * {@link Provides @Provides} or {@link Produces @Produces} methods.\n     */\n    SYNTHETIC_MULTIBOUND_MAP,\n\n    /**\n     * A binding (provision or production) that delegates from requests for one key to another.\n     * These are the bindings that satisfy {@code @Binds} declarations.\n     */\n    SYNTHETIC_DELEGATE_BINDING,\n\n    /**\n     * A synthetic binding for {@code Optional} of a type or a {@link javax.inject.Provider}, {@link\n     * dagger.Lazy}, or {@code Provider} of {@code Lazy} of a type. Generated by a {@link\n     * dagger.BindsOptionalOf} declaration.\n     */\n    SYNTHETIC_OPTIONAL_BINDING,\n\n    // Provision kinds\n\n    /** An {@link Inject}-annotated constructor. */\n    INJECTION,\n\n    /** A {@link Provides}-annotated method. */\n    PROVISION,\n\n    /** An implicit binding to a {@link Component @Component}-annotated type. */\n    COMPONENT,\n\n    /** A provision method on a component\u0027s {@linkplain Component#dependencies() dependency}. */\n    COMPONENT_PROVISION,\n\n    /**\n     * A subcomponent builder method on a component or subcomponent.\n     */\n    SUBCOMPONENT_BUILDER,\n\n    // Production kinds\n\n    /** A {@link Produces}-annotated method. */\n    PRODUCTION,\n\n    /**\n     * A production method on a production component\u0027s {@linkplain\n     * dagger.producers.ProductionComponent#dependencies()} dependency} that returns a\n     * {@link ListenableFuture}. Methods on production component dependencies that don\u0027t return a\n     * {@link ListenableFuture} are considered {@linkplain #PROVISION provision bindings}.\n     */\n    COMPONENT_PRODUCTION,\n    ;\n\n    static final ImmutableSet\u003cKind\u003e SYNTHETIC_MULTIBOUND_KINDS \u003d\n        immutableEnumSet(SYNTHETIC_MULTIBOUND_SET, SYNTHETIC_MULTIBOUND_MAP);\n\n    /**\n     * {@link #SYNTHETIC_MULTIBOUND_SET} or {@link #SYNTHETIC_MULTIBOUND_MAP}, depending on the key.\n     */\n    static Kind forMultibindingKey(Key key) {\n      if (SetType.isSet(key)) {\n        return SYNTHETIC_MULTIBOUND_SET;\n      } else if (MapType.isMap(key)) {\n        return SYNTHETIC_MULTIBOUND_MAP;\n      } else {\n        throw new IllegalArgumentException(String.format(\"key is not for a set or map: %s\", key));\n      }\n    }\n  }\n\n  /**\n   * The kind of this contribution binding.\n   */\n  protected abstract Kind bindingKind();\n\n  /**\n   * {@code true} if {@link #contributingModule()} is present and this is a nonabstract instance\n   * method.\n   */\n  boolean requiresModuleInstance() {\n    if (!bindingElement().isPresent() || !contributingModule().isPresent()) {\n      return false;\n    }\n    Set\u003cModifier\u003e modifiers \u003d bindingElement().get().getModifiers();\n    return !modifiers.contains(ABSTRACT) \u0026\u0026 !modifiers.contains(STATIC);\n  }\n\n  /**\n   * The strategy for getting an instance of a factory for a {@link ContributionBinding}.\n   */\n  enum FactoryCreationStrategy {\n    /** The factory class is an enum with one value named {@code INSTANCE}. */\n    ENUM_INSTANCE,\n    /** The factory must be created by calling the constructor. */\n    CLASS_CONSTRUCTOR,\n    /** The factory is simply delegated to another. */\n    DELEGATE,\n  }\n\n  /**\n   * Returns the {@link FactoryCreationStrategy} appropriate for a binding.\n   *\n   * \u003cp\u003eDelegate bindings use the {@link FactoryCreationStrategy#DELEGATE} strategy.\n   *\n   * \u003cp\u003eBindings without dependencies that don\u0027t require a module instance use the {@link\n   * FactoryCreationStrategy#ENUM_INSTANCE} strategy.\n   *\n   * \u003cp\u003eAll other bindings use the {@link FactoryCreationStrategy#CLASS_CONSTRUCTOR} strategy.\n   */\n  FactoryCreationStrategy factoryCreationStrategy() {\n    switch (bindingKind()) {\n      case SYNTHETIC_DELEGATE_BINDING:\n        return DELEGATE;\n      case PROVISION:\n        return implicitDependencies().isEmpty() \u0026\u0026 !requiresModuleInstance()\n            ? ENUM_INSTANCE\n            : CLASS_CONSTRUCTOR;\n      case INJECTION:\n      case SYNTHETIC_MULTIBOUND_SET:\n      case SYNTHETIC_MULTIBOUND_MAP:\n        return implicitDependencies().isEmpty() ? ENUM_INSTANCE : CLASS_CONSTRUCTOR;\n      default:\n        return CLASS_CONSTRUCTOR;\n    }\n  }\n\n  /**\n   * The {@link TypeMirror type} for the {@code Factory\u003cT\u003e} or {@code Producer\u003cT\u003e} which is created\n   * for this binding. Uses the binding\u0027s key, V in the came of {@code Map\u003cK, FrameworkClass\u003cV\u003e\u003e\u003e},\n   * and E {@code Set\u003cE\u003e} for {@link dagger.multibindings.IntoSet @IntoSet} methods.\n   */\n  final TypeMirror factoryType() {\n    switch (contributionType()) {\n      case MAP:\n        return MapType.from(key()).unwrappedValueType(bindingType().frameworkClass());\n      case SET:\n        return SetType.from(key()).elementType();\n      case SET_VALUES:\n      case UNIQUE:\n        return key().type();\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  /**\n   * Indexes map-multibindings by map key (the result of calling\n   * {@link AnnotationValue#getValue()} on a single member or the whole {@link AnnotationMirror}\n   * itself, depending on {@link MapKey#unwrapValue()}).\n   */\n  static ImmutableSetMultimap\u003cObject, ContributionBinding\u003e indexMapBindingsByMapKey(\n      Set\u003cContributionBinding\u003e mapBindings) {\n    return ImmutableSetMultimap.copyOf(\n        Multimaps.index(\n            mapBindings,\n            mapBinding -\u003e {\n              AnnotationMirror mapKey \u003d mapBinding.mapKey().get();\n              Optional\u003c? extends AnnotationValue\u003e unwrappedValue \u003d unwrapValue(mapKey);\n              return unwrappedValue.isPresent() ? unwrappedValue.get().getValue() : mapKey;\n            }));\n  }\n\n  /**\n   * Indexes map-multibindings by map key annotation type.\n   */\n  static ImmutableSetMultimap\u003cWrapper\u003cDeclaredType\u003e, ContributionBinding\u003e\n      indexMapBindingsByAnnotationType(Set\u003cContributionBinding\u003e mapBindings) {\n    return ImmutableSetMultimap.copyOf(\n        Multimaps.index(\n            mapBindings,\n            mapBinding -\u003e\n                MoreTypes.equivalence().wrap(mapBinding.mapKey().get().getAnnotationType())));\n  }\n\n  /**\n   * Base builder for {@link com.google.auto.value.AutoValue @AutoValue} subclasses of\n   * {@link ContributionBinding}.\n   */\n  @CanIgnoreReturnValue\n  abstract static class Builder\u003cB extends Builder\u003cB\u003e\u003e {\n    abstract B contributionType(ContributionType contributionType);\n\n    abstract B bindingElement(Element bindingElement);\n\n    abstract B contributingModule(TypeElement contributingModule);\n\n    abstract B key(Key key);\n\n    abstract B dependencies(Iterable\u003cDependencyRequest\u003e dependencies);\n\n    abstract B dependencies(DependencyRequest... dependencies);\n\n    abstract B nullableType(Optional\u003cDeclaredType\u003e nullableType);\n\n    abstract B wrappedMapKey(Optional\u003cEquivalence.Wrapper\u003cAnnotationMirror\u003e\u003e wrappedMapKey);\n\n    abstract B bindingKind(ContributionBinding.Kind kind);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ContributionType.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\n\nimport dagger.Provides;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntoMap;\nimport dagger.multibindings.IntoSet;\nimport dagger.producers.Produces;\nimport javax.lang.model.element.ExecutableElement;\n\n/**\n * Whether a binding or declaration is for a unique contribution or a map or set multibinding.\n */\nenum ContributionType {\n  /** Represents map bindings. */\n  MAP,\n  /** Represents set bindings. */\n  SET,\n  /** Represents set values bindings. */\n  SET_VALUES,\n  /** Represents a valid non-collection binding. */\n  UNIQUE,\n  ;\n\n  /**\n   * An object that is associated with a {@link ContributionType}.\n   */\n  interface HasContributionType {\n\n    /** The contribution type of this object. */\n    ContributionType contributionType();\n  }\n\n  /**\n   * {@code true} if this is for a multibinding.\n   */\n  boolean isMultibinding() {\n    return !this.equals(UNIQUE);\n  }\n\n  /** The contribution type for a given provision type. */\n  private static ContributionType forProvisionType(Provides.Type provisionType) {\n    switch (provisionType) {\n      case SET:\n        return SET;\n      case SET_VALUES:\n        return SET_VALUES;\n      case MAP:\n        return MAP;\n      case UNIQUE:\n        return UNIQUE;\n      default:\n        throw new AssertionError(\"Unknown provision type: \" + provisionType);\n    }\n  }\n\n  private static ContributionType forProductionType(Produces.Type productionType) {\n    switch (productionType) {\n      case SET:\n        return SET;\n      case SET_VALUES:\n        return SET_VALUES;\n      case MAP:\n        return MAP;\n      case UNIQUE:\n        return UNIQUE;\n      default:\n        throw new AssertionError(\"Unknown production type: \" + productionType);\n    }\n  }\n\n  /**\n   * The contribution type from a binding method annotations. Presumes a well-formed binding method\n   * (only one of @IntoSet, @IntoMap, @ElementsIntoSet, @Provides.type or @Produces.type. {@link\n   * ProvidesMethodValidator} and {@link ProducesMethodValidator} validate correctness on their own.\n   */\n  static ContributionType fromBindingMethod(ExecutableElement method) {\n    if (isAnnotationPresent(method, IntoMap.class)) {\n      return ContributionType.MAP;\n    } else if (isAnnotationPresent(method, IntoSet.class)) {\n      return ContributionType.SET;\n    } else if (isAnnotationPresent(method, ElementsIntoSet.class)) {\n      return ContributionType.SET_VALUES;\n    }\n\n    if (isAnnotationPresent(method, Provides.class)) {\n      return forProvisionType(method.getAnnotation(Provides.class).type());\n    } else if (isAnnotationPresent(method, Produces.class)) {\n      return forProductionType(method.getAnnotation(Produces.class).type());\n    } else {\n      return ContributionType.UNIQUE;\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\DelegateDeclaration.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static dagger.internal.codegen.MapKeys.getMapKey;\nimport static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Equivalence;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.Iterables;\nimport dagger.Binds;\nimport dagger.internal.codegen.ContributionType.HasContributionType;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.util.Types;\n\n/**\n * The declaration for a delegate binding established by a {@link Binds} method.\n */\n@AutoValue\nabstract class DelegateDeclaration extends BindingDeclaration implements HasContributionType {\n  abstract DependencyRequest delegateRequest();\n\n  abstract Optional\u003cEquivalence.Wrapper\u003cAnnotationMirror\u003e\u003e wrappedMapKey();\n\n  static final class Factory {\n    private final Types types;\n    private final Key.Factory keyFactory;\n    private final DependencyRequest.Factory dependencyRequestFactory;\n\n    Factory(\n        Types types, Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {\n      this.types \u003d types;\n      this.keyFactory \u003d keyFactory;\n      this.dependencyRequestFactory \u003d dependencyRequestFactory;\n    }\n\n    DelegateDeclaration create(\n        ExecutableElement bindsMethod, TypeElement contributingModule) {\n      checkArgument(MoreElements.isAnnotationPresent(bindsMethod, Binds.class));\n      ExecutableType resolvedMethod \u003d\n          MoreTypes.asExecutable(\n              types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), bindsMethod));\n      DependencyRequest delegateRequest \u003d\n          dependencyRequestFactory.forRequiredResolvedVariable(\n              Iterables.getOnlyElement(bindsMethod.getParameters()),\n              Iterables.getOnlyElement(resolvedMethod.getParameterTypes()));\n      return new AutoValue_DelegateDeclaration(\n          ContributionType.fromBindingMethod(bindsMethod),\n          keyFactory.forBindsMethod(bindsMethod, contributingModule),\n          Optional.\u003cElement\u003eof(bindsMethod),\n          Optional.of(contributingModule),\n          delegateRequest,\n          wrapOptionalInEquivalence(getMapKey(bindsMethod)));\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\DependencyRequest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreTypes.asDeclared;\nimport static com.google.auto.common.MoreTypes.isType;\nimport static com.google.auto.common.MoreTypes.isTypeOf;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getNullableType;\nimport static dagger.internal.codegen.TypeNames.lazyOf;\nimport static dagger.internal.codegen.TypeNames.listenableFutureOf;\nimport static dagger.internal.codegen.TypeNames.producedOf;\nimport static dagger.internal.codegen.TypeNames.producerOf;\nimport static dagger.internal.codegen.TypeNames.providerOf;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.squareup.javapoet.TypeName;\nimport dagger.Lazy;\nimport dagger.MembersInjector;\nimport dagger.Provides;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport java.util.List;\nimport javax.annotation.CheckReturnValue;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.ErrorType;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.TypeKind;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.SimpleTypeVisitor7;\n\n/**\n * Represents a request for a key at an injection point. Parameters to {@link Inject} constructors\n * or {@link Provides} methods are examples of key requests.\n *\n * @author Gregory Kick\n * @since 2.0\n */\n// TODO(gak): Set bindings and the permutations thereof need to be addressed\n@AutoValue\nabstract class DependencyRequest {\n\n  enum Kind {\n    /** A default request for an instance.  E.g.: {@code Blah} */\n    INSTANCE,\n\n    /** A request for a {@link Provider}.  E.g.: {@code Provider\u003cBlah\u003e} */\n    PROVIDER(Provider.class),\n\n    /** A request for a {@link Lazy}.  E.g.: {@code Lazy\u003cBlah\u003e} */\n    LAZY(Lazy.class),\n\n    /** A request for a {@link Provider} of a {@link Lazy}. E.g.: {@code Provider\u003cLazy\u003cBlah\u003e\u003e} */\n    PROVIDER_OF_LAZY,\n\n    /** A request for a {@link MembersInjector}.  E.g.: {@code MembersInjector\u003cBlah\u003e} */\n    MEMBERS_INJECTOR(MembersInjector.class),\n\n    /** A request for a {@link Producer}.  E.g.: {@code Producer\u003cBlah\u003e} */\n    PRODUCER(Producer.class),\n\n    /** A request for a {@link Produced}.  E.g.: {@code Produced\u003cBlah\u003e} */\n    PRODUCED(Produced.class),\n\n    /**\n     * A request for a {@link ListenableFuture}.  E.g.: {@code ListenableFuture\u003cBlah\u003e}.\n     * These can only be requested by component interfaces.\n     */\n    FUTURE,\n    ;\n\n    final Optional\u003cClass\u003c?\u003e\u003e frameworkClass;\n\n    Kind(Class\u003c?\u003e frameworkClass) {\n      this.frameworkClass \u003d Optional.\u003cClass\u003c?\u003e\u003eof(frameworkClass);\n    }\n\n    Kind() {\n      this.frameworkClass \u003d Optional.absent();\n    }\n\n    /**\n     * If {@code type}\u0027s raw type is {@link #frameworkClass}, returns a {@link KindAndType} with\n     * this kind that represents the dependency request.\n     */\n    Optional\u003cKindAndType\u003e from(TypeMirror type) {\n      if (frameworkClass.isPresent() \u0026\u0026 isType(type) \u0026\u0026 isTypeOf(frameworkClass.get(), type)) {\n        List\u003c? extends TypeMirror\u003e typeArguments \u003d asDeclared(type).getTypeArguments();\n        if (typeArguments.isEmpty()) {\n          return Optional.absent();\n        }\n        return Optional.of(this.ofType(getOnlyElement(typeArguments)));\n      }\n      return Optional.\u003cKindAndType\u003eabsent();\n    }\n\n    /** Returns a {@link KindAndType} with this kind and {@code type} type. */\n    KindAndType ofType(TypeMirror type) {\n      return new AutoValue_DependencyRequest_KindAndType(this, type);\n    }\n\n    /** Returns the type of a request of this kind for a key with a given type. */\n    TypeName typeName(TypeName keyType) {\n      switch (this) {\n        case INSTANCE:\n          return keyType;\n\n        case PROVIDER:\n          return providerOf(keyType);\n\n        case LAZY:\n          return lazyOf(keyType);\n\n        case PROVIDER_OF_LAZY:\n          return providerOf(lazyOf(keyType));\n\n        case PRODUCER:\n          return producerOf(keyType);\n\n        case PRODUCED:\n          return producedOf(keyType);\n\n        case FUTURE:\n          return listenableFutureOf(keyType);\n\n        default:\n          throw new AssertionError(this);\n      }\n    }\n  }\n\n  abstract Kind kind();\n  abstract Key key();\n  \n  BindingKey bindingKey() {\n    switch (kind()) {\n      case INSTANCE:\n      case LAZY:\n      case PROVIDER:\n      case PROVIDER_OF_LAZY:\n      case PRODUCER:\n      case PRODUCED:\n      case FUTURE:\n        return BindingKey.contribution(key());\n      case MEMBERS_INJECTOR:\n        return BindingKey.membersInjection(key());\n      default:\n        throw new AssertionError(this);\n    }\n  }\n\n  /** The element that declares this dependency request. Absent for synthetic requests. */\n  abstract Optional\u003cElement\u003e requestElement();\n\n  /** Returns true if this request allows null objects. */\n  abstract boolean isNullable();\n\n  /**\n   * An optional name for this request when it\u0027s referred to in generated code. If absent, it will\n   * use a name derived from {@link #requestElement}.\n   */\n  abstract Optional\u003cString\u003e overriddenVariableName();\n\n  private static DependencyRequest.Builder builder() {\n    return new AutoValue_DependencyRequest.Builder().isNullable(false);\n  }\n\n  /**\n   * Extracts the dependency request type and kind from the type of a dependency request element.\n   * For example, if a user requests {@code Provider\u003cFoo\u003e}, this will return ({@link Kind#PROVIDER},\n   * {@code Foo}).\n   *\n   * @throws TypeNotPresentException if {@code type}\u0027s kind is {@link TypeKind#ERROR}, which may\n   *     mean that the type will be generated in a later round of processing\n   */\n  static KindAndType extractKindAndType(TypeMirror type) {\n    return type.accept(\n        new SimpleTypeVisitor7\u003cKindAndType, Void\u003e() {\n          @Override\n          public KindAndType visitError(ErrorType errorType, Void p) {\n            throw new TypeNotPresentException(errorType.toString(), null);\n          }\n\n          @Override\n          public KindAndType visitExecutable(ExecutableType executableType, Void p) {\n            return executableType.getReturnType().accept(this, null);\n          }\n\n          @Override\n          public KindAndType visitDeclared(DeclaredType declaredType, Void p) {\n            return KindAndType.from(declaredType).or(defaultAction(declaredType, p));\n          }\n\n          @Override\n          protected KindAndType defaultAction(TypeMirror otherType, Void p) {\n            return Kind.INSTANCE.ofType(otherType);\n          }\n        },\n        null);\n  }\n\n  @AutoValue\n  abstract static class KindAndType {\n    abstract Kind kind();\n\n    abstract TypeMirror type();\n\n    static Optional\u003cKindAndType\u003e from(TypeMirror type) {\n      for (Kind kind : Kind.values()) {\n        Optional\u003cKindAndType\u003e kindAndType \u003d kind.from(type);\n        if (kindAndType.isPresent()) {\n          return kindAndType.get().maybeProviderOfLazy().or(kindAndType);\n        }\n      }\n      return Optional.absent();\n    }\n\n    /**\n     * If {@code kindAndType} represents a {@link Kind#PROVIDER} of a {@code Lazy\u003cT\u003e} for some type\n     * {@code T}, then this method returns ({@link Kind#PROVIDER_OF_LAZY}, {@code T}).\n     */\n    private Optional\u003cKindAndType\u003e maybeProviderOfLazy() {\n      if (kind().equals(Kind.PROVIDER)) {\n        Optional\u003cKindAndType\u003e providedKindAndType \u003d from(type());\n        if (providedKindAndType.isPresent() \u0026\u0026 providedKindAndType.get().kind().equals(Kind.LAZY)) {\n          return Optional.of(Kind.PROVIDER_OF_LAZY.ofType(providedKindAndType.get().type()));\n        }\n      }\n      return Optional.absent();\n    }\n  }\n\n  @CanIgnoreReturnValue\n  @AutoValue.Builder\n  abstract static class Builder {\n    abstract Builder kind(Kind kind);\n\n    abstract Builder key(Key key);\n\n    abstract Builder requestElement(Element element);\n\n    abstract Builder isNullable(boolean isNullable);\n\n    abstract Builder overriddenVariableName(Optional\u003cString\u003e overriddenVariableName);\n\n    @CheckReturnValue\n    abstract DependencyRequest build();\n  }\n\n  /**\n   * Factory for {@link DependencyRequest}s.\n   *\n   * \u003cp\u003eAny factory method may throw {@link TypeNotPresentException} if a type is not available,\n   * which may mean that the type will be generated in a later round of processing.\n   */\n  static final class Factory {\n    private final Key.Factory keyFactory;\n\n    Factory(Key.Factory keyFactory) {\n      this.keyFactory \u003d keyFactory;\n    }\n\n    ImmutableSet\u003cDependencyRequest\u003e forRequiredResolvedVariables(\n        List\u003c? extends VariableElement\u003e variables, List\u003c? extends TypeMirror\u003e resolvedTypes) {\n      checkState(resolvedTypes.size() \u003d\u003d variables.size());\n      ImmutableSet.Builder\u003cDependencyRequest\u003e builder \u003d ImmutableSet.builder();\n      for (int i \u003d 0; i \u003c variables.size(); i++) {\n        builder.add(forRequiredResolvedVariable(variables.get(i), resolvedTypes.get(i)));\n      }\n      return builder.build();\n    }\n\n    /**\n     * Creates a implicit {@link DependencyRequest} for {@code mapOfFactoryKey}.\n     *\n     * @param mapOfFactoryKey a key equivalent to {@code mapOfValueRequest}\u0027s key, whose type is\n     *     {@code Map\u003cK, Provider\u003cV\u003e\u003e} or {@code Map\u003cK, Producer\u003cV\u003e\u003e}\n     */\n    DependencyRequest forImplicitMapBinding(Key mapOfFactoryKey) {\n      return DependencyRequest.builder()\n          .kind(Kind.PROVIDER)\n          .key(mapOfFactoryKey)\n          .build();\n    }\n\n    /**\n     * Creates a synthetic dependency request for one individual {@code multibindingContribution}.\n     */\n    private DependencyRequest forMultibindingContribution(\n        ContributionBinding multibindingContribution) {\n      checkArgument(\n          multibindingContribution.key().multibindingContributionIdentifier().isPresent(),\n          \"multibindingContribution\u0027s key must have a multibinding contribution identifier: %s\",\n          multibindingContribution);\n      return DependencyRequest.builder()\n          .kind(multibindingContributionRequestKind(multibindingContribution))\n          .key(multibindingContribution.key())\n          .build();\n    }\n\n    private Kind multibindingContributionRequestKind(ContributionBinding multibindingContribution) {\n      switch (multibindingContribution.contributionType()) {\n        case MAP:\n          return multibindingContribution.bindingType().equals(BindingType.PRODUCTION)\n              ? Kind.PRODUCER\n              : Kind.PROVIDER;\n        case SET:\n        case SET_VALUES:\n          return Kind.INSTANCE;\n        case UNIQUE:\n          throw new IllegalArgumentException(\n              \"multibindingContribution must be a multibinding: \" + multibindingContribution);\n        default:\n          throw new AssertionError(multibindingContribution.toString());\n      }\n    }\n\n    /**\n     * Creates synthetic dependency requests for each individual multibinding contribution in {@code\n     * multibindingContributions}.\n     */\n    ImmutableSet\u003cDependencyRequest\u003e forMultibindingContributions(\n        Iterable\u003cContributionBinding\u003e multibindingContributions) {\n      ImmutableSet.Builder\u003cDependencyRequest\u003e requests \u003d ImmutableSet.builder();\n      for (ContributionBinding multibindingContribution : multibindingContributions) {\n        requests.add(forMultibindingContribution(multibindingContribution));\n      }\n      return requests.build();\n    }\n\n    DependencyRequest forRequiredVariable(VariableElement variableElement) {\n      return forRequiredVariable(variableElement, Optional.\u003cString\u003eabsent());\n    }\n\n    DependencyRequest forRequiredVariable(VariableElement variableElement, Optional\u003cString\u003e name) {\n      checkNotNull(variableElement);\n      TypeMirror type \u003d variableElement.asType();\n      Optional\u003cAnnotationMirror\u003e qualifier \u003d InjectionAnnotations.getQualifier(variableElement);\n      return newDependencyRequest(variableElement, type, qualifier, name);\n    }\n\n    DependencyRequest forRequiredResolvedVariable(\n        VariableElement variableElement, TypeMirror resolvedType) {\n      checkNotNull(variableElement);\n      checkNotNull(resolvedType);\n      Optional\u003cAnnotationMirror\u003e qualifier \u003d InjectionAnnotations.getQualifier(variableElement);\n      return newDependencyRequest(\n          variableElement, resolvedType, qualifier, Optional.\u003cString\u003eabsent());\n    }\n\n    DependencyRequest forComponentProvisionMethod(ExecutableElement provisionMethod,\n        ExecutableType provisionMethodType) {\n      checkNotNull(provisionMethod);\n      checkNotNull(provisionMethodType);\n      checkArgument(\n          provisionMethod.getParameters().isEmpty(),\n          \"Component provision methods must be empty: %s\",\n          provisionMethod);\n      Optional\u003cAnnotationMirror\u003e qualifier \u003d InjectionAnnotations.getQualifier(provisionMethod);\n      return newDependencyRequest(\n          provisionMethod,\n          provisionMethodType.getReturnType(),\n          qualifier,\n          Optional.\u003cString\u003eabsent());\n    }\n\n    DependencyRequest forComponentProductionMethod(ExecutableElement productionMethod,\n        ExecutableType productionMethodType) {\n      checkNotNull(productionMethod);\n      checkNotNull(productionMethodType);\n      checkArgument(productionMethod.getParameters().isEmpty(),\n          \"Component production methods must be empty: %s\", productionMethod);\n      TypeMirror type \u003d productionMethodType.getReturnType();\n      Optional\u003cAnnotationMirror\u003e qualifier \u003d InjectionAnnotations.getQualifier(productionMethod);\n      // Only a component production method can be a request for a ListenableFuture, so we\n      // special-case it here.\n      if (isTypeOf(ListenableFuture.class, type)) {\n        return DependencyRequest.builder()\n            .kind(Kind.FUTURE)\n            .key(keyFactory.forQualifiedType(\n                qualifier, Iterables.getOnlyElement(((DeclaredType) type).getTypeArguments())))\n            .requestElement(productionMethod)\n            .build();\n      } else {\n        return newDependencyRequest(productionMethod, type, qualifier, Optional.\u003cString\u003eabsent());\n      }\n    }\n\n    DependencyRequest forComponentMembersInjectionMethod(ExecutableElement membersInjectionMethod,\n        ExecutableType membersInjectionMethodType) {\n      checkNotNull(membersInjectionMethod);\n      checkNotNull(membersInjectionMethodType);\n      Optional\u003cAnnotationMirror\u003e qualifier \u003d\n          InjectionAnnotations.getQualifier(membersInjectionMethod);\n      checkArgument(!qualifier.isPresent());\n      TypeMirror returnType \u003d membersInjectionMethodType.getReturnType();\n      TypeMirror membersInjectedType \u003d\n          MoreTypes.isType(returnType) \u0026\u0026 MoreTypes.isTypeOf(MembersInjector.class, returnType)\n              ? getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments())\n              : getOnlyElement(membersInjectionMethodType.getParameterTypes());\n      return DependencyRequest.builder()\n          .kind(Kind.MEMBERS_INJECTOR)\n          .key(keyFactory.forMembersInjectedType(membersInjectedType))\n          .requestElement(membersInjectionMethod)\n          .build();\n    }\n\n    DependencyRequest forMembersInjectedType(DeclaredType type) {\n      return DependencyRequest.builder()\n          .kind(Kind.MEMBERS_INJECTOR)\n          .key(keyFactory.forMembersInjectedType(type))\n          .requestElement(type.asElement())\n          .build();\n    }\n\n    DependencyRequest forProductionImplementationExecutor() {\n      Key key \u003d keyFactory.forProductionImplementationExecutor();\n      return DependencyRequest.builder()\n          .kind(Kind.PROVIDER)\n          .key(key)\n          .requestElement(MoreTypes.asElement(key.type()))\n          .build();\n    }\n\n    DependencyRequest forProductionComponentMonitor() {\n      Key key \u003d keyFactory.forProductionComponentMonitor();\n      return DependencyRequest.builder()\n          .kind(Kind.PROVIDER)\n          .key(key)\n          .requestElement(MoreTypes.asElement(key.type()))\n          .overriddenVariableName(Optional.of(\"monitor\"))\n          .build();\n    }\n\n    /**\n     * Returns a synthetic request for the present value of an optional binding generated from a\n     * {@link dagger.BindsOptionalOf} declaration.\n     */\n    DependencyRequest forSyntheticPresentOptionalBinding(Key requestKey, Kind kind) {\n      Optional\u003cKey\u003e key \u003d keyFactory.unwrapOptional(requestKey);\n      checkArgument(key.isPresent(), \"not a request for optional: %s\", requestKey);\n      return builder()\n          .kind(kind)\n          .key(key.get())\n          .isNullable(\n              allowsNull(\n                  extractKindAndType(OptionalType.from(requestKey).valueType()).kind(),\n                  Optional.\u003cDeclaredType\u003eabsent()))\n          .build();\n    }\n\n    private DependencyRequest newDependencyRequest(\n        Element requestElement,\n        TypeMirror type,\n        Optional\u003cAnnotationMirror\u003e qualifier,\n        Optional\u003cString\u003e name) {\n      KindAndType kindAndType \u003d extractKindAndType(type);\n      if (kindAndType.kind().equals(Kind.MEMBERS_INJECTOR)) {\n        checkArgument(!qualifier.isPresent());\n      }\n      return DependencyRequest.builder()\n          .kind(kindAndType.kind())\n          .key(keyFactory.forQualifiedType(qualifier, kindAndType.type()))\n          .requestElement(requestElement)\n          .isNullable(allowsNull(kindAndType.kind(), getNullableType(requestElement)))\n          .overriddenVariableName(name)\n          .build();\n    }\n\n    /**\n     * Returns {@code true} if a given request element allows null values. {@link Kind#INSTANCE}\n     * requests must be annotated with {@code @Nullable} in order to allow null values. All other\n     * request kinds implicitly allow null values because they are are wrapped inside {@link\n     * Provider}, {@link Lazy}, etc.\n     */\n    // TODO(sameb): should Produced/Producer always require non-nullable?\n    private boolean allowsNull(Kind kind, Optional\u003cDeclaredType\u003e nullableType) {\n      return kind.equals(Kind.INSTANCE) ? nullableType.isPresent() : true;\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\DependencyRequestFormatter.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.asExecutable;\nimport static dagger.internal.codegen.ErrorMessages.DOUBLE_INDENT;\nimport static dagger.internal.codegen.ErrorMessages.INDENT;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Predicates;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport dagger.Lazy;\nimport dagger.Provides;\nimport dagger.internal.codegen.BindingGraphValidator.DependencyPath;\nimport dagger.producers.Produces;\nimport java.util.List;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.ElementKindVisitor7;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/**\n * Formats a {@link DependencyRequest} into a {@link String} suitable for an error message listing\n * a chain of dependencies.\n * \n * \u003cdl\u003e\n * \u003cdt\u003eFor component provision methods\n * \u003cdd\u003e{@code @Qualifier SomeType is provided at\\n    ComponentType.method()}\n * \n * \u003cdt\u003eFor component injection methods\n * \u003cdd\u003e{@code SomeType is injected at\\n    ComponentType.method(foo)}\n * \n * \u003cdt\u003eFor parameters to {@link Provides @Provides}, {@link Produces @Produces}, or\n * {@link Inject @Inject} methods:\n * \u003cdd\u003e{@code @Qualified ResolvedType is injected at\\n    EnclosingType.method([…, ]param[, …])}\n * \n * \u003cdt\u003eFor parameters to {@link Inject @Inject} constructors:\n * \u003cdd\u003e{@code @Qualified ResolvedType is injected at\\n    EnclosingType.\u003cinit\u003e([…, ]param[, …])}\n * \n * \u003cdt\u003eFor {@link Inject @Inject} fields:\n * \u003cdd\u003e{@code @Qualified ResolvedType is injected at\\n    EnclosingType.field}\n * \u003c/dl\u003e\n */\nfinal class DependencyRequestFormatter extends Formatter\u003cDependencyRequest\u003e {\n\n  private final Types types;\n  private final Elements elements;\n\n  DependencyRequestFormatter(Types types, Elements elements) {\n    this.types \u003d types;\n    this.elements \u003d elements;\n  }\n\n  /**\n   * A string representation of the dependency trace, starting with the\n   * {@linkplain DependencyPath#currentDependencyRequest() current request} and ending with the\n   * entry point, excluding {@linkplain DependencyRequest#isSynthetic() synthetic} requests.\n   */\n  String toDependencyTrace(DependencyPath dependencyPath) {\n    return Joiner.on(\u0027\\n\u0027)\n        .join(\n            dependencyPath\n                .resolvedRequests()\n                .transform(\n                    resolvedRequest -\u003e {\n                      ImmutableSet\u003cOptionalBindingDeclaration\u003e optionalBindingDeclarations \u003d\n                          resolvedRequest.dependentOptionalBindingDeclarations();\n                      return optionalBindingDeclarations.isEmpty()\n                          ? format(resolvedRequest.dependencyRequest())\n                          : formatSyntheticOptionalBindingDependency(optionalBindingDeclarations);\n                    })\n                .filter(Predicates.not(Predicates.equalTo(\"\")))\n                .toList()\n                .reverse());\n  }\n\n  // TODO(cgruber): Sweep this class for TypeMirror.toString() usage and do some preventive format.\n  // TODO(cgruber): consider returning a small structure containing strings to be indented later.\n  @Override\n  public String format(DependencyRequest request) {\n    if (!request.requestElement().isPresent()) {\n      return \"\";\n    }\n    return request\n        .requestElement()\n        .get()\n        .accept(\n            new ElementKindVisitor7\u003cString, DependencyRequest\u003e() {\n\n              /** Returns the description for component methods. */\n              @Override\n              public String visitExecutableAsMethod(\n                  ExecutableElement method, DependencyRequest request) {\n                StringBuilder builder \u003d new StringBuilder();\n                builder\n                    .append(INDENT)\n                    .append(formatKey(request.key()))\n                    .append(\" is \")\n                    .append(componentMethodRequestVerb(request))\n                    .append(\" at\\n\")\n                    .append(DOUBLE_INDENT);\n                appendEnclosingTypeAndMemberName(method, builder);\n                builder.append(\u0027(\u0027);\n                for (VariableElement parameter : method.getParameters()) {\n                  builder.append(parameter.getSimpleName());\n                }\n                builder.append(\u0027)\u0027);\n                return builder.toString();\n              }\n\n              /**\n               * Returns the description for {@link javax.inject.Inject @Inject} constructor and\n               * method parameters and for {@link dagger.Provides @Provides} and {@link\n               * dagger.producers.Produces @Produces} method parameters.\n               */\n              @Override\n              public String visitVariableAsParameter(\n                  VariableElement variable, DependencyRequest request) {\n                StringBuilder builder \u003d new StringBuilder();\n                appendRequestedTypeIsInjectedAt(builder, request);\n\n                ExecutableElement methodOrConstructor \u003d\n                    asExecutable(variable.getEnclosingElement());\n                appendEnclosingTypeAndMemberName(methodOrConstructor, builder).append(\u0027(\u0027);\n                List\u003c? extends VariableElement\u003e parameters \u003d methodOrConstructor.getParameters();\n                int parameterIndex \u003d parameters.indexOf(variable);\n                builder.append(\n                    formatArgumentInList(\n                        parameterIndex, parameters.size(), variable.getSimpleName()));\n                builder.append(\u0027)\u0027);\n                return builder.toString();\n              }\n\n              /** Returns the description for {@link javax.inject.Inject @Inject} fields. */\n              @Override\n              public String visitVariableAsField(\n                  VariableElement variable, DependencyRequest request) {\n                StringBuilder builder \u003d new StringBuilder();\n                appendRequestedTypeIsInjectedAt(builder, request);\n                appendEnclosingTypeAndMemberName(variable, builder);\n                return builder.toString();\n              }\n\n              @Override\n              public String visitType(TypeElement e, DependencyRequest request) {\n                return \"\"; // types by themselves provide no useful information.\n              }\n\n              @Override\n              protected String defaultAction(Element element, DependencyRequest request) {\n                throw new IllegalStateException(\n                    \"Invalid request \" + element.getKind() + \" element \" + element);\n              }\n            },\n            request);\n  }\n\n  @CanIgnoreReturnValue\n  private StringBuilder appendRequestedTypeIsInjectedAt(\n      StringBuilder builder, DependencyRequest request) {\n    return builder\n        .append(INDENT)\n        .append(formatKey(request.key().qualifier(), requestedType(request)))\n        .append(\" is injected at\\n\")\n        .append(DOUBLE_INDENT);\n  }\n\n  private TypeMirror requestedType(DependencyRequest request) {\n    TypeMirror keyType \u003d request.key().type();\n    switch (request.kind()) {\n      case FUTURE:\n        return wrapType(ListenableFuture.class, keyType);\n\n      case PROVIDER_OF_LAZY:\n        return wrapType(Provider.class, wrapType(Lazy.class, keyType));\n\n      default:\n        if (request.kind().frameworkClass.isPresent()) {\n          return wrapType(request.kind().frameworkClass.get(), keyType);\n        } else {\n          return keyType;\n        }\n    }\n  }\n\n  private DeclaredType wrapType(Class\u003c?\u003e wrapperType, TypeMirror wrappedType) {\n    return types.getDeclaredType(\n        elements.getTypeElement(wrapperType.getCanonicalName()), wrappedType);\n  }\n\n  private String formatKey(Key key) {\n    return formatKey(key.qualifier(), key.type());\n  }\n\n  private String formatKey(Optional\u003cAnnotationMirror\u003e qualifier, TypeMirror type) {\n    StringBuilder builder \u003d new StringBuilder();\n    if (qualifier.isPresent()) {\n      builder.append(qualifier.get()).append(\u0027 \u0027);\n    }\n    builder.append(type);\n    return builder.toString();\n  }\n\n  /**\n   * Returns the verb for a component method dependency request. Returns \"produced\", \"provided\", or\n   * \"injected\", depending on the kind of request.\n   */\n  private String componentMethodRequestVerb(DependencyRequest request) {\n    switch (request.kind()) {\n      case FUTURE:\n      case PRODUCER:\n        return \"produced\";\n\n      case INSTANCE:\n      case LAZY:\n      case PROVIDER:\n      case PROVIDER_OF_LAZY:\n        return \"provided\";\n\n      case MEMBERS_INJECTOR:\n        return \"injected\";\n\n      case PRODUCED:\n      default:\n        throw new AssertionError(\"illegal request kind for method: \" + request);\n    }\n  }\n\n  @CanIgnoreReturnValue\n  private StringBuilder appendEnclosingTypeAndMemberName(Element member, StringBuilder builder) {\n    TypeElement type \u003d MoreElements.asType(member.getEnclosingElement());\n    return builder\n        .append(type.getQualifiedName())\n        .append(\u0027.\u0027)\n        .append(member.getSimpleName());\n  }\n\n  /**\n   * Returns a string of the form \"{@code @BindsOptionalOf SomeKey is declared at Module.method()}\",\n   * where {@code Module.method()} is the declaration. If there is more than one such declaration,\n   * one is chosen arbitrarily, and \", among others\" is appended.\n   */\n  private String formatSyntheticOptionalBindingDependency(\n      ImmutableSet\u003cOptionalBindingDeclaration\u003e optionalBindingDeclarations) {\n    OptionalBindingDeclaration optionalBindingDeclaration \u003d\n        optionalBindingDeclarations.iterator().next();\n    StringBuilder builder \u003d new StringBuilder();\n    builder\n        .append(INDENT)\n        .append(\"@BindsOptionalOf \")\n        .append(formatKey(optionalBindingDeclaration.key()))\n        .append(\" is declared at\\n\")\n        .append(DOUBLE_INDENT);\n\n    appendEnclosingTypeAndMemberName(optionalBindingDeclaration.bindingElement().get(), builder);\n    builder.append(\"()\");\n    if (optionalBindingDeclarations.size() \u003e 1) {\n      builder.append(\", among others\");\n    }\n\n    return builder.toString();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\DependencyVariableNamer.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\n\nimport com.google.common.base.Ascii;\nimport com.google.common.base.CaseFormat;\nimport com.google.common.base.Function;\nimport dagger.Lazy;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.inject.Provider;\n\n/**\n * Picks a reasonable name for what we think is being provided from the variable name associated\n * with the {@link DependencyRequest}.  I.e. strips out words like \"lazy\" and \"provider\" if we\n * believe that those refer to {@link Lazy} and {@link Provider} rather than the type being\n * provided.\n *\n * @author Gregory Kick\n * @since 2.0\n */\n//TODO(gak): develop the heuristics to get better names\nfinal class DependencyVariableNamer implements Function\u003cDependencyRequest, String\u003e {\n  private static final Pattern LAZY_PROVIDER_PATTERN \u003d Pattern.compile(\"lazy(\\\\w+)Provider\");\n\n  @Override\n  public String apply(DependencyRequest dependency) {\n    if (dependency.overriddenVariableName().isPresent()) {\n      return dependency.overriddenVariableName().get();\n    }\n    checkArgument(dependency.requestElement().isPresent());\n    String variableName \u003d dependency.requestElement().get().getSimpleName().toString();\n    if (Ascii.isUpperCase(variableName.charAt(0))) {\n      variableName \u003d toLowerCamel(variableName);\n    }\n    switch (dependency.kind()) {\n      case INSTANCE:\n        return variableName;\n      case LAZY:\n        return variableName.startsWith(\"lazy\") \u0026\u0026 !variableName.equals(\"lazy\")\n            ? toLowerCamel(variableName.substring(4))\n            : variableName;\n      case PROVIDER_OF_LAZY:\n        Matcher matcher \u003d LAZY_PROVIDER_PATTERN.matcher(variableName);\n        if (matcher.matches()) {\n          return toLowerCamel(matcher.group(1));\n        }\n        // fall through\n      case PROVIDER:\n        return variableName.endsWith(\"Provider\") \u0026\u0026 !variableName.equals(\"Provider\")\n            ? variableName.substring(0, variableName.length() - 8)\n            : variableName;\n      case MEMBERS_INJECTOR:\n        return variableName.endsWith(\"MembersInjector\") \u0026\u0026 !variableName.equals(\"MembersInjector\")\n            ? variableName.substring(0, variableName.length() - 15)\n            : variableName;\n      case PRODUCED:\n        return variableName.startsWith(\"produced\") \u0026\u0026 !variableName.equals(\"produced\")\n            ? toLowerCamel(variableName.substring(8))\n            : variableName;\n      case PRODUCER:\n        return variableName.endsWith(\"Producer\") \u0026\u0026 !variableName.equals(\"Producer\")\n            ? variableName.substring(0, variableName.length() - 8)\n            : variableName;\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  private String toLowerCamel(String name) {\n    return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, name);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ErrorMessages.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentAnnotation;\nimport static dagger.internal.codegen.MoreAnnotationMirrors.simpleName;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport dagger.Multibindings;\nimport dagger.Provides;\nimport dagger.multibindings.Multibinds;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.TypeMirror;\n\n/**\n * The collection of error messages to be reported back to users.\n *\n * @author Gregory Kick\n * @since 2.0\n */\nfinal class ErrorMessages {\n  /*\n   * Common constants.\n   */\n  static final String INDENT \u003d \"    \";\n  static final String DOUBLE_INDENT \u003d INDENT + INDENT;\n  static final int DUPLICATE_SIZE_LIMIT \u003d 10;\n\n  /*\n   * JSR-330 errors\n   *\n   * These are errors that are explicitly outlined in the JSR-330 APIs\n   */\n\n  /* constructors */\n  static final String MULTIPLE_INJECT_CONSTRUCTORS \u003d\n      \"Types may only contain one @Inject constructor.\";\n\n  /* fields */\n  static final String FINAL_INJECT_FIELD \u003d \"@Inject fields may not be final\";\n\n  /* methods */\n  static final String ABSTRACT_INJECT_METHOD \u003d \"Methods with @Inject may not be abstract.\";\n  static final String GENERIC_INJECT_METHOD \u003d\n      \"Methods with @Inject may not declare type parameters.\";\n\n  /* qualifiers */\n  static final String MULTIPLE_QUALIFIERS \u003d\n      \"A single injection site may not use more than one @Qualifier.\";\n\n  /* scope */\n  static final String MULTIPLE_SCOPES \u003d \"A single binding may not declare more than one @Scope.\";\n\n  /*\n   * Dagger errors\n   *\n   * These are errors that arise due to restrictions imposed by the dagger implementation.\n   */\n\n  /* constructors */\n  static final String INJECT_ON_PRIVATE_CONSTRUCTOR \u003d\n      \"Dagger does not support injection into private constructors\";\n  static final String INJECT_CONSTRUCTOR_ON_INNER_CLASS \u003d\n      \"@Inject constructors are invalid on inner classes\";\n  static final String INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS \u003d\n      \"@Inject is nonsense on the constructor of an abstract class\";\n  static final String QUALIFIER_ON_INJECT_CONSTRUCTOR \u003d\n      \"@Qualifier annotations are not allowed on @Inject constructors.\";\n  static final String SCOPE_ON_INJECT_CONSTRUCTOR \u003d\n      \"@Scope annotations are not allowed on @Inject constructors. Annotate the class instead.\";\n  static final String CHECKED_EXCEPTIONS_ON_CONSTRUCTORS \u003d\n      \"Dagger does not support checked exceptions on @Inject constructors.\";\n\n  /* fields */\n  static final String PRIVATE_INJECT_FIELD \u003d\n      \"Dagger does not support injection into private fields\";\n\n  static final String STATIC_INJECT_FIELD \u003d\n      \"Dagger does not support injection into static fields\";\n\n  /* methods */\n  static final String PRIVATE_INJECT_METHOD \u003d\n      \"Dagger does not support injection into private methods\";\n\n  static final String STATIC_INJECT_METHOD \u003d\n      \"Dagger does not support injection into static methods\";\n\n  /* all */\n  static final String INJECT_INTO_PRIVATE_CLASS \u003d\n      \"Dagger does not support injection into private classes\";\n\n  static final String CANNOT_INJECT_WILDCARD_TYPE \u003d\n      \"Dagger does not support injecting Provider\u003cT\u003e, Lazy\u003cT\u003e or Produced\u003cT\u003e when T is a wildcard \"\n          + \"type such as \u003c%s\u003e.\";\n\n  /*\n   * Configuration errors\n   *\n   * These are errors that relate specifically to the Dagger configuration API (@Module, @Provides,\n   * etc.)\n   */\n  static final String DUPLICATE_BINDINGS_FOR_KEY_FORMAT \u003d\n      \"%s is bound multiple times:\";\n\n  static String duplicateMapKeysError(String key) {\n    return \"The same map key is bound more than once for \" + key;\n  }\n\n  static String inconsistentMapKeyAnnotationsError(String key) {\n    return key + \" uses more than one @MapKey annotation type\";\n  }\n\n  static final String COMPONENT_ANNOTATED_REUSABLE \u003d\n      \"@Reusable cannot be applied to components or subcomponents.\";\n\n  static final String BINDING_METHOD_RETURN_TYPE \u003d\n      \"@%s methods must return a primitive, an array, a type variable, or a declared type.\";\n\n  static final String BINDING_METHOD_THROWS_CHECKED \u003d\n      \"@%s methods may only throw unchecked exceptions\";\n\n  static final String PRODUCES_METHOD_NULLABLE \u003d\n      \"@Nullable on @Produces methods does not do anything.\";\n\n  static final String PRODUCES_METHOD_RETURN_TYPE \u003d\n      \"@Produces methods must return a primitive, an array, a type variable, or a declared type, \"\n          + \"or a ListenableFuture of one of those types.\";\n\n  static final String PRODUCES_METHOD_RAW_FUTURE \u003d\n      \"@Produces methods cannot return a raw ListenableFuture.\";\n\n  static final String BINDING_METHOD_SET_VALUES_RAW_SET \u003d\n      \"@%s methods of type set values cannot return a raw Set\";\n\n  static final String BINDS_ELEMENTS_INTO_SET_METHOD_RAW_SET_PARAMETER \u003d\n      \"@Binds @ElementsIntoSet methods cannot take a raw Set parameter\";\n\n  static final String BINDING_METHOD_SET_VALUES_RETURN_SET \u003d\n      \"@%s methods of type set values must return a Set\";\n\n  static final String PRODUCES_METHOD_SET_VALUES_RETURN_SET \u003d\n      \"@Produces methods of type set values must return a Set or ListenableFuture of Set\";\n\n  static final String PRODUCES_METHOD_SCOPE \u003d \"@Produces methods may not have scope annotations.\";\n\n  static final String BINDING_METHOD_THROWS \u003d\n      \"@%s methods may only throw unchecked exceptions or exceptions subclassing Exception\";\n\n  static final String BINDING_METHOD_THROWS_ANY \u003d \"@%s methods may not throw\";\n\n  static final String BINDING_METHOD_MUST_RETURN_A_VALUE \u003d\n      \"@%s methods must return a value (not void).\";\n\n  static final String BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES \u003d\n      \"@%s methods must not return framework types.\";\n\n  static final String BINDING_METHOD_ABSTRACT \u003d \"@%s methods cannot be abstract\";\n\n  static final String BINDING_METHOD_NOT_ABSTRACT \u003d \"@%s methods must be abstract\";\n\n  static final String BINDING_METHOD_PRIVATE \u003d \"@%s methods cannot be private\";\n\n  static final String BINDING_METHOD_TYPE_PARAMETER \u003d\n      \"@%s methods may not have type parameters.\";\n\n  // TODO(ronshapiro): clarify this error message for @ElementsIntoSet cases, where the\n  // right-hand-side might not be assignable to the left-hand-side, but still compatible with\n  // Set.addAll(Collection\u003c? extends E\u003e)\n  static final String BINDS_METHOD_ONE_ASSIGNABLE_PARAMETER \u003d\n      \"@Binds methods must have only one parameter whose type is assignable to the return type\";\n\n  static final String BINDS_OPTIONAL_OF_METHOD_HAS_PARAMETER \u003d\n      \"@BindsOptionalOf methods must not have parameters\";\n\n  static final String BINDS_OPTIONAL_OF_METHOD_RETURNS_IMPLICITLY_PROVIDED_TYPE \u003d\n      \"@BindsOptionalOf methods cannot \"\n          + \"return unqualified types that have an @Inject-annotated constructor because those are \"\n          + \"always present\";\n\n  static final String BINDING_METHOD_NOT_IN_MODULE \u003d \"@%s methods can only be present within a @%s\";\n\n  static final String BINDS_ELEMENTS_INTO_SET_METHOD_RETURN_SET \u003d\n      \"@Binds @ElementsIntoSet methods must return a Set and take a Set parameter\";\n\n  static final String BINDING_METHOD_NOT_MAP_HAS_MAP_KEY \u003d\n      \"@%s methods of non map type cannot declare a map key\";\n\n  static final String BINDING_METHOD_WITH_NO_MAP_KEY \u003d\n      \"@%s methods of type map must declare a map key\";\n\n  static final String BINDING_METHOD_WITH_MULTIPLE_MAP_KEYS \u003d\n      \"@%s methods may not have more than one @MapKey-marked annotation\";\n\n  static final String BINDING_METHOD_WITH_SAME_NAME \u003d\n      \"Cannot have more than one @%s method with the same name in a single module\";\n\n  static final String INCOMPATIBLE_MODULE_METHODS \u003d\n      \"A @%1$s may not contain both non-static @%2$s methods and abstract @Binds or @Multibinds \"\n          + \"declarations\";\n\n  static final String MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT \u003d\n      \"Modules with type parameters must be abstract\";\n\n  static final String REFERENCED_MODULE_NOT_ANNOTATED \u003d\n      \"%s is listed as a module, but is not annotated with %s\";\n\n  static final String REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS \u003d\n      \"%s is listed as a module, but has type parameters\";\n\n  static final String PROVIDES_METHOD_OVERRIDES_ANOTHER \u003d\n      \"@%s methods may not override another method. Overrides: %s\";\n\n  static final String METHOD_OVERRIDES_PROVIDES_METHOD \u003d\n      \"@%s methods may not be overridden in modules. Overrides: %s\";\n\n  static final String BINDING_METHOD_MULTIPLE_QUALIFIERS \u003d\n      \"Cannot use more than one @Qualifier\";\n\n  /* mapKey errors*/\n  static final String MAPKEY_WITHOUT_MEMBERS \u003d\n      \"Map key annotations must have members\";\n\n  static final String UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS\u003d\n      \"Map key annotations with unwrapped values must have exactly one member\";\n\n  static final String UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER \u003d\n      \"Map key annotations with unwrapped values cannot use arrays\";\n\n  /* collection binding errors */\n  static final String MULTIPLE_CONTRIBUTION_TYPES_FOR_KEY_FORMAT \u003d\n      \"%s has incompatible bindings or declarations:\\n\";\n\n  static final String PROVIDER_ENTRY_POINT_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT \u003d\n      \"%s is a provision entry-point, which cannot depend on a production.\";\n\n  static final String PROVIDER_MAY_NOT_DEPEND_ON_PRODUCER_FORMAT \u003d\n      \"%s is a provision, which cannot depend on a production.\";\n\n  static final String DEPENDS_ON_PRODUCTION_EXECUTOR_FORMAT \u003d\n      \"%s may not depend on the production executor.\";\n\n  static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_FORMAT \u003d\n      \"%s cannot be provided without an @Inject constructor or from an @Provides-annotated method.\";\n\n  static final String REQUIRES_PROVIDER_FORMAT \u003d\n      \"%s cannot be provided without an @Provides-annotated method.\";\n\n  static final String REQUIRES_AT_INJECT_CONSTRUCTOR_OR_PROVIDER_OR_PRODUCER_FORMAT \u003d\n      \"%s cannot be provided without an @Inject constructor or from an @Provides- or \"\n      + \"@Produces-annotated method.\";\n\n  static final String REQUIRES_PROVIDER_OR_PRODUCER_FORMAT \u003d\n      \"%s cannot be provided without an @Provides- or @Produces-annotated method.\";\n\n  private static final String PROVISION_MAY_NOT_DEPEND_ON_PRODUCER_TYPE_FORMAT \u003d\n      \"%s may only be injected in @Produces methods.\";\n\n  static String provisionMayNotDependOnProducerType(TypeMirror type) {\n    return String.format(\n        PROVISION_MAY_NOT_DEPEND_ON_PRODUCER_TYPE_FORMAT,\n        MoreTypes.asTypeElement(type).getSimpleName());\n  }\n\n  static final String MEMBERS_INJECTION_DOES_NOT_IMPLY_PROVISION \u003d\n      \"This type supports members injection but cannot be implicitly provided.\";\n\n  static final String MEMBERS_INJECTION_WITH_RAW_TYPE \u003d\n      \"%s has type parameters, cannot members inject the raw type. via:\\n%s\";\n\n  static final String MEMBERS_INJECTION_WITH_UNBOUNDED_TYPE \u003d\n      \"Type parameters must be bounded for members injection. %s required by %s, via:\\n%s\";\n\n  static final String CONTAINS_DEPENDENCY_CYCLE_FORMAT \u003d \"%s.%s() contains a dependency cycle:\\n%s\";\n\n  static String nullableToNonNullable(String typeName, String bindingString) {\n    return String.format(\n            \"%s is not nullable, but is being provided by %s\",\n            typeName,\n            bindingString);\n  }\n\n  static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD \u003d\n      \"Cannot return null from a non-@Nullable component method\";\n\n  static final String CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD \u003d\n      \"Cannot return null from a non-@Nullable @Provides method\";\n\n  /* Multibinding messages */\n  static final String MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD \u003d\n      \"Multibinding annotations may only be on @Provides, @Produces, or @Binds methods\";\n\n  static final String MULTIPLE_MULTIBINDING_ANNOTATIONS_ON_METHOD \u003d\n      \"Multiple multibinding annotations cannot be placed on the same %s method\";\n\n  static final String MULTIBINDING_ANNOTATION_CONFLICTS_WITH_BINDING_ANNOTATION_ENUM \u003d\n      \"@%s.type cannot be used with multibinding annotations\";\n\n  static ComponentBuilderMessages builderMsgsFor(ComponentDescriptor.Kind kind) {\n    switch(kind) {\n      case COMPONENT:\n        return ComponentBuilderMessages.INSTANCE;\n      case SUBCOMPONENT:\n        return SubcomponentBuilderMessages.INSTANCE;\n      case PRODUCTION_COMPONENT:\n        return ProductionComponentBuilderMessages.INSTANCE;\n      case PRODUCTION_SUBCOMPONENT:\n        return ProductionSubcomponentBuilderMessages.INSTANCE;\n      default:\n        throw new IllegalStateException(kind.toString());\n    }\n  }\n\n  static class ComponentBuilderMessages {\n    static final ComponentBuilderMessages INSTANCE \u003d new ComponentBuilderMessages();\n\n    protected String process(String s) { return s; }\n\n    /** Errors for component builders. */\n    final String moreThanOne() {\n      return process(\"@Component has more than one @Component.Builder: %s\");\n    }\n\n    final String cxtorOnlyOneAndNoArgs() {\n      return process(\"@Component.Builder classes must have exactly one constructor,\"\n          + \" and it must not have any parameters\");\n    }\n\n    final String generics() {\n      return process(\"@Component.Builder types must not have any generic types\");\n    }\n\n    final String mustBeInComponent() {\n      return process(\"@Component.Builder types must be nested within a @Component\");\n    }\n\n    final String mustBeClassOrInterface() {\n      return process(\"@Component.Builder types must be abstract classes or interfaces\");\n    }\n\n    final String isPrivate() {\n      return process(\"@Component.Builder types must not be private\");\n    }\n\n    final String mustBeStatic() {\n      return process(\"@Component.Builder types must be static\");\n    }\n\n    final String mustBeAbstract() {\n      return process(\"@Component.Builder types must be abstract\");\n    }\n\n    final String missingBuildMethod() {\n      return process(\"@Component.Builder types must have exactly one no-args method that \"\n          + \" returns the @Component type\");\n    }\n\n    final String manyMethodsForType() {\n      return process(\"@Component.Builder types must not have more than one setter method per type,\"\n          + \" but %s is set by %s\");\n    }\n\n    final String extraSetters() {\n      return process(\n          \"@Component.Builder has setters for modules or components that aren\u0027t required: %s\");\n    }\n\n    final String missingSetters() {\n      return process(\n          \"@Component.Builder is missing setters for required modules or components: %s\");\n    }\n\n    final String twoBuildMethods() {\n      return process(\"@Component.Builder types must have exactly one zero-arg method, and that\"\n          + \" method must return the @Component type. Already found: %s\");\n    }\n\n    final String inheritedTwoBuildMethods() {\n      return process(\"@Component.Builder types must have exactly one zero-arg method, and that\"\n          + \" method must return the @Component type. Found %s and %s\");\n    }\n\n    final String buildMustReturnComponentType() {\n      return process(\n          \"@Component.Builder methods that have no arguments must return the @Component type\");\n    }\n\n    final String inheritedBuildMustReturnComponentType() {\n      return process(\n          \"@Component.Builder methods that have no arguments must return the @Component type\"\n          + \" Inherited method: %s\");\n    }\n\n    final String methodsMustTakeOneArg() {\n      return process(\"@Component.Builder methods must not have more than one argument\");\n    }\n\n    final String inheritedMethodsMustTakeOneArg() {\n      return process(\n          \"@Component.Builder methods must not have more than one argument. Inherited method: %s\");\n    }\n\n    final String methodsMustReturnVoidOrBuilder() {\n      return process(\"@Component.Builder setter methods must return void, the builder,\"\n          + \" or a supertype of the builder\");\n    }\n\n    final String inheritedMethodsMustReturnVoidOrBuilder() {\n      return process(\"@Component.Builder setter methods must return void, the builder,\"\n          + \"or a supertype of the builder. Inherited method: %s\");\n    }\n\n    final String methodsMayNotHaveTypeParameters() {\n      return process(\"@Component.Builder methods must not have type parameters\");\n    }\n\n    final String inheritedMethodsMayNotHaveTypeParameters() {\n      return process(\n          \"@Component.Builder methods must not have type parameters. Inherited method: %s\");\n    }\n  }\n\n  static final class SubcomponentBuilderMessages extends ComponentBuilderMessages {\n    @SuppressWarnings(\"hiding\")\n    static final SubcomponentBuilderMessages INSTANCE \u003d new SubcomponentBuilderMessages();\n\n    @Override protected String process(String s) {\n      return s.replaceAll(\"component\", \"subcomponent\").replaceAll(\"Component\", \"Subcomponent\");\n    }\n\n    String builderMethodRequiresNoArgs() {\n      return \"Methods returning a @Subcomponent.Builder must have no arguments\";\n    }\n\n    String moreThanOneRefToSubcomponent() {\n      return \"Only one method can create a given subcomponent. %s is created by: %s\";\n    }\n  }\n\n  private static final class ProductionComponentBuilderMessages extends ComponentBuilderMessages {\n    @SuppressWarnings(\"hiding\")\n    static final ProductionComponentBuilderMessages INSTANCE \u003d\n        new ProductionComponentBuilderMessages();\n\n    @Override protected String process(String s) {\n      return s.replaceAll(\"component\", \"production component\")\n          .replaceAll(\"Component\", \"ProductionComponent\");\n    }\n  }\n\n  private static final class ProductionSubcomponentBuilderMessages\n      extends ComponentBuilderMessages {\n    @SuppressWarnings(\"hiding\")\n    static final ProductionSubcomponentBuilderMessages INSTANCE \u003d\n        new ProductionSubcomponentBuilderMessages();\n\n    @Override\n    protected String process(String s) {\n      return s.replaceAll(\"component\", \"production subcomponent\")\n          .replaceAll(\"Component\", \"ProductionSubcomponent\");\n    }\n  }\n\n  /** Error messages related to {@link Multibindings @Multibindings}. */\n  static final class MultibindingsMessages {\n    static final String MUST_BE_INTERFACE \u003d \"@Multibindings can be applied only to interfaces\";\n\n    static final String MUST_NOT_HAVE_TYPE_PARAMETERS \u003d\n        \"@Multibindings types must not have type parameters\";\n\n    static final String MUST_BE_IN_MODULE \u003d\n        \"@Multibindings types must be nested within a @Module or @ProducerModule\";\n\n    static String tooManyMethodsForKey(String formattedKey) {\n      return String.format(\n          \"Too many @Multibindings methods for %s\", stripCommonTypePrefixes(formattedKey));\n    }\n\n    private MultibindingsMessages() {}\n  }\n\n  /**\n   * Error messages related to {@link Multibinds @Multibinds} methods and methods in\n   * {@link Multibindings} interfaces.\n   */\n  static final class MultibindsMessages {\n    static final String METHOD_MUST_RETURN_MAP_OR_SET \u003d\n        \"@%s methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\";\n\n    static final String PARAMETERS \u003d \"@%s methods cannot have parameters\";\n\n    private MultibindsMessages() {}\n  }\n\n  static class ModuleMessages {\n    static String moduleSubcomponentsIncludesBuilder(TypeElement moduleSubcomponentsAttribute) {\n      TypeElement subcomponentType \u003d\n          MoreElements.asType(moduleSubcomponentsAttribute.getEnclosingElement());\n      return String.format(\n          \"%s is a @%s.Builder. Did you mean to use %s?\",\n          moduleSubcomponentsAttribute.getQualifiedName(),\n          simpleName(getSubcomponentAnnotation(subcomponentType).get()),\n          subcomponentType.getQualifiedName());\n    }\n\n    static String moduleSubcomponentsIncludesNonSubcomponent(\n        TypeElement moduleSubcomponentsAttribute) {\n      return moduleSubcomponentsAttribute.getQualifiedName()\n          + \" is not a @Subcomponent or @ProductionSubcomponent\";\n    }\n\n    static String moduleSubcomponentsDoesntHaveBuilder(\n        TypeElement subcomponent, AnnotationMirror moduleAnnotation) {\n      return String.format(\n          \"%s doesn\u0027t have a @%s.Builder, which is required when used with @%s.subcomponents\",\n          subcomponent.getQualifiedName(),\n          simpleName(getSubcomponentAnnotation(subcomponent).get()),\n          simpleName(moduleAnnotation));\n    }\n  }\n\n  /**\n   * A regular expression to match a small list of specific packages deemed to\n   * be unhelpful to display in fully qualified types in error messages.\n   *\n   * Note: This should never be applied to messages themselves.\n   */\n  private static final Pattern COMMON_PACKAGE_PATTERN \u003d Pattern.compile(\n      \"(?:^|[^.a-z_])\"     // What we want to match on but not capture.\n      + \"((?:\"             // Start a group with a non-capturing or part\n      + \"java[.]lang\"\n      + \"|java[.]util\"\n      + \"|javax[.]inject\"\n      + \"|dagger\"\n      + \"|com[.]google[.]common[.]base\"\n      + \"|com[.]google[.]common[.]collect\"\n      + \")[.])\"            // Always end with a literal .\n      + \"[A-Z]\");           // What we want to match on but not capture.\n\n  /**\n   * A method to strip out common packages and a few rare type prefixes\n   * from types\u0027 string representation before being used in error messages.\n   *\n   * This type assumes a String value that is a valid fully qualified\n   * (and possibly parameterized) type, and should NOT be used with\n   * arbitrary text, especially prose error messages.\n   *\n   * TODO(cgruber): Tighten these to take type representations (mirrors\n   *     and elements) to avoid accidental mis-use by running errors\n   *     through this method.\n   */\n  static String stripCommonTypePrefixes(String type) {\n    // Special case this enum\u0027s constants since they will be incredibly common.\n    type \u003d type.replace(Provides.Type.class.getCanonicalName() + \".\", \"\");\n\n    // Do regex magic to remove common packages we care to shorten.\n    Matcher matcher \u003d COMMON_PACKAGE_PATTERN.matcher(type);\n    StringBuilder result \u003d new StringBuilder();\n    int index \u003d 0;\n    while (matcher.find()) {\n      result.append(type.subSequence(index, matcher.start(1)));\n      index \u003d matcher.end(1); // Skip the matched pattern content.\n    }\n    result.append(type.subSequence(index, type.length()));\n    return result.toString();\n  }\n\n  //TODO(cgruber): Extract Formatter and do something less stringy.\n  static String format(AnnotationMirror annotation) {\n    return stripCommonTypePrefixes(annotation.toString());\n  }\n\n  private ErrorMessages() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\FactoryGenerator.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.squareup.javapoet.MethodSpec.constructorBuilder;\nimport static com.squareup.javapoet.MethodSpec.methodBuilder;\nimport static com.squareup.javapoet.TypeSpec.classBuilder;\nimport static com.squareup.javapoet.TypeSpec.enumBuilder;\nimport static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;\nimport static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;\nimport static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;\nimport static dagger.internal.codegen.ContributionBinding.FactoryCreationStrategy.ENUM_INSTANCE;\nimport static dagger.internal.codegen.ContributionBinding.Kind.INJECTION;\nimport static dagger.internal.codegen.ContributionBinding.Kind.PROVISION;\nimport static dagger.internal.codegen.ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD;\nimport static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;\nimport static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;\nimport static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;\nimport static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;\nimport static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;\nimport static dagger.internal.codegen.TypeNames.factoryOf;\nimport static javax.lang.model.element.Modifier.FINAL;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.element.Modifier.PUBLIC;\nimport static javax.lang.model.element.Modifier.STATIC;\n\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Lists;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport com.squareup.javapoet.FieldSpec;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.ParameterSpec;\nimport com.squareup.javapoet.ParameterizedTypeName;\nimport com.squareup.javapoet.TypeName;\nimport com.squareup.javapoet.TypeSpec;\nimport com.squareup.javapoet.TypeVariableName;\nimport dagger.internal.Factory;\nimport dagger.internal.MembersInjectors;\nimport dagger.internal.Preconditions;\nimport java.util.List;\nimport java.util.Map;\nimport javax.annotation.processing.Filer;\nimport javax.inject.Inject;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.util.Elements;\nimport javax.tools.Diagnostic;\n\n/**\n * Generates {@link Factory} implementations from {@link ProvisionBinding} instances for\n * {@link Inject} constructors.\n *\n * @author Gregory Kick\n * @since 2.0\n */\nfinal class FactoryGenerator extends SourceFileGenerator\u003cProvisionBinding\u003e {\n\n  private final CompilerOptions compilerOptions;\n  private final InjectValidator injectValidator;\n\n  FactoryGenerator(\n      Filer filer,\n      Elements elements,\n      CompilerOptions compilerOptions,\n      InjectValidator injectValidator) {\n    super(filer, elements);\n    this.compilerOptions \u003d compilerOptions;\n    this.injectValidator \u003d injectValidator;\n  }\n\n  @Override\n  ClassName nameGeneratedType(ProvisionBinding binding) {\n    return generatedClassNameForBinding(binding);\n  }\n\n  @Override\n  Optional\u003c? extends Element\u003e getElementForErrorReporting(ProvisionBinding binding) {\n    return binding.bindingElement();\n  }\n\n  @Override\n  Optional\u003cTypeSpec.Builder\u003e write(ClassName generatedTypeName, ProvisionBinding binding) {\n    // We don\u0027t want to write out resolved bindings -- we want to write out the generic version.\n    checkArgument(!binding.unresolved().isPresent());\n    checkArgument(binding.bindingElement().isPresent());\n\n    if (binding.bindingKind().equals(INJECTION)\n        \u0026\u0026 !injectValidator.isValidType(binding.factoryType())) {\n      return Optional.absent();\n    }\n\n    TypeName providedTypeName \u003d TypeName.get(binding.factoryType());\n    ParameterizedTypeName parameterizedFactoryName \u003d factoryOf(providedTypeName);\n    Optional\u003cParameterizedTypeName\u003e factoryOfRawTypeName \u003d Optional.absent();\n    TypeSpec.Builder factoryBuilder;\n    Optional\u003cMethodSpec.Builder\u003e constructorBuilder \u003d Optional.absent();\n    ImmutableList\u003cTypeVariableName\u003e typeParameters \u003d bindingTypeElementTypeVariableNames(binding);\n    UniqueNameSet uniqueFieldNames \u003d new UniqueNameSet();\n    ImmutableMap.Builder\u003cBindingKey, FieldSpec\u003e fieldsBuilder \u003d ImmutableMap.builder();\n\n    boolean useRawType \u003d\n        binding.factoryCreationStrategy() \u003d\u003d ENUM_INSTANCE\n            \u0026\u0026 binding.bindingKind() \u003d\u003d INJECTION\n            \u0026\u0026 !typeParameters.isEmpty();\n    switch (binding.factoryCreationStrategy()) {\n      case ENUM_INSTANCE:\n        factoryBuilder \u003d enumBuilder(generatedTypeName.simpleName()).addEnumConstant(\"INSTANCE\");\n        // If we have type parameters, then remove the parameters from our providedTypeName,\n        // since we\u0027ll be implementing an erased version of it.\n        if (useRawType) {\n          factoryBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);\n          // TODO(ronshapiro): instead of reassigning, introduce an optional/second parameter\n          providedTypeName \u003d ((ParameterizedTypeName) providedTypeName).rawType;\n          factoryOfRawTypeName \u003d Optional.of(factoryOf(providedTypeName));\n        }\n        break;\n      case CLASS_CONSTRUCTOR:\n        factoryBuilder \u003d\n            classBuilder(generatedTypeName).addTypeVariables(typeParameters).addModifiers(FINAL);\n        constructorBuilder \u003d Optional.of(constructorBuilder().addModifiers(PUBLIC));\n        if (binding.requiresModuleInstance()) {\n          addConstructorParameterAndTypeField(\n              TypeName.get(binding.bindingTypeElement().get().asType()),\n              \"module\",\n              factoryBuilder,\n              constructorBuilder.get());\n        }\n        for (Map.Entry\u003cBindingKey, FrameworkField\u003e entry :\n            generateBindingFieldsForDependencies(binding).entrySet()) {\n          BindingKey bindingKey \u003d entry.getKey();\n          FrameworkField bindingField \u003d entry.getValue();\n          FieldSpec field \u003d\n              addConstructorParameterAndTypeField(\n                  bindingField.type(),\n                  uniqueFieldNames.getUniqueName(bindingField.name()),\n                  factoryBuilder,\n                  constructorBuilder.get());\n          fieldsBuilder.put(bindingKey, field);\n        }\n        break;\n      case DELEGATE:\n        return Optional.absent();\n      default:\n        throw new AssertionError();\n    }\n    ImmutableMap\u003cBindingKey, FieldSpec\u003e fields \u003d fieldsBuilder.build();\n\n    factoryBuilder\n        .addModifiers(PUBLIC)\n        .addSuperinterface(factoryOfRawTypeName.or(parameterizedFactoryName));\n\n    // If constructing a factory for @Inject or @Provides bindings, we use a static create method\n    // so that generated components can avoid having to refer to the generic types\n    // of the factory.  (Otherwise they may have visibility problems referring to the types.)\n    Optional\u003cMethodSpec\u003e createMethod;\n    switch(binding.bindingKind()) {\n      case INJECTION:\n      case PROVISION:\n        // The return type is usually the same as the implementing type, except in the case\n        // of enums with type variables (where we cast).\n        MethodSpec.Builder createMethodBuilder \u003d\n            methodBuilder(\"create\")\n                .addModifiers(PUBLIC, STATIC)\n                .returns(parameterizedFactoryName);\n        if (binding.factoryCreationStrategy() !\u003d ENUM_INSTANCE\n            || binding.bindingKind() \u003d\u003d INJECTION) {\n          createMethodBuilder.addTypeVariables(typeParameters);\n        }\n        List\u003cParameterSpec\u003e params \u003d\n            constructorBuilder.isPresent()\n                ? constructorBuilder.get().build().parameters : ImmutableList.\u003cParameterSpec\u003eof();\n        createMethodBuilder.addParameters(params);\n        switch (binding.factoryCreationStrategy()) {\n          case ENUM_INSTANCE:\n            if (!useRawType) {\n              createMethodBuilder.addStatement(\"return INSTANCE\");\n            } else {\n              // We use an unsafe cast here because the types are different.\n              // It\u0027s safe because the type is never referenced anywhere.\n              createMethodBuilder.addStatement(\"return ($T) INSTANCE\", TypeNames.FACTORY);\n              createMethodBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);\n            }\n            break;\n\n          case CLASS_CONSTRUCTOR:\n            createMethodBuilder.addStatement(\n                \"return new $T($L)\",\n                parameterizedGeneratedTypeNameForBinding(binding),\n                makeParametersCodeBlock(\n                    Lists.transform(params, input -\u003e CodeBlock.of(\"$N\", input))));\n            break;\n          default:\n            throw new AssertionError();\n        }\n        createMethod \u003d Optional.of(createMethodBuilder.build());\n        break;\n      default:\n        createMethod \u003d Optional.absent();\n    }\n\n    if (constructorBuilder.isPresent()) {\n      factoryBuilder.addMethod(constructorBuilder.get().build());\n    }\n\n    List\u003cCodeBlock\u003e parameters \u003d Lists.newArrayList();\n    for (DependencyRequest dependency : binding.dependencies()) {\n      parameters.add(\n          frameworkTypeUsageStatement(\n              CodeBlock.of(\"$N\", fields.get(dependency.bindingKey())), dependency.kind()));\n    }\n    CodeBlock parametersCodeBlock \u003d makeParametersCodeBlock(parameters);\n\n    MethodSpec.Builder getMethodBuilder \u003d\n        methodBuilder(\"get\")\n            .returns(providedTypeName)\n            .addAnnotation(Override.class)\n            .addModifiers(PUBLIC);\n\n    if (binding.bindingKind().equals(PROVISION)) {\n      CodeBlock.Builder providesMethodInvocationBuilder \u003d CodeBlock.builder();\n      if (binding.requiresModuleInstance()) {\n        providesMethodInvocationBuilder.add(\"module\");\n      } else {\n        providesMethodInvocationBuilder.add(\n            \"$T\", ClassName.get(binding.bindingTypeElement().get()));\n      }\n      providesMethodInvocationBuilder.add(\n          \".$L($L)\", binding.bindingElement().get().getSimpleName(), parametersCodeBlock);\n      CodeBlock providesMethodInvocation \u003d providesMethodInvocationBuilder.build();\n\n      if (binding.nullableType().isPresent()\n          || compilerOptions.nullableValidationKind().equals(Diagnostic.Kind.WARNING)) {\n        if (binding.nullableType().isPresent()) {\n          getMethodBuilder.addAnnotation((ClassName) TypeName.get(binding.nullableType().get()));\n        }\n        getMethodBuilder.addStatement(\"return $L\", providesMethodInvocation);\n      } else {\n        getMethodBuilder.addStatement(\"return $T.checkNotNull($L, $S)\",\n            Preconditions.class,\n            providesMethodInvocation,\n            CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);\n      }\n    } else if (binding.membersInjectionRequest().isPresent()) {\n      getMethodBuilder.addStatement(\n          \"return $T.injectMembers($N, new $T($L))\",\n          MembersInjectors.class,\n          fields.get(binding.membersInjectionRequest().get().bindingKey()),\n          providedTypeName,\n          parametersCodeBlock);\n    } else {\n      getMethodBuilder.addStatement(\"return new $T($L)\", providedTypeName, parametersCodeBlock);\n    }\n\n    factoryBuilder.addMethod(getMethodBuilder.build());\n    if (createMethod.isPresent()) {\n      factoryBuilder.addMethod(createMethod.get());\n    }\n\n    // TODO(gak): write a sensible toString\n    return Optional.of(factoryBuilder);\n  }\n\n  @CanIgnoreReturnValue\n  private FieldSpec addConstructorParameterAndTypeField(\n      TypeName typeName,\n      String variableName,\n      TypeSpec.Builder factoryBuilder,\n      MethodSpec.Builder constructorBuilder) {\n    FieldSpec field \u003d FieldSpec.builder(typeName, variableName, PRIVATE, FINAL).build();\n    factoryBuilder.addField(field);\n    ParameterSpec parameter \u003d ParameterSpec.builder(typeName, variableName).build();\n    constructorBuilder.addParameter(parameter);\n    constructorBuilder.addCode(\"assert $1N !\u003d null; this.$2N \u003d $1N;\", parameter, field);\n    return field;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\FeatureStatus.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\n/** Allows options to control how features in component processing are enabled. */\nenum FeatureStatus {\n  ENABLED,\n  DISABLED;\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\Formatter.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkElementIndex;\nimport static dagger.internal.codegen.ErrorMessages.INDENT;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.Iterables;\n\n/**\n * A formatter which transforms an instance of a particular type into a string\n * representation.\n *\n * @param \u003cT\u003e the type of the object to be transformed.\n * @author Christian Gruber\n * @since 2.0\n */\nabstract class Formatter\u003cT\u003e implements Function\u003cT, String\u003e {\n\n  /**\n   * Performs the transformation of an object into a string representation.\n   */\n  public abstract String format(T object);\n\n  /**\n   * Performs the transformation of an object into a string representation in\n   * conformity with the {@link Function}{@code \u003cT, String\u003e} contract, delegating\n   * to {@link #format(Object)}.\n   *\n   * @deprecated Call {@link #format(T)} instead.  This method exists to make\n   * formatters easy to use when functions are required, but shouldn\u0027t be called directly.\n   */\n  @SuppressWarnings(\"javadoc\")\n  @Deprecated\n  @Override final public String apply(T object) {\n    return format(object);\n  }\n\n  /**\n   * Formats {@code items}, one per line. Stops after {@code limit} items.\n   */\n  public void formatIndentedList(\n      StringBuilder builder, Iterable\u003c? extends T\u003e items, int indentLevel, int limit) {\n    formatIndentedList(\n        builder, indentLevel, Iterables.limit(items, limit), Iterables.skip(items, limit));\n  }\n\n  private void formatIndentedList(\n      StringBuilder builder,\n      int indentLevel,\n      Iterable\u003c? extends T\u003e firstItems,\n      Iterable\u003c? extends T\u003e restOfItems) {\n    for (T item : firstItems) {\n      builder.append(\u0027\\n\u0027);\n      appendIndent(builder, indentLevel);\n      builder.append(format(item));\n    }\n    int numberOfOtherItems \u003d Iterables.size(restOfItems);\n    if (numberOfOtherItems \u003e 0) {\n      builder.append(\u0027\\n\u0027);\n      appendIndent(builder, indentLevel);\n      builder.append(\"and \").append(numberOfOtherItems).append(\" other\");\n    }\n    if (numberOfOtherItems \u003e 1) {\n      builder.append(\u0027s\u0027);\n    }\n  }\n\n  private void appendIndent(StringBuilder builder, int indentLevel) {\n    for (int i \u003d 0; i \u003c indentLevel; i++) {\n      builder.append(INDENT);\n    }\n  }\n\n  protected String formatArgumentInList(int index, int size, CharSequence name) {\n    checkElementIndex(index, size);\n    StringBuilder builder \u003d new StringBuilder();\n    if (index \u003e 0) {\n      builder.append(\"…, \");\n    }\n    builder.append(name);\n    if (index \u003c size - 1) {\n      builder.append(\", …\");\n    }\n    return builder.toString();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\FrameworkDependency.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.collect.Iterables.getOnlyElement;\n\nimport com.google.auto.value.AutoValue;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport javax.inject.Provider;\n\n/**\n * The framework class and binding key for a resolved dependency of a binding. If a binding has\n * several dependencies for a key, then only one instance of this class will represent them all.\n *\n * \u003cp\u003eIn the following example, the binding {@code provideFoo()} has two dependency requests:\n *\n * \u003col\u003e\n * \u003cli\u003e{@code Bar bar}\n * \u003cli\u003e{@code Provider\u003cBar\u003e barProvider}\n * \u003c/ol\u003e\n *\n * But they both can be satisfied with the same instance of {@code Provider\u003cBar\u003e}. So one instance\n * of {@code FrameworkDependency} will be used for both. Its {@link #bindingKey()} will be for\n * {@code Bar}, and its {@link #frameworkClass()} will be {@link Provider}.\n *\n * \u003cpre\u003e\u003ccode\u003e\n *   {@literal @Provides} static Foo provideFoo(Bar bar, {@literal Provider\u003cBar\u003e} barProvider) {\n *     return new Foo(…);\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n */\n@AutoValue\nabstract class FrameworkDependency {\n\n  /**\n   * The fully-resolved binding key shared by all the dependency requests.\n   */\n  abstract BindingKey bindingKey();\n\n  /** The binding type of the framework dependency. */\n  abstract BindingType bindingType();\n\n  /** The framework class to use for these requests. */\n  final Class\u003c?\u003e frameworkClass() {\n    return bindingType().frameworkClass();\n  }\n\n  /**\n   * The dependency requests that are all satisfied by one framework instance.\n   */\n  abstract ImmutableSet\u003cDependencyRequest\u003e dependencyRequests();\n\n  /**\n   * The framework dependencies of {@code binding}. There will be one element for each\n   * different binding key in the \u003cem\u003e{@linkplain Binding#unresolved() unresolved}\u003c/em\u003e version of\n   * {@code binding}.\n   *\n   * \u003cp\u003eFor example, given the following modules:\n   * \u003cpre\u003e\u003ccode\u003e\n   *   {@literal @Module} abstract class {@literal BaseModule\u003cT\u003e} {\n   *     {@literal @Provides} Foo provideFoo(T t, String string) {\n   *       return …;\n   *     }\n   *   }\n   *\n   *   {@literal @Module} class StringModule extends {@literal BaseModule\u003cString\u003e} {}\n   * \u003c/code\u003e\u003c/pre\u003e\n   *\n   * Both dependencies of {@code StringModule.provideFoo} have the same binding key:\n   * {@code String}. But there are still two dependencies, because in the unresolved binding they\n   * have different binding keys:\n   *\n   * \u003cdl\u003e\n   * \u003cdt\u003e{@code T} \u003cdd\u003e{@code String t}\n   * \u003cdt\u003e{@code String} \u003cdd\u003e{@code String string}\n   * \u003c/dl\u003e\n   * \n   * \u003cp\u003eNote that the sets returned by this method when called on the same binding will be equal,\n   * and their elements will be in the same order.\n   */\n  /* TODO(dpb): The stable-order postcondition is actually hard to verify in code for two equal\n   * instances of Binding, because it really depends on the order of the binding\u0027s dependencies,\n   * and two equal instances of Binding may have the same dependencies in a different order. */\n  static ImmutableSet\u003cFrameworkDependency\u003e frameworkDependenciesForBinding(Binding binding) {\n    BindingTypeMapper bindingTypeMapper \u003d\n        BindingTypeMapper.forBindingType(binding.bindingType());\n    ImmutableSet.Builder\u003cFrameworkDependency\u003e frameworkDependencies \u003d ImmutableSet.builder();\n    for (Collection\u003cDependencyRequest\u003e requests : groupByUnresolvedKey(binding)) {\n      frameworkDependencies.add(\n          new AutoValue_FrameworkDependency(\n              getOnlyElement(\n                  FluentIterable.from(requests).transform(DependencyRequest::bindingKey).toSet()),\n              bindingTypeMapper.getBindingType(requests),\n              ImmutableSet.copyOf(requests)));\n    }\n    return frameworkDependencies.build();\n  }\n\n  /** Indexes {@code dependencies} by their {@link #dependencyRequests()}. */\n  static ImmutableMap\u003cDependencyRequest, FrameworkDependency\u003e indexByDependencyRequest(\n      Iterable\u003cFrameworkDependency\u003e dependencies) {\n    ImmutableMap.Builder\u003cDependencyRequest, FrameworkDependency\u003e frameworkDependencyMap \u003d\n        ImmutableMap.builder();\n    for (FrameworkDependency dependency : dependencies) {\n      for (DependencyRequest request : dependency.dependencyRequests()) {\n        frameworkDependencyMap.put(request, dependency);\n      }\n    }\n    return frameworkDependencyMap.build();\n  }\n\n  /**\n   * Groups {@code binding}\u0027s implicit dependencies by their binding key, using the dependency keys\n   * from the {@link Binding#unresolved()} binding if it exists.\n   */\n  private static ImmutableList\u003cCollection\u003cDependencyRequest\u003e\u003e groupByUnresolvedKey(\n      Binding binding) {\n    ImmutableSetMultimap.Builder\u003cBindingKey, DependencyRequest\u003e dependenciesByKeyBuilder \u003d\n        ImmutableSetMultimap.builder();\n    Iterator\u003cDependencyRequest\u003e dependencies \u003d binding.implicitDependencies().iterator();\n    Binding unresolved \u003d binding.unresolved().isPresent() ? binding.unresolved().get() : binding;\n    Iterator\u003cDependencyRequest\u003e unresolvedDependencies \u003d\n        unresolved.implicitDependencies().iterator();\n    while (dependencies.hasNext()) {\n      dependenciesByKeyBuilder.put(unresolvedDependencies.next().bindingKey(), dependencies.next());\n    }\n    return ImmutableList.copyOf(\n        dependenciesByKeyBuilder\n            .orderValuesBy(SourceFiles.DEPENDENCY_ORDERING)\n            .build()\n            .asMap()\n            .values());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\FrameworkField.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.CaseFormat;\nimport com.google.common.base.Optional;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.ParameterizedTypeName;\nimport com.squareup.javapoet.TypeName;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ElementVisitor;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.ElementKindVisitor6;\n\n/**\n * A value object that represents a field in the generated Component class.\n *\n * \u003cp\u003eExamples:\n * \u003cul\u003e\n *   \u003cli\u003e{@code Provider\u003cString\u003e}\n *   \u003cli\u003e{@code Producer\u003cWidget\u003e}\n *   \u003cli\u003e{@code Provider\u003cMap\u003cSomeMapKey, MapValue\u003e\u003e}.\n * \u003c/ul\u003e\n *\n * @author Jesse Beder\n * @since 2.0\n */\n@AutoValue\nabstract class FrameworkField {\n\n  /**\n   * Creates a framework field.\n   * \n   * @param frameworkClassName the name of the framework class (e.g., {@link javax.inject.Provider})\n   * @param valueTypeName the name of the type parameter of the framework class (e.g., {@code Foo}\n   *     for {@code Provider\u003cFoo\u003e}\n   * @param fieldName the name of the field\n   */\n  static FrameworkField create(\n      ClassName frameworkClassName, TypeName valueTypeName, String fieldName) {\n    String suffix \u003d frameworkClassName.simpleName();\n    return new AutoValue_FrameworkField(\n        ParameterizedTypeName.get(frameworkClassName, valueTypeName),\n        fieldName.endsWith(suffix) ? fieldName : fieldName + suffix);\n  }\n\n  /**\n   * A framework field for a {@link ResolvedBindings}.\n   * \n   * @param frameworkClass if present, the field will use this framework class instead of the normal\n   *     one for the bindings\n   */\n  static FrameworkField forResolvedBindings(\n      ResolvedBindings resolvedBindings, Optional\u003cClassName\u003e frameworkClass) {\n    return create(frameworkClass.or(ClassName.get(resolvedBindings.frameworkClass())),\n        TypeName.get(fieldValueType(resolvedBindings)),\n        frameworkFieldName(resolvedBindings));\n  }\n\n  private static TypeMirror fieldValueType(ResolvedBindings resolvedBindings) {\n    if (resolvedBindings.isMultibindingContribution()) {\n      switch (resolvedBindings.contributionType()) {\n        case MAP:\n          return MapType.from(resolvedBindings.key())\n              .unwrappedValueType(resolvedBindings.frameworkClass());\n        case SET:\n          return SetType.from(resolvedBindings.key()).elementType();\n        default:\n          // do nothing\n      }\n    }\n    return resolvedBindings.key().type();\n  }\n\n  private static String frameworkFieldName(ResolvedBindings resolvedBindings) {\n    if (resolvedBindings.bindingKey().kind().equals(BindingKey.Kind.CONTRIBUTION)) {\n      ContributionBinding binding \u003d resolvedBindings.contributionBinding();\n      if (binding.bindingElement().isPresent()) {\n        return BINDING_ELEMENT_NAME.visit(binding.bindingElement().get(), binding);\n      }\n    }\n    return BindingVariableNamer.name(resolvedBindings.binding());\n  }\n\n  private static final ElementVisitor\u003cString, Binding\u003e BINDING_ELEMENT_NAME \u003d\n      new ElementKindVisitor6\u003cString, Binding\u003e() {\n\n        @Override\n        protected String defaultAction(Element e, Binding p) {\n          throw new IllegalArgumentException(\"Unexpected binding \" + p);\n        }\n\n        @Override\n        public String visitExecutableAsConstructor(ExecutableElement e, Binding p) {\n          return visit(e.getEnclosingElement(), p);\n        }\n\n        @Override\n        public String visitExecutableAsMethod(ExecutableElement e, Binding p) {\n          return e.getSimpleName().toString();\n        }\n\n        @Override\n        public String visitType(TypeElement e, Binding p) {\n          return CaseFormat.UPPER_CAMEL.to(CaseFormat.LOWER_CAMEL, e.getSimpleName().toString());\n        }\n      };\n\n  abstract ParameterizedTypeName type();\n  abstract String name();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\FrameworkType.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.CaseFormat.UPPER_CAMEL;\nimport static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;\nimport static dagger.internal.codegen.DependencyRequest.Kind.INSTANCE;\n\nimport com.google.common.util.concurrent.Futures;\nimport com.squareup.javapoet.CodeBlock;\nimport dagger.MembersInjector;\nimport dagger.internal.DoubleCheck;\nimport dagger.internal.ProviderOfLazy;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport dagger.producers.internal.Producers;\nimport javax.inject.Provider;\n\n/** One of the core types initialized as fields in a generated component. */\nenum FrameworkType {\n  /** A {@link Provider}. */\n  PROVIDER {\n    @Override\n    CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {\n      switch (requestKind) {\n        case INSTANCE:\n          return CodeBlock.of(\"$L.get()\", from);\n\n        case LAZY:\n          return CodeBlock.of(\"$T.lazy($L)\", DoubleCheck.class, from);\n\n        case PROVIDER:\n          return from;\n\n        case PROVIDER_OF_LAZY:\n          return CodeBlock.of(\"$T.create($L)\", ProviderOfLazy.class, from);\n\n        case PRODUCER:\n          return CodeBlock.of(\"$T.producerFromProvider($L)\", Producers.class, from);\n\n        case FUTURE:\n          return CodeBlock.of(\"$T.immediateFuture($L)\", Futures.class, to(INSTANCE, from));\n\n        case PRODUCED:\n          return CodeBlock.of(\"$T.successful($L)\", Produced.class, to(INSTANCE, from));\n\n        default:\n          throw new IllegalArgumentException(\n              String.format(\"Cannot request a %s from a %s\", requestKind, this));\n      }\n    }\n  },\n\n  /** A {@link Producer}. */\n  PRODUCER {\n    @Override\n    CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {\n      switch (requestKind) {\n        case FUTURE:\n          return CodeBlock.of(\"$L.get()\", from);\n\n        case PRODUCER:\n          return from;\n\n        default:\n          throw new IllegalArgumentException(\n              String.format(\"Cannot request a %s from a %s\", requestKind, this));\n      }\n    }\n  },\n\n  /** A {@link MembersInjector}. */\n  MEMBERS_INJECTOR {\n    @Override\n    CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from) {\n      switch (requestKind) {\n        case MEMBERS_INJECTOR:\n          return from;\n\n        default:\n          throw new IllegalArgumentException(\n              String.format(\"Cannot request a %s from a %s\", requestKind, this));\n      }\n    }\n  },\n  ;\n\n  /**\n   * Returns an expression that evaluates to a requested object given an expression that evaluates\n   * to an instance of this framework type.\n   *\n   * @param requestKind the kind of {@link DependencyRequest} that the returned expression can\n   *     satisfy\n   * @param from an expression that evaluates to an instance of this framework type\n   * @throws IllegalArgumentException if a valid expression cannot be generated for {@code\n   *     requestKind}\n   */\n  abstract CodeBlock to(DependencyRequest.Kind requestKind, CodeBlock from);\n\n  @Override\n  public String toString() {\n    return UPPER_UNDERSCORE.to(UPPER_CAMEL, super.toString());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\FrameworkTypes.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreTypes.isType;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.collect.ImmutableSet;\nimport dagger.Lazy;\nimport dagger.MembersInjector;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport java.util.Set;\nimport javax.inject.Provider;\nimport javax.lang.model.type.TypeMirror;\n\n/**\n * A collection of utility methods for dealing with Dagger framework types. A framework type is any\n * type that the framework itself defines.\n */\nfinal class FrameworkTypes {\n  private static final ImmutableSet\u003cClass\u003c?\u003e\u003e PROVISION_TYPES \u003d\n      ImmutableSet.of(Provider.class, Lazy.class, MembersInjector.class);\n\n  // NOTE(beder): ListenableFuture is not considered a producer framework type because it is not\n  // defined by the framework, so we can\u0027t treat it specially in ordinary Dagger.\n  private static final ImmutableSet\u003cClass\u003c?\u003e\u003e PRODUCTION_TYPES \u003d\n      ImmutableSet.of(Produced.class, Producer.class);\n\n  /** Returns true if the type represents a producer-related framework type. */\n  static boolean isProducerType(TypeMirror type) {\n    return isType(type) \u0026\u0026 typeIsOneOf(PRODUCTION_TYPES, type);\n  }\n\n  /** Returns true if the type represents a framework type. */\n  static boolean isFrameworkType(TypeMirror type) {\n    return isType(type)\n        \u0026\u0026 (typeIsOneOf(PROVISION_TYPES, type)\n            || typeIsOneOf(PRODUCTION_TYPES, type));\n  }\n\n  private static boolean typeIsOneOf(Set\u003cClass\u003c?\u003e\u003e classes, TypeMirror type) {\n    for (Class\u003c?\u003e clazz : classes) {\n      if (MoreTypes.isTypeOf(clazz, type)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private FrameworkTypes() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\InjectBindingRegistry.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;\nimport static dagger.internal.codegen.MembersInjectionBinding.Strategy.INJECT_MEMBERS;\nimport static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.squareup.javapoet.ClassName;\nimport dagger.Component;\nimport dagger.Provides;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.annotation.processing.Messager;\nimport javax.inject.Inject;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\nimport javax.tools.Diagnostic.Kind;\n\n/**\n * Maintains the collection of provision bindings from {@link Inject} constructors and members\n * injection bindings from {@link Inject} fields and methods known to the annotation processor.\n * Note that this registry \u003cb\u003edoes not\u003c/b\u003e handle any explicit bindings (those from {@link Provides}\n * methods, {@link Component} dependencies, etc.).\n *\n * @author Gregory Kick\n */\nfinal class InjectBindingRegistry {\n  private final Elements elements;\n  private final Types types;\n  private final Messager messager;\n  private final InjectValidator injectValidator;\n  private final Key.Factory keyFactory;\n  private final ProvisionBinding.Factory provisionBindingFactory;\n  private final MembersInjectionBinding.Factory membersInjectionBindingFactory;\n\n  final class BindingsCollection\u003cB extends Binding\u003e {\n    private final BindingType bindingType;\n    private final Map\u003cKey, B\u003e bindingsByKey \u003d Maps.newLinkedHashMap();\n    private final Deque\u003cB\u003e bindingsRequiringGeneration \u003d new ArrayDeque\u003c\u003e();\n    private final Set\u003cKey\u003e materializedBindingKeys \u003d Sets.newLinkedHashSet();\n    \n    BindingsCollection(BindingType bindingType) {\n      this.bindingType \u003d bindingType;\n    }\n\n    void generateBindings(SourceFileGenerator\u003cB\u003e generator) throws SourceFileGenerationException {\n      for (B binding \u003d bindingsRequiringGeneration.poll();\n          binding !\u003d null;\n          binding \u003d bindingsRequiringGeneration.poll()) {\n        checkState(!binding.unresolved().isPresent());\n        generator.generate(binding);\n        materializedBindingKeys.add(binding.key());\n      }\n      // Because Elements instantiated across processing rounds are not guaranteed to be equals() to\n      // the logically same element, clear the cache after generating\n      bindingsByKey.clear();\n    }\n\n    /** Returns a previously cached binding. */\n    B getBinding(Key key) {\n      return bindingsByKey.get(key);\n    }\n\n    /** Caches the binding and generates it if it needs generation. */\n    void tryRegisterBinding(B binding, boolean warnIfNotAlreadyGenerated) {\n      tryToCacheBinding(binding);\n      tryToGenerateBinding(binding, warnIfNotAlreadyGenerated);\n    }\n\n    /**\n     * Tries to generate a binding, not generating if it already is generated. For resolved\n     * bindings, this will try to generate the unresolved version of the binding.\n     */\n    void tryToGenerateBinding(B binding, boolean warnIfNotAlreadyGenerated) {\n      if (shouldGenerateBinding(binding, generatedClassNameForBinding(binding))) {\n        bindingsRequiringGeneration.offer(binding);\n        if (warnIfNotAlreadyGenerated) {\n          messager.printMessage(\n              Kind.NOTE,\n              String.format(\n                  \"Generating a %s for %s. \"\n                      + \"Prefer to run the dagger processor over that class instead.\",\n                  bindingType.frameworkClass().getSimpleName(),\n                  types.erasure(binding.key().type()))); // erasure to strip \u003cT\u003e from msgs.\n        }\n      }\n    }\n\n    /** Returns true if the binding needs to be generated. */\n    private boolean shouldGenerateBinding(B binding, ClassName factoryName) {\n      return !binding.unresolved().isPresent()\n          \u0026\u0026 elements.getTypeElement(factoryName.toString()) \u003d\u003d null\n          \u0026\u0026 !materializedBindingKeys.contains(binding.key())\n          \u0026\u0026 !bindingsRequiringGeneration.contains(binding);\n    }\n\n    /** Caches the binding for future lookups by key. */\n    private void tryToCacheBinding(B binding) {\n      // We only cache resolved bindings or unresolved bindings w/o type arguments.\n      // Unresolved bindings w/ type arguments aren\u0027t valid for the object graph.\n      if (binding.unresolved().isPresent()\n          || binding.bindingTypeElement().get().getTypeParameters().isEmpty()) {\n        Key key \u003d binding.key();\n        Binding previousValue \u003d bindingsByKey.put(key, binding);\n        checkState(previousValue \u003d\u003d null || binding.equals(previousValue),\n            \"couldn\u0027t register %s. %s was already registered for %s\",\n            binding, previousValue, key);\n      }\n    }\n  }\n\n  private final BindingsCollection\u003cProvisionBinding\u003e provisionBindings \u003d\n      new BindingsCollection\u003c\u003e(BindingType.PROVISION);\n  private final BindingsCollection\u003cMembersInjectionBinding\u003e membersInjectionBindings \u003d\n      new BindingsCollection\u003c\u003e(BindingType.MEMBERS_INJECTION);\n\n  InjectBindingRegistry(\n      Elements elements,\n      Types types,\n      Messager messager,\n      InjectValidator injectValidator,\n      Key.Factory keyFactory,\n      ProvisionBinding.Factory provisionBindingFactory,\n      MembersInjectionBinding.Factory membersInjectionBindingFactory) {\n    this.elements \u003d elements;\n    this.types \u003d types;\n    this.messager \u003d messager;\n    this.injectValidator \u003d injectValidator;\n    this.keyFactory \u003d keyFactory;\n    this.provisionBindingFactory \u003d provisionBindingFactory;\n    this.membersInjectionBindingFactory \u003d membersInjectionBindingFactory;\n  }\n\n  /**\n   * This method ensures that sources for all registered {@link Binding bindings} (either\n   * {@linkplain #registerBinding explicitly} or implicitly via\n   * {@link #getOrFindMembersInjectionBinding} or {@link #getOrFindProvisionBinding}) are generated.\n   */\n  void generateSourcesForRequiredBindings(FactoryGenerator factoryGenerator,\n      MembersInjectorGenerator membersInjectorGenerator) throws SourceFileGenerationException {\n    provisionBindings.generateBindings(factoryGenerator);\n    membersInjectionBindings.generateBindings(membersInjectorGenerator);\n  }\n\n  /**\n   * Registers the binding for generation and later lookup. If the binding is resolved, we also\n   * attempt to register an unresolved version of it.\n   */\n  private void registerBinding(ProvisionBinding binding, boolean warnIfNotAlreadyGenerated) {\n    provisionBindings.tryRegisterBinding(binding, warnIfNotAlreadyGenerated);\n    if (binding.unresolved().isPresent()) {\n      provisionBindings.tryToGenerateBinding(binding.unresolved().get(), warnIfNotAlreadyGenerated);\n    }\n  }\n\n  /**\n   * Registers the binding for generation and later lookup. If the binding is resolved, we also\n   * attempt to register an unresolved version of it.\n   */\n  private void registerBinding(MembersInjectionBinding binding, boolean warnIfNotAlreadyGenerated) {\n    /*\n     * We generate MembersInjector classes for types with @Inject constructors only if they have any\n     * injection sites.\n     *\n     * We generate MembersInjector classes for types without @Inject constructors only if they have\n     * local (non-inherited) injection sites.\n     *\n     * Warn only when registering bindings post-hoc for those types.\n     */\n    warnIfNotAlreadyGenerated \u003d\n        warnIfNotAlreadyGenerated\n            \u0026\u0026 (!injectedConstructors(binding.membersInjectedType()).isEmpty()\n                ? !binding.injectionSites().isEmpty()\n                : binding.hasLocalInjectionSites());\n    membersInjectionBindings.tryRegisterBinding(binding, warnIfNotAlreadyGenerated);\n    if (binding.unresolved().isPresent()) {\n      membersInjectionBindings.tryToGenerateBinding(\n          binding.unresolved().get(), warnIfNotAlreadyGenerated);\n    }\n  }\n\n  @CanIgnoreReturnValue\n  Optional\u003cProvisionBinding\u003e tryRegisterConstructor(ExecutableElement constructorElement) {\n    return tryRegisterConstructor(constructorElement, Optional.\u003cTypeMirror\u003eabsent(), false);\n  }\n\n  @CanIgnoreReturnValue\n  private Optional\u003cProvisionBinding\u003e tryRegisterConstructor(\n      ExecutableElement constructorElement,\n      Optional\u003cTypeMirror\u003e resolvedType,\n      boolean warnIfNotAlreadyGenerated) {\n    TypeElement typeElement \u003d MoreElements.asType(constructorElement.getEnclosingElement());\n    DeclaredType type \u003d MoreTypes.asDeclared(typeElement.asType());\n    Key key \u003d keyFactory.forInjectConstructorWithResolvedType(type);\n    ProvisionBinding cachedBinding \u003d provisionBindings.getBinding(key);\n    if (cachedBinding !\u003d null) {\n      return Optional.of(cachedBinding);\n    }\n\n    ValidationReport\u003cTypeElement\u003e report \u003d injectValidator.validateConstructor(constructorElement);\n    report.printMessagesTo(messager);\n    if (report.isClean()) {\n      ProvisionBinding binding \u003d\n          provisionBindingFactory.forInjectConstructor(constructorElement, resolvedType);\n      registerBinding(binding, warnIfNotAlreadyGenerated);\n      if (membersInjectionBindingFactory.hasInjectedMembers(type)) {\n        tryRegisterMembersInjectedType(typeElement, resolvedType, warnIfNotAlreadyGenerated);\n      }\n      return Optional.of(binding);\n    }\n    return Optional.absent();\n  }\n\n  @CanIgnoreReturnValue\n  Optional\u003cMembersInjectionBinding\u003e tryRegisterMembersInjectedType(TypeElement typeElement) {\n    return tryRegisterMembersInjectedType(typeElement, Optional.\u003cTypeMirror\u003eabsent(), false);\n  }\n\n  @CanIgnoreReturnValue\n  private Optional\u003cMembersInjectionBinding\u003e tryRegisterMembersInjectedType(\n      TypeElement typeElement,\n      Optional\u003cTypeMirror\u003e resolvedType,\n      boolean warnIfNotAlreadyGenerated) {\n    DeclaredType type \u003d MoreTypes.asDeclared(typeElement.asType());\n    Key key \u003d keyFactory.forInjectConstructorWithResolvedType(type);\n    MembersInjectionBinding cachedBinding \u003d membersInjectionBindings.getBinding(key);\n    if (cachedBinding !\u003d null) {\n      return Optional.of(cachedBinding);\n    }\n\n    ValidationReport\u003cTypeElement\u003e report \u003d\n        injectValidator.validateMembersInjectionType(typeElement);\n    report.printMessagesTo(messager);\n    if (report.isClean()) {\n      MembersInjectionBinding binding \u003d\n          membersInjectionBindingFactory.forInjectedType(type, resolvedType);\n      registerBinding(binding, warnIfNotAlreadyGenerated);\n      if (binding.parentKey().isPresent() \u0026\u0026 binding.injectionStrategy().equals(INJECT_MEMBERS)) {\n        getOrFindMembersInjectionBinding(binding.parentKey().get());\n      }\n      return Optional.of(binding);\n    }\n    return Optional.absent();\n  }\n\n  @CanIgnoreReturnValue\n  Optional\u003cProvisionBinding\u003e getOrFindProvisionBinding(Key key) {\n    checkNotNull(key);\n    if (!key.isValidImplicitProvisionKey(types)) {\n      return Optional.absent();\n    }\n    ProvisionBinding binding \u003d provisionBindings.getBinding(key);\n    if (binding !\u003d null) {\n      return Optional.of(binding);\n    }\n\n    // ok, let\u0027s see if we can find an @Inject constructor\n    TypeElement element \u003d MoreElements.asType(types.asElement(key.type()));\n    ImmutableSet\u003cExecutableElement\u003e injectConstructors \u003d injectedConstructors(element);\n    switch (injectConstructors.size()) {\n      case 0:\n        // No constructor found.\n        return Optional.absent();\n      case 1:\n        return tryRegisterConstructor(\n            Iterables.getOnlyElement(injectConstructors), Optional.of(key.type()), true);\n      default:\n        throw new IllegalStateException(\"Found multiple @Inject constructors: \"\n            + injectConstructors);\n    }\n  }\n\n  /**\n   * Returns a {@link MembersInjectionBinding} for {@code key}. If none has been registered yet,\n   * registers one, along with all necessary members injection bindings for superclasses.\n   */\n  @CanIgnoreReturnValue\n  Optional\u003cMembersInjectionBinding\u003e getOrFindMembersInjectionBinding(Key key) {\n    checkNotNull(key);\n    // TODO(gak): is checking the kind enough?\n    checkArgument(key.isValidMembersInjectionKey());\n    MembersInjectionBinding binding \u003d membersInjectionBindings.getBinding(key);\n    if (binding !\u003d null) {\n      return Optional.of(binding);\n    }\n    Optional\u003cMembersInjectionBinding\u003e newBinding \u003d\n        tryRegisterMembersInjectedType(\n            MoreTypes.asTypeElement(key.type()), Optional.of(key.type()), true);\n    return newBinding;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\InjectionAnnotations.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static javax.lang.model.util.ElementFilter.constructorsIn;\n\nimport com.google.auto.common.AnnotationMirrors;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableSet;\nimport javax.inject.Inject;\nimport javax.inject.Qualifier;\nimport javax.inject.Scope;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\n\n/**\n * Utilities relating to annotations defined in the {@code javax.inject} package.\n *\n * @author Gregory Kick\n * @since 2.0\n */\nfinal class InjectionAnnotations {\n  static Optional\u003cAnnotationMirror\u003e getQualifier(Element e) {\n    checkNotNull(e);\n    ImmutableSet\u003c? extends AnnotationMirror\u003e qualifierAnnotations \u003d getQualifiers(e);\n    switch (qualifierAnnotations.size()) {\n      case 0:\n        return Optional.absent();\n      case 1:\n        return Optional.\u003cAnnotationMirror\u003eof(qualifierAnnotations.iterator().next());\n      default:\n        throw new IllegalArgumentException(\n            e + \" was annotated with more than one @Qualifier annotation\");\n    }\n  }\n\n  static ImmutableSet\u003c? extends AnnotationMirror\u003e getQualifiers(Element element) {\n    return AnnotationMirrors.getAnnotatedAnnotations(element, Qualifier.class);\n  }\n\n  static ImmutableSet\u003c? extends AnnotationMirror\u003e getScopes(Element element) {\n    return AnnotationMirrors.getAnnotatedAnnotations(element, Scope.class);\n  }\n\n  /** Returns the constructors in {@code type} that are annotated with {@link Inject}. */\n  static ImmutableSet\u003cExecutableElement\u003e injectedConstructors(TypeElement type) {\n    return FluentIterable.from(constructorsIn(type.getEnclosedElements()))\n        .filter(constructor -\u003e isAnnotationPresent(constructor, Inject.class))\n        .toSet();\n  }\n\n  private InjectionAnnotations() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\InjectProcessingStep.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.auto.common.BasicAnnotationProcessor;\nimport com.google.auto.common.MoreElements;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.SetMultimap;\nimport java.lang.annotation.Annotation;\nimport java.util.Set;\nimport javax.inject.Inject;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.util.ElementKindVisitor6;\n\n/**\n * An annotation processor for generating Dagger implementation code based on the {@link Inject}\n * annotation.\n *\n * @author Gregory Kick\n * @since 2.0\n */\nfinal class InjectProcessingStep implements BasicAnnotationProcessor.ProcessingStep {\n  private final InjectBindingRegistry injectBindingRegistry;\n\n  InjectProcessingStep(InjectBindingRegistry factoryRegistrar) {\n    this.injectBindingRegistry \u003d factoryRegistrar;\n  }\n\n  @Override\n  public Set\u003cClass\u003c? extends Annotation\u003e\u003e annotations() {\n    return ImmutableSet.\u003cClass\u003c? extends Annotation\u003e\u003eof(Inject.class);\n  }\n\n  @Override\n  public Set\u003cElement\u003e process(\n      SetMultimap\u003cClass\u003c? extends Annotation\u003e, Element\u003e elementsByAnnotation) {\n    ImmutableSet.Builder\u003cElement\u003e rejectedElements \u003d ImmutableSet.builder();\n    // TODO(gak): add some error handling for bad source files\n\n    for (Element injectElement : elementsByAnnotation.get(Inject.class)) {\n      try {\n        injectElement.accept(\n            new ElementKindVisitor6\u003cVoid, Void\u003e() {\n              @Override\n              public Void visitExecutableAsConstructor(\n                  ExecutableElement constructorElement, Void v) {\n                injectBindingRegistry.tryRegisterConstructor(constructorElement);\n                return null;\n              }\n\n              @Override\n              public Void visitVariableAsField(VariableElement fieldElement, Void p) {\n                injectBindingRegistry.tryRegisterMembersInjectedType(\n                    MoreElements.asType(fieldElement.getEnclosingElement()));\n                return null;\n              }\n\n              @Override\n              public Void visitExecutableAsMethod(ExecutableElement methodElement, Void p) {\n                injectBindingRegistry.tryRegisterMembersInjectedType(\n                    MoreElements.asType(methodElement.getEnclosingElement()));\n                return null;\n              }\n            },\n            null);\n      } catch (TypeNotPresentException e) {\n        rejectedElements.add(injectElement);\n      }\n    }\n\n    return rejectedElements.build();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\InjectValidator.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static dagger.internal.codegen.Accessibility.isElementAccessibleFromOwnPackage;\nimport static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;\nimport static dagger.internal.codegen.ErrorMessages.CHECKED_EXCEPTIONS_ON_CONSTRUCTORS;\nimport static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;\nimport static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;\nimport static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;\nimport static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;\nimport static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;\nimport static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;\nimport static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;\nimport static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;\nimport static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;\nimport static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;\nimport static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;\nimport static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;\nimport static dagger.internal.codegen.ErrorMessages.SCOPE_ON_INJECT_CONSTRUCTOR;\nimport static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;\nimport static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;\nimport static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;\nimport static dagger.internal.codegen.InjectionAnnotations.getQualifiers;\nimport static dagger.internal.codegen.InjectionAnnotations.getScopes;\nimport static dagger.internal.codegen.InjectionAnnotations.injectedConstructors;\nimport static javax.lang.model.element.Modifier.ABSTRACT;\nimport static javax.lang.model.element.Modifier.FINAL;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.element.Modifier.STATIC;\nimport static javax.lang.model.type.TypeKind.DECLARED;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableSet;\nimport java.util.Set;\nimport javax.inject.Inject;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.TypeKind;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.ElementFilter;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\nimport javax.tools.Diagnostic;\n\n/**\n * A {@linkplain ValidationReport validator} for {@link Inject}-annotated elements and the types\n * that contain them.\n *\n * @author Gregory Kick\n * @since 2.0\n */\nfinal class InjectValidator {\n  private final Types types;\n  private final Elements elements;\n  private final CompilerOptions compilerOptions;\n  private final Optional\u003cDiagnostic.Kind\u003e privateAndStaticInjectionDiagnosticKind;\n\n  InjectValidator(Types types, Elements elements, CompilerOptions compilerOptions) {\n    this(types, elements, compilerOptions, Optional.\u003cDiagnostic.Kind\u003eabsent());\n  }\n\n  private InjectValidator(\n      Types types,\n      Elements elements,\n      CompilerOptions compilerOptions,\n      Optional\u003cDiagnostic.Kind\u003e privateAndStaticInjectionDiagnosticKind) {\n    this.types \u003d types;\n    this.elements \u003d elements;\n    this.compilerOptions \u003d compilerOptions;\n    this.privateAndStaticInjectionDiagnosticKind \u003d privateAndStaticInjectionDiagnosticKind;\n  }\n\n  /**\n   * Returns a new validator that performs the same validation as this one, but is strict about\n   * rejecting optionally-specified JSR 330 behavior that Dagger doesn\u0027t support.\n   */\n  InjectValidator whenGeneratingCode() {\n    return compilerOptions.ignorePrivateAndStaticInjectionForComponent()\n        ? new InjectValidator(types, elements, compilerOptions, Optional.of(Diagnostic.Kind.ERROR))\n        : this;\n  }\n\n  ValidationReport\u003cTypeElement\u003e validateConstructor(ExecutableElement constructorElement) {\n    ValidationReport.Builder\u003cTypeElement\u003e builder \u003d\n        ValidationReport.about(MoreElements.asType(constructorElement.getEnclosingElement()));\n    if (constructorElement.getModifiers().contains(PRIVATE)) {\n      builder.addError(INJECT_ON_PRIVATE_CONSTRUCTOR, constructorElement);\n    }\n\n    for (AnnotationMirror qualifier : getQualifiers(constructorElement)) {\n      builder.addError(QUALIFIER_ON_INJECT_CONSTRUCTOR, constructorElement, qualifier);\n    }\n\n    for (AnnotationMirror scope : getScopes(constructorElement)) {\n      builder.addError(SCOPE_ON_INJECT_CONSTRUCTOR, constructorElement, scope);\n    }\n\n    for (VariableElement parameter : constructorElement.getParameters()) {\n      ImmutableSet\u003c? extends AnnotationMirror\u003e qualifiers \u003d getQualifiers(parameter);\n      if (qualifiers.size() \u003e 1) {\n        for (AnnotationMirror qualifier : qualifiers) {\n          builder.addError(MULTIPLE_QUALIFIERS, constructorElement, qualifier);\n        }\n      }\n      if (FrameworkTypes.isProducerType(parameter.asType())) {\n        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);\n      }\n    }\n\n    if (throwsCheckedExceptions(constructorElement)) {\n      builder.addItem(\n          CHECKED_EXCEPTIONS_ON_CONSTRUCTORS,\n          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),\n          constructorElement);\n    }\n\n    TypeElement enclosingElement \u003d\n        MoreElements.asType(constructorElement.getEnclosingElement());\n    Set\u003cModifier\u003e typeModifiers \u003d enclosingElement.getModifiers();\n\n    if (!Accessibility.isElementAccessibleFromOwnPackage(enclosingElement)) {\n      builder.addItem(\n          INJECT_INTO_PRIVATE_CLASS,\n          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),\n          constructorElement);\n    }\n\n    if (typeModifiers.contains(ABSTRACT)) {\n      builder.addError(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS, constructorElement);\n    }\n\n    if (enclosingElement.getNestingKind().isNested()\n        \u0026\u0026 !typeModifiers.contains(STATIC)) {\n      builder.addError(INJECT_CONSTRUCTOR_ON_INNER_CLASS, constructorElement);\n    }\n\n    // This is computationally expensive, but probably preferable to a giant index\n    ImmutableSet\u003cExecutableElement\u003e injectConstructors \u003d injectedConstructors(enclosingElement);\n\n    if (injectConstructors.size() \u003e 1) {\n      builder.addError(MULTIPLE_INJECT_CONSTRUCTORS, constructorElement);\n    }\n\n    ImmutableSet\u003c? extends AnnotationMirror\u003e scopes \u003d getScopes(enclosingElement);\n    if (scopes.size() \u003e 1) {\n      for (AnnotationMirror scope : scopes) {\n        builder.addError(MULTIPLE_SCOPES, enclosingElement, scope);\n      }\n    }\n\n    return builder.build();\n  }\n\n  private ValidationReport\u003cVariableElement\u003e validateField(VariableElement fieldElement) {\n    ValidationReport.Builder\u003cVariableElement\u003e builder \u003d ValidationReport.about(fieldElement);\n    Set\u003cModifier\u003e modifiers \u003d fieldElement.getModifiers();\n    if (modifiers.contains(FINAL)) {\n      builder.addError(FINAL_INJECT_FIELD, fieldElement);\n    }\n\n    if (modifiers.contains(PRIVATE)) {\n      builder.addItem(\n          PRIVATE_INJECT_FIELD,\n          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),\n          fieldElement);\n    }\n\n    if (modifiers.contains(STATIC)) {\n      builder.addItem(\n          STATIC_INJECT_FIELD,\n          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.staticMemberValidationKind()),\n          fieldElement);\n    }\n\n    ImmutableSet\u003c? extends AnnotationMirror\u003e qualifiers \u003d getQualifiers(fieldElement);\n    if (qualifiers.size() \u003e 1) {\n      for (AnnotationMirror qualifier : qualifiers) {\n        builder.addError(MULTIPLE_QUALIFIERS, fieldElement, qualifier);\n      }\n    }\n\n    if (FrameworkTypes.isProducerType(fieldElement.asType())) {\n      builder.addError(provisionMayNotDependOnProducerType(fieldElement.asType()), fieldElement);\n    }\n\n    return builder.build();\n  }\n\n  private ValidationReport\u003cExecutableElement\u003e validateMethod(ExecutableElement methodElement) {\n    ValidationReport.Builder\u003cExecutableElement\u003e builder \u003d ValidationReport.about(methodElement);\n    Set\u003cModifier\u003e modifiers \u003d methodElement.getModifiers();\n    if (modifiers.contains(ABSTRACT)) {\n      builder.addError(ABSTRACT_INJECT_METHOD, methodElement);\n    }\n\n    if (modifiers.contains(PRIVATE)) {\n      builder.addItem(\n          PRIVATE_INJECT_METHOD,\n          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),\n          methodElement);\n    }\n\n    if (modifiers.contains(STATIC)) {\n      builder.addItem(\n          STATIC_INJECT_METHOD,\n          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.staticMemberValidationKind()),\n          methodElement);\n    }\n\n    if (!methodElement.getTypeParameters().isEmpty()) {\n      builder.addError(GENERIC_INJECT_METHOD, methodElement);\n    }\n\n    for (VariableElement parameter : methodElement.getParameters()) {\n      ImmutableSet\u003c? extends AnnotationMirror\u003e qualifiers \u003d getQualifiers(parameter);\n      if (qualifiers.size() \u003e 1) {\n        for (AnnotationMirror qualifier : qualifiers) {\n          builder.addError(MULTIPLE_QUALIFIERS, methodElement, qualifier);\n        }\n      }\n      if (FrameworkTypes.isProducerType(parameter.asType())) {\n        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);\n      }\n    }\n\n    return builder.build();\n  }\n\n  ValidationReport\u003cTypeElement\u003e validateMembersInjectionType(TypeElement typeElement) {\n    // TODO(beder): This element might not be currently compiled, so this error message could be\n    // left in limbo. Find an appropriate way to display the error message in that case.\n    ValidationReport.Builder\u003cTypeElement\u003e builder \u003d ValidationReport.about(typeElement);\n    boolean hasInjectedMembers \u003d false;\n    for (VariableElement element : ElementFilter.fieldsIn(typeElement.getEnclosedElements())) {\n      if (MoreElements.isAnnotationPresent(element, Inject.class)) {\n        hasInjectedMembers \u003d true;\n        ValidationReport\u003cVariableElement\u003e report \u003d validateField(element);\n        if (!report.isClean()) {\n          builder.addSubreport(report);\n        }\n      }\n    }\n    for (ExecutableElement element : ElementFilter.methodsIn(typeElement.getEnclosedElements())) {\n      if (MoreElements.isAnnotationPresent(element, Inject.class)) {\n        hasInjectedMembers \u003d true;\n        ValidationReport\u003cExecutableElement\u003e report \u003d validateMethod(element);\n        if (!report.isClean()) {\n          builder.addSubreport(report);\n        }\n      }\n    }\n    // We can\u0027t use MembersInjectionBinding.Factory#hasInjectedMembers because that assumes this\n    // binding already validates, so we just check it again here.\n    if (hasInjectedMembers \u0026\u0026 !isElementAccessibleFromOwnPackage(typeElement)) {\n      builder.addItem(\n          INJECT_INTO_PRIVATE_CLASS,\n          privateAndStaticInjectionDiagnosticKind.or(compilerOptions.privateMemberValidationKind()),\n          typeElement);\n    }\n    TypeMirror superclass \u003d typeElement.getSuperclass();\n    if (!superclass.getKind().equals(TypeKind.NONE)) {\n      ValidationReport\u003cTypeElement\u003e report \u003d validateType(MoreTypes.asTypeElement(superclass));\n      if (!report.isClean()) {\n        builder.addSubreport(report);\n      }\n    }\n    return builder.build();\n  }\n\n  ValidationReport\u003cTypeElement\u003e validateType(TypeElement typeElement) {\n    ValidationReport.Builder\u003cTypeElement\u003e builder \u003d ValidationReport.about(typeElement);\n    ValidationReport\u003cTypeElement\u003e membersInjectionReport \u003d\n        validateMembersInjectionType(typeElement);\n    if (!membersInjectionReport.isClean()) {\n      builder.addSubreport(membersInjectionReport);\n    }\n    for (ExecutableElement element :\n        ElementFilter.constructorsIn(typeElement.getEnclosedElements())) {\n      if (isAnnotationPresent(element, Inject.class)) {\n        ValidationReport\u003cTypeElement\u003e report \u003d validateConstructor(element);\n        if (!report.isClean()) {\n          builder.addSubreport(report);\n        }\n      }\n    }\n    return builder.build();\n  }\n\n  boolean isValidType(TypeMirror type) {\n    if (!type.getKind().equals(DECLARED)) {\n      return true;\n    }\n    return validateType(MoreTypes.asTypeElement(type)).isClean();\n  }\n\n  /** Returns true if the given method element declares a checked exception. */\n  private boolean throwsCheckedExceptions(ExecutableElement methodElement) {\n    TypeMirror runtimeExceptionType \u003d\n        elements.getTypeElement(RuntimeException.class.getCanonicalName()).asType();\n    TypeMirror errorType \u003d elements.getTypeElement(Error.class.getCanonicalName()).asType();\n    for (TypeMirror thrownType : methodElement.getThrownTypes()) {\n      if (!types.isSubtype(thrownType, runtimeExceptionType)\n          \u0026\u0026 !types.isSubtype(thrownType, errorType)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\Key.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static com.google.auto.common.MoreTypes.asExecutable;\nimport static com.google.auto.common.MoreTypes.isType;\nimport static com.google.auto.common.MoreTypes.isTypeOf;\nimport static com.google.common.base.Optional.presentInstances;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static dagger.internal.codegen.InjectionAnnotations.getQualifier;\nimport static dagger.internal.codegen.MapKeys.getMapKey;\nimport static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;\nimport static dagger.internal.codegen.MoreAnnotationMirrors.unwrapOptionalEquivalence;\nimport static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;\nimport static javax.lang.model.element.ElementKind.METHOD;\n\nimport com.google.auto.common.AnnotationMirrors;\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Equivalence;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Multimaps;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.Binds;\nimport dagger.BindsOptionalOf;\nimport dagger.Multibindings;\nimport dagger.multibindings.Multibinds;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport dagger.producers.Production;\nimport dagger.producers.internal.ProductionImplementation;\nimport dagger.producers.monitoring.ProductionComponentMonitor;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Executor;\nimport javax.inject.Provider;\nimport javax.inject.Qualifier;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.ElementKind;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.PrimitiveType;\nimport javax.lang.model.type.TypeKind;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.SimpleTypeVisitor6;\nimport javax.lang.model.util.Types;\n\n/**\n * Represents a unique combination of {@linkplain TypeMirror type} and\n * {@linkplain Qualifier qualifier} to which binding can occur.\n *\n * @author Gregory Kick\n */\n@AutoValue\nabstract class Key {\n\n  /** An object that is associated with a {@link Key}. */\n  interface HasKey {\n    /** The key associated with this object. */\n    Key key();\n  }\n\n  /**\n   * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix\n   * for the type of this key.\n   *\n   * Despite documentation in {@link AnnotationMirror}, equals and hashCode aren\u0027t implemented\n   * to represent logical equality, so {@link AnnotationMirrors#equivalence()}\n   * provides this facility.\n   */\n  abstract Optional\u003cEquivalence.Wrapper\u003cAnnotationMirror\u003e\u003e wrappedQualifier();\n\n  /**\n   * The type represented by this key.\n   *\n   * As documented in {@link TypeMirror}, equals and hashCode aren\u0027t implemented to represent\n   * logical equality, so {@link MoreTypes#equivalence()} wraps this type.\n   */\n  abstract Equivalence.Wrapper\u003cTypeMirror\u003e wrappedType();\n\n  /**\n   * Distinguishes keys for multibinding contributions that share a {@link #type()} and {@link\n   * #qualifier()}.\n   *\n   * \u003cp\u003eEach multibound map and set has a {@linkplain\n   * ProvisionBinding.Factory#syntheticMultibinding(DependencyRequest, Iterable) synthetic\n   * multibinding} that depends on the specific contributions to that map or set using keys that\n   * identify those multibinding contributions.\n   *\n   * \u003cp\u003eAbsent except for multibinding contributions.\n   */\n  abstract Optional\u003cMultibindingContributionIdentifier\u003e multibindingContributionIdentifier();\n\n  abstract Builder toBuilder();\n\n  static Builder builder(TypeMirror type) {\n    return new AutoValue_Key.Builder().type(type);\n  }\n\n  @AutoValue.Builder\n  abstract static class Builder {\n    abstract Builder wrappedType(Equivalence.Wrapper\u003cTypeMirror\u003e wrappedType);\n\n    Builder type(TypeMirror type) {\n      return wrappedType(MoreTypes.equivalence().wrap(checkNotNull(type)));\n    }\n\n    abstract Builder wrappedQualifier(\n        Optional\u003cEquivalence.Wrapper\u003cAnnotationMirror\u003e\u003e wrappedQualifier);\n\n    abstract Builder wrappedQualifier(Equivalence.Wrapper\u003cAnnotationMirror\u003e wrappedQualifier);\n\n    Builder qualifier(AnnotationMirror qualifier) {\n      return wrappedQualifier(AnnotationMirrors.equivalence().wrap(checkNotNull(qualifier)));\n    }\n\n    Builder qualifier(Optional\u003cAnnotationMirror\u003e qualifier) {\n      return wrappedQualifier(wrapOptionalInEquivalence(checkNotNull(qualifier)));\n    }\n\n    Builder qualifier(TypeElement annotationType) {\n      return qualifier(SimpleAnnotationMirror.of(annotationType));\n    }\n\n    abstract Builder multibindingContributionIdentifier(\n        Optional\u003cMultibindingContributionIdentifier\u003e identifier);\n\n    abstract Builder multibindingContributionIdentifier(\n        MultibindingContributionIdentifier identifier);\n\n    abstract Key build();\n  }\n\n  /**\n   * An object that identifies a multibinding contribution method and the module class that\n   * contributes it to the graph.\n   *\n   * @see Key#multibindingContributionIdentifier()\n   */\n  static final class MultibindingContributionIdentifier {\n    private final String identifierString;\n\n    MultibindingContributionIdentifier(\n        ExecutableElement bindingMethod, TypeElement contributingModule) {\n      this.identifierString \u003d\n          String.format(\n              \"%s#%s\", contributingModule.getQualifiedName(), bindingMethod.getSimpleName());\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * \u003cp\u003eThe returned string is human-readable and distinguishes the keys in the same way as the\n     * whole object.\n     */\n    @Override\n    public String toString() {\n      return identifierString;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n      return obj instanceof MultibindingContributionIdentifier\n          \u0026\u0026 ((MultibindingContributionIdentifier) obj)\n              .identifierString.equals(this.identifierString);\n    }\n\n    @Override\n    public int hashCode() {\n      return identifierString.hashCode();\n    }\n  }\n\n  /**\n   * A {@link javax.inject.Qualifier} annotation that provides a unique namespace prefix\n   * for the type of this key.\n   */\n  Optional\u003cAnnotationMirror\u003e qualifier() {\n    return unwrapOptionalEquivalence(wrappedQualifier());\n  }\n\n  /**\n   * The type represented by this key.\n   */\n  TypeMirror type() {\n    return wrappedType().get();\n  }\n\n  /**\n   * A key whose {@link #qualifier()} and {@link #type()} are equivalent to this one\u0027s, but without\n   * a {@link #multibindingContributionIdentifier()}.\n   */\n  Key withoutMultibindingContributionIdentifier() {\n    return toBuilder()\n        .multibindingContributionIdentifier(Optional.\u003cMultibindingContributionIdentifier\u003eabsent())\n        .build();\n  }\n\n  boolean isValidMembersInjectionKey() {\n    return !qualifier().isPresent() \u0026\u0026 !type().getKind().equals(TypeKind.WILDCARD);\n  }\n\n  /**\n   * Returns {@code true} if this is valid as an implicit key (that is, if it\u0027s valid for a\n   * just-in-time binding by discovering an {@code @Inject} constructor).\n   */\n  boolean isValidImplicitProvisionKey(Types types) {\n    return isValidImplicitProvisionKey(qualifier(), type(), types);\n  }\n\n  /**\n   * Returns {@code true} if a key with {@code qualifier} and {@code type} is valid as an implicit\n   * key (that is, if it\u0027s valid for a just-in-time binding by discovering an {@code @Inject}\n   * constructor).\n   */\n  static boolean isValidImplicitProvisionKey(\n      Optional\u003c? extends AnnotationMirror\u003e qualifier, TypeMirror type, final Types types) {\n    // Qualifiers disqualify implicit provisioning.\n    if (qualifier.isPresent()) {\n      return false;\n    }\n\n    return type.accept(\n        new SimpleTypeVisitor6\u003cBoolean, Void\u003e(false) {\n          @Override\n          public Boolean visitDeclared(DeclaredType type, Void ignored) {\n            // Non-classes or abstract classes aren\u0027t allowed.\n            TypeElement element \u003d MoreElements.asType(type.asElement());\n            if (!element.getKind().equals(ElementKind.CLASS)\n                || element.getModifiers().contains(Modifier.ABSTRACT)) {\n              return false;\n            }\n\n            // If the key has type arguments, validate that each type argument is declared.\n            // Otherwise the type argument may be a wildcard (or other type), and we can\u0027t\n            // resolve that to actual types.\n            for (TypeMirror arg : type.getTypeArguments()) {\n              if (arg.getKind() !\u003d TypeKind.DECLARED) {\n                return false;\n              }\n            }\n\n            // Also validate that the key is not the erasure of a generic type.\n            // If it is, that means the user referred to Foo\u003cT\u003e as just \u0027Foo\u0027,\n            // which we don\u0027t allow.  (This is a judgement call -- we *could*\n            // allow it and instantiate the type bounds... but we don\u0027t.)\n            return MoreTypes.asDeclared(element.asType()).getTypeArguments().isEmpty()\n                || !types.isSameType(types.erasure(element.asType()), type);\n          }\n        },\n        null);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * \u003cp\u003eThe returned string is equal to another key\u0027s if and only if this key is {@link\n   * #equal(Object)} to it.\n   */\n  @Override\n  public String toString() {\n    return Joiner.on(\u0027 \u0027)\n        .skipNulls()\n        .join(qualifier().orNull(), type(), multibindingContributionIdentifier().orNull());\n  }\n\n  /**\n   * Indexes {@code haveKeys} by {@link HasKey#key()}.\n   */\n  static \u003cT extends HasKey\u003e ImmutableSetMultimap\u003cKey, T\u003e indexByKey(Iterable\u003cT\u003e haveKeys) {\n    return ImmutableSetMultimap.copyOf(Multimaps.index(haveKeys, HasKey::key));\n  }\n\n  static final class Factory {\n    private final Types types;\n    private final Elements elements;\n\n    Factory(Types types, Elements elements) {\n      this.types \u003d checkNotNull(types);\n      this.elements \u003d checkNotNull(elements);\n    }\n\n    private TypeElement getClassElement(Class\u003c?\u003e cls) {\n      return elements.getTypeElement(cls.getCanonicalName());\n    }\n\n    private TypeMirror boxPrimitives(TypeMirror type) {\n      return type.getKind().isPrimitive() ? types.boxedClass((PrimitiveType) type).asType() : type;\n    }\n\n    private DeclaredType setOf(TypeMirror elementType) {\n      return types.getDeclaredType(getClassElement(Set.class), boxPrimitives(elementType));\n    }\n\n    private DeclaredType mapOf(TypeMirror keyType, TypeMirror valueType) {\n      return types.getDeclaredType(\n          getClassElement(Map.class), boxPrimitives(keyType), boxPrimitives(valueType));\n    }\n\n    /** Returns {@code Map\u003cKeyType, FrameworkType\u003cValueType\u003e\u003e}. */\n    private TypeMirror mapOfFrameworkType(\n        TypeMirror keyType, TypeElement frameworkType, TypeMirror valueType) {\n      return mapOf(keyType, types.getDeclaredType(frameworkType, boxPrimitives(valueType)));\n    }\n\n    Key forComponentMethod(ExecutableElement componentMethod) {\n      checkArgument(componentMethod.getKind().equals(METHOD));\n      return forMethod(componentMethod, componentMethod.getReturnType());\n    }\n\n    Key forProductionComponentMethod(ExecutableElement componentMethod) {\n      checkArgument(componentMethod.getKind().equals(METHOD));\n      TypeMirror returnType \u003d componentMethod.getReturnType();\n      TypeMirror keyType \u003d\n          isTypeOf(ListenableFuture.class, returnType)\n              ? getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments())\n              : returnType;\n      return forMethod(componentMethod, keyType);\n    }\n\n    Key forSubcomponentBuilderMethod(\n        ExecutableElement subcomponentBuilderMethod, DeclaredType declaredContainer) {\n      checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));\n      ExecutableType resolvedMethod \u003d\n          asExecutable(types.asMemberOf(declaredContainer, subcomponentBuilderMethod));\n      return builder(resolvedMethod.getReturnType()).build();\n    }\n\n    Key forSubcomponentBuilder(TypeMirror builderType) {\n      return builder(builderType).build();\n    }\n\n    Key forProvidesMethod(ExecutableElement method, TypeElement contributingModule) {\n      return forBindingMethod(\n          method, contributingModule, Optional.of(getClassElement(Provider.class)));\n    }\n\n    Key forProducesMethod(ExecutableElement method, TypeElement contributingModule) {\n      return forBindingMethod(\n          method, contributingModule, Optional.of(getClassElement(Producer.class)));\n    }\n\n    /** Returns the key bound by a {@link Binds} method. */\n    Key forBindsMethod(ExecutableElement method, TypeElement contributingModule) {\n      checkArgument(isAnnotationPresent(method, Binds.class));\n      return forBindingMethod(method, contributingModule, Optional.\u003cTypeElement\u003eabsent());\n    }\n\n    /** Returns the base key bound by a {@link BindsOptionalOf} method. */\n    Key forBindsOptionalOfMethod(ExecutableElement method, TypeElement contributingModule) {\n      checkArgument(isAnnotationPresent(method, BindsOptionalOf.class));\n      return forBindingMethod(method, contributingModule, Optional.\u003cTypeElement\u003eabsent());\n    }\n\n    private Key forBindingMethod(\n        ExecutableElement method,\n        TypeElement contributingModule,\n        Optional\u003cTypeElement\u003e frameworkType) {\n      checkArgument(method.getKind().equals(METHOD));\n      ExecutableType methodType \u003d\n          MoreTypes.asExecutable(\n              types.asMemberOf(MoreTypes.asDeclared(contributingModule.asType()), method));\n      ContributionType contributionType \u003d ContributionType.fromBindingMethod(method);\n      TypeMirror returnType \u003d methodType.getReturnType();\n      if (frameworkType.isPresent()\n          \u0026\u0026 frameworkType.get().equals(getClassElement(Producer.class))\n          \u0026\u0026 isType(returnType)) {\n        if (isTypeOf(ListenableFuture.class, returnType)) {\n          returnType \u003d getOnlyElement(MoreTypes.asDeclared(returnType).getTypeArguments());\n        } else if (contributionType.equals(ContributionType.SET_VALUES)\n            \u0026\u0026 SetType.isSet(returnType)) {\n          SetType setType \u003d SetType.from(returnType);\n          if (setType.elementsAreTypeOf(ListenableFuture.class)) {\n            returnType \u003d\n                types.getDeclaredType(\n                    getClassElement(Set.class),\n                    setType.unwrappedElementType(ListenableFuture.class));\n          }\n        }\n      }\n      TypeMirror keyType \u003d\n          bindingMethodKeyType(returnType, method, contributionType, frameworkType);\n      Key key \u003d forMethod(method, keyType);\n      return contributionType.equals(ContributionType.UNIQUE)\n          ? key\n          : key.toBuilder()\n              .multibindingContributionIdentifier(\n                  new MultibindingContributionIdentifier(method, contributingModule))\n              .build();\n    }\n\n    /**\n     * Returns the key for a {@link Multibinds @Multibinds} method or a method in a\n     * {@link Multibindings @Multibindings} interface.\n     *\n     * \u003cp\u003eThe key\u0027s type is either {@code Set\u003cT\u003e} or {@code Map\u003cK, F\u003cV\u003e\u003e}, where {@code F} is either\n     * {@link Provider} or {@link Producer}, depending on {@code bindingType}.\n     */\n    Key forMultibindsMethod(\n        BindingType bindingType, ExecutableType executableType, ExecutableElement method) {\n      checkArgument(method.getKind().equals(METHOD), \"%s must be a method\", method);\n      TypeElement factoryType \u003d\n          elements.getTypeElement(bindingType.frameworkClass().getCanonicalName());\n      TypeMirror returnType \u003d executableType.getReturnType();\n      TypeMirror keyType \u003d\n          MapType.isMap(returnType)\n              ? mapOfFrameworkType(\n                  MapType.from(returnType).keyType(),\n                  factoryType,\n                  MapType.from(returnType).valueType())\n              : returnType;\n      return forMethod(method, keyType);\n    }\n\n    private TypeMirror bindingMethodKeyType(\n        TypeMirror returnType,\n        ExecutableElement method,\n        ContributionType contributionType,\n        Optional\u003cTypeElement\u003e frameworkType) {\n      switch (contributionType) {\n        case UNIQUE:\n          return returnType;\n        case SET:\n          return setOf(returnType);\n        case MAP:\n          if (frameworkType.isPresent()) {\n            return mapOfFrameworkType(mapKeyType(method), frameworkType.get(), returnType);\n          } else {\n            return mapOf(mapKeyType(method), returnType);\n          }\n        case SET_VALUES:\n          // TODO(gak): do we want to allow people to use \"covariant return\" here?\n          checkArgument(SetType.isSet(returnType));\n          return returnType;\n        default:\n          throw new AssertionError();\n      }\n    }\n\n    /**\n     * Returns the key for a binding associated with a {@link DelegateDeclaration}.\n     *\n     * If {@code delegateDeclaration} is {@code @IntoMap}, transforms the {@code Map\u003cK, V\u003e} key\n     * from {@link DelegateDeclaration#key()} to {@code Map\u003cK, FrameworkType\u003cV\u003e\u003e}. If {@code\n     * delegateDeclaration} is not a map contribution, its key is returned.\n     */\n    Key forDelegateBinding(\n        DelegateDeclaration delegateDeclaration, Class\u003c?\u003e frameworkType) {\n      return delegateDeclaration.contributionType().equals(ContributionType.MAP)\n          ? wrapMapValue(delegateDeclaration.key(), frameworkType)\n          : delegateDeclaration.key();\n    }\n\n    private TypeMirror mapKeyType(ExecutableElement method) {\n      AnnotationMirror mapKeyAnnotation \u003d getMapKey(method).get();\n      return MapKeys.unwrapValue(mapKeyAnnotation).isPresent()\n          ? getUnwrappedMapKeyType(mapKeyAnnotation.getAnnotationType(), types)\n          : mapKeyAnnotation.getAnnotationType();\n    }\n\n    private Key forMethod(ExecutableElement method, TypeMirror keyType) {\n      return forQualifiedType(getQualifier(method), keyType);\n    }\n\n    Key forInjectConstructorWithResolvedType(TypeMirror type) {\n      return builder(type).build();\n    }\n\n    Key forComponent(TypeMirror type) {\n      return builder(type).build();\n    }\n\n    Key forMembersInjectedType(TypeMirror type) {\n      return builder(type).build();\n    }\n\n    Key forQualifiedType(Optional\u003cAnnotationMirror\u003e qualifier, TypeMirror type) {\n      return builder(boxPrimitives(type)).qualifier(qualifier).build();\n    }\n\n    Key forProductionExecutor() {\n      return builder(getClassElement(Executor.class).asType())\n          .qualifier(getClassElement(Production.class))\n          .build();\n    }\n\n    Key forProductionImplementationExecutor() {\n      return builder(getClassElement(Executor.class).asType())\n          .qualifier(getClassElement(ProductionImplementation.class))\n          .build();\n    }\n\n    Key forProductionComponentMonitor() {\n      return builder(getClassElement(ProductionComponentMonitor.class).asType()).build();\n    }\n\n    /**\n     * If {@code requestKey} is for a {@code Map\u003cK, V\u003e} or {@code Map\u003cK, Produced\u003cV\u003e\u003e}, returns keys\n     * for {@code Map\u003cK, Provider\u003cV\u003e\u003e} and {@code Map\u003cK, Producer\u003cV\u003e\u003e} (if Dagger-Producers is on\n     * the classpath).\n     */\n    FluentIterable\u003cKey\u003e implicitFrameworkMapKeys(Key requestKey) {\n      return FluentIterable.from(\n          presentInstances(\n              ImmutableList.of(\n                  implicitMapProviderKeyFrom(requestKey), implicitMapProducerKeyFrom(requestKey))));\n    }\n\n    /**\n     * Optionally extract a {@link Key} for the underlying provision binding(s) if such a\n     * valid key can be inferred from the given key.  Specifically, if the key represents a\n     * {@link Map}{@code \u003cK, V\u003e}, a key of {@code Map\u003cK, Provider\u003cV\u003e\u003e} will be returned.\n     */\n    Optional\u003cKey\u003e implicitMapProviderKeyFrom(Key possibleMapKey) {\n      return wrapMapKey(possibleMapKey, Provider.class);\n    }\n\n    /**\n     * Optionally extract a {@link Key} for the underlying production binding(s) if such a\n     * valid key can be inferred from the given key.  Specifically, if the key represents a\n     * {@link Map}{@code \u003cK, V\u003e} or {@code Map\u003cK, Produced\u003cV\u003e\u003e}, a key of\n     * {@code Map\u003cK, Producer\u003cV\u003e\u003e} will be returned.\n     */\n    Optional\u003cKey\u003e implicitMapProducerKeyFrom(Key possibleMapKey) {\n      return rewrapMapKey(possibleMapKey, Produced.class, Producer.class)\n          .or(wrapMapKey(possibleMapKey, Producer.class));\n    }\n\n    /**\n     * Keys for map contributions from {@link dagger.Provides} and {@link dagger.producers.Produces}\n     * are in the form {@code Map\u003cK, Framework\u003cV\u003e\u003e}, but keys for {@link Binds} methods are just\n     * {@code Map\u003cK, V\u003e} since the framework type is not known until graph resolution. This\n     * translates from the {@code @Provides}/{@code @Produces} format into the {@code @Binds}\n     * format. If {@link Key#type() possibleMapKey.type()} is not a {@code Map\u003cK, Framework\u003cV\u003e\u003e},\n     * returns {@code possibleMapKey}.\n     */\n    Key convertToDelegateKey(Key possibleMapKey) {\n      if (!MapType.isMap(possibleMapKey)) {\n        return possibleMapKey;\n      }\n      MapType mapType \u003d MapType.from(possibleMapKey);\n      TypeMirror wrappedValueType;\n      if (mapType.valuesAreTypeOf(Provider.class)) {\n        wrappedValueType \u003d mapType.unwrappedValueType(Provider.class);\n      } else if (mapType.valuesAreTypeOf(Producer.class)) {\n        wrappedValueType \u003d mapType.unwrappedValueType(Producer.class);\n      } else {\n        return possibleMapKey;\n      }\n      return possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build();\n    }\n\n    /**\n     * Converts a {@link Key} of type {@code Map\u003cK, V\u003e} to {@code Map\u003cK, Provider\u003cV\u003e\u003e}.\n     */\n    private Key wrapMapValue(Key key, Class\u003c?\u003e newWrappingClass) {\n      checkArgument(\n          FrameworkTypes.isFrameworkType(\n              elements.getTypeElement(newWrappingClass.getName()).asType()));\n      return wrapMapKey(key, newWrappingClass).get();\n    }\n\n    /**\n     * If {@code key}\u0027s type is {@code Map\u003cK, CurrentWrappingClass\u003cBar\u003e\u003e}, returns a key with type\n     * {@code Map\u003cK, NewWrappingClass\u003cBar\u003e\u003e} with the same qualifier. Otherwise returns {@link\n     * Optional#absent()}.\n     *\n     * \u003cp\u003eReturns {@link Optional#absent()} if {@code newWrappingClass} is not in the classpath.\n     *\n     * @throws IllegalArgumentException if {@code newWrappingClass} is the same as {@code\n     *     currentWrappingClass}\n     */\n    Optional\u003cKey\u003e rewrapMapKey(\n        Key possibleMapKey, Class\u003c?\u003e currentWrappingClass, Class\u003c?\u003e newWrappingClass) {\n      checkArgument(!currentWrappingClass.equals(newWrappingClass));\n      if (MapType.isMap(possibleMapKey)) {\n        MapType mapType \u003d MapType.from(possibleMapKey);\n        if (mapType.valuesAreTypeOf(currentWrappingClass)) {\n          TypeElement wrappingElement \u003d getClassElement(newWrappingClass);\n          if (wrappingElement \u003d\u003d null) {\n            // This target might not be compiled with Producers, so wrappingClass might not have an\n            // associated element.\n            return Optional.absent();\n          }\n          DeclaredType wrappedValueType \u003d\n              types.getDeclaredType(\n                  wrappingElement, mapType.unwrappedValueType(currentWrappingClass));\n          return Optional.of(\n              possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build());\n        }\n      }\n      return Optional.absent();\n    }\n\n    /**\n     * If {@code key}\u0027s type is {@code Map\u003cK, Foo\u003e} and {@code Foo} is not {@code WrappingClass\n     * \u003cBar\u003e}, returns a key with type {@code Map\u003cK, WrappingClass\u003cFoo\u003e\u003e} with the same qualifier.\n     * Otherwise returns {@link Optional#absent()}.\n     *\n     * \u003cp\u003eReturns {@link Optional#absent()} if {@code WrappingClass} is not in the classpath.\n     */\n    private Optional\u003cKey\u003e wrapMapKey(Key possibleMapKey, Class\u003c?\u003e wrappingClass) {\n      if (MapType.isMap(possibleMapKey)) {\n        MapType mapType \u003d MapType.from(possibleMapKey);\n        if (!mapType.valuesAreTypeOf(wrappingClass)) {\n          TypeElement wrappingElement \u003d getClassElement(wrappingClass);\n          if (wrappingElement \u003d\u003d null) {\n            // This target might not be compiled with Producers, so wrappingClass might not have an\n            // associated element.\n            return Optional.absent();\n          }\n          DeclaredType wrappedValueType \u003d\n              types.getDeclaredType(wrappingElement, mapType.valueType());\n          return Optional.of(\n              possibleMapKey.toBuilder().type(mapOf(mapType.keyType(), wrappedValueType)).build());\n        }\n      }\n      return Optional.absent();\n    }\n\n    /**\n     * If {@code key}\u0027s type is {@code Set\u003cWrappingClass\u003cBar\u003e\u003e}, returns a key with type {@code Set\n     * \u003cBar\u003e} with the same qualifier. Otherwise returns {@link Optional#absent()}.\n     */\n    Optional\u003cKey\u003e unwrapSetKey(Key key, Class\u003c?\u003e wrappingClass) {\n      if (SetType.isSet(key)) {\n        SetType setType \u003d SetType.from(key);\n        if (setType.elementsAreTypeOf(wrappingClass)) {\n          return Optional.of(\n              key.toBuilder().type(setOf(setType.unwrappedElementType(wrappingClass))).build());\n        }\n      }\n      return Optional.absent();\n    }\n\n    /**\n     * If {@code key}\u0027s type is {@code Optional\u003cT\u003e} for some {@code T}, returns a key with the same\n     * qualifier whose type is {@linkplain DependencyRequest#extractKindAndType(TypeMirror)\n     * extracted} from {@code T}.\n     */\n    Optional\u003cKey\u003e unwrapOptional(Key key) {\n      if (!OptionalType.isOptional(key)) {\n        return Optional.absent();\n      }\n      TypeMirror underlyingType \u003d\n          DependencyRequest.extractKindAndType(OptionalType.from(key).valueType()).type();\n      return Optional.of(key.toBuilder().type(underlyingType).build());\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\KeyFormatter.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\n/** Formats a {@link Key} into a {@link String} suitable for use in error messages. */\nfinal class KeyFormatter extends Formatter\u003cKey\u003e {\n  @Override\n  public String format(Key key) {\n    return key.toString();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MapKeyProcessingStep.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static dagger.internal.codegen.MapKeys.getUnwrappedMapKeyType;\nimport static javax.lang.model.element.ElementKind.ANNOTATION_TYPE;\nimport static javax.lang.model.util.ElementFilter.typesIn;\n\nimport com.google.auto.common.BasicAnnotationProcessor;\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.SetMultimap;\nimport dagger.MapKey;\nimport java.lang.annotation.Annotation;\nimport java.util.Set;\nimport javax.annotation.processing.Messager;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ElementKind;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.util.Types;\n\n/**\n * The annotation processor responsible for validating the mapKey annotation and auto-generate\n * implementation of annotations marked with {@link MapKey @MapKey} where necessary.\n *\n * @author Chenying Hou\n * @since 2.0\n */\npublic class MapKeyProcessingStep implements BasicAnnotationProcessor.ProcessingStep {\n  private final Messager messager;\n  private final Types types;\n  private final MapKeyValidator mapKeyValidator;\n  private final AnnotationCreatorGenerator annotationCreatorGenerator;\n  private final UnwrappedMapKeyGenerator unwrappedMapKeyGenerator;\n\n  MapKeyProcessingStep(\n      Messager messager,\n      Types types,\n      MapKeyValidator mapKeyValidator,\n      AnnotationCreatorGenerator annotationCreatorGenerator,\n      UnwrappedMapKeyGenerator unwrappedMapKeyGenerator) {\n    this.messager \u003d messager;\n    this.types \u003d types;\n    this.mapKeyValidator \u003d mapKeyValidator;\n    this.annotationCreatorGenerator \u003d annotationCreatorGenerator;\n    this.unwrappedMapKeyGenerator \u003d unwrappedMapKeyGenerator;\n  }\n\n  @Override\n  public Set\u003cClass\u003c? extends Annotation\u003e\u003e annotations() {\n    return ImmutableSet.\u003cClass\u003c? extends Annotation\u003e\u003eof(MapKey.class);\n  }\n\n  @Override\n  public Set\u003cElement\u003e process(\n      SetMultimap\u003cClass\u003c? extends Annotation\u003e, Element\u003e elementsByAnnotation) {\n    for (TypeElement mapKeyAnnotationType : typesIn(elementsByAnnotation.get(MapKey.class))) {\n      ValidationReport\u003cElement\u003e mapKeyReport \u003d mapKeyValidator.validate(mapKeyAnnotationType);\n      mapKeyReport.printMessagesTo(messager);\n\n      if (mapKeyReport.isClean()) {\n        MapKey mapkey \u003d mapKeyAnnotationType.getAnnotation(MapKey.class);\n        if (!mapkey.unwrapValue()) {\n          annotationCreatorGenerator.generate(mapKeyAnnotationType, messager);\n        } else if (unwrappedValueKind(mapKeyAnnotationType).equals(ANNOTATION_TYPE)) {\n          unwrappedMapKeyGenerator.generate(mapKeyAnnotationType, messager);\n        }\n      }\n    }\n    return ImmutableSet.of();\n  }\n\n  private ElementKind unwrappedValueKind(TypeElement mapKeyAnnotationType) {\n    DeclaredType unwrappedMapKeyType \u003d\n        getUnwrappedMapKeyType(MoreTypes.asDeclared(mapKeyAnnotationType.asType()), types);\n    return unwrappedMapKeyType.asElement().getKind();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MapKeys.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.AnnotationMirrors.getAnnotatedAnnotations;\nimport static com.google.auto.common.AnnotationMirrors.getAnnotationValuesWithDefaults;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static javax.lang.model.util.ElementFilter.methodsIn;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableSet;\nimport com.squareup.javapoet.CodeBlock;\nimport dagger.MapKey;\nimport java.util.NoSuchElementException;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.AnnotationValue;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ElementKind;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.type.ArrayType;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.PrimitiveType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.SimpleTypeVisitor6;\nimport javax.lang.model.util.Types;\n\n/**\n * Methods for extracting {@link MapKey} annotations and key code blocks from binding elements.\n */\nfinal class MapKeys {\n\n  /**\n   * If {@code bindingElement} is annotated with a {@link MapKey} annotation, returns it.\n   *\n   * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}\n   *     annotation\n   */\n  static Optional\u003cAnnotationMirror\u003e getMapKey(Element bindingElement) {\n    ImmutableSet\u003c? extends AnnotationMirror\u003e mapKeys \u003d getMapKeys(bindingElement);\n    return mapKeys.isEmpty()\n        ? Optional.\u003cAnnotationMirror\u003eabsent()\n        : Optional.\u003cAnnotationMirror\u003eof(getOnlyElement(mapKeys));\n  }\n\n  /**\n   * Returns all of the {@link MapKey} annotations that annotate {@code bindingElement}.\n   */\n  static ImmutableSet\u003c? extends AnnotationMirror\u003e getMapKeys(Element bindingElement) {\n    return getAnnotatedAnnotations(bindingElement, MapKey.class);\n  }\n\n  /**\n   * Returns the annotation value if {@code mapKey}\u0027s type is annotated with\n   * {@link MapKey @MapKey(unwrapValue \u003d true)}.\n   *\n   * @throws IllegalArgumentException if {@code mapKey}\u0027s type is not annotated with\n   *     {@link MapKey @MapKey} at all.\n   */\n  static Optional\u003c? extends AnnotationValue\u003e unwrapValue(AnnotationMirror mapKey) {\n    MapKey mapKeyAnnotation \u003d mapKey.getAnnotationType().asElement().getAnnotation(MapKey.class);\n    checkArgument(\n        mapKeyAnnotation !\u003d null, \"%s is not annotated with @MapKey\", mapKey.getAnnotationType());\n    return mapKeyAnnotation.unwrapValue()\n        ? Optional.of(getOnlyElement(getAnnotationValuesWithDefaults(mapKey).values()))\n        : Optional.\u003cAnnotationValue\u003eabsent();\n  }\n\n  /**\n   * Returns the map key type for an unwrapped {@link MapKey} annotation type. If the single member\n   * type is primitive, returns the boxed type.\n   *\n   * @throws IllegalArgumentException if {@code mapKeyAnnotationType} is not an annotation type or\n   *     has more than one member, or if its single member is an array\n   * @throws NoSuchElementException if the annotation has no members\n   */\n  public static DeclaredType getUnwrappedMapKeyType(\n      final DeclaredType mapKeyAnnotationType, final Types types) {\n    checkArgument(\n        MoreTypes.asTypeElement(mapKeyAnnotationType).getKind() \u003d\u003d ElementKind.ANNOTATION_TYPE,\n        \"%s is not an annotation type\",\n        mapKeyAnnotationType);\n\n    final ExecutableElement onlyElement \u003d\n        getOnlyElement(methodsIn(mapKeyAnnotationType.asElement().getEnclosedElements()));\n\n    SimpleTypeVisitor6\u003cDeclaredType, Void\u003e keyTypeElementVisitor \u003d\n        new SimpleTypeVisitor6\u003cDeclaredType, Void\u003e() {\n\n          @Override\n          public DeclaredType visitArray(ArrayType t, Void p) {\n            throw new IllegalArgumentException(\n                mapKeyAnnotationType + \".\" + onlyElement.getSimpleName() + \" cannot be an array\");\n          }\n\n          @Override\n          public DeclaredType visitPrimitive(PrimitiveType t, Void p) {\n            return MoreTypes.asDeclared(types.boxedClass(t).asType());\n          }\n\n          @Override\n          public DeclaredType visitDeclared(DeclaredType t, Void p) {\n            return t;\n          }\n        };\n    return keyTypeElementVisitor.visit(onlyElement.getReturnType());\n  }\n\n  /**\n   * Returns a code block for the map key specified by the {@link MapKey} annotation on\n   * {@code bindingElement}.\n   *\n   * @throws IllegalArgumentException if the element is annotated with more than one {@code MapKey}\n   *     annotation\n   * @throws IllegalStateException if {@code bindingElement} is not annotated with a {@code MapKey}\n   *     annotation\n   */\n  static CodeBlock getMapKeyExpression(AnnotationMirror mapKey) {\n    Optional\u003c? extends AnnotationValue\u003e unwrappedValue \u003d unwrapValue(mapKey);\n    AnnotationExpression annotationExpression \u003d new AnnotationExpression(mapKey);\n    if (unwrappedValue.isPresent()) {\n      TypeMirror unwrappedValueType \u003d\n          getOnlyElement(getAnnotationValuesWithDefaults(mapKey).keySet()).getReturnType();\n      return annotationExpression.getValueExpression(unwrappedValueType, unwrappedValue.get());\n    } else {\n      return annotationExpression.getAnnotationInstanceExpression();\n    }\n  }\n\n  private MapKeys() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MapKeyValidator.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static dagger.internal.codegen.ErrorMessages.MAPKEY_WITHOUT_MEMBERS;\nimport static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER;\nimport static dagger.internal.codegen.ErrorMessages.UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS;\nimport static javax.lang.model.util.ElementFilter.methodsIn;\n\nimport dagger.MapKey;\nimport java.util.List;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.TypeKind;\n\n/**\n * A validator for {@link MapKey} annotations.\n *\n * @author Chenying Hou\n * @since 2.0\n */\n// TODO(dpb,gak): Should unwrapped MapKeys be required to have their single member be named \"value\"?\nfinal class MapKeyValidator {\n  ValidationReport\u003cElement\u003e validate(Element element) {\n    ValidationReport.Builder\u003cElement\u003e builder \u003d ValidationReport.about(element);\n    List\u003cExecutableElement\u003e members \u003d methodsIn(((TypeElement) element).getEnclosedElements());\n    if (members.isEmpty()) {\n      builder.addError(MAPKEY_WITHOUT_MEMBERS, element);\n    } else if (element.getAnnotation(MapKey.class).unwrapValue()) {\n      if (members.size() \u003e 1) {\n        builder.addError(UNWRAPPED_MAP_KEY_WITH_TOO_MANY_MEMBERS, element);\n      } else if (members.get(0).getReturnType().getKind() \u003d\u003d TypeKind.ARRAY) {\n        builder.addError(UNWRAPPED_MAP_KEY_WITH_ARRAY_MEMBER, element);\n      }\n    }\n    return builder.build();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MapType.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkState;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Equivalence;\nimport java.util.Map;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeMirror;\n\n/**\n * Information about a {@link Map} {@link TypeMirror}.\n */\n@AutoValue\nabstract class MapType {\n  /**\n   * The map type itself, wrapped using {@link MoreTypes#equivalence()}. Use\n   * {@link #declaredMapType()} instead.\n   */\n  protected abstract Equivalence.Wrapper\u003cDeclaredType\u003e wrappedDeclaredMapType();\n\n  /**\n   * The map type itself.\n   */\n  DeclaredType declaredMapType() {\n    return wrappedDeclaredMapType().get();\n  }\n\n  /**\n   * {@code true} if the map type is the raw {@link Map} type.\n   */\n  boolean isRawType() {\n    return declaredMapType().getTypeArguments().isEmpty();\n  }\n\n  /**\n   * The map key type.\n   * \n   * @throws IllegalStateException if {@link #isRawType()} is true.\n   */\n  TypeMirror keyType() {\n    checkState(!isRawType());\n    return declaredMapType().getTypeArguments().get(0);\n  }\n\n  /**\n   * The map value type.\n   * \n   * @throws IllegalStateException if {@link #isRawType()} is true.\n   */\n  TypeMirror valueType() {\n    checkState(!isRawType());\n    return declaredMapType().getTypeArguments().get(1);\n  }\n\n  /**\n   * {@code true} if {@link #valueType()} is a {@code clazz}.\n   * \n   * @throws IllegalStateException if {@link #isRawType()} is true.\n   */\n  boolean valuesAreTypeOf(Class\u003c?\u003e clazz) {\n    return MoreTypes.isType(valueType()) \u0026\u0026 MoreTypes.isTypeOf(clazz, valueType());\n  }\n\n  /**\n   * Returns {@code true} if the {@linkplain #valueType() value type} of the {@link Map} is a\n   * {@linkplain FrameworkTypes#isFrameworkType(TypeMirror) framework type}.\n   */\n  boolean valuesAreFrameworkType() {\n    return FrameworkTypes.isFrameworkType(valueType());\n  }\n  \n  /**\n   * {@code V} if {@link #valueType()} is a {@code WrappingClass\u003cV\u003e}.\n   *\n   * @throws IllegalStateException if {@link #isRawType()} is true or {@link #valueType()} is not a\n   *     {@code WrappingClass\u003cV\u003e}\n   * @throws IllegalArgumentException if {@code wrappingClass} does not have exactly one type\n   *     parameter\n   */\n  TypeMirror unwrappedValueType(Class\u003c?\u003e wrappingClass) {\n    checkArgument(\n        wrappingClass.getTypeParameters().length \u003d\u003d 1,\n        \"%s must have exactly one type parameter\",\n        wrappingClass);\n    checkState(valuesAreTypeOf(wrappingClass), \"expected values to be %s: %s\", wrappingClass, this);\n    return MoreTypes.asDeclared(valueType()).getTypeArguments().get(0);\n  }\n\n  /**\n   * {@code true} if {@code type} is a {@link Map} type.\n   */\n  static boolean isMap(TypeMirror type) {\n    return MoreTypes.isType(type) \u0026\u0026 MoreTypes.isTypeOf(Map.class, type);\n  }\n\n  /**\n   * {@code true} if {@code key.type()} is a {@link Map} type.\n   */\n  static boolean isMap(Key key) {\n    return isMap(key.type());\n  }\n\n  /**\n   * Returns a {@link MapType} for {@code type}.\n   *\n   * @throws IllegalArgumentException if {@code type} is not a {@link Map} type\n   */\n  static MapType from(TypeMirror type) {\n    checkArgument(isMap(type), \"%s is not a Map\", type);\n    return new AutoValue_MapType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));\n  }\n\n  /**\n   * Returns a {@link MapType} for {@code key}\u0027s {@link Key#type() type}.\n   *\n   * @throws IllegalArgumentException if {@code key.type()} is not a {@link Map} type\n   */\n  static MapType from(Key key) {\n    return from(key.type());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MemberSelect.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static dagger.internal.codegen.Accessibility.isTypeAccessibleFrom;\nimport static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;\nimport static dagger.internal.codegen.CodeBlocks.toCodeBlocks;\nimport static dagger.internal.codegen.TypeNames.FACTORY;\nimport static dagger.internal.codegen.TypeNames.MAP_OF_PRODUCER_PRODUCER;\nimport static dagger.internal.codegen.TypeNames.MAP_PROVIDER_FACTORY;\nimport static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;\nimport static dagger.internal.codegen.TypeNames.MEMBERS_INJECTORS;\n\nimport com.google.common.collect.ImmutableList;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport dagger.MembersInjector;\nimport dagger.internal.MapProviderFactory;\nimport dagger.producers.internal.MapOfProducerProducer;\nimport java.util.List;\nimport java.util.Set;\nimport javax.lang.model.type.TypeMirror;\n\n/**\n * Represents a {@link com.sun.source.tree.MemberSelectTree} as a {@link CodeBlock}.\n */\nabstract class MemberSelect {\n  /**\n   * Returns a {@link MemberSelect} that accesses the field given by {@code fieldName} owned by\n   * {@code owningClass}.  In this context \"local\" refers to the fact that the field is owned by the\n   * type (or an enclosing type) from which the code block will be used.  The returned\n   * {@link MemberSelect} will not be valid for accessing the field from a different class\n   * (regardless of accessibility).\n   */\n  static MemberSelect localField(ClassName owningClass, String fieldName) {\n    return new LocalField(owningClass, fieldName);\n  }\n\n  private static final class LocalField extends MemberSelect {\n    final String fieldName;\n\n    LocalField(ClassName owningClass, String fieldName) {\n      super(owningClass, false);\n      this.fieldName \u003d checkNotNull(fieldName);\n    }\n\n    @Override\n    CodeBlock getExpressionFor(ClassName usingClass) {\n      return owningClass().equals(usingClass)\n          ? CodeBlock.of(\"$L\", fieldName)\n          : CodeBlock.of(\"$T.this.$L\", owningClass(), fieldName);\n    }\n  }\n\n  /**\n   * Returns a {@link MemberSelect} for the invocation of a static method (given by\n   * {@code methodInvocationCodeBlock}) on the {@code owningClass}.\n   */\n  static MemberSelect staticMethod(ClassName owningClass, CodeBlock methodInvocationCodeBlock) {\n    return new StaticMethod(owningClass, methodInvocationCodeBlock);\n  }\n\n  /**\n   * Returns a {@link MemberSelect} for the instance of a {@code create()} method on a factory.\n   * This only applies for factories that do not have any dependencies.\n   */\n  static MemberSelect parameterizedFactoryCreateMethod(\n      ClassName owningClass, List\u003c? extends TypeMirror\u003e parameters) {\n    return new ParameterizedStaticMethod(\n        owningClass,\n        ImmutableList.\u003cTypeMirror\u003ecopyOf(parameters),\n        CodeBlock.of(\"create()\"),\n        FACTORY);\n  }\n\n  private static final class StaticMethod extends MemberSelect {\n    final CodeBlock methodCodeBlock;\n\n    StaticMethod(ClassName owningClass, CodeBlock methodCodeBlock) {\n      super(owningClass, true);\n      this.methodCodeBlock \u003d checkNotNull(methodCodeBlock);\n    }\n\n    @Override\n    CodeBlock getExpressionFor(ClassName usingClass) {\n      return owningClass().equals(usingClass)\n          ? methodCodeBlock\n          : CodeBlock.of(\"$T.$L\", owningClass(), methodCodeBlock);\n    }\n  }\n\n  /**\n   * Returns the {@link MemberSelect} for a no-op {@link MembersInjector} for the given type.\n   */\n  static MemberSelect noOpMembersInjector(TypeMirror type) {\n    return new ParameterizedStaticMethod(\n        MEMBERS_INJECTORS,\n        ImmutableList.of(type),\n        CodeBlock.of(\"noOp()\"),\n        MEMBERS_INJECTOR);\n  }\n\n  /**\n   * A {@link MemberSelect} for an empty map of framework types.\n   *\n   * @param frameworkMapFactoryClass either {@link MapProviderFactory}\n   *     or {@link MapOfProducerProducer}\n   */\n  static MemberSelect emptyFrameworkMapFactory(\n      ClassName frameworkMapFactoryClass, TypeMirror keyType, TypeMirror unwrappedValueType) {\n    checkArgument(\n        frameworkMapFactoryClass.equals(MAP_PROVIDER_FACTORY)\n            || frameworkMapFactoryClass.equals(MAP_OF_PRODUCER_PRODUCER),\n        \"frameworkMapFactoryClass must be MapProviderFactory or MapOfProducerProducer: %s\",\n        frameworkMapFactoryClass);\n    return new ParameterizedStaticMethod(\n        frameworkMapFactoryClass,\n        ImmutableList.of(keyType, unwrappedValueType),\n        CodeBlock.of(\"empty()\"),\n        frameworkMapFactoryClass);\n  }\n\n  /**\n   * Returns the {@link MemberSelect} for an empty set provider.  Since there are several different\n   * implementations for a multibound {@link Set}, the caller is responsible for passing the\n   * correct factory.\n   */\n  static MemberSelect emptySetProvider(ClassName setFactoryType, SetType setType) {\n    return new ParameterizedStaticMethod(\n        setFactoryType, ImmutableList.of(setType.elementType()), CodeBlock.of(\"empty()\"), FACTORY);\n  }\n\n  private static final class ParameterizedStaticMethod extends MemberSelect {\n    final ImmutableList\u003cTypeMirror\u003e typeParameters;\n    final CodeBlock methodCodeBlock;\n    final ClassName rawReturnType;\n\n    ParameterizedStaticMethod(\n        ClassName owningClass,\n        ImmutableList\u003cTypeMirror\u003e typeParameters,\n        CodeBlock methodCodeBlock,\n        ClassName rawReturnType) {\n      super(owningClass, true);\n      this.typeParameters \u003d typeParameters;\n      this.methodCodeBlock \u003d methodCodeBlock;\n      this.rawReturnType \u003d rawReturnType;\n    }\n\n    @Override\n    CodeBlock getExpressionFor(ClassName usingClass) {\n      boolean accessible \u003d true;\n      for (TypeMirror typeParameter : typeParameters) {\n        accessible \u0026\u003d isTypeAccessibleFrom(typeParameter, usingClass.packageName());\n      }\n\n      if (accessible) {\n        return CodeBlock.of(\n            \"$T.\u003c$L\u003e$L\",\n            owningClass(),\n            makeParametersCodeBlock(toCodeBlocks(typeParameters)),\n            methodCodeBlock);\n      } else {\n        return CodeBlock.of(\"(($T) $T.$L)\", rawReturnType, owningClass(), methodCodeBlock);\n      }\n    }\n  }\n\n  private final ClassName owningClass;\n  private final boolean staticMember;\n\n  MemberSelect(ClassName owningClass, boolean staticMemeber) {\n    this.owningClass \u003d owningClass;\n    this.staticMember \u003d staticMemeber;\n  }\n\n  /** Returns the class that owns the member being selected. */\n  ClassName owningClass() {\n    return owningClass;\n  }\n\n  /**\n   * Returns true if the member being selected is static and does not require an instance of\n   * {@link #owningClass()}.\n   */\n  boolean staticMember() {\n    return staticMember;\n  }\n\n  /**\n   * Returns a {@link CodeBlock} suitable for accessing the member from the given {@code\n   * usingClass}.\n   */\n  abstract CodeBlock getExpressionFor(ClassName usingClass);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MembersInjectionBinding.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.element.Modifier.STATIC;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.LinkedHashMultimap;\nimport com.google.common.collect.SetMultimap;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport javax.inject.Inject;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ElementKind;\nimport javax.lang.model.element.ElementVisitor;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.ElementKindVisitor6;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/**\n * Represents the full members injection of a particular type.\n *\n * @author Gregory Kick\n * @since 2.0\n */\n@AutoValue\nabstract class MembersInjectionBinding extends Binding {\n  @Override\n  Optional\u003cElement\u003e bindingElement() {\n    return Optional.\u003cElement\u003eof(membersInjectedType());\n  }\n\n  abstract TypeElement membersInjectedType();\n\n  @Override\n  abstract Optional\u003cMembersInjectionBinding\u003e unresolved();\n\n  @Override\n  Optional\u003cTypeElement\u003e contributingModule() {\n    return Optional.absent();\n  }\n\n  /** The set of individual sites where {@link Inject} is applied. */\n  abstract ImmutableSortedSet\u003cInjectionSite\u003e injectionSites();\n\n  /**\n   * The {@link Key} for the non-object superclass of {@link #bindingElement()}. Absent if\n   * {@link #bindingElement()} is a direct subclass of {@link Object}. \n   */\n  abstract Optional\u003cKey\u003e parentKey();\n\n  enum Strategy {\n    NO_OP,\n    INJECT_MEMBERS,\n  }\n\n  Strategy injectionStrategy() {\n    return injectionSites().isEmpty() ? Strategy.NO_OP : Strategy.INJECT_MEMBERS;\n  }\n\n  @Override\n  public BindingType bindingType() {\n    return BindingType.MEMBERS_INJECTION;\n  }\n\n  /**\n   * Returns {@code true} if any of this binding\u0027s injection sites are directly on the bound type.\n   */\n  boolean hasLocalInjectionSites() {\n    return FluentIterable.from(injectionSites())\n        .anyMatch(\n            injectionSite -\u003e\n                injectionSite.element().getEnclosingElement().equals(membersInjectedType()));\n  }\n\n  @AutoValue\n  abstract static class InjectionSite {\n    enum Kind {\n      FIELD,\n      METHOD,\n    }\n\n    abstract Kind kind();\n\n    abstract Element element();\n\n    abstract ImmutableSet\u003cDependencyRequest\u003e dependencies();\n    \n    static int indexAmongSiblingMembers(InjectionSite injectionSite) {\n      return injectionSite\n          .element()\n          .getEnclosingElement()\n          .getEnclosedElements()\n          .indexOf(injectionSite.element());\n    }\n  }\n\n  static final class Factory {\n    private final Elements elements;\n    private final Types types;\n    private final Key.Factory keyFactory;\n    private final DependencyRequest.Factory dependencyRequestFactory;\n\n    Factory(Elements elements, Types types, Key.Factory keyFactory,\n        DependencyRequest.Factory dependencyRequestFactory) {\n      this.elements \u003d checkNotNull(elements);\n      this.types \u003d checkNotNull(types);\n      this.keyFactory \u003d checkNotNull(keyFactory);\n      this.dependencyRequestFactory \u003d checkNotNull(dependencyRequestFactory);\n    }\n\n    private InjectionSite injectionSiteForInjectMethod(\n        ExecutableElement methodElement, DeclaredType containingType) {\n      checkNotNull(methodElement);\n      checkArgument(methodElement.getKind().equals(ElementKind.METHOD));\n      ExecutableType resolved \u003d\n          MoreTypes.asExecutable(types.asMemberOf(containingType, methodElement));\n      return new AutoValue_MembersInjectionBinding_InjectionSite(\n          InjectionSite.Kind.METHOD,\n          methodElement,\n          dependencyRequestFactory.forRequiredResolvedVariables(\n              methodElement.getParameters(), resolved.getParameterTypes()));\n    }\n\n    private InjectionSite injectionSiteForInjectField(\n        VariableElement fieldElement, DeclaredType containingType) {\n      checkNotNull(fieldElement);\n      checkArgument(fieldElement.getKind().equals(ElementKind.FIELD));\n      checkArgument(isAnnotationPresent(fieldElement, Inject.class));\n      TypeMirror resolved \u003d types.asMemberOf(containingType, fieldElement);\n      return new AutoValue_MembersInjectionBinding_InjectionSite(\n          InjectionSite.Kind.FIELD,\n          fieldElement,\n          ImmutableSet.of(\n              dependencyRequestFactory.forRequiredResolvedVariable(fieldElement, resolved)));\n    }\n\n    /** Returns true if the type has some injected members in itself or any of its super classes. */\n    boolean hasInjectedMembers(DeclaredType declaredType) {\n      return !getInjectionSites(declaredType).isEmpty();\n    }\n\n    /**\n     * Returns a MembersInjectionBinding for the given type. If {@code resolvedType} is present,\n     * this will return a resolved binding, with the key \u0026 type resolved to the given type (using\n     * {@link Types#asMemberOf(DeclaredType, Element)}).\n     */\n    MembersInjectionBinding forInjectedType(\n        DeclaredType declaredType, Optional\u003cTypeMirror\u003e resolvedType) {\n      // If the class this is injecting has some type arguments, resolve everything.\n      if (!declaredType.getTypeArguments().isEmpty() \u0026\u0026 resolvedType.isPresent()) {\n        DeclaredType resolved \u003d MoreTypes.asDeclared(resolvedType.get());\n        // Validate that we\u0027re resolving from the correct type.\n        checkState(\n            types.isSameType(types.erasure(resolved), types.erasure(declaredType)),\n            \"erased expected type: %s, erased actual type: %s\",\n            types.erasure(resolved),\n            types.erasure(declaredType));\n        declaredType \u003d resolved;\n      }\n      ImmutableSortedSet\u003cInjectionSite\u003e injectionSites \u003d getInjectionSites(declaredType);\n      ImmutableSet\u003cDependencyRequest\u003e dependencies \u003d\n          FluentIterable.from(injectionSites)\n              .transformAndConcat(InjectionSite::dependencies)\n              .toSet();\n\n      Optional\u003cKey\u003e parentKey \u003d\n          MoreTypes.nonObjectSuperclass(types, elements, declaredType)\n              .transform(keyFactory::forMembersInjectedType);\n\n      Key key \u003d keyFactory.forMembersInjectedType(declaredType);\n      TypeElement typeElement \u003d MoreElements.asType(declaredType.asElement());\n      return new AutoValue_MembersInjectionBinding(\n          key,\n          dependencies,\n          typeElement,\n          hasNonDefaultTypeParameters(typeElement, key.type(), types)\n              ? Optional.of(\n                  forInjectedType(\n                      MoreTypes.asDeclared(typeElement.asType()), Optional.\u003cTypeMirror\u003eabsent()))\n              : Optional.\u003cMembersInjectionBinding\u003eabsent(),\n          injectionSites,\n          parentKey);\n    }\n\n    private ImmutableSortedSet\u003cInjectionSite\u003e getInjectionSites(DeclaredType declaredType) {\n      Set\u003cInjectionSite\u003e injectionSites \u003d new HashSet\u003c\u003e();\n      final List\u003cTypeElement\u003e ancestors \u003d new ArrayList\u003c\u003e();\n      SetMultimap\u003cString, ExecutableElement\u003e overriddenMethodMap \u003d LinkedHashMultimap.create();\n      for (Optional\u003cDeclaredType\u003e currentType \u003d Optional.of(declaredType);\n          currentType.isPresent();\n          currentType \u003d MoreTypes.nonObjectSuperclass(types, elements, currentType.get())) {\n        final DeclaredType type \u003d currentType.get();\n        ancestors.add(MoreElements.asType(type.asElement()));\n        for (Element enclosedElement : type.asElement().getEnclosedElements()) {\n          Optional\u003cInjectionSite\u003e maybeInjectionSite \u003d\n              injectionSiteVisitor.visit(enclosedElement, type);\n          if (maybeInjectionSite.isPresent()) {\n            InjectionSite injectionSite \u003d maybeInjectionSite.get();\n            if (shouldBeInjected(injectionSite.element(), overriddenMethodMap)) {\n              injectionSites.add(injectionSite);\n            }\n            if (injectionSite.kind() \u003d\u003d InjectionSite.Kind.METHOD) {\n              ExecutableElement injectionSiteMethod \u003d\n                  MoreElements.asExecutable(injectionSite.element());\n              overriddenMethodMap.put(\n                  injectionSiteMethod.getSimpleName().toString(), injectionSiteMethod);\n            }\n          }\n        }\n      }\n      return ImmutableSortedSet.copyOf(\n          // supertypes before subtypes\n          Comparator.comparing(\n                  (InjectionSite injectionSite) -\u003e\n                      ancestors.indexOf(injectionSite.element().getEnclosingElement()))\n              .reversed()\n              // fields before methods\n              .thenComparing(injectionSite -\u003e injectionSite.element().getKind())\n              // then sort by whichever element comes first in the parent\n              // this isn\u0027t necessary, but makes the processor nice and predictable\n              .thenComparing(InjectionSite::indexAmongSiblingMembers),\n          injectionSites);\n    }\n\n    private boolean shouldBeInjected(\n        Element injectionSite, SetMultimap\u003cString, ExecutableElement\u003e overriddenMethodMap) {\n      if (!isAnnotationPresent(injectionSite, Inject.class)\n          || injectionSite.getModifiers().contains(PRIVATE)\n          || injectionSite.getModifiers().contains(STATIC)) {\n        return false;\n      }\n\n      if (injectionSite.getKind().isField()) { // Inject all fields (self and ancestors)\n        return true;\n      }\n\n      // For each method with the same name belonging to any descendant class, return false if any\n      // method has already overridden the injectionSite method. To decrease the number of methods\n      // that are checked, we store the already injected methods in a SetMultimap and only\n      // check the methods with the same name.\n      ExecutableElement injectionSiteMethod \u003d MoreElements.asExecutable(injectionSite);\n      TypeElement injectionSiteType \u003d MoreElements.asType(injectionSite.getEnclosingElement());\n      for (ExecutableElement method :\n          overriddenMethodMap.get(injectionSiteMethod.getSimpleName().toString())) {\n        if (elements.overrides(method, injectionSiteMethod, injectionSiteType)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private final ElementVisitor\u003cOptional\u003cInjectionSite\u003e, DeclaredType\u003e injectionSiteVisitor \u003d\n        new ElementKindVisitor6\u003cOptional\u003cInjectionSite\u003e, DeclaredType\u003e(Optional.absent()) {\n          @Override\n          public Optional\u003cInjectionSite\u003e visitExecutableAsMethod(\n              ExecutableElement e, DeclaredType type) {\n            return Optional.of(injectionSiteForInjectMethod(e, type));\n          }\n\n          @Override\n          public Optional\u003cInjectionSite\u003e visitVariableAsField(\n              VariableElement e, DeclaredType type) {\n            return (isAnnotationPresent(e, Inject.class)\n                    \u0026\u0026 !e.getModifiers().contains(PRIVATE)\n                    \u0026\u0026 !e.getModifiers().contains(STATIC))\n                ? Optional.of(injectionSiteForInjectField(e, type))\n                : Optional.absent();\n          }\n        };\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MembersInjectorGenerator.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getPackage;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static com.squareup.javapoet.MethodSpec.constructorBuilder;\nimport static com.squareup.javapoet.MethodSpec.methodBuilder;\nimport static com.squareup.javapoet.TypeSpec.classBuilder;\nimport static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;\nimport static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;\nimport static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;\nimport static dagger.internal.codegen.SourceFiles.bindingTypeElementTypeVariableNames;\nimport static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;\nimport static dagger.internal.codegen.SourceFiles.membersInjectorNameForType;\nimport static dagger.internal.codegen.SourceFiles.parameterizedGeneratedTypeNameForBinding;\nimport static dagger.internal.codegen.TypeNames.membersInjectorOf;\nimport static javax.lang.model.element.Modifier.FINAL;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.element.Modifier.PUBLIC;\nimport static javax.lang.model.element.Modifier.STATIC;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.common.base.CaseFormat;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport com.squareup.javapoet.FieldSpec;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.ParameterSpec;\nimport com.squareup.javapoet.ParameterizedTypeName;\nimport com.squareup.javapoet.TypeName;\nimport com.squareup.javapoet.TypeSpec;\nimport com.squareup.javapoet.TypeVariableName;\nimport dagger.MembersInjector;\nimport dagger.internal.codegen.MembersInjectionBinding.InjectionSite;\nimport dagger.producers.Producer;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport javax.annotation.processing.Filer;\nimport javax.inject.Provider;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.type.ArrayType;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeVisitor;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.SimpleTypeVisitor7;\n\n/**\n * Generates {@link MembersInjector} implementations from {@link MembersInjectionBinding} instances.\n *\n * @author Gregory Kick\n * @since 2.0\n */\nfinal class MembersInjectorGenerator extends SourceFileGenerator\u003cMembersInjectionBinding\u003e {\n  private final InjectValidator injectValidator;\n\n  MembersInjectorGenerator(Filer filer, Elements elements, InjectValidator injectValidator) {\n    super(filer, elements);\n    this.injectValidator \u003d injectValidator;\n  }\n\n  @Override\n  ClassName nameGeneratedType(MembersInjectionBinding binding) {\n    return membersInjectorNameForType(binding.membersInjectedType());\n  }\n\n  @Override\n  Optional\u003c? extends Element\u003e getElementForErrorReporting(MembersInjectionBinding binding) {\n    return Optional.of(binding.membersInjectedType());\n  }\n\n  @Override\n  Optional\u003cTypeSpec.Builder\u003e write(ClassName generatedTypeName, MembersInjectionBinding binding) {\n    // Empty members injection bindings are special and don\u0027t need source files.\n    if (binding.injectionSites().isEmpty()) {\n      return Optional.absent();\n    }\n    if (!injectValidator.isValidType(binding.key().type())) {\n      return Optional.absent();\n    }\n    // We don\u0027t want to write out resolved bindings -- we want to write out the generic version.\n    checkState(!binding.unresolved().isPresent());\n\n    ImmutableList\u003cTypeVariableName\u003e typeParameters \u003d bindingTypeElementTypeVariableNames(binding);\n    TypeSpec.Builder injectorTypeBuilder \u003d\n        classBuilder(generatedTypeName)\n            .addModifiers(PUBLIC, FINAL)\n            .addTypeVariables(typeParameters);\n\n    TypeName injectedTypeName \u003d TypeName.get(binding.key().type());\n    TypeName implementedType \u003d membersInjectorOf(injectedTypeName);\n    injectorTypeBuilder.addSuperinterface(implementedType);\n\n    MethodSpec.Builder injectMembersBuilder \u003d\n        methodBuilder(\"injectMembers\")\n            .returns(TypeName.VOID)\n            .addModifiers(PUBLIC)\n            .addAnnotation(Override.class)\n            .addParameter(injectedTypeName, \"instance\")\n            .addCode(\"if (instance \u003d\u003d null) {\")\n            .addStatement(\n                \"throw new $T($S)\",\n                NullPointerException.class,\n                \"Cannot inject members into a null reference\")\n            .addCode(\"}\");\n\n    ImmutableMap\u003cBindingKey, FrameworkField\u003e fields \u003d\n        SourceFiles.generateBindingFieldsForDependencies(binding);\n\n    ImmutableMap.Builder\u003cBindingKey, FieldSpec\u003e dependencyFieldsBuilder \u003d ImmutableMap.builder();\n\n    MethodSpec.Builder constructorBuilder \u003d constructorBuilder().addModifiers(PUBLIC);\n\n    // We use a static create method so that generated components can avoid having\n    // to refer to the generic types of the factory.\n    // (Otherwise they may have visibility problems referring to the types.)\n    MethodSpec.Builder createMethodBuilder \u003d\n        methodBuilder(\"create\")\n            .returns(implementedType)\n            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n            .addTypeVariables(typeParameters);\n\n    createMethodBuilder.addCode(\n        \"return new $T(\", parameterizedGeneratedTypeNameForBinding(binding));\n    ImmutableList.Builder\u003cCodeBlock\u003e constructorInvocationParameters \u003d ImmutableList.builder();\n\n    boolean usesRawFrameworkTypes \u003d false;\n    UniqueNameSet fieldNames \u003d new UniqueNameSet();\n    for (Entry\u003cBindingKey, FrameworkField\u003e fieldEntry : fields.entrySet()) {\n      BindingKey bindingKey \u003d fieldEntry.getKey();\n      FrameworkField bindingField \u003d fieldEntry.getValue();\n\n      // If the dependency type is not visible to this members injector, then use the raw framework\n      // type for the field.\n      boolean useRawFrameworkType \u003d\n          !VISIBLE_TO_MEMBERS_INJECTOR.visit(bindingKey.key().type(), binding);\n\n      String fieldName \u003d fieldNames.getUniqueName(bindingField.name());\n      TypeName fieldType \u003d\n          useRawFrameworkType\n              ? bindingField.type().rawType\n              : bindingField.type();\n      FieldSpec.Builder fieldBuilder \u003d FieldSpec.builder(fieldType, fieldName, PRIVATE, FINAL);\n      ParameterSpec.Builder parameterBuilder \u003d ParameterSpec.builder(fieldType, fieldName);\n\n      // If we\u0027re using the raw type for the field, then suppress the injectMembers method\u0027s\n      // unchecked-type warning and the field\u0027s and the constructor and create-method\u0027s\n      // parameters\u0027 raw-type warnings.\n      if (useRawFrameworkType) {\n        usesRawFrameworkTypes \u003d true;\n        fieldBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);\n        parameterBuilder.addAnnotation(SUPPRESS_WARNINGS_RAWTYPES);\n      }\n      constructorBuilder.addParameter(parameterBuilder.build());\n      createMethodBuilder.addParameter(parameterBuilder.build());\n\n      FieldSpec field \u003d fieldBuilder.build();\n      injectorTypeBuilder.addField(field);\n      constructorBuilder.addStatement(\"assert $N !\u003d null\", field);\n      constructorBuilder.addStatement(\"this.$N \u003d $N\", field, field);\n      dependencyFieldsBuilder.put(bindingKey, field);\n      constructorInvocationParameters.add(CodeBlock.of(\"$N\", field));\n    }\n    createMethodBuilder.addCode(CodeBlocks.join(constructorInvocationParameters.build(), \", \"));\n    createMethodBuilder.addCode(\");\");\n\n    injectorTypeBuilder.addMethod(constructorBuilder.build());\n    injectorTypeBuilder.addMethod(createMethodBuilder.build());\n\n    Set\u003cString\u003e delegateMethods \u003d new HashSet\u003c\u003e();\n    ImmutableMap\u003cBindingKey, FieldSpec\u003e dependencyFields \u003d dependencyFieldsBuilder.build();\n    List\u003cMethodSpec\u003e injectMethodsForSubclasses \u003d new ArrayList\u003c\u003e();\n    for (InjectionSite injectionSite : binding.injectionSites()) {\n      injectMembersBuilder.addCode(\n          visibleToMembersInjector(binding, injectionSite.element())\n              ? directInjectMemberCodeBlock(binding, dependencyFields, injectionSite)\n              : delegateInjectMemberCodeBlock(dependencyFields, injectionSite));\n      if (!injectionSite.element().getModifiers().contains(PUBLIC)\n          \u0026\u0026 injectionSite.element().getEnclosingElement().equals(binding.membersInjectedType())\n          \u0026\u0026 delegateMethods.add(injectionSiteDelegateMethodName(injectionSite.element()))) {\n        injectMethodsForSubclasses.add(\n            injectorMethodForSubclasses(\n                dependencyFields,\n                typeParameters,\n                injectedTypeName,\n                injectionSite.element(),\n                injectionSite.dependencies()));\n      }\n    }\n\n    if (usesRawFrameworkTypes) {\n      injectMembersBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);\n    }\n\n    injectorTypeBuilder.addMethod(injectMembersBuilder.build());\n    for (MethodSpec methodSpec : injectMethodsForSubclasses) {\n      injectorTypeBuilder.addMethod(methodSpec);\n    }\n\n    return Optional.of(injectorTypeBuilder);\n  }\n\n  /**\n   * Returns {@code true} if {@code element} is visible to the members injector for {@code binding}.\n   */\n  // TODO(dpb,gak): Make sure that all cases are covered here. E.g., what if element is public but\n  // enclosed in a package-private element?\n  private static boolean visibleToMembersInjector(\n      MembersInjectionBinding binding, Element element) {\n    return getPackage(element).equals(getPackage(binding.membersInjectedType()))\n        || element.getModifiers().contains(PUBLIC);\n  }\n\n  /**\n   * Returns a code block that directly injects the instance\u0027s field or method.\n   */\n  private CodeBlock directInjectMemberCodeBlock(\n      MembersInjectionBinding binding,\n      ImmutableMap\u003cBindingKey, FieldSpec\u003e dependencyFields,\n      InjectionSite injectionSite) {\n    return CodeBlock.of(\n        injectionSite.element().getKind().isField() ? \"$L.$L \u003d $L;\" : \"$L.$L($L);\",\n        getInstanceCodeBlockWithPotentialCast(\n            injectionSite.element().getEnclosingElement(), binding.membersInjectedType()),\n        injectionSite.element().getSimpleName(),\n        makeParametersCodeBlock(\n            parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), true)));\n  }\n\n  /**\n   * Returns a code block that injects the instance\u0027s field or method by calling a static method on\n   * the parent MembersInjector class.\n   */\n  private CodeBlock delegateInjectMemberCodeBlock(\n      ImmutableMap\u003cBindingKey, FieldSpec\u003e dependencyFields, InjectionSite injectionSite) {\n    return CodeBlock.of(\n        \"$L.$L($L);\",\n        membersInjectorNameForType(\n            MoreElements.asType(injectionSite.element().getEnclosingElement())),\n        injectionSiteDelegateMethodName(injectionSite.element()),\n        makeParametersCodeBlock(\n            new ImmutableList.Builder\u003cCodeBlock\u003e()\n                .add(CodeBlock.of(\"instance\"))\n                .addAll(parameterCodeBlocks(dependencyFields, injectionSite.dependencies(), false))\n                .build()));\n  }\n\n  /**\n   * Returns the parameters for injecting a member.\n   *\n   * @param passValue if {@code true}, each parameter code block will be the result of converting\n   *     the field from the framework type ({@link Provider}, {@link Producer}, etc.) to the real\n   *     value; if {@code false}, each parameter code block will be just the field\n   */\n  private ImmutableList\u003cCodeBlock\u003e parameterCodeBlocks(\n      ImmutableMap\u003cBindingKey, FieldSpec\u003e dependencyFields,\n      ImmutableSet\u003cDependencyRequest\u003e dependencies,\n      boolean passValue) {\n    ImmutableList.Builder\u003cCodeBlock\u003e parameters \u003d ImmutableList.builder();\n    for (DependencyRequest dependency : dependencies) {\n      CodeBlock fieldCodeBlock \u003d\n          CodeBlock.of(\"$L\", dependencyFields.get(dependency.bindingKey()).name);\n      parameters.add(\n          passValue\n              ? frameworkTypeUsageStatement(fieldCodeBlock, dependency.kind())\n              : fieldCodeBlock);\n    }\n    return parameters.build();\n  }\n\n  private CodeBlock getInstanceCodeBlockWithPotentialCast(\n      Element injectionSiteElement, Element bindingElement) {\n    if (injectionSiteElement.equals(bindingElement)) {\n      return CodeBlock.of(\"instance\");\n    }\n    TypeName injectionSiteName \u003d TypeName.get(injectionSiteElement.asType());\n    if (injectionSiteName instanceof ParameterizedTypeName) {\n      injectionSiteName \u003d ((ParameterizedTypeName) injectionSiteName).rawType;\n    }\n    return CodeBlock.of(\"(($T) instance)\", injectionSiteName);\n  }\n\n  private String injectionSiteDelegateMethodName(Element injectionSiteElement) {\n    return \"inject\"\n        + CaseFormat.LOWER_CAMEL.to(\n            CaseFormat.UPPER_CAMEL, injectionSiteElement.getSimpleName().toString());\n  }\n\n  private MethodSpec injectorMethodForSubclasses(\n      ImmutableMap\u003cBindingKey, FieldSpec\u003e dependencyFields,\n      List\u003cTypeVariableName\u003e typeParameters,\n      TypeName injectedTypeName,\n      Element injectionElement,\n      ImmutableSet\u003cDependencyRequest\u003e dependencies) {\n    MethodSpec.Builder methodBuilder \u003d\n        methodBuilder(injectionSiteDelegateMethodName(injectionElement))\n            .addModifiers(PUBLIC, STATIC)\n            .addParameter(injectedTypeName, \"instance\")\n            .addTypeVariables(typeParameters);\n    ImmutableList.Builder\u003cCodeBlock\u003e providedParameters \u003d ImmutableList.builder();\n    Set\u003cString\u003e parameterNames \u003d new HashSet\u003c\u003e();\n    for (DependencyRequest dependency : dependencies) {\n      FieldSpec field \u003d dependencyFields.get(dependency.bindingKey());\n      ParameterSpec parameter \u003d\n          ParameterSpec.builder(\n                  field.type,\n                  staticInjectMethodDependencyParameterName(parameterNames, dependency, field))\n              .build();\n      methodBuilder.addParameter(parameter);\n      providedParameters.add(\n          frameworkTypeUsageStatement(CodeBlock.of(\"$N\", parameter), dependency.kind()));\n    }\n    if (injectionElement.getKind().isField()) {\n      methodBuilder.addStatement(\n          \"instance.$L \u003d $L\",\n          injectionElement.getSimpleName(),\n          getOnlyElement(providedParameters.build()));\n    } else {\n      methodBuilder.addStatement(\n          \"instance.$L($L)\",\n          injectionElement.getSimpleName(),\n          makeParametersCodeBlock(providedParameters.build()));\n    }\n    return methodBuilder.build();\n  }\n\n  /**\n   * Returns the static inject method parameter name for a dependency.\n   *\n   * @param parameterNames the parameter names used so far\n   * @param dependency the dependency\n   * @param field the field used to hold the framework type for the dependency\n   */\n  private String staticInjectMethodDependencyParameterName(\n      Set\u003cString\u003e parameterNames, DependencyRequest dependency, FieldSpec field) {\n    StringBuilder parameterName \u003d\n        new StringBuilder(dependency.requestElement().get().getSimpleName().toString());\n    switch (dependency.kind()) {\n      case LAZY:\n      case INSTANCE:\n      case FUTURE:\n        String suffix \u003d ((ParameterizedTypeName) field.type).rawType.simpleName();\n        if (parameterName.length() \u003c\u003d suffix.length()\n            || !parameterName.substring(parameterName.length() - suffix.length()).equals(suffix)) {\n          parameterName.append(suffix);\n        }\n        break;\n\n      default:\n        break;\n    }\n    int baseLength \u003d parameterName.length();\n    for (int i \u003d 2; !parameterNames.add(parameterName.toString()); i++) {\n      parameterName.replace(baseLength, parameterName.length(), String.valueOf(i));\n    }\n    return parameterName.toString();\n  }\n\n  private static final TypeVisitor\u003cBoolean, MembersInjectionBinding\u003e VISIBLE_TO_MEMBERS_INJECTOR \u003d\n      new SimpleTypeVisitor7\u003cBoolean, MembersInjectionBinding\u003e(true) {\n        @Override\n        public Boolean visitArray(ArrayType t, MembersInjectionBinding p) {\n          return visit(t.getComponentType(), p);\n        }\n\n        @Override\n        public Boolean visitDeclared(DeclaredType t, MembersInjectionBinding p) {\n          return visibleToMembersInjector(p, t.asElement());\n        }\n      };\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MembersInjectorRequestFulfillment.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static dagger.internal.codegen.BindingKey.Kind.MEMBERS_INJECTION;\n\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport dagger.internal.codegen.DependencyRequest.Kind;\n\n/** Fulfills requests for {@link MembersInjectionBinding} instances. */\nfinal class MembersInjectorRequestFulfillment extends RequestFulfillment {\n  private final MemberSelect membersInjectorFieldSelect;\n\n  MembersInjectorRequestFulfillment(\n      BindingKey bindingKey, MemberSelect membersInjectorFieldSelect) {\n    super(bindingKey);\n    checkArgument(bindingKey.kind().equals(MEMBERS_INJECTION));\n    this.membersInjectorFieldSelect \u003d membersInjectorFieldSelect;\n  }\n\n  @Override\n  public CodeBlock getSnippetForDependencyRequest(\n      DependencyRequest request, ClassName requestingClass) {\n    checkArgument(request.kind().equals(Kind.MEMBERS_INJECTOR));\n    return membersInjectorFieldSelect.getExpressionFor(requestingClass);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MethodSignature.java",
    "code": "\"package dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Equivalence;\nimport com.google.common.collect.ImmutableList;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.TypeMirror;\n\n@AutoValue\nabstract class MethodSignature {\n  abstract String name();\n  abstract ImmutableList\u003cEquivalence.Wrapper\u003cTypeMirror\u003e\u003e parameterTypes();\n  abstract ImmutableList\u003cEquivalence.Wrapper\u003cTypeMirror\u003e\u003e thrownTypes();\n\n  static MethodSignature fromExecutableType(String methodName, ExecutableType methodType) {\n    checkNotNull(methodType);\n    ImmutableList.Builder\u003cEquivalence.Wrapper\u003cTypeMirror\u003e\u003e parameters \u003d ImmutableList.builder();\n    ImmutableList.Builder\u003cEquivalence.Wrapper\u003cTypeMirror\u003e\u003e thrownTypes \u003d ImmutableList.builder();\n    for (TypeMirror parameter : methodType.getParameterTypes()) {\n      parameters.add(MoreTypes.equivalence().wrap(parameter));\n    }\n    for (TypeMirror thrownType : methodType.getThrownTypes()) {\n      thrownTypes.add(MoreTypes.equivalence().wrap(thrownType));\n    }\n    return new AutoValue_MethodSignature(\n        methodName,\n        parameters.build(),\n        thrownTypes.build());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MethodSignatureFormatter.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkState;\nimport static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.base.Optional;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Types;\n\n/**\n * Formats the signature of an {@link ExecutableElement} suitable for use in error messages.\n *\n * @author Christian Gruber\n * @since 2.0\n */\nfinal class MethodSignatureFormatter extends Formatter\u003cExecutableElement\u003e {\n  private final Types types;\n\n  MethodSignatureFormatter(Types types) {\n    this.types \u003d types;\n  }\n\n  @Override public String format(ExecutableElement method) {\n    return format(method, Optional.\u003cDeclaredType\u003eabsent());\n  }\n\n  /**\n   * Formats an ExecutableElement as if it were contained within the container, if the container is\n   * present.\n   */\n  public String format(ExecutableElement method, Optional\u003cDeclaredType\u003e container) {\n    StringBuilder builder \u003d new StringBuilder();\n    TypeElement type \u003d MoreElements.asType(method.getEnclosingElement());\n    ExecutableType executableType \u003d MoreTypes.asExecutable(method.asType());\n    if (container.isPresent()) {\n      executableType \u003d MoreTypes.asExecutable(types.asMemberOf(container.get(), method));\n      type \u003d MoreElements.asType(container.get().asElement());\n    }\n\n    // TODO(cgruber): AnnotationMirror formatter.\n    List\u003c? extends AnnotationMirror\u003e annotations \u003d method.getAnnotationMirrors();\n    if (!annotations.isEmpty()) {\n      Iterator\u003c? extends AnnotationMirror\u003e annotationIterator \u003d annotations.iterator();\n      for (int i \u003d 0; annotationIterator.hasNext(); i++) {\n        if (i \u003e 0) {\n          builder.append(\u0027 \u0027);\n        }\n        builder.append(ErrorMessages.format(annotationIterator.next()));\n      }\n      builder.append(\u0027 \u0027);\n    }\n    builder.append(nameOfType(executableType.getReturnType()));\n    builder.append(\u0027 \u0027);\n    builder.append(type.getQualifiedName());\n    builder.append(\u0027.\u0027);\n    builder.append(method.getSimpleName());\n    builder.append(\u0027(\u0027);\n    checkState(method.getParameters().size() \u003d\u003d executableType.getParameterTypes().size());\n    Iterator\u003c? extends VariableElement\u003e parameters \u003d method.getParameters().iterator();\n    Iterator\u003c? extends TypeMirror\u003e parameterTypes \u003d executableType.getParameterTypes().iterator();\n    for (int i \u003d 0; parameters.hasNext(); i++) {\n      if (i \u003e 0) {\n        builder.append(\", \");\n      }\n      appendParameter(builder, parameters.next(), parameterTypes.next());\n    }\n    builder.append(\u0027)\u0027);\n    return builder.toString();\n  }\n\n  private static void appendParameter(StringBuilder builder, VariableElement parameter,\n      TypeMirror type) {\n    Optional\u003cAnnotationMirror\u003e qualifier \u003d InjectionAnnotations.getQualifier(parameter);\n    if (qualifier.isPresent()) {\n      builder.append(ErrorMessages.format(qualifier.get())).append(\u0027 \u0027);\n    }\n    builder.append(nameOfType(type));\n  }\n\n  private static String nameOfType(TypeMirror type) {\n    return stripCommonTypePrefixes(type.toString());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MissingBindingSuggestions.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.common.collect.ImmutableList;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\n/**\n * Utility code that looks for bindings matching a key in all subcomponents in a binding graph so\n * that a user is advised that a binding exists elsewhere when it is not found in the current\n * subgraph. If a binding matching a key exists in a sub- or sibling component, that is often what\n * the user actually wants to use.\n */\nclass MissingBindingSuggestions {\n  /**\n   * Searches the entire binding graph from the top-level graph for a binding matching\n   * {@code key}.\n   */\n  static ImmutableList\u003cString\u003e forKey(BindingGraph topLevelGraph, BindingKey key) {\n    ImmutableList.Builder\u003cString\u003e resolutions \u003d new ImmutableList.Builder\u003c\u003e();\n    Deque\u003cBindingGraph\u003e graphsToTry \u003d new ArrayDeque\u003c\u003e();\n\n    graphsToTry.add(topLevelGraph);\n    do {\n      BindingGraph graph \u003d graphsToTry.removeLast();\n      ResolvedBindings bindings \u003d graph.resolvedBindings().get(key);\n      if ((bindings \u003d\u003d null) || bindings.bindings().isEmpty()) {\n        graphsToTry.addAll(graph.subgraphs());\n      } else {\n        resolutions.add(\"A binding with matching key exists in component: \"\n            + graph.componentDescriptor().componentDefinitionType().getQualifiedName());\n      }\n    } while (!graphsToTry.isEmpty());\n\n    return resolutions.build();\n  }\n\n  private MissingBindingSuggestions() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ModuleDescriptor.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getAnnotationMirror;\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Verify.verify;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;\nimport static javax.lang.model.type.TypeKind.DECLARED;\nimport static javax.lang.model.type.TypeKind.NONE;\nimport static javax.lang.model.util.ElementFilter.methodsIn;\nimport static javax.lang.model.util.ElementFilter.typesIn;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport dagger.Binds;\nimport dagger.BindsOptionalOf;\nimport dagger.Module;\nimport dagger.Multibindings;\nimport dagger.Provides;\nimport dagger.multibindings.Multibinds;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport java.lang.annotation.Annotation;\nimport java.util.EnumSet;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\n\n@AutoValue\nabstract class ModuleDescriptor {\n\n  abstract TypeElement moduleElement();\n\n  abstract ImmutableSet\u003cModuleDescriptor\u003e includedModules();\n\n  abstract ImmutableSet\u003cContributionBinding\u003e bindings();\n\n  /** The multibinding declarations contained in this module. */\n  abstract ImmutableSet\u003cMultibindingDeclaration\u003e multibindingDeclarations();\n\n  /** The {@link Module#subcomponents() subcomponent declarations} contained in this module. */\n  abstract ImmutableSet\u003cSubcomponentDeclaration\u003e subcomponentDeclarations();\n\n  /** The {@link Binds} method declarations that define delegate bindings. */\n  abstract ImmutableSet\u003cDelegateDeclaration\u003e delegateDeclarations();\n\n  /** The {@link BindsOptionalOf} method declarations that define optional bindings. */\n  abstract ImmutableSet\u003cOptionalBindingDeclaration\u003e optionalDeclarations();\n\n  enum Kind {\n    MODULE(\n        Module.class, Provides.class, ImmutableSet.of(Module.class)),\n    PRODUCER_MODULE(\n        ProducerModule.class,\n        Produces.class,\n        ImmutableSet.of(Module.class, ProducerModule.class));\n\n    private final Class\u003c? extends Annotation\u003e moduleAnnotation;\n    private final Class\u003c? extends Annotation\u003e methodAnnotation;\n    private final ImmutableSet\u003c? extends Class\u003c? extends Annotation\u003e\u003e includesTypes;\n\n    /**\n     * Returns the kind of an annotated element if it is annotated with one of the\n     * {@linkplain #moduleAnnotation() annotation types}.\n     *\n     * @throws IllegalArgumentException if the element is annotated with more than one of the\n     *     annotation types\n     */\n    static Optional\u003cKind\u003e forAnnotatedElement(TypeElement element) {\n      Set\u003cKind\u003e kinds \u003d EnumSet.noneOf(Kind.class);\n      for (Kind kind : values()) {\n        if (MoreElements.isAnnotationPresent(element, kind.moduleAnnotation())) {\n          kinds.add(kind);\n        }\n      }\n      checkArgument(\n          kinds.size() \u003c\u003d 1, \"%s cannot be annotated with more than one of %s\", element, kinds);\n      return Optional.fromNullable(Iterables.getOnlyElement(kinds, null));\n    }\n\n    Kind(\n        Class\u003c? extends Annotation\u003e moduleAnnotation,\n        Class\u003c? extends Annotation\u003e methodAnnotation,\n        ImmutableSet\u003c? extends Class\u003c? extends Annotation\u003e\u003e includesTypes) {\n      this.moduleAnnotation \u003d moduleAnnotation;\n      this.methodAnnotation \u003d methodAnnotation;\n      this.includesTypes \u003d includesTypes;\n    }\n\n    Optional\u003cAnnotationMirror\u003e getModuleAnnotationMirror(TypeElement element) {\n      return getAnnotationMirror(element, moduleAnnotation);\n    }\n\n    Class\u003c? extends Annotation\u003e moduleAnnotation() {\n      return moduleAnnotation;\n    }\n\n    Class\u003c? extends Annotation\u003e methodAnnotation() {\n      return methodAnnotation;\n    }\n\n    ImmutableSet\u003c? extends Class\u003c? extends Annotation\u003e\u003e includesTypes() {\n      return includesTypes;\n    }\n  }\n\n  static final class Factory {\n    private final Elements elements;\n    private final ProvisionBinding.Factory provisionBindingFactory;\n    private final ProductionBinding.Factory productionBindingFactory;\n    private final MultibindingDeclaration.Factory multibindingDeclarationFactory;\n    private final DelegateDeclaration.Factory bindingDelegateDeclarationFactory;\n    private final SubcomponentDeclaration.Factory subcomponentDeclarationFactory;\n    private final OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory;\n\n    Factory(\n        Elements elements,\n        ProvisionBinding.Factory provisionBindingFactory,\n        ProductionBinding.Factory productionBindingFactory,\n        MultibindingDeclaration.Factory multibindingDeclarationFactory,\n        DelegateDeclaration.Factory bindingDelegateDeclarationFactory,\n        SubcomponentDeclaration.Factory subcomponentDeclarationFactory,\n        OptionalBindingDeclaration.Factory optionalBindingDeclarationFactory) {\n      this.elements \u003d elements;\n      this.provisionBindingFactory \u003d provisionBindingFactory;\n      this.productionBindingFactory \u003d productionBindingFactory;\n      this.multibindingDeclarationFactory \u003d multibindingDeclarationFactory;\n      this.bindingDelegateDeclarationFactory \u003d bindingDelegateDeclarationFactory;\n      this.subcomponentDeclarationFactory \u003d subcomponentDeclarationFactory;\n      this.optionalBindingDeclarationFactory \u003d optionalBindingDeclarationFactory;\n    }\n\n    ModuleDescriptor create(TypeElement moduleElement) {\n      ImmutableSet.Builder\u003cContributionBinding\u003e bindings \u003d ImmutableSet.builder();\n      ImmutableSet.Builder\u003cDelegateDeclaration\u003e delegates \u003d ImmutableSet.builder();\n      ImmutableSet.Builder\u003cMultibindingDeclaration\u003e multibindingDeclarations \u003d\n          ImmutableSet.builder();\n      ImmutableSet.Builder\u003cOptionalBindingDeclaration\u003e optionalDeclarations \u003d\n          ImmutableSet.builder();\n\n      for (ExecutableElement moduleMethod : methodsIn(elements.getAllMembers(moduleElement))) {\n        if (isAnnotationPresent(moduleMethod, Provides.class)) {\n          bindings.add(provisionBindingFactory.forProvidesMethod(moduleMethod, moduleElement));\n        }\n        if (isAnnotationPresent(moduleMethod, Produces.class)) {\n          bindings.add(productionBindingFactory.forProducesMethod(moduleMethod, moduleElement));\n        }\n        if (isAnnotationPresent(moduleMethod, Binds.class)) {\n          delegates.add(bindingDelegateDeclarationFactory.create(moduleMethod, moduleElement));\n        }\n        if (isAnnotationPresent(moduleMethod, Multibinds.class)) {\n          multibindingDeclarations.add(\n              multibindingDeclarationFactory.forMultibindsMethod(moduleMethod, moduleElement));\n        }\n        if (isAnnotationPresent(moduleMethod, BindsOptionalOf.class)) {\n          optionalDeclarations.add(\n              optionalBindingDeclarationFactory.forMethod(moduleMethod, moduleElement));\n        }\n      }\n\n      for (TypeElement memberType : typesIn(elements.getAllMembers(moduleElement))) {\n        if (isAnnotationPresent(memberType, Multibindings.class)) {\n          multibindingDeclarations.addAll(\n              multibindingDeclarationFactory.forMultibindingsInterface(memberType));\n        }\n      }\n\n      return new AutoValue_ModuleDescriptor(\n          moduleElement,\n          ImmutableSet.copyOf(collectIncludedModules(new LinkedHashSet\u003c\u003e(), moduleElement)),\n          bindings.build(),\n          multibindingDeclarations.build(),\n          subcomponentDeclarationFactory.forModule(moduleElement),\n          delegates.build(),\n          optionalDeclarations.build());\n    }\n\n    @CanIgnoreReturnValue\n    private Set\u003cModuleDescriptor\u003e collectIncludedModules(\n        Set\u003cModuleDescriptor\u003e includedModules, TypeElement moduleElement) {\n      TypeMirror superclass \u003d moduleElement.getSuperclass();\n      if (!superclass.getKind().equals(NONE)) {\n        verify(superclass.getKind().equals(DECLARED));\n        TypeElement superclassElement \u003d MoreTypes.asTypeElement(superclass);\n        if (!superclassElement.getQualifiedName().contentEquals(Object.class.getCanonicalName())) {\n          collectIncludedModules(includedModules, superclassElement);\n        }\n      }\n      Optional\u003cAnnotationMirror\u003e moduleAnnotation \u003d getModuleAnnotation(moduleElement);\n      if (moduleAnnotation.isPresent()) {\n        getModuleIncludes(moduleAnnotation.get())\n            .stream()\n            .map(MoreTypes::asTypeElement)\n            .map(this::create)\n            .forEach(includedModules::add);\n      }\n      return includedModules;\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ModuleProcessingStep.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static dagger.internal.codegen.Util.elementsWithAnnotation;\nimport static javax.lang.model.util.ElementFilter.methodsIn;\nimport static javax.lang.model.util.ElementFilter.typesIn;\n\nimport com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.SetMultimap;\nimport com.google.common.collect.Sets;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport java.lang.annotation.Annotation;\nimport java.util.List;\nimport java.util.Set;\nimport javax.annotation.processing.Messager;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\n\n/**\n * A {@link ProcessingStep} that validates module classes and generates factories for binding\n * methods.\n */\nfinal class ModuleProcessingStep implements ProcessingStep {\n\n  /**\n   * A {@link ProcessingStep} for {@code @Module} classes that generates factories for\n   * {@code @Provides} methods.\n   */\n  static ModuleProcessingStep moduleProcessingStep(\n      Messager messager,\n      ModuleValidator moduleValidator,\n      final ProvisionBinding.Factory provisionBindingFactory,\n      FactoryGenerator factoryGenerator,\n      ProvidesMethodValidator providesMethodValidator,\n      BindsMethodValidator bindsMethodValidator,\n      MultibindsMethodValidator multibindsMethodValidator,\n      BindsOptionalOfMethodValidator bindsOptionalOfMethodValidator) {\n    return new ModuleProcessingStep(\n        messager,\n        Module.class,\n        moduleValidator,\n        ImmutableSet.\u003cModuleMethodFactoryGenerator\u003eof(\n            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator)),\n        ImmutableSet.of(\n            providesMethodValidator,\n            bindsMethodValidator,\n            multibindsMethodValidator,\n            bindsOptionalOfMethodValidator));\n  }\n\n  /**\n   * A {@link ProcessingStep} for {@code @ProducerModule} classes that generates factories for\n   * {@code @Provides} and {@code @Produces} methods.\n   */\n  static ModuleProcessingStep producerModuleProcessingStep(\n      Messager messager,\n      ModuleValidator moduleValidator,\n      ProvisionBinding.Factory provisionBindingFactory,\n      FactoryGenerator factoryGenerator,\n      ProvidesMethodValidator providesMethodValidator,\n      ProductionBinding.Factory productionBindingFactory,\n      ProducerFactoryGenerator producerFactoryGenerator,\n      ProducesMethodValidator producesMethodValidator,\n      BindsMethodValidator bindsMethodValidator,\n      MultibindsMethodValidator multibindsMethodValidator,\n      BindsOptionalOfMethodValidator bindsOptionalOfMethodValidator) {\n    return new ModuleProcessingStep(\n        messager,\n        ProducerModule.class,\n        moduleValidator,\n        ImmutableSet.of(\n            new ProvisionModuleMethodFactoryGenerator(provisionBindingFactory, factoryGenerator),\n            new ProductionModuleMethodFactoryGenerator(\n                productionBindingFactory, producerFactoryGenerator)),\n        ImmutableSet.of(\n            providesMethodValidator,\n            producesMethodValidator,\n            bindsMethodValidator,\n            multibindsMethodValidator,\n            bindsOptionalOfMethodValidator));\n  }\n\n  private final Messager messager;\n  private final Class\u003c? extends Annotation\u003e moduleAnnotation;\n  private final ModuleValidator moduleValidator;\n  private final ImmutableSet\u003cModuleMethodFactoryGenerator\u003e moduleMethodFactoryGenerators;\n  private final ImmutableSet\u003c? extends BindingMethodValidator\u003e methodValidators;\n  private final Set\u003cTypeElement\u003e processedModuleElements \u003d Sets.newLinkedHashSet();\n\n  /**\n   * Creates a new processing step.\n   *\n   * @param moduleAnnotation the annotation on the module class\n   * @param methodValidators validators for binding methods\n   */\n  ModuleProcessingStep(\n      Messager messager,\n      Class\u003c? extends Annotation\u003e moduleAnnotation,\n      ModuleValidator moduleValidator,\n      ImmutableSet\u003cModuleMethodFactoryGenerator\u003e moduleMethodFactoryGenerators,\n      Iterable\u003c? extends BindingMethodValidator\u003e methodValidators) {\n    this.messager \u003d messager;\n    this.moduleAnnotation \u003d moduleAnnotation;\n    this.moduleValidator \u003d moduleValidator;\n    this.moduleMethodFactoryGenerators \u003d moduleMethodFactoryGenerators;\n    this.methodValidators \u003d ImmutableSet.copyOf(methodValidators);\n  }\n\n  @Override\n  public Set\u003c? extends Class\u003c? extends Annotation\u003e\u003e annotations() {\n    ImmutableSet.Builder\u003cClass\u003c? extends Annotation\u003e\u003e annotations \u003d ImmutableSet.builder();\n    annotations.add(moduleAnnotation);\n    for (BindingMethodValidator validator : methodValidators) {\n      annotations.add(validator.methodAnnotation());\n    }\n    return annotations.build();\n  }\n\n  @Override\n  public Set\u003cElement\u003e process(\n      SetMultimap\u003cClass\u003c? extends Annotation\u003e, Element\u003e elementsByAnnotation) {\n    ImmutableSet\u003cExecutableElement\u003e validMethods \u003d validMethods(elementsByAnnotation);\n\n    // process each module\n    for (TypeElement moduleElement :\n        Sets.difference(\n            typesIn(elementsByAnnotation.get(moduleAnnotation)), processedModuleElements)) {\n      ValidationReport\u003cTypeElement\u003e report \u003d moduleValidator.validate(moduleElement);\n      report.printMessagesTo(messager);\n\n      if (report.isClean()) {\n        List\u003cExecutableElement\u003e moduleMethods \u003d methodsIn(moduleElement.getEnclosedElements());\n        if (moduleMethodsAreValid(validMethods, moduleMethods)) {\n          for (ModuleMethodFactoryGenerator generator : moduleMethodFactoryGenerators) {\n            for (ExecutableElement method :\n                elementsWithAnnotation(moduleMethods, generator.factoryMethodAnnotation())) {\n              generator.generate(method, moduleElement, messager);\n            }\n          }\n        }\n      }\n      processedModuleElements.add(moduleElement);\n    }\n    return ImmutableSet.of();\n  }\n\n  /** The binding methods that are valid according to their validator. */\n  private ImmutableSet\u003cExecutableElement\u003e validMethods(\n      SetMultimap\u003cClass\u003c? extends Annotation\u003e, Element\u003e elementsByAnnotation) {\n    ImmutableSet.Builder\u003cExecutableElement\u003e validMethods \u003d ImmutableSet.builder();\n    for (BindingMethodValidator validator : methodValidators) {\n      validMethods.addAll(\n          validator.validate(\n              messager, methodsIn(elementsByAnnotation.get(validator.methodAnnotation()))));\n    }\n    return validMethods.build();\n  }\n\n  /**\n   * {@code true} if all {@code moduleMethods} that are annotated with a binding method annotation\n   * are in {@code validMethods}.\n   */\n  private boolean moduleMethodsAreValid(\n      ImmutableSet\u003cExecutableElement\u003e validMethods, Iterable\u003cExecutableElement\u003e moduleMethods) {\n    for (ExecutableElement methodElement : moduleMethods) {\n      if (!validMethods.contains(methodElement)) {\n        for (BindingMethodValidator validator : methodValidators) {\n          if (isAnnotationPresent(methodElement, validator.methodAnnotation())) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }\n\n  interface ModuleMethodFactoryGenerator {\n    /** Binding method annotation for which factories should be generated. */\n    Class\u003c? extends Annotation\u003e factoryMethodAnnotation();\n\n    /** Generates the factory source file for the given method and module. */\n    void generate(ExecutableElement method, TypeElement moduleElement, Messager messager);\n  }\n\n  private static final class ProvisionModuleMethodFactoryGenerator\n      implements ModuleMethodFactoryGenerator {\n\n    private final ProvisionBinding.Factory provisionBindingFactory;\n    private final FactoryGenerator factoryGenerator;\n\n    ProvisionModuleMethodFactoryGenerator(\n        ProvisionBinding.Factory provisionBindingFactory, FactoryGenerator factoryGenerator) {\n      this.provisionBindingFactory \u003d provisionBindingFactory;\n      this.factoryGenerator \u003d factoryGenerator;\n    }\n\n    @Override\n    public Class\u003c? extends Annotation\u003e factoryMethodAnnotation() {\n      return Provides.class;\n    }\n\n    @Override\n    public void generate(ExecutableElement method, TypeElement moduleElement, Messager messager) {\n      factoryGenerator.generate(\n          provisionBindingFactory.forProvidesMethod(method, moduleElement), messager);\n    }\n  }\n\n  private static final class ProductionModuleMethodFactoryGenerator\n      implements ModuleMethodFactoryGenerator {\n\n    private final ProductionBinding.Factory productionBindingFactory;\n    private final ProducerFactoryGenerator producerFactoryGenerator;\n\n    ProductionModuleMethodFactoryGenerator(\n        ProductionBinding.Factory productionBindingFactory,\n        ProducerFactoryGenerator productionFactoryGenerator) {\n      this.productionBindingFactory \u003d productionBindingFactory;\n      this.producerFactoryGenerator \u003d productionFactoryGenerator;\n    }\n\n    @Override\n    public Class\u003c? extends Annotation\u003e factoryMethodAnnotation() {\n      return Produces.class;\n    }\n\n    @Override\n    public void generate(ExecutableElement method, TypeElement moduleElement, Messager messager) {\n      producerFactoryGenerator.generate(\n          productionBindingFactory.forProducesMethod(method, moduleElement), messager);\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ModuleValidator.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getAnnotationMirror;\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static com.google.auto.common.Visibility.PRIVATE;\nimport static com.google.auto.common.Visibility.PUBLIC;\nimport static com.google.auto.common.Visibility.effectiveVisibilityOfElement;\nimport static com.google.common.collect.Iterables.any;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getModuleIncludes;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;\nimport static dagger.internal.codegen.ErrorMessages.INCOMPATIBLE_MODULE_METHODS;\nimport static dagger.internal.codegen.ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD;\nimport static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;\nimport static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsDoesntHaveBuilder;\nimport static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsIncludesBuilder;\nimport static dagger.internal.codegen.ErrorMessages.ModuleMessages.moduleSubcomponentsIncludesNonSubcomponent;\nimport static dagger.internal.codegen.ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER;\nimport static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS;\nimport static dagger.internal.codegen.ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED;\nimport static dagger.internal.codegen.Util.isAnyAnnotationPresent;\nimport static java.util.stream.Collectors.joining;\nimport static javax.lang.model.element.Modifier.ABSTRACT;\nimport static javax.lang.model.element.Modifier.STATIC;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.common.Visibility;\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ListMultimap;\nimport com.google.common.collect.Sets;\nimport dagger.Binds;\nimport dagger.Module;\nimport dagger.Subcomponent;\nimport dagger.internal.codegen.ModuleDescriptor.Kind;\nimport dagger.multibindings.Multibinds;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.ProductionSubcomponent;\nimport java.lang.annotation.Annotation;\nimport java.util.Collection;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ElementKind;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.ElementFilter;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.SimpleTypeVisitor6;\nimport javax.lang.model.util.Types;\n\n/**\n * A {@linkplain ValidationReport validator} for {@link Module}s or {@link ProducerModule}s.\n *\n * @author Gregory Kick\n * @since 2.0\n */\nfinal class ModuleValidator {\n  private static final ImmutableSet\u003cClass\u003c? extends Annotation\u003e\u003e SUBCOMPONENT_TYPES \u003d\n      ImmutableSet.of(Subcomponent.class, ProductionSubcomponent.class);\n  private static final ImmutableSet\u003cClass\u003c? extends Annotation\u003e\u003e SUBCOMPONENT_BUILDER_TYPES \u003d\n      ImmutableSet.of(Subcomponent.Builder.class, ProductionSubcomponent.Builder.class);\n\n  private final Types types;\n  private final Elements elements;\n  private final MethodSignatureFormatter methodSignatureFormatter;\n\n  ModuleValidator(\n      Types types, Elements elements, MethodSignatureFormatter methodSignatureFormatter) {\n    this.types \u003d types;\n    this.elements \u003d elements;\n    this.methodSignatureFormatter \u003d methodSignatureFormatter;\n  }\n\n  ValidationReport\u003cTypeElement\u003e validate(final TypeElement subject) {\n    final ValidationReport.Builder\u003cTypeElement\u003e builder \u003d ValidationReport.about(subject);\n    ModuleDescriptor.Kind moduleKind \u003d ModuleDescriptor.Kind.forAnnotatedElement(subject).get();\n\n    List\u003cExecutableElement\u003e moduleMethods \u003d ElementFilter.methodsIn(subject.getEnclosedElements());\n    ListMultimap\u003cString, ExecutableElement\u003e allMethodsByName \u003d ArrayListMultimap.create();\n    ListMultimap\u003cString, ExecutableElement\u003e bindingMethodsByName \u003d ArrayListMultimap.create();\n\n    Set\u003cModuleMethodKind\u003e methodKinds \u003d EnumSet.noneOf(ModuleMethodKind.class);\n    for (ExecutableElement moduleMethod : moduleMethods) {\n      if (isAnyAnnotationPresent(\n          moduleMethod,\n          ImmutableSet.of(moduleKind.methodAnnotation(), Binds.class, Multibinds.class))) {\n        bindingMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);\n        methodKinds.add(ModuleMethodKind.ofMethod(moduleMethod));\n      }\n      allMethodsByName.put(moduleMethod.getSimpleName().toString(), moduleMethod);\n    }\n\n    if (methodKinds.containsAll(\n        EnumSet.of(ModuleMethodKind.ABSTRACT_DECLARATION, ModuleMethodKind.INSTANCE_BINDING))) {\n      builder.addError(\n          String.format(\n              INCOMPATIBLE_MODULE_METHODS,\n              moduleKind.moduleAnnotation().getSimpleName(),\n              moduleKind.methodAnnotation().getSimpleName()));\n    }\n\n    validateModuleVisibility(subject, moduleKind, builder);\n    validateMethodsWithSameName(moduleKind, builder, bindingMethodsByName);\n    if (subject.getKind() !\u003d ElementKind.INTERFACE) {\n      validateProvidesOverrides(\n          subject, moduleKind, builder, allMethodsByName, bindingMethodsByName);\n    }\n    validateModifiers(subject, builder);\n    validateReferencedModules(subject, moduleKind, builder);\n    validateReferencedSubcomponents(subject, moduleKind, builder);\n\n    // TODO(gak): port the dagger 1 module validation?\n    return builder.build();\n  }\n\n  private void validateReferencedSubcomponents(\n      final TypeElement subject,\n      ModuleDescriptor.Kind moduleKind,\n      final ValidationReport.Builder\u003cTypeElement\u003e builder) {\n    final AnnotationMirror moduleAnnotation \u003d moduleKind.getModuleAnnotationMirror(subject).get();\n    // TODO(ronshapiro): use validateTypesAreDeclared when it is checked in\n    for (TypeMirror subcomponentAttribute : getModuleSubcomponents(moduleAnnotation)) {\n      subcomponentAttribute.accept(\n          new SimpleTypeVisitor6\u003cVoid, Void\u003e(){\n            @Override\n            protected Void defaultAction(TypeMirror e, Void aVoid) {\n              builder.addError(e + \" is not a valid subcomponent type\", subject, moduleAnnotation);\n              return null;\n            }\n\n            @Override\n            public Void visitDeclared(DeclaredType declaredType, Void aVoid) {\n              TypeElement attributeType \u003d MoreTypes.asTypeElement(declaredType);\n              if (isAnyAnnotationPresent(attributeType, SUBCOMPONENT_TYPES)) {\n                validateSubcomponentHasBuilder(attributeType, moduleAnnotation, builder);\n              } else {\n                builder.addError(\n                    isAnyAnnotationPresent(attributeType, SUBCOMPONENT_BUILDER_TYPES)\n                        ? moduleSubcomponentsIncludesBuilder(attributeType)\n                        : moduleSubcomponentsIncludesNonSubcomponent(attributeType),\n                    attributeType,\n                    moduleAnnotation);\n              }\n\n              return null;\n            }\n          }, null);\n    }\n  }\n\n  private void validateSubcomponentHasBuilder(\n      TypeElement subcomponentAttribute,\n      AnnotationMirror moduleAnnotation,\n      ValidationReport.Builder\u003cTypeElement\u003e builder) {\n    if (getSubcomponentBuilder(subcomponentAttribute).isPresent()) {\n      return;\n    }\n    builder.addError(\n        moduleSubcomponentsDoesntHaveBuilder(subcomponentAttribute, moduleAnnotation),\n        subcomponentAttribute,\n        moduleAnnotation);\n  }\n\n  enum ModuleMethodKind {\n    ABSTRACT_DECLARATION,\n    INSTANCE_BINDING,\n    STATIC_BINDING,\n    ;\n\n    static ModuleMethodKind ofMethod(ExecutableElement moduleMethod) {\n      if (moduleMethod.getModifiers().contains(STATIC)) {\n        return STATIC_BINDING;\n      } else if (moduleMethod.getModifiers().contains(ABSTRACT)) {\n        return ABSTRACT_DECLARATION;\n      } else {\n        return INSTANCE_BINDING;\n      }\n    }\n  }\n\n  private void validateModifiers(\n      TypeElement subject, ValidationReport.Builder\u003cTypeElement\u003e builder) {\n    // This coupled with the check for abstract modules in ComponentValidator guarantees that\n    // only modules without type parameters are referenced from @Component(modules\u003d{...}).\n    if (!subject.getTypeParameters().isEmpty() \u0026\u0026 !subject.getModifiers().contains(ABSTRACT)) {\n      builder.addError(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT, subject);\n    }\n  }\n\n  private void validateMethodsWithSameName(\n      ModuleDescriptor.Kind moduleKind,\n      ValidationReport.Builder\u003cTypeElement\u003e builder,\n      ListMultimap\u003cString, ExecutableElement\u003e bindingMethodsByName) {\n    for (Entry\u003cString, Collection\u003cExecutableElement\u003e\u003e entry :\n        bindingMethodsByName.asMap().entrySet()) {\n      if (entry.getValue().size() \u003e 1) {\n        for (ExecutableElement offendingMethod : entry.getValue()) {\n          builder.addError(\n              String.format(\n                  BINDING_METHOD_WITH_SAME_NAME, moduleKind.methodAnnotation().getSimpleName()),\n              offendingMethod);\n        }\n      }\n    }\n  }\n\n  private void validateReferencedModules(\n      TypeElement subject,\n      ModuleDescriptor.Kind moduleKind,\n      ValidationReport.Builder\u003cTypeElement\u003e builder) {\n    // Validate that all the modules we include are valid for inclusion.\n    AnnotationMirror mirror \u003d moduleKind.getModuleAnnotationMirror(subject).get();\n    ImmutableList\u003cTypeMirror\u003e includes \u003d getModuleIncludes(mirror);\n    validateReferencedModules(subject, builder, includes, ImmutableSet.of(moduleKind));\n  }\n\n  private static ImmutableSet\u003c? extends Class\u003c? extends Annotation\u003e\u003e includedModuleClasses(\n      ImmutableSet\u003cModuleDescriptor.Kind\u003e validModuleKinds) {\n    return FluentIterable.from(validModuleKinds).transformAndConcat(Kind::includesTypes).toSet();\n  }\n\n  /**\n   * Used by {@link ModuleValidator} \u0026 {@link ComponentValidator} to validate referenced modules.\n   */\n  void validateReferencedModules(\n      final TypeElement subject,\n      final ValidationReport.Builder\u003cTypeElement\u003e builder,\n      ImmutableList\u003cTypeMirror\u003e includes,\n      ImmutableSet\u003cModuleDescriptor.Kind\u003e validModuleKinds) {\n    final ImmutableSet\u003c? extends Class\u003c? extends Annotation\u003e\u003e includedModuleClasses \u003d\n        includedModuleClasses(validModuleKinds);\n\n    for (TypeMirror includesType : includes) {\n      includesType.accept(\n          new SimpleTypeVisitor6\u003cVoid, Void\u003e() {\n            @Override\n            protected Void defaultAction(TypeMirror mirror, Void p) {\n              builder.addError(mirror + \" is not a valid module type.\", subject);\n              return null;\n            }\n\n            @Override\n            public Void visitDeclared(DeclaredType t, Void p) {\n              final TypeElement element \u003d MoreElements.asType(t.asElement());\n              if (!t.getTypeArguments().isEmpty()) {\n                builder.addError(\n                    String.format(\n                        REFERENCED_MODULE_MUST_NOT_HAVE_TYPE_PARAMS, element.getQualifiedName()),\n                    subject);\n              }\n              boolean isIncludedModule \u003d\n                  any(\n                      includedModuleClasses,\n                      otherClass -\u003e MoreElements.isAnnotationPresent(element, otherClass));\n              if (!isIncludedModule) {\n                builder.addError(\n                    String.format(\n                        REFERENCED_MODULE_NOT_ANNOTATED,\n                        element.getQualifiedName(),\n                        (includedModuleClasses.size() \u003e 1 ? \"one of \" : \"\")\n                            + includedModuleClasses.stream()\n                                .map(otherClass -\u003e \"@\" + otherClass.getSimpleName())\n                                .collect(joining(\", \"))),\n                    subject);\n              }\n              return null;\n            }\n          },\n          null);\n    }\n  }\n\n  private void validateProvidesOverrides(\n      TypeElement subject,\n      ModuleDescriptor.Kind moduleKind,\n      ValidationReport.Builder\u003cTypeElement\u003e builder,\n      ListMultimap\u003cString, ExecutableElement\u003e allMethodsByName,\n      ListMultimap\u003cString, ExecutableElement\u003e bindingMethodsByName) {\n    // For every @Provides method, confirm it overrides nothing *and* nothing overrides it.\n    // Consider the following hierarchy:\n    // class Parent {\n    //    @Provides Foo a() {}\n    //    @Provides Foo b() {}\n    //    Foo c() {}\n    // }\n    // class Child extends Parent {\n    //    @Provides Foo a() {}\n    //    Foo b() {}\n    //    @Provides Foo c() {}\n    // }\n    // In each of those cases, we want to fail.  \"a\" is clear, \"b\" because Child is overriding\n    // a method marked @Provides in Parent, and \"c\" because Child is defining an @Provides\n    // method that overrides Parent.\n    TypeElement currentClass \u003d subject;\n    TypeMirror objectType \u003d elements.getTypeElement(Object.class.getCanonicalName()).asType();\n    // We keep track of methods that failed so we don\u0027t spam with multiple failures.\n    Set\u003cExecutableElement\u003e failedMethods \u003d Sets.newHashSet();\n    while (!types.isSameType(currentClass.getSuperclass(), objectType)) {\n      currentClass \u003d MoreElements.asType(types.asElement(currentClass.getSuperclass()));\n      List\u003cExecutableElement\u003e superclassMethods \u003d\n          ElementFilter.methodsIn(currentClass.getEnclosedElements());\n      for (ExecutableElement superclassMethod : superclassMethods) {\n        String name \u003d superclassMethod.getSimpleName().toString();\n        // For each method in the superclass, confirm our @Provides methods don\u0027t override it\n        for (ExecutableElement providesMethod : bindingMethodsByName.get(name)) {\n          if (!failedMethods.contains(providesMethod)\n              \u0026\u0026 elements.overrides(providesMethod, superclassMethod, subject)) {\n            failedMethods.add(providesMethod);\n            builder.addError(\n                String.format(\n                    PROVIDES_METHOD_OVERRIDES_ANOTHER,\n                    moduleKind.methodAnnotation().getSimpleName(),\n                    methodSignatureFormatter.format(superclassMethod)),\n                providesMethod);\n          }\n        }\n        // For each @Provides method in superclass, confirm our methods don\u0027t override it.\n        if (isAnnotationPresent(superclassMethod, moduleKind.methodAnnotation())) {\n          for (ExecutableElement method : allMethodsByName.get(name)) {\n            if (!failedMethods.contains(method)\n                \u0026\u0026 elements.overrides(method, superclassMethod, subject)) {\n              failedMethods.add(method);\n              builder.addError(\n                  String.format(\n                      METHOD_OVERRIDES_PROVIDES_METHOD,\n                      moduleKind.methodAnnotation().getSimpleName(),\n                      methodSignatureFormatter.format(superclassMethod)),\n                  method);\n            }\n          }\n        }\n        allMethodsByName.put(superclassMethod.getSimpleName().toString(), superclassMethod);\n      }\n    }\n  }\n\n  private void validateModuleVisibility(\n      final TypeElement moduleElement,\n      ModuleDescriptor.Kind moduleKind,\n      final ValidationReport.Builder\u003c?\u003e reportBuilder) {\n    Visibility moduleVisibility \u003d Visibility.ofElement(moduleElement);\n    if (moduleVisibility.equals(PRIVATE)) {\n      reportBuilder.addError(\"Modules cannot be private.\", moduleElement);\n    } else if (effectiveVisibilityOfElement(moduleElement).equals(PRIVATE)) {\n      reportBuilder.addError(\"Modules cannot be enclosed in private types.\", moduleElement);\n    }\n\n    switch (moduleElement.getNestingKind()) {\n      case ANONYMOUS:\n        throw new IllegalStateException(\"Can\u0027t apply @Module to an anonymous class\");\n      case LOCAL:\n        throw new IllegalStateException(\"Local classes shouldn\u0027t show up in the processor\");\n      case MEMBER:\n      case TOP_LEVEL:\n        if (moduleVisibility.equals(PUBLIC)) {\n          ImmutableSet\u003cElement\u003e nonPublicModules \u003d\n              FluentIterable.from(\n                      getModuleIncludes(\n                          getAnnotationMirror(moduleElement, moduleKind.moduleAnnotation()).get()))\n                  .transform(types::asElement)\n                  .filter(element -\u003e effectiveVisibilityOfElement(element).compareTo(PUBLIC) \u003c 0)\n                  .toSet();\n          if (!nonPublicModules.isEmpty()) {\n            reportBuilder.addError(\n                String.format(\n                    \"This module is public, but it includes non-public \"\n                        + \"(or effectively non-public) modules. \"\n                        + \"Either reduce the visibility of this module or make %s public.\",\n                    formatListForErrorMessage(nonPublicModules.asList())),\n                moduleElement);\n          }\n        }\n        break;\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  private static String formatListForErrorMessage(List\u003c?\u003e things) {\n    switch (things.size()) {\n      case 0:\n        return \"\";\n      case 1:\n        return things.get(0).toString();\n      default:\n        StringBuilder output \u003d new StringBuilder();\n        Joiner.on(\", \").appendTo(output, things.subList(0, things.size() - 1));\n        output.append(\" and \").append(things.get(things.size() - 1));\n        return output.toString();\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MonitoringModuleGenerator.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.squareup.javapoet.MethodSpec.constructorBuilder;\nimport static com.squareup.javapoet.MethodSpec.methodBuilder;\nimport static com.squareup.javapoet.TypeSpec.classBuilder;\nimport static dagger.internal.codegen.TypeNames.PRODUCTION_COMPONENT_MONITOR_FACTORY;\nimport static dagger.internal.codegen.TypeNames.providerOf;\nimport static dagger.internal.codegen.TypeNames.setOf;\nimport static javax.lang.model.element.Modifier.ABSTRACT;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.element.Modifier.STATIC;\n\nimport com.google.common.base.Optional;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.TypeSpec;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.multibindings.Multibinds;\nimport dagger.producers.ProductionScope;\nimport dagger.producers.monitoring.ProductionComponentMonitor;\nimport dagger.producers.monitoring.internal.Monitors;\nimport javax.annotation.processing.Filer;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.util.Elements;\n\n/** Generates a monitoring module for use with production components. */\nfinal class MonitoringModuleGenerator extends SourceFileGenerator\u003cTypeElement\u003e {\n\n  MonitoringModuleGenerator(Filer filer, Elements elements) {\n    super(filer, elements);\n  }\n\n  @Override\n  ClassName nameGeneratedType(TypeElement componentElement) {\n    return SourceFiles.generatedMonitoringModuleName(componentElement);\n  }\n\n  @Override\n  Optional\u003c? extends Element\u003e getElementForErrorReporting(TypeElement componentElement) {\n    return Optional.of(componentElement);\n  }\n\n  @Override\n  Optional\u003cTypeSpec.Builder\u003e write(ClassName generatedTypeName, TypeElement componentElement) {\n    return Optional.of(\n        classBuilder(generatedTypeName)\n.addAnnotation(Module.class)\n            .addModifiers(ABSTRACT)\n            .addMethod(privateConstructor())\n            .addMethod(setOfFactories())\n            .addMethod(monitor(componentElement)));\n  }\n\n  private MethodSpec privateConstructor() {\n    return constructorBuilder().addModifiers(PRIVATE).build();\n  }\n\n  private MethodSpec setOfFactories() {\n    return methodBuilder(\"setOfFactories\")\n        .addAnnotation(Multibinds.class)\n        .addModifiers(ABSTRACT)\n        .returns(setOf(PRODUCTION_COMPONENT_MONITOR_FACTORY))\n        .build();\n  }\n\n  private MethodSpec monitor(TypeElement componentElement) {\n    return methodBuilder(\"monitor\")\n        .returns(ProductionComponentMonitor.class)\n        .addModifiers(STATIC)\n        .addAnnotation(Provides.class)\n        .addAnnotation(ProductionScope.class)\n        .addParameter(providerOf(ClassName.get(componentElement.asType())), \"component\")\n        .addParameter(\n            providerOf(setOf(PRODUCTION_COMPONENT_MONITOR_FACTORY)), \"factories\")\n        .addStatement(\n            \"return $T.createMonitorForComponent(component, factories)\", Monitors.class)\n        .build();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MonitoringModuleProcessingStep.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;\nimport com.google.auto.common.MoreElements;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.SetMultimap;\nimport dagger.producers.ProductionComponent;\nimport dagger.producers.ProductionSubcomponent;\nimport java.lang.annotation.Annotation;\nimport java.util.Set;\nimport javax.annotation.processing.Messager;\nimport javax.lang.model.element.Element;\n\n/**\n * A processing step that is responsible for generating a special module for a\n * {@link ProductionComponent} or {@link ProductionSubcomponent}.\n */\nfinal class MonitoringModuleProcessingStep implements ProcessingStep {\n  private final Messager messager;\n  private final MonitoringModuleGenerator monitoringModuleGenerator;\n\n  MonitoringModuleProcessingStep(\n      Messager messager, MonitoringModuleGenerator monitoringModuleGenerator) {\n    this.messager \u003d messager;\n    this.monitoringModuleGenerator \u003d monitoringModuleGenerator;\n  }\n\n  @Override\n  public Set\u003c? extends Class\u003c? extends Annotation\u003e\u003e annotations() {\n    return ImmutableSet.of(ProductionComponent.class, ProductionSubcomponent.class);\n  }\n\n  @Override\n  public Set\u003cElement\u003e process(\n      SetMultimap\u003cClass\u003c? extends Annotation\u003e, Element\u003e elementsByAnnotation) {\n    for (Element element : elementsByAnnotation.values()) {\n      monitoringModuleGenerator.generate(MoreElements.asType(element), messager);\n    }\n    return ImmutableSet.of();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MoreAnnotationMirrors.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.auto.common.AnnotationMirrors;\nimport com.google.common.base.Equivalence;\nimport com.google.common.base.Optional;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Name;\n\n/**\n * A utility class for working with {@link AnnotationMirror} instances, similar to {@link\n * AnnotationMirrors}.\n */\nfinal class MoreAnnotationMirrors {\n\n  private MoreAnnotationMirrors() {}\n\n  /**\n   * Wraps an {@link Optional} of a type in an {@code Optional} of a {@link Equivalence.Wrapper} for\n   * that type.\n   */\n  static Optional\u003cEquivalence.Wrapper\u003cAnnotationMirror\u003e\u003e wrapOptionalInEquivalence(\n      Optional\u003cAnnotationMirror\u003e optional) {\n    return optional.isPresent()\n        ? Optional.of(AnnotationMirrors.equivalence().wrap(optional.get()))\n        : Optional.\u003cEquivalence.Wrapper\u003cAnnotationMirror\u003e\u003eabsent();\n  }\n\n  /**\n   * Unwraps an {@link Optional} of a {@link Equivalence.Wrapper} into an {@code Optional} of the\n   * underlying type.\n   */\n  static Optional\u003cAnnotationMirror\u003e unwrapOptionalEquivalence(\n      Optional\u003cEquivalence.Wrapper\u003cAnnotationMirror\u003e\u003e wrappedOptional) {\n    return wrappedOptional.isPresent()\n        ? Optional.of(wrappedOptional.get().get())\n        : Optional.\u003cAnnotationMirror\u003eabsent();\n  }\n\n  static Name simpleName(AnnotationMirror annotationMirror) {\n    return annotationMirror.getAnnotationType().asElement().getSimpleName();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MultibindingAnnotations.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getAnnotationMirror;\n\nimport com.google.common.collect.ImmutableSet;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntoMap;\nimport dagger.multibindings.IntoSet;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.ExecutableElement;\n\n/**\n * Utility methods related to processing {@link IntoSet}, {@link ElementsIntoSet}, and {@link\n * IntoMap}.\n */\nfinal class MultibindingAnnotations {\n  static ImmutableSet\u003cAnnotationMirror\u003e forMethod(ExecutableElement method) {\n    return ImmutableSet.\u003cAnnotationMirror\u003ebuilder()\n        .addAll(getAnnotationMirror(method, IntoSet.class).asSet())\n        .addAll(getAnnotationMirror(method, ElementsIntoSet.class).asSet())\n        .addAll(getAnnotationMirror(method, IntoMap.class).asSet())\n        .build();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MultibindingAnnotationsProcessingStep.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getAnnotationMirror;\nimport static dagger.internal.codegen.ErrorMessages.MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD;\nimport static dagger.internal.codegen.Util.isAnyAnnotationPresent;\n\nimport com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.SetMultimap;\nimport dagger.Binds;\nimport dagger.Provides;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntoMap;\nimport dagger.multibindings.IntoSet;\nimport dagger.producers.Produces;\nimport java.lang.annotation.Annotation;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport javax.annotation.processing.Messager;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.tools.Diagnostic.Kind;\n\n/**\n * Processing step which verifies that {@link IntoSet @IntoSet}, {@link ElementsIntoSet\n * @ElementsIntoSet} and {@link IntoMap @IntoMap} are not present on invalid elements.\n */\nfinal class MultibindingAnnotationsProcessingStep implements ProcessingStep {\n\n  private static final ImmutableSet\u003cClass\u003c? extends Annotation\u003e\u003e VALID_BINDING_ANNOTATIONS \u003d\n      ImmutableSet.of(Provides.class, Produces.class, Binds.class);\n\n  private final Messager messager;\n\n  MultibindingAnnotationsProcessingStep(Messager messager) {\n    this.messager \u003d messager;\n  }\n\n  @Override\n  public Set\u003c? extends Class\u003c? extends Annotation\u003e\u003e annotations() {\n    return ImmutableSet.of(IntoSet.class, ElementsIntoSet.class, IntoMap.class);\n  }\n\n  @Override\n  public Set\u003cElement\u003e process(\n      SetMultimap\u003cClass\u003c? extends Annotation\u003e, Element\u003e elementsByAnnotation) {\n    for (Entry\u003cClass\u003c? extends Annotation\u003e, Element\u003e entry : elementsByAnnotation.entries()) {\n      Element element \u003d entry.getValue();\n      if (!isAnyAnnotationPresent(element, VALID_BINDING_ANNOTATIONS)) {\n        AnnotationMirror annotation \u003d getAnnotationMirror(entry.getValue(), entry.getKey()).get();\n        messager.printMessage(\n            Kind.ERROR, MULTIBINDING_ANNOTATION_NOT_ON_BINDING_METHOD, element, annotation);\n      }\n    }\n    return ImmutableSet.of();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MultibindingDeclaration.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static javax.lang.model.element.ElementKind.INTERFACE;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableSet;\nimport dagger.Module;\nimport dagger.Multibindings;\nimport dagger.internal.codegen.BindingType.HasBindingType;\nimport dagger.internal.codegen.ContributionType.HasContributionType;\nimport dagger.multibindings.Multibinds;\nimport dagger.producers.Producer;\nimport dagger.producers.ProducerModule;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.inject.Provider;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/**\n * A declaration that a multibinding with a certain key is available to be injected in a component\n * even if the component has no multibindings for that key. Identified by a map- or set-returning\n * method in a {@link Multibindings @Multibindings}-annotated interface nested within a module.\n */\n@AutoValue\nabstract class MultibindingDeclaration extends BindingDeclaration\n    implements HasBindingType, HasContributionType {\n\n  /**\n   * The map or set key whose availability is declared. For maps, this will be {@code Map\u003cK, F\u003cV\u003e\u003e},\n   * where {@code F} is either {@link Provider} or {@link Producer}. For sets, this will be\n   * {@code Set\u003cT\u003e}.\n   */\n  @Override\n  public abstract Key key();\n\n  /**\n   * {@link ContributionType#SET} if the declared type is a {@link Set}, or\n   * {@link ContributionType#MAP} if it is a {@link Map}.\n   */\n  @Override\n  public abstract ContributionType contributionType();\n\n  /**\n   * {@link BindingType#PROVISION} if the {@link Multibindings @Multibindings}-annotated interface\n   * is nested in a {@link Module @Module}, or {@link BindingType#PROVISION} if it is nested in a\n   * {@link ProducerModule @ProducerModule}.\n   */\n  @Override\n  public abstract BindingType bindingType();\n\n  /**\n   * A factory for {@link MultibindingDeclaration}s.\n   */\n  static final class Factory {\n    private final Elements elements;\n    private final Types types;\n    private final Key.Factory keyFactory;\n    private final TypeElement objectElement;\n\n    Factory(Elements elements, Types types, Key.Factory keyFactory) {\n      this.elements \u003d elements;\n      this.types \u003d types;\n      this.keyFactory \u003d keyFactory;\n      this.objectElement \u003d elements.getTypeElement(Object.class.getCanonicalName());\n    }\n\n    /**\n     * Creates multibinding declarations for each method in a\n     * {@link Multibindings @Multibindings}-annotated interface.\n     */\n    ImmutableSet\u003cMultibindingDeclaration\u003e forMultibindingsInterface(TypeElement interfaceElement) {\n      checkArgument(interfaceElement.getKind().equals(INTERFACE));\n      checkArgument(isAnnotationPresent(interfaceElement, Multibindings.class));\n      BindingType bindingType \u003d bindingType(interfaceElement.getEnclosingElement());\n      DeclaredType interfaceType \u003d MoreTypes.asDeclared(interfaceElement.asType());\n\n      ImmutableSet.Builder\u003cMultibindingDeclaration\u003e declarations \u003d ImmutableSet.builder();\n      for (ExecutableElement method : getLocalAndInheritedMethods(interfaceElement, elements)) {\n        if (!method.getEnclosingElement().equals(objectElement)) {\n          ExecutableType methodType \u003d\n              MoreTypes.asExecutable(types.asMemberOf(interfaceType, method));\n          declarations.add(forDeclaredMethod(bindingType, method, methodType, interfaceElement));\n        }\n      }\n      return declarations.build();\n    }\n\n    /** A multibinding declaration for a {@link Multibinds @Multibinds} method. */\n    MultibindingDeclaration forMultibindsMethod(\n        ExecutableElement moduleMethod, TypeElement moduleElement) {\n      checkArgument(isAnnotationPresent(moduleMethod, Multibinds.class));\n      return forDeclaredMethod(\n          bindingType(moduleElement),\n          moduleMethod,\n          MoreTypes.asExecutable(\n              types.asMemberOf(MoreTypes.asDeclared(moduleElement.asType()), moduleMethod)),\n          moduleElement);\n    }\n\n    private BindingType bindingType(Element moduleElement) {\n      if (isAnnotationPresent(moduleElement, Module.class)) {\n        return BindingType.PROVISION;\n      } else if (isAnnotationPresent(moduleElement, ProducerModule.class)) {\n        return BindingType.PRODUCTION;\n      } else {\n        throw new IllegalArgumentException(\n            \"Expected \" + moduleElement + \" to be a @Module or @ProducerModule\");\n      }\n    }\n\n    private MultibindingDeclaration forDeclaredMethod(\n        BindingType bindingType,\n        ExecutableElement method,\n        ExecutableType methodType,\n        TypeElement contributingType) {\n      TypeMirror returnType \u003d methodType.getReturnType();\n      checkArgument(\n          SetType.isSet(returnType) || MapType.isMap(returnType),\n          \"%s must return a set or map\",\n          method);\n      return new AutoValue_MultibindingDeclaration(\n          Optional.\u003cElement\u003eof(method),\n          Optional.of(contributingType),\n          keyFactory.forMultibindsMethod(bindingType, methodType, method),\n          contributionType(returnType),\n          bindingType);\n    }\n\n    private ContributionType contributionType(TypeMirror returnType) {\n      if (MapType.isMap(returnType)) {\n        return ContributionType.MAP;\n      } else if (SetType.isSet(returnType)) {\n        return ContributionType.SET;\n      } else {\n        throw new IllegalArgumentException(\"Must be Map or Set: \" + returnType);\n      }\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MultibindingsMethodValidator.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.common.collect.ImmutableSet;\nimport dagger.Multibindings;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/** A validator for methods in {@link Multibindings @Multibindings} interfaces. */\nfinal class MultibindingsMethodValidator extends MultibindsMethodValidator {\n\n  MultibindingsMethodValidator(Elements elements, Types types) {\n    super(elements, types, Multibindings.class, ImmutableSet.of(Multibindings.class));\n  }\n\n  @Override\n  protected void checkEnclosingElement(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    // no-op, since @Multibindings interfaces can inherit methods from unannotated supertypes.\n  }\n}\n\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MultibindingsProcessingStep.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static javax.lang.model.util.ElementFilter.typesIn;\n\nimport com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.SetMultimap;\nimport dagger.Multibindings;\nimport java.lang.annotation.Annotation;\nimport java.util.Set;\nimport javax.annotation.processing.Messager;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.TypeElement;\n\n/**\n * Processes elements annotated with {@link Multibindings @Multibindings}.\n */\nclass MultibindingsProcessingStep implements ProcessingStep {\n  private final Messager messager;\n  private final MultibindingsValidator multibindingsValidator;\n\n  MultibindingsProcessingStep(Messager messager, MultibindingsValidator multibindingsValidator) {\n    this.messager \u003d messager;\n    this.multibindingsValidator \u003d multibindingsValidator;\n  }\n\n  @Override\n  public Set\u003c? extends Class\u003c? extends Annotation\u003e\u003e annotations() {\n    return ImmutableSet.of(Multibindings.class);\n  }\n\n  @Override\n  public Set\u003cElement\u003e process(\n      SetMultimap\u003cClass\u003c? extends Annotation\u003e, Element\u003e elementsByAnnotation) {\n    for (TypeElement element : typesIn(elementsByAnnotation.values())) {\n      multibindingsValidator.validate(element).printMessagesTo(messager);\n    }\n    return ImmutableSet.of();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MultibindingsValidator.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static com.google.auto.common.MoreTypes.asExecutable;\nimport static dagger.internal.codegen.ErrorMessages.DUPLICATE_SIZE_LIMIT;\nimport static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_INTERFACE;\nimport static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_BE_IN_MODULE;\nimport static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.MUST_NOT_HAVE_TYPE_PARAMETERS;\nimport static dagger.internal.codegen.ErrorMessages.MultibindingsMessages.tooManyMethodsForKey;\nimport static javax.lang.model.element.ElementKind.INTERFACE;\n\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableListMultimap;\nimport dagger.Module;\nimport dagger.Multibindings;\nimport dagger.producers.ProducerModule;\nimport java.util.Collection;\nimport java.util.Map;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.util.Elements;\n\n/**\n * A {@linkplain ValidationReport validator} for {@link Multibindings @Multibindings}-annotated\n * types.\n */\nfinal class MultibindingsValidator {\n  private final Elements elements;\n  private final Key.Factory keyFactory;\n  private final KeyFormatter keyFormatter;\n  private final MethodSignatureFormatter methodSignatureFormatter;\n  private final TypeElement objectElement;\n  private final MultibindingsMethodValidator multibindingsMethodValidator;\n\n  MultibindingsValidator(\n      Elements elements,\n      Key.Factory keyFactory,\n      KeyFormatter keyFormatter,\n      MethodSignatureFormatter methodSignatureFormatter,\n      MultibindingsMethodValidator multibindingsMethodValidator) {\n    this.elements \u003d elements;\n    this.keyFactory \u003d keyFactory;\n    this.keyFormatter \u003d keyFormatter;\n    this.methodSignatureFormatter \u003d methodSignatureFormatter;\n    this.multibindingsMethodValidator \u003d multibindingsMethodValidator;\n    this.objectElement \u003d elements.getTypeElement(Object.class.getCanonicalName());\n  }\n\n  /**\n   * Returns a report containing validation errors for a\n   * {@link Multibindings @Multibindings}-annotated type.\n   */\n  public ValidationReport\u003cTypeElement\u003e validate(TypeElement multibindingsType) {\n    ValidationReport.Builder\u003cTypeElement\u003e validation \u003d ValidationReport.about(multibindingsType);\n    if (!multibindingsType.getKind().equals(INTERFACE)) {\n      validation.addError(MUST_BE_INTERFACE, multibindingsType);\n    }\n    if (!multibindingsType.getTypeParameters().isEmpty()) {\n      validation.addError(MUST_NOT_HAVE_TYPE_PARAMETERS, multibindingsType);\n    }\n    Optional\u003cBindingType\u003e bindingType \u003d bindingType(multibindingsType);\n    if (!bindingType.isPresent()) {\n      validation.addError(MUST_BE_IN_MODULE, multibindingsType);\n    }\n\n    ImmutableListMultimap.Builder\u003cKey, ExecutableElement\u003e methodsByKey \u003d\n        ImmutableListMultimap.builder();\n    for (ExecutableElement method : getLocalAndInheritedMethods(multibindingsType, elements)) {\n      // Skip methods in Object.\n      if (method.getEnclosingElement().equals(objectElement)) {\n        continue;\n      }\n      \n      ValidationReport\u003cExecutableElement\u003e methodReport \u003d\n          multibindingsMethodValidator.validate(method);\n      validation.addItems(methodReport.items());\n\n      if (methodReport.isClean() \u0026\u0026 bindingType.isPresent()) {\n        methodsByKey.put(\n            keyFactory.forMultibindsMethod(\n                bindingType.get(), asExecutable(method.asType()), method),\n            method);\n      }\n    }\n    for (Map.Entry\u003cKey, Collection\u003cExecutableElement\u003e\u003e entry :\n        methodsByKey.build().asMap().entrySet()) {\n      Collection\u003cExecutableElement\u003e methods \u003d entry.getValue();\n      if (methods.size() \u003e 1) {\n        Key key \u003d entry.getKey();\n        validation.addError(tooManyMultibindingsMethodsForKey(key, methods), multibindingsType);\n      }\n    }\n    return validation.build();\n  }\n\n  private String tooManyMultibindingsMethodsForKey(Key key, Collection\u003cExecutableElement\u003e methods) {\n    StringBuilder builder \u003d new StringBuilder(tooManyMethodsForKey(keyFormatter.format(key)));\n    builder.append(\u0027:\u0027);\n    methodSignatureFormatter.formatIndentedList(builder, methods, 1, DUPLICATE_SIZE_LIMIT);\n    return builder.toString();\n  }\n\n  private Optional\u003cBindingType\u003e bindingType(TypeElement multibindingsType) {\n    if (isAnnotationPresent(multibindingsType.getEnclosingElement(), Module.class)) {\n      return Optional.of(BindingType.PROVISION);\n    } else if (isAnnotationPresent(multibindingsType.getEnclosingElement(), ProducerModule.class)) {\n      return Optional.of(BindingType.PRODUCTION);\n    } else {\n      return Optional.\u003cBindingType\u003eabsent();\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\MultibindsMethodValidator.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_ABSTRACT;\nimport static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.NO_MULTIBINDINGS;\nimport static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.NO_EXCEPTIONS;\nimport static dagger.internal.codegen.ErrorMessages.MultibindsMessages.METHOD_MUST_RETURN_MAP_OR_SET;\nimport static dagger.internal.codegen.ErrorMessages.MultibindsMessages.PARAMETERS;\nimport static dagger.internal.codegen.FrameworkTypes.isFrameworkType;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.collect.ImmutableSet;\nimport dagger.Module;\nimport dagger.Multibindings;\nimport dagger.multibindings.Multibinds;\nimport dagger.producers.ProducerModule;\nimport java.lang.annotation.Annotation;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/**\n * A validator for {@link Multibinds @Multibinds} methods or methods in {@link Multibindings\n * @Multibindings} interfaces.\n */\nclass MultibindsMethodValidator extends BindingMethodValidator {\n\n  /** Creates a validator for {@link Multibinds @Multibinds} methods. */\n  MultibindsMethodValidator(Elements elements, Types types) {\n    this(elements, types, Multibinds.class, ImmutableSet.of(Module.class, ProducerModule.class));\n  }\n\n  protected MultibindsMethodValidator(\n      Elements elements,\n      Types types,\n      Class\u003c? extends Annotation\u003e methodAnnotation,\n      Iterable\u003c? extends Class\u003c? extends Annotation\u003e\u003e enclosingElementAnnotations) {\n    super(\n        elements,\n        types,\n        methodAnnotation,\n        enclosingElementAnnotations,\n        MUST_BE_ABSTRACT,\n        NO_EXCEPTIONS,\n        NO_MULTIBINDINGS);\n  }\n  \n  @Override\n  protected void checkMethod(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    super.checkMethod(builder);\n\n    checkParameters(builder);\n  }\n\n  private void checkParameters(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    if (!builder.getSubject().getParameters().isEmpty()) {\n      builder.addError(formatErrorMessage(PARAMETERS));\n    }\n  }\n\n  /** Adds an error unless the method returns a {@code Map\u003cK, V\u003e} or {@code Set\u003cT\u003e}. */\n  @Override\n  protected void checkReturnType(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    if (!isPlainMap(builder.getSubject().getReturnType())\n        \u0026\u0026 !isPlainSet(builder.getSubject().getReturnType())) {\n      builder.addError(formatErrorMessage(METHOD_MUST_RETURN_MAP_OR_SET));\n    }\n  }\n\n  private boolean isPlainMap(TypeMirror returnType) {\n    if (!MapType.isMap(returnType)) {\n      return false;\n    }\n    MapType mapType \u003d MapType.from(returnType);\n    return !mapType.isRawType()\n        \u0026\u0026 MoreTypes.isType(mapType.valueType()) // No wildcards.\n        \u0026\u0026 !isFrameworkType(mapType.valueType());\n  }\n\n  private boolean isPlainSet(TypeMirror returnType) {\n    if (!SetType.isSet(returnType)) {\n      return false;\n    }\n    SetType setType \u003d SetType.from(returnType);\n    return !setType.isRawType()\n        \u0026\u0026 MoreTypes.isType(setType.elementType()) // No wildcards.\n        \u0026\u0026 !isFrameworkType(setType.elementType());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\OptionalBindingDeclaration.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static com.google.common.base.Preconditions.checkArgument;\n\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport dagger.BindsOptionalOf;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\n\n/** A {@link BindsOptionalOf} declaration. */\n@AutoValue\nabstract class OptionalBindingDeclaration extends BindingDeclaration {\n\n  /**\n   * {@inheritDoc}\n   *\n   * \u003cp\u003eThe key\u0027s type is the method\u0027s return type, even though the synthetic bindings will be for\n   * {@code Optional} of derived types.\n   */\n  @Override\n  public abstract Key key();\n\n  static class Factory {\n    private final Key.Factory keyFactory;\n\n    Factory(Key.Factory keyFactory) {\n      this.keyFactory \u003d keyFactory;\n    }\n\n    OptionalBindingDeclaration forMethod(ExecutableElement method, TypeElement contributingModule) {\n      checkArgument(isAnnotationPresent(method, BindsOptionalOf.class));\n      return new AutoValue_OptionalBindingDeclaration(\n          Optional.\u003cElement\u003eof(method),\n          Optional.of(contributingModule),\n          keyFactory.forBindsOptionalOfMethod(method, contributingModule));\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\OptionalFactories.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.CaseFormat.UPPER_CAMEL;\nimport static com.google.common.base.CaseFormat.UPPER_UNDERSCORE;\nimport static com.squareup.javapoet.MethodSpec.constructorBuilder;\nimport static com.squareup.javapoet.MethodSpec.methodBuilder;\nimport static com.squareup.javapoet.TypeSpec.anonymousClassBuilder;\nimport static com.squareup.javapoet.TypeSpec.classBuilder;\nimport static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_RAWTYPES;\nimport static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;\nimport static dagger.internal.codegen.TypeNames.PROVIDER;\nimport static dagger.internal.codegen.TypeNames.listenableFutureOf;\nimport static dagger.internal.codegen.TypeNames.providerOf;\nimport static javax.lang.model.element.Modifier.FINAL;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.element.Modifier.PUBLIC;\nimport static javax.lang.model.element.Modifier.STATIC;\n\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Function;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport com.squareup.javapoet.FieldSpec;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.ParameterSpec;\nimport com.squareup.javapoet.ParameterizedTypeName;\nimport com.squareup.javapoet.TypeName;\nimport com.squareup.javapoet.TypeSpec;\nimport com.squareup.javapoet.TypeVariableName;\nimport dagger.internal.InstanceFactory;\nimport dagger.internal.Preconditions;\nimport dagger.internal.codegen.OptionalType.OptionalKind;\nimport dagger.producers.Producer;\nimport dagger.producers.internal.Producers;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport javax.inject.Provider;\n\n/** The nested class and static methods required by the component to implement optional bindings. */\n// TODO(dpb): Name members simply if a component uses only one of Guava or JDK Optional.\nfinal class OptionalFactories {\n\n  /**\n   * The factory classes that implement {@code Provider\u003cOptional\u003cT\u003e\u003e} or {@code\n   * Producer\u003cOptional\u003cT\u003e\u003e} for present optional bindings for a given kind of dependency request\n   * within the component.\n   *\n   * \u003cp\u003eThe key is the {@code Provider\u003cOptional\u003cT\u003e\u003e} type.\n   */\n  private final Map\u003cPresentFactorySpec, TypeSpec\u003e presentFactoryClasses \u003d\n      new TreeMap\u003c\u003e(\n          Comparator.comparing(PresentFactorySpec::valueKind)\n              .thenComparing(PresentFactorySpec::bindingType)\n              .thenComparing(PresentFactorySpec::optionalKind));\n\n  /**\n   * The static methods that return a {@code Provider\u003cOptional\u003cT\u003e\u003e} that always returns an absent\n   * value.\n   */\n  private final Map\u003cOptionalKind, MethodSpec\u003e absentOptionalProviderMethods \u003d new TreeMap\u003c\u003e();\n\n  /**\n   * The static fields for {@code Provider\u003cOptional\u003cT\u003e\u003e} objects that always return an absent value.\n   */\n  private final Map\u003cOptionalKind, FieldSpec\u003e absentOptionalProviderFields \u003d new TreeMap\u003c\u003e();\n\n  /**\n   * Returns an expression that calls a static method that returns a {@code Provider\u003cOptional\u003cT\u003e\u003e}\n   * for absent optional bindings.\n   */\n  CodeBlock absentOptionalProvider(ContributionBinding binding) {\n    OptionalKind optionalKind \u003d OptionalType.from(binding.key()).kind();\n    return CodeBlock.of(\n        \"$N()\",\n        absentOptionalProviderMethods.computeIfAbsent(\n            optionalKind, this::absentOptionalProviderMethod));\n  }\n\n  /**\n   * Creates a method specification for a {@link Provider\u003cOptional\u003cT\u003e\u003e} that always returns an\n   * absent value.\n   */\n  private MethodSpec absentOptionalProviderMethod(OptionalKind optionalKind) {\n    TypeVariableName typeVariable \u003d TypeVariableName.get(\"T\");\n    return methodBuilder(\n            String.format(\n                \"absent%sProvider\", UPPER_UNDERSCORE.to(UPPER_CAMEL, optionalKind.name())))\n        .addModifiers(PRIVATE, STATIC)\n        .addTypeVariable(typeVariable)\n        .returns(providerOf(optionalKind.of(typeVariable)))\n        .addJavadoc(\n            \"Returns a {@link $T} that returns {@code $L}.\",\n            Provider.class,\n            optionalKind.absentValueExpression())\n        .addCode(\"$L // safe covariant cast\\n\", SUPPRESS_WARNINGS_UNCHECKED)\n        .addCode(\n            \"$1T provider \u003d ($1T) $2N;\",\n            providerOf(optionalKind.of(typeVariable)),\n            absentOptionalProviderFields.computeIfAbsent(\n                optionalKind, this::absentOptionalProviderField))\n        .addCode(\"return provider;\")\n        .build();\n  }\n\n  /**\n   * Creates a field specification for a {@link Provider\u003cOptional\u003cT\u003e\u003e} that always returns an absent\n   * value.\n   */\n  private FieldSpec absentOptionalProviderField(OptionalKind optionalKind) {\n    return FieldSpec.builder(\n            PROVIDER,\n            String.format(\"ABSENT_%s_PROVIDER\", optionalKind.name()),\n            PRIVATE,\n            STATIC,\n            FINAL)\n        .addAnnotation(SUPPRESS_WARNINGS_RAWTYPES)\n        .initializer(\"$T.create($L)\", InstanceFactory.class, optionalKind.absentValueExpression())\n        .addJavadoc(\n            \"A {@link $T} that returns {@code $L}.\",\n            Provider.class,\n            optionalKind.absentValueExpression())\n        .build();\n  }\n\n  /** Information about the type of a factory for present bindings. */\n  @AutoValue\n  abstract static class PresentFactorySpec {\n    /** Whether the factory is a {@link Provider} or a {@link Producer}. */\n    abstract BindingType bindingType();\n\n    /** What kind of {@code Optional} is returned. */\n    abstract OptionalKind optionalKind();\n\n    /** The kind of request satisfied by the value of the {@code Optional}. */\n    abstract DependencyRequest.Kind valueKind();\n\n    /** The type variable for the factory class. */\n    TypeVariableName typeVariable() {\n      return TypeVariableName.get(\"T\");\n    }\n\n    /** The type contained by the {@code Optional}. */\n    TypeName valueType() {\n      return valueKind().typeName(typeVariable());\n    }\n\n    /** The type provided or produced by the factory. */\n    ParameterizedTypeName optionalType() {\n      return optionalKind().of(valueType());\n    }\n\n    /** The type of the factory. */\n    ParameterizedTypeName factoryType() {\n      return bindingType().frameworkClassOf(optionalType());\n    }\n\n    /** The type of the delegate provider or producer. */\n    ParameterizedTypeName delegateType() {\n      return bindingType().frameworkClassOf(typeVariable());\n    }\n\n    /** The name of the factory class. */\n    String factoryClassName() {\n      return new StringBuilder(\"Present\")\n          .append(UPPER_UNDERSCORE.to(UPPER_CAMEL, optionalKind().name()))\n          .append(UPPER_UNDERSCORE.to(UPPER_CAMEL, valueKind().toString()))\n          .append(bindingType().frameworkClass().getSimpleName())\n          .toString();\n    }\n\n    private static PresentFactorySpec of(ContributionBinding binding) {\n      OptionalKind optionalKind \u003d OptionalType.from(binding.key()).kind();\n      DependencyRequest.Kind valueKind \u003d\n          DependencyRequest.extractKindAndType(OptionalType.from(binding.key()).valueType()).kind();\n      return new AutoValue_OptionalFactories_PresentFactorySpec(\n          binding.bindingType(), optionalKind, valueKind);\n    }\n  }\n  \n  /**\n   * Returns an expression for an instance of a nested class that implements {@code\n   * Provider\u003cOptional\u003cT\u003e\u003e} or {@code Producer\u003cOptional\u003cT\u003e\u003e} for a present optional binding, where\n   * {@code T} represents dependency requests of that kind.\n   *\n   * \u003cul\u003e\n   * \u003cli\u003eIf {@code optionalRequestKind} is {@link DependencyRequest.Kind#INSTANCE}, the class\n   *     implements {@code ProviderOrProducer\u003cOptional\u003cT\u003e\u003e}.\n   * \u003cli\u003eIf {@code optionalRequestKind} is {@link DependencyRequest.Kind#PROVIDER}, the class\n   *     implements {@code Provider\u003cOptional\u003cProvider\u003cT\u003e\u003e\u003e}.\n   * \u003cli\u003eIf {@code optionalRequestKind} is {@link DependencyRequest.Kind#LAZY}, the class implements\n   *     {@code Provider\u003cOptional\u003cLazy\u003cT\u003e\u003e\u003e}.\n   * \u003cli\u003eIf {@code optionalRequestKind} is {@link DependencyRequest.Kind#PROVIDER_OF_LAZY}, the\n   *     class implements {@code Provider\u003cOptional\u003cProvider\u003cLazy\u003cT\u003e\u003e\u003e\u003e}.\n   * \u003cli\u003eIf {@code optionalRequestKind} is {@link DependencyRequest.Kind#PRODUCER}, the class\n   *     implements {@code Producer\u003cOptional\u003cProducer\u003cT\u003e\u003e\u003e}.\n   * \u003cli\u003eIf {@code optionalRequestKind} is {@link DependencyRequest.Kind#PRODUCED}, the class\n   *     implements {@code Producer\u003cOptional\u003cProduced\u003cT\u003e\u003e\u003e}.\n   * \u003c/ul\u003e\n   *\n   * @param delegateFactory an expression for a {@link Provider} or {@link Producer} of the\n   *     underlying type\n   */\n  CodeBlock presentOptionalFactory(ContributionBinding binding, CodeBlock delegateFactory) {\n    return CodeBlock.of(\n        \"$N.of($L)\",\n        presentFactoryClasses.computeIfAbsent(\n            PresentFactorySpec.of(binding), this::presentOptionalFactoryClass),\n        delegateFactory);\n  }\n\n  private TypeSpec presentOptionalFactoryClass(PresentFactorySpec spec) {\n    FieldSpec delegateField \u003d\n        FieldSpec.builder(spec.delegateType(), \"delegate\", PRIVATE, FINAL).build();\n    ParameterSpec delegateParameter \u003d ParameterSpec.builder(delegateField.type, \"delegate\").build();\n\n    MethodSpec.Builder getMethodBuilder \u003d\n        methodBuilder(\"get\").addAnnotation(Override.class).addModifiers(PUBLIC);\n    switch (spec.bindingType()) {\n      case PROVISION:\n        getMethodBuilder\n            .returns(spec.optionalType())\n            .addCode(\n                \"return $L;\",\n                spec.optionalKind()\n                    .presentExpression(\n                        FrameworkType.PROVIDER.to(\n                            spec.valueKind(), CodeBlock.of(\"$N\", delegateField))));\n        break;\n\n      case PRODUCTION:\n        getMethodBuilder.returns(listenableFutureOf(spec.optionalType()));\n\n        switch (spec.valueKind()) {\n          case FUTURE: // return a ListenableFuture\u003cOptional\u003cListenableFuture\u003cT\u003e\u003e\u003e\n          case PRODUCER: // return a ListenableFuture\u003cOptional\u003cProducer\u003cT\u003e\u003e\u003e\n            getMethodBuilder.addCode(\n                \"return $T.immediateFuture($L);\",\n                Futures.class,\n                spec.optionalKind()\n                    .presentExpression(\n                        FrameworkType.PRODUCER.to(\n                            spec.valueKind(), CodeBlock.of(\"$N\", delegateField))));\n            break;\n\n          case INSTANCE: // return a ListenableFuture\u003cOptional\u003cT\u003e\u003e\n            getMethodBuilder.addCode(\n                \"return $L;\",\n                transformFutureToOptional(\n                    spec.optionalKind(),\n                    spec.typeVariable(),\n                    CodeBlock.of(\"$N.get()\", delegateField)));\n            break;\n\n          case PRODUCED: // return a ListenableFuture\u003cOptional\u003cProduced\u003cT\u003e\u003e\u003e\n            getMethodBuilder.addCode(\n                \"return $L;\",\n                transformFutureToOptional(\n                    spec.optionalKind(),\n                    spec.valueType(),\n                    CodeBlock.of(\n                        \"$T.createFutureProduced($N.get())\", Producers.class, delegateField)));\n            break;\n\n          default:\n            throw new UnsupportedOperationException(\n                spec.factoryType() + \" objects are not supported\");\n        }\n        break;\n\n      default:\n        throw new AssertionError(spec.bindingType());\n    }\n\n    return classBuilder(spec.factoryClassName())\n        .addTypeVariable(spec.typeVariable())\n        .addModifiers(PRIVATE, STATIC, FINAL)\n        .addSuperinterface(spec.factoryType())\n        .addJavadoc(\n            \"A {@link $T} that uses a delegate {@code $T}.\", spec.factoryType(), delegateField.type)\n        .addField(delegateField)\n        .addMethod(\n            constructorBuilder()\n                .addModifiers(PRIVATE)\n                .addParameter(delegateParameter)\n                .addCode(\n                    \"this.$N \u003d $T.checkNotNull($N);\",\n                    delegateField,\n                    Preconditions.class,\n                    delegateParameter)\n                .build())\n        .addMethod(getMethodBuilder.build())\n        .addMethod(\n            methodBuilder(\"of\")\n                .addModifiers(PRIVATE, STATIC)\n                .addTypeVariable(spec.typeVariable())\n                .returns(spec.factoryType())\n                .addParameter(delegateParameter)\n                .addCode(\n                    \"return new $L\u003c$T\u003e($N);\",\n                    spec.factoryClassName(),\n                    spec.typeVariable(),\n                    delegateParameter)\n                .build())\n        .build();\n  }\n\n  /**\n   * An expression that uses {@link Futures#transform(ListenableFuture, Function)} to transform a\n   * {@code ListenableFuture\u003cinputType\u003e} into a {@code ListenableFuture\u003cOptional\u003cinputType\u003e\u003e}.\n   *\n   * @param inputFuture an expression of type {@code ListenableFuture\u003cinputType\u003e}\n   */\n  private static CodeBlock transformFutureToOptional(\n      OptionalKind optionalKind, TypeName inputType, CodeBlock inputFuture) {\n    return CodeBlock.of(\n        \"$T.transform($L, $L)\",\n        Futures.class,\n        inputFuture,\n        anonymousClassBuilder(\"\")\n            .addSuperinterface(\n                ParameterizedTypeName.get(\n                    ClassName.get(Function.class), inputType, optionalKind.of(inputType)))\n            .addMethod(\n                methodBuilder(\"apply\")\n                    .addAnnotation(Override.class)\n                    .addModifiers(PUBLIC)\n                    .returns(optionalKind.of(inputType))\n                    .addParameter(inputType, \"input\")\n                    .addCode(\"return $L;\", optionalKind.presentExpression(CodeBlock.of(\"input\")))\n                    .build())\n            .build());\n  }\n\n  /**\n   * Adds classes and methods required by previous calls to {@link\n   * #absentOptionalProvider(ContributionBinding)} and {@link\n   * #presentOptionalFactory(ContributionBinding, CodeBlock)} to the top-level {@code component}.\n   */\n  void addMembers(TypeSpec.Builder component) {\n    component.addTypes(presentFactoryClasses.values());\n    component.addMethods(absentOptionalProviderMethods.values());\n    component.addFields(absentOptionalProviderFields.values());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\OptionalType.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Equivalence;\nimport com.google.common.base.Optional;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport com.squareup.javapoet.ParameterizedTypeName;\nimport com.squareup.javapoet.TypeName;\nimport javax.lang.model.element.Name;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.type.TypeVisitor;\nimport javax.lang.model.util.SimpleTypeVisitor8;\n\n/**\n * Information about an {@code Optional} {@link TypeMirror}.\n *\n * \u003cp\u003e{@link com.google.common.base.Optional} and {@link java.util.Optional} are supported.\n */\n@AutoValue\nabstract class OptionalType {\n\n  /** A variant of {@code Optional}. */\n  enum OptionalKind {\n    /** {@link com.google.common.base.Optional}. */\n    GUAVA_OPTIONAL(com.google.common.base.Optional.class, \"absent\"),\n\n    /** {@link java.util.Optional}. */\n    JDK_OPTIONAL(java.util.Optional.class, \"empty\"),\n    ;\n\n    private final Class\u003c?\u003e clazz;\n    private final String absentFactoryMethodName;\n\n    OptionalKind(Class\u003c?\u003e clazz, String absentFactoryMethodName) {\n      this.clazz \u003d clazz;\n      this.absentFactoryMethodName \u003d absentFactoryMethodName;\n    }\n\n    /** Returns {@code valueType} wrapped in the correct class. */\n    ParameterizedTypeName of(TypeName valueType) {\n      return ParameterizedTypeName.get(ClassName.get(clazz), valueType);\n    }\n\n    /** Returns an expression for the absent/empty value. */\n    CodeBlock absentValueExpression() {\n      return CodeBlock.of(\"$T.$L()\", clazz, absentFactoryMethodName);\n    }\n\n    /** Returns an expression for the present {@code value}. */\n    CodeBlock presentExpression(CodeBlock value) {\n      return CodeBlock.of(\"$T.of($L)\", clazz, value);\n    }\n  }\n\n  private static final TypeVisitor\u003cOptional\u003cOptionalKind\u003e, Void\u003e OPTIONAL_KIND \u003d\n      new SimpleTypeVisitor8\u003cOptional\u003cOptionalKind\u003e, Void\u003e(Optional.absent()) {\n        @Override\n        public Optional\u003cOptionalKind\u003e visitDeclared(DeclaredType t, Void p) {\n          for (OptionalKind optionalKind : OptionalKind.values()) {\n            Name qualifiedName \u003d MoreElements.asType(t.asElement()).getQualifiedName();\n            if (qualifiedName.contentEquals(optionalKind.clazz.getCanonicalName())) {\n              return Optional.of(optionalKind);\n            }\n          }\n          return Optional.absent();\n        }\n      };\n\n  /**\n   * The optional type itself, wrapped using {@link MoreTypes#equivalence()}.\n   *\n   * @deprecated Use {@link #declaredOptionalType()} instead.\n   */\n  @Deprecated\n  protected abstract Equivalence.Wrapper\u003cDeclaredType\u003e wrappedDeclaredOptionalType();\n\n  /** The optional type itself. */\n  @SuppressWarnings(\"deprecation\")\n  DeclaredType declaredOptionalType() {\n    return wrappedDeclaredOptionalType().get();\n  }\n  \n  /** Which {@code Optional} type is used. */\n  OptionalKind kind() {\n    return declaredOptionalType().accept(OPTIONAL_KIND, null).get();\n  }\n\n  /** The value type. */\n  TypeMirror valueType() {\n    return declaredOptionalType().getTypeArguments().get(0);\n  }\n\n  /** Returns {@code true} if {@code type} is an {@code Optional} type. */\n  static boolean isOptional(TypeMirror type) {\n    return type.accept(OPTIONAL_KIND, null).isPresent();\n  }\n\n  /** Returns {@code true} if {@code key.type()} is an {@code Optional} type. */\n  static boolean isOptional(Key key) {\n    return isOptional(key.type());\n  }\n\n  /**\n   * Returns a {@link OptionalType} for {@code type}.\n   *\n   * @throws IllegalArgumentException if {@code type} is not an {@code Optional} type\n   */\n  static OptionalType from(TypeMirror type) {\n    checkArgument(isOptional(type), \"%s must be an Optional\", type);\n    return new AutoValue_OptionalType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));\n  }\n\n  /**\n   * Returns a {@link OptionalType} for {@code key}\u0027s {@link Key#type() type}.\n   *\n   * @throws IllegalArgumentException if {@code key.type()} is not an {@code Optional} type\n   */\n  static OptionalType from(Key key) {\n    return from(key.type());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\package-info.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n@CheckReturnValue\npackage dagger.internal.codegen;\n\nimport javax.annotation.CheckReturnValue;\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ProducerFactoryGenerator.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.squareup.javapoet.ClassName.OBJECT;\nimport static com.squareup.javapoet.MethodSpec.constructorBuilder;\nimport static com.squareup.javapoet.MethodSpec.methodBuilder;\nimport static com.squareup.javapoet.TypeSpec.classBuilder;\nimport static dagger.internal.codegen.AnnotationSpecs.SUPPRESS_WARNINGS_UNCHECKED;\nimport static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;\nimport static dagger.internal.codegen.SourceFiles.frameworkTypeUsageStatement;\nimport static dagger.internal.codegen.SourceFiles.generateBindingFieldsForDependencies;\nimport static dagger.internal.codegen.SourceFiles.generatedClassNameForBinding;\nimport static dagger.internal.codegen.TypeNames.ASYNC_FUNCTION;\nimport static dagger.internal.codegen.TypeNames.FUTURES;\nimport static dagger.internal.codegen.TypeNames.PRODUCERS;\nimport static dagger.internal.codegen.TypeNames.PRODUCER_TOKEN;\nimport static dagger.internal.codegen.TypeNames.VOID_CLASS;\nimport static dagger.internal.codegen.TypeNames.abstractProducerOf;\nimport static dagger.internal.codegen.TypeNames.listOf;\nimport static dagger.internal.codegen.TypeNames.listenableFutureOf;\nimport static dagger.internal.codegen.TypeNames.producedOf;\nimport static java.util.stream.Collectors.joining;\nimport static javax.lang.model.element.Modifier.FINAL;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.element.Modifier.PROTECTED;\nimport static javax.lang.model.element.Modifier.PUBLIC;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Iterables;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport com.squareup.javapoet.FieldSpec;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.ParameterizedTypeName;\nimport com.squareup.javapoet.TypeName;\nimport com.squareup.javapoet.TypeSpec;\nimport dagger.producers.Producer;\nimport java.util.Map;\nimport javax.annotation.processing.Filer;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\n\n/**\n * Generates {@link Producer} implementations from {@link ProductionBinding} instances.\n *\n * @author Jesse Beder\n * @since 2.0\n */\nfinal class ProducerFactoryGenerator extends SourceFileGenerator\u003cProductionBinding\u003e {\n  private final CompilerOptions compilerOptions;\n\n  ProducerFactoryGenerator(Filer filer, Elements elements, CompilerOptions compilerOptions) {\n    super(filer, elements);\n    this.compilerOptions \u003d compilerOptions;\n  }\n\n  @Override\n  ClassName nameGeneratedType(ProductionBinding binding) {\n    return generatedClassNameForBinding(binding);\n  }\n\n  @Override\n  Optional\u003c? extends Element\u003e getElementForErrorReporting(ProductionBinding binding) {\n    return binding.bindingElement();\n  }\n\n  @Override\n  Optional\u003cTypeSpec.Builder\u003e write(ClassName generatedTypeName, ProductionBinding binding) {\n    checkArgument(binding.bindingElement().isPresent());\n\n    TypeName providedTypeName \u003d TypeName.get(binding.factoryType());\n    TypeName futureTypeName \u003d listenableFutureOf(providedTypeName);\n\n    TypeSpec.Builder factoryBuilder \u003d\n        classBuilder(generatedTypeName)\n            .addModifiers(PUBLIC, FINAL)\n            .superclass(abstractProducerOf(providedTypeName));\n\n    UniqueNameSet uniqueFieldNames \u003d new UniqueNameSet();\n    ImmutableMap.Builder\u003cBindingKey, FieldSpec\u003e fieldsBuilder \u003d ImmutableMap.builder();\n\n    MethodSpec.Builder constructorBuilder \u003d constructorBuilder().addModifiers(PUBLIC);\n\n    Optional\u003cFieldSpec\u003e moduleField \u003d\n        binding.requiresModuleInstance()\n            ? Optional.of(\n                addFieldAndConstructorParameter(\n                    factoryBuilder,\n                    constructorBuilder,\n                    uniqueFieldNames.getUniqueName(\"module\"),\n                    TypeName.get(binding.bindingTypeElement().get().asType())))\n            : Optional.\u003cFieldSpec\u003eabsent();\n\n    for (Map.Entry\u003cBindingKey, FrameworkField\u003e entry :\n        generateBindingFieldsForDependencies(binding).entrySet()) {\n      BindingKey bindingKey \u003d entry.getKey();\n      FrameworkField bindingField \u003d entry.getValue();\n      FieldSpec field \u003d\n          addFieldAndConstructorParameter(\n              factoryBuilder,\n              constructorBuilder,\n              uniqueFieldNames.getUniqueName(bindingField.name()),\n              bindingField.type());\n      fieldsBuilder.put(bindingKey, field);\n    }\n    ImmutableMap\u003cBindingKey, FieldSpec\u003e fields \u003d fieldsBuilder.build();\n\n    constructorBuilder.addStatement(\n        \"super($N, $L)\",\n        fields.get(binding.monitorRequest().get().bindingKey()),\n        producerTokenConstruction(generatedTypeName, binding));\n\n    if (binding.requiresModuleInstance()) {\n      assignField(constructorBuilder, moduleField.get());\n    }\n    \n    for (FieldSpec field : fields.values()) {\n      assignField(constructorBuilder, field);\n    }\n\n    MethodSpec.Builder computeMethodBuilder \u003d\n        methodBuilder(\"compute\")\n            .returns(futureTypeName)\n            .addAnnotation(Override.class)\n            .addModifiers(PROTECTED);\n\n    ImmutableList\u003cDependencyRequest\u003e asyncDependencies \u003d asyncDependencies(binding);\n    for (DependencyRequest dependency : asyncDependencies) {\n      TypeName futureType \u003d listenableFutureOf(asyncDependencyType(dependency));\n      CodeBlock futureAccess \u003d CodeBlock.of(\"$N.get()\", fields.get(dependency.bindingKey()));\n      computeMethodBuilder.addStatement(\n          \"$T $L \u003d $L\",\n          futureType,\n          dependencyFutureName(dependency),\n          dependency.kind().equals(DependencyRequest.Kind.PRODUCED)\n              ? CodeBlock.of(\"$T.createFutureProduced($L)\", PRODUCERS, futureAccess)\n              : futureAccess);\n    }\n    FutureTransform futureTransform \u003d FutureTransform.create(fields, binding, asyncDependencies);\n\n    computeMethodBuilder.addStatement(\n        \"return $T.transformAsync($L, this, executorProvider.get())\",\n        FUTURES,\n        futureTransform.futureCodeBlock());\n\n    factoryBuilder.addSuperinterface(\n        ParameterizedTypeName.get(\n            ASYNC_FUNCTION, futureTransform.applyArgType(), providedTypeName));\n\n    MethodSpec.Builder applyMethodBuilder \u003d\n        methodBuilder(\"apply\")\n            .returns(futureTypeName)\n            .addJavadoc(\"@deprecated this may only be called from the internal {@link #compute()}\")\n            .addAnnotation(Deprecated.class)\n            .addAnnotation(Override.class)\n            .addModifiers(PUBLIC)\n            .addParameter(futureTransform.applyArgType(), futureTransform.applyArgName())\n            .addExceptions(getThrownTypeNames(binding.thrownTypes()))\n            .addStatement(\n                \"assert monitor !\u003d null : $S\",\n                \"apply() may only be called internally from compute(); \"\n                    + \"if it\u0027s called explicitly, the monitor might be null\")\n            .addCode(\n                getInvocationCodeBlock(\n                    generatedTypeName,\n                    binding,\n                    providedTypeName,\n                    futureTransform.parameterCodeBlocks()));\n    if (futureTransform.hasUncheckedCast()) {\n      applyMethodBuilder.addAnnotation(SUPPRESS_WARNINGS_UNCHECKED);\n    }\n\n    factoryBuilder.addMethod(constructorBuilder.build());\n    factoryBuilder.addMethod(computeMethodBuilder.build());\n    factoryBuilder.addMethod(applyMethodBuilder.build());\n\n    // TODO(gak): write a sensible toString\n    return Optional.of(factoryBuilder);\n  }\n\n  // TODO(ronshapiro): consolidate versions of these\n  private static FieldSpec addFieldAndConstructorParameter(\n      TypeSpec.Builder typeBuilder,\n      MethodSpec.Builder constructorBuilder,\n      String variableName,\n      TypeName variableType) {\n    FieldSpec field \u003d FieldSpec.builder(variableType, variableName, PRIVATE, FINAL).build();\n    typeBuilder.addField(field);\n    constructorBuilder.addParameter(field.type, field.name);\n    return field;\n  }\n\n  private static void assignField(MethodSpec.Builder constructorBuilder, FieldSpec field) {\n    constructorBuilder\n        .addStatement(\"assert $N !\u003d null\", field)\n        .addStatement(\"this.$1N \u003d $1N\", field);\n  }\n\n  /** Returns a list of dependencies that are generated asynchronously. */\n  private static ImmutableList\u003cDependencyRequest\u003e asyncDependencies(Binding binding) {\n    final ImmutableMap\u003cDependencyRequest, FrameworkDependency\u003e frameworkDependencies \u003d\n        FrameworkDependency.indexByDependencyRequest(\n            FrameworkDependency.frameworkDependenciesForBinding(binding));\n    return FluentIterable.from(binding.implicitDependencies())\n        .filter(\n            dependency -\u003e\n                isAsyncDependency(dependency)\n                    \u0026\u0026 frameworkDependencies\n                        .get(dependency)\n                        .frameworkClass()\n                        .equals(Producer.class))\n        .toList();\n  }\n\n  private CodeBlock producerTokenConstruction(\n      ClassName generatedTypeName, ProductionBinding binding) {\n    CodeBlock producerTokenArgs \u003d\n        compilerOptions.writeProducerNameInToken()\n            ? CodeBlock.of(\n                \"$S\",\n                String.format(\n                    \"%s#%s\",\n                    ClassName.get(binding.bindingTypeElement().get()),\n                    binding.bindingElement().get().getSimpleName()))\n            : CodeBlock.of(\"$T.class\", generatedTypeName);\n    return CodeBlock.of(\"$T.create($L)\", PRODUCER_TOKEN, producerTokenArgs);\n  }\n\n  /** Returns a name of the variable representing this dependency\u0027s future. */\n  private static String dependencyFutureName(DependencyRequest dependency) {\n    return dependency.requestElement().get().getSimpleName() + \"Future\";\n  }\n\n  /** Represents the transformation of an input future by a producer method. */\n  abstract static class FutureTransform {\n    protected final ImmutableMap\u003cBindingKey, FieldSpec\u003e fields;\n    protected final ProductionBinding binding;\n\n    FutureTransform(ImmutableMap\u003cBindingKey, FieldSpec\u003e fields, ProductionBinding binding) {\n      this.fields \u003d fields;\n      this.binding \u003d binding;\n    }\n\n    /** The code block representing the future that should be transformed. */\n    abstract CodeBlock futureCodeBlock();\n\n    /** The type of the argument to the apply method. */\n    abstract TypeName applyArgType();\n\n    /** The name of the argument to the apply method */\n    abstract String applyArgName();\n\n    /** The code blocks to be passed to the produces method itself. */\n    abstract ImmutableList\u003cCodeBlock\u003e parameterCodeBlocks();\n\n    /** Whether the transform method has an unchecked cast. */\n    boolean hasUncheckedCast() {\n      return false;\n    }\n\n    static FutureTransform create(\n        ImmutableMap\u003cBindingKey, FieldSpec\u003e fields,\n        ProductionBinding binding,\n        ImmutableList\u003cDependencyRequest\u003e asyncDependencies) {\n      if (asyncDependencies.isEmpty()) {\n        return new NoArgFutureTransform(fields, binding);\n      } else if (asyncDependencies.size() \u003d\u003d 1) {\n        return new SingleArgFutureTransform(\n            fields, binding, Iterables.getOnlyElement(asyncDependencies));\n      } else {\n        return new MultiArgFutureTransform(fields, binding, asyncDependencies);\n      }\n    }\n  }\n\n  static final class NoArgFutureTransform extends FutureTransform {\n    NoArgFutureTransform(ImmutableMap\u003cBindingKey, FieldSpec\u003e fields, ProductionBinding binding) {\n      super(fields, binding);\n    }\n\n    @Override\n    CodeBlock futureCodeBlock() {\n      return CodeBlock.of(\"$T.\u003c$T\u003eimmediateFuture(null)\", FUTURES, VOID_CLASS);\n    }\n\n    @Override\n    TypeName applyArgType() {\n      return VOID_CLASS;\n    }\n\n    @Override\n    String applyArgName() {\n      return \"ignoredVoidArg\";\n    }\n\n    @Override\n    ImmutableList\u003cCodeBlock\u003e parameterCodeBlocks() {\n      ImmutableList.Builder\u003cCodeBlock\u003e parameterCodeBlocks \u003d ImmutableList.builder();\n      for (DependencyRequest dependency : binding.dependencies()) {\n        parameterCodeBlocks.add(\n            frameworkTypeUsageStatement(\n                CodeBlock.of(\"$N\", fields.get(dependency.bindingKey())), dependency.kind()));\n      }\n      return parameterCodeBlocks.build();\n    }\n  }\n\n  static final class SingleArgFutureTransform extends FutureTransform {\n    private final DependencyRequest asyncDependency;\n\n    SingleArgFutureTransform(\n        ImmutableMap\u003cBindingKey, FieldSpec\u003e fields,\n        ProductionBinding binding,\n        DependencyRequest asyncDependency) {\n      super(fields, binding);\n      this.asyncDependency \u003d asyncDependency;\n    }\n\n    @Override\n    CodeBlock futureCodeBlock() {\n      return CodeBlock.of(\"$L\", dependencyFutureName(asyncDependency));\n    }\n\n    @Override\n    TypeName applyArgType() {\n      return asyncDependencyType(asyncDependency);\n    }\n\n    @Override\n    String applyArgName() {\n      return asyncDependency.requestElement().get().getSimpleName().toString();\n    }\n\n    @Override\n    ImmutableList\u003cCodeBlock\u003e parameterCodeBlocks() {\n      ImmutableList.Builder\u003cCodeBlock\u003e parameterCodeBlocks \u003d ImmutableList.builder();\n      for (DependencyRequest dependency : binding.dependencies()) {\n        // We really want to compare instances here, because asyncDependency is an element in the\n        // set binding.dependencies().\n        if (dependency \u003d\u003d asyncDependency) {\n          parameterCodeBlocks.add(CodeBlock.of(\"$L\", applyArgName()));\n        } else {\n          parameterCodeBlocks.add(\n              // TODO(ronshapiro) extract this into a method shared by FutureTransform subclasses\n              frameworkTypeUsageStatement(\n                  CodeBlock.of(\"$N\", fields.get(dependency.bindingKey())), dependency.kind()));\n        }\n      }\n      return parameterCodeBlocks.build();\n    }\n  }\n\n  static final class MultiArgFutureTransform extends FutureTransform {\n    private final ImmutableList\u003cDependencyRequest\u003e asyncDependencies;\n\n    MultiArgFutureTransform(\n        ImmutableMap\u003cBindingKey, FieldSpec\u003e fields,\n        ProductionBinding binding,\n        ImmutableList\u003cDependencyRequest\u003e asyncDependencies) {\n      super(fields, binding);\n      this.asyncDependencies \u003d asyncDependencies;\n    }\n\n    @Override\n    CodeBlock futureCodeBlock() {\n      return CodeBlock.of(\n          \"$T.\u003c$T\u003eallAsList($L)\",\n          FUTURES,\n          OBJECT,\n          asyncDependencies\n              .stream()\n              .map(ProducerFactoryGenerator::dependencyFutureName)\n              .collect(joining(\", \")));\n    }\n\n    @Override\n    TypeName applyArgType() {\n      return listOf(OBJECT);\n    }\n\n    @Override\n    String applyArgName() {\n      return \"args\";\n    }\n\n    @Override\n    ImmutableList\u003cCodeBlock\u003e parameterCodeBlocks() {\n      return getParameterCodeBlocks(binding, fields, applyArgName());\n    }\n\n    @Override\n    boolean hasUncheckedCast() {\n      return true;\n    }\n  }\n\n  private static boolean isAsyncDependency(DependencyRequest dependency) {\n    switch (dependency.kind()) {\n      case INSTANCE:\n      case PRODUCED:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  private static TypeName asyncDependencyType(DependencyRequest dependency) {\n    TypeName keyName \u003d TypeName.get(dependency.key().type());\n    switch (dependency.kind()) {\n      case INSTANCE:\n        return keyName;\n      case PRODUCED:\n        return producedOf(keyName);\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  private static ImmutableList\u003cCodeBlock\u003e getParameterCodeBlocks(\n      ProductionBinding binding, ImmutableMap\u003cBindingKey, FieldSpec\u003e fields, String listArgName) {\n    int argIndex \u003d 0;\n    ImmutableList.Builder\u003cCodeBlock\u003e codeBlocks \u003d ImmutableList.builder();\n    for (DependencyRequest dependency : binding.dependencies()) {\n      if (isAsyncDependency(dependency)) {\n        codeBlocks.add(\n            CodeBlock.of(\n                \"($T) $L.get($L)\", asyncDependencyType(dependency), listArgName, argIndex));\n        argIndex++;\n      } else {\n        codeBlocks.add(\n            frameworkTypeUsageStatement(\n                CodeBlock.of(\"$N\", fields.get(dependency.bindingKey())), dependency.kind()));\n      }\n    }\n    return codeBlocks.build();\n  }\n\n  /**\n   * Creates a code block for the invocation of the producer method from the module, which should be\n   * used entirely within a method body.\n   *\n   * @param binding The binding to generate the invocation code block for.\n   * @param providedTypeName The type name that should be provided by this producer.\n   * @param parameterCodeBlocks The code blocks for all the parameters to the producer method.\n   */\n  private CodeBlock getInvocationCodeBlock(\n      ClassName generatedTypeName,\n      ProductionBinding binding,\n      TypeName providedTypeName,\n      ImmutableList\u003cCodeBlock\u003e parameterCodeBlocks) {\n    CodeBlock moduleCodeBlock \u003d\n        CodeBlock.of(\n            \"$L.$L($L)\",\n            binding.requiresModuleInstance()\n                ? CodeBlock.of(\"$T.this.module\", generatedTypeName)\n                : CodeBlock.of(\"$T\", ClassName.get(binding.bindingTypeElement().get())),\n            binding.bindingElement().get().getSimpleName(),\n            makeParametersCodeBlock(parameterCodeBlocks));\n\n    // NOTE(beder): We don\u0027t worry about catching exceptions from the monitor methods themselves\n    // because we\u0027ll wrap all monitoring in non-throwing monitors before we pass them to the\n    // factories.\n    ImmutableList.Builder\u003cCodeBlock\u003e codeBlocks \u003d ImmutableList.builder();\n    codeBlocks.add(CodeBlock.of(\"monitor.methodStarting();\"));\n\n    final CodeBlock returnCodeBlock;\n    switch (binding.productionKind().get()) {\n      case IMMEDIATE:\n        returnCodeBlock \u003d\n            CodeBlock.of(\"$T.\u003c$T\u003eimmediateFuture($L)\", FUTURES, providedTypeName, moduleCodeBlock);\n        break;\n      case FUTURE:\n        returnCodeBlock \u003d moduleCodeBlock;\n        break;\n      case SET_OF_FUTURE:\n        returnCodeBlock \u003d CodeBlock.of(\"$T.allAsSet($L)\", PRODUCERS, moduleCodeBlock);\n        break;\n      default:\n        throw new AssertionError();\n    }\n    return CodeBlock.of(\n        Joiner.on(\u0027\\n\u0027)\n            .join(\n                \"monitor.methodStarting();\",\n                \"try {\",\n                \"  return $L;\",\n                \"} finally {\",\n                \"  monitor.methodFinished();\",\n                \"}\"),\n        returnCodeBlock);\n  }\n\n  /**\n   * Converts the list of thrown types into type names.\n   *\n   * @param thrownTypes the list of thrown types.\n   */\n  private FluentIterable\u003c? extends TypeName\u003e getThrownTypeNames(\n      Iterable\u003c? extends TypeMirror\u003e thrownTypes) {\n    return FluentIterable.from(thrownTypes).transform(TypeName::get);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ProducerFieldRequestFulfillment.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;\n\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\n\n/** Fulfills requests for {@link ProductionBinding} instances. */\nfinal class ProducerFieldRequestFulfillment extends RequestFulfillment {\n  private final MemberSelect producerFieldSelect;\n\n  ProducerFieldRequestFulfillment(BindingKey bindingKey, MemberSelect producerFieldSelect) {\n    super(bindingKey);\n    checkArgument(bindingKey.kind().equals(CONTRIBUTION));\n    this.producerFieldSelect \u003d producerFieldSelect;\n  }\n\n  @Override\n  public CodeBlock getSnippetForDependencyRequest(\n      DependencyRequest request, ClassName requestingClass) {\n    return FrameworkType.PRODUCER.to(\n        request.kind(), producerFieldSelect.getExpressionFor(requestingClass));\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ProducesMethodValidator.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;\nimport static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;\nimport static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.EXCEPTION;\nimport static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_NULLABLE;\nimport static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;\nimport static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;\nimport static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SCOPE;\nimport static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.base.Optional;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport java.util.Set;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/**\n * A validator for {@link Produces} methods.\n *\n * @author Jesse Beder\n * @since 2.0\n */\n// TODO(beder): Consider unifying this with the ProvidesMethodValidator after Provides.Type and\n// Produces.Type are reconciled.\nfinal class ProducesMethodValidator extends BindingMethodValidator {\n\n  ProducesMethodValidator(Elements elements, Types types) {\n    super(\n        elements,\n        types,\n        Produces.class,\n        ProducerModule.class,\n        MUST_BE_CONCRETE,\n        EXCEPTION,\n        ALLOWS_MULTIBINDINGS);\n  }\n  \n  @Override\n  protected void checkMethod(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    super.checkMethod(builder);\n    checkNullable(builder);\n    checkScope(builder);\n  }\n\n  /** Adds a warning if a {@link Produces @Produces} method is declared nullable. */\n  // TODO(beder): Make this an error.\n  private void checkNullable(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    if (ConfigurationAnnotations.getNullableType(builder.getSubject()).isPresent()) {\n      builder.addWarning(PRODUCES_METHOD_NULLABLE);\n    }\n  }\n\n  /** Adds an error if a {@link Produces @Produces} method has a scope annotation. */\n  private void checkScope(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    if (!Scope.scopesOf(builder.getSubject()).isEmpty()) {\n      builder.addError(PRODUCES_METHOD_SCOPE);\n    }\n  }\n\n  @Override\n  protected String badReturnTypeMessage() {\n    return formatErrorMessage(PRODUCES_METHOD_RETURN_TYPE);\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * \u003cp\u003eAllows {@code keyType} to be a {@link ListenableFuture} of an otherwise-valid key type.\n   */\n  @Override\n  protected void checkKeyType(\n      ValidationReport.Builder\u003cExecutableElement\u003e reportBuilder, TypeMirror keyType) {\n    Optional\u003cTypeMirror\u003e typeToCheck \u003d unwrapListenableFuture(reportBuilder, keyType);\n    if (typeToCheck.isPresent()) {\n      super.checkKeyType(reportBuilder, typeToCheck.get());\n    }\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * \u003cp\u003eAllows an {@link ElementsIntoSet @ElementsIntoSet} or {@code SET_VALUES} method to return a\n   * {@link ListenableFuture} of a {@link Set} as well.\n   */\n  @Override\n  protected void checkSetValuesType(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    Optional\u003cTypeMirror\u003e typeToCheck \u003d\n        unwrapListenableFuture(builder, builder.getSubject().getReturnType());\n    if (typeToCheck.isPresent()) {\n      checkSetValuesType(builder, typeToCheck.get());\n    }\n  }\n\n  @Override\n  protected String badSetValuesTypeMessage() {\n    return PRODUCES_METHOD_SET_VALUES_RETURN_SET;\n  }\n\n  private Optional\u003cTypeMirror\u003e unwrapListenableFuture(\n      ValidationReport.Builder\u003cExecutableElement\u003e reportBuilder, TypeMirror type) {\n    if (MoreTypes.isType(type) \u0026\u0026 MoreTypes.isTypeOf(ListenableFuture.class, type)) {\n      DeclaredType declaredType \u003d MoreTypes.asDeclared(type);\n      if (declaredType.getTypeArguments().isEmpty()) {\n        reportBuilder.addError(PRODUCES_METHOD_RAW_FUTURE);\n        return Optional.absent();\n      } else {\n        return Optional.of((TypeMirror) getOnlyElement(declaredType.getTypeArguments()));\n      }\n    }\n    return Optional.of(type);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ProductionBinding.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static dagger.internal.codegen.MapKeys.getMapKey;\nimport static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;\nimport static javax.lang.model.element.ElementKind.METHOD;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport dagger.producers.Producer;\nimport java.util.Set;\nimport javax.annotation.CheckReturnValue;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Types;\n\n/**\n * A value object representing the mechanism by which a {@link Key} can be produced. New instances\n * should be created using an instance of the {@link Factory}.\n *\n * @author Jesse Beder\n * @since 2.0\n */\n@AutoValue\nabstract class ProductionBinding extends ContributionBinding {\n\n  @Override\n  public BindingType bindingType() {\n    return BindingType.PRODUCTION;\n  }\n\n  @Override\n  Optional\u003cProductionBinding\u003e unresolved() {\n    return Optional.absent();\n  }\n\n  @Override\n  Set\u003cDependencyRequest\u003e frameworkDependencies() {\n    return new ImmutableSet.Builder\u003cDependencyRequest\u003e()\n        .addAll(executorRequest().asSet())\n        .addAll(monitorRequest().asSet())\n        .build();\n  }\n\n  /** What kind of object this produces method returns. */\n  enum ProductionKind {\n    /** A value. */\n    IMMEDIATE,\n    /** A {@code ListenableFuture\u003cT\u003e}. */\n    FUTURE,\n    /** A {@code Set\u003cListenableFuture\u003cT\u003e\u003e}. */\n    SET_OF_FUTURE;\n  }\n\n  /**\n   * Returns the kind of object the produces method returns. All production bindings from\n   * {@code @Produces} methods will have a production kind, but synthetic production bindings may\n   * not.\n   */\n  abstract Optional\u003cProductionKind\u003e productionKind();\n\n  /** Returns the list of types in the throws clause of the method. */\n  abstract ImmutableList\u003c? extends TypeMirror\u003e thrownTypes();\n\n  /**\n   * If this production requires an executor, this will be the corresponding request.  All\n   * production bindings from {@code @Produces} methods will have an executor request, but\n   * synthetic production bindings may not.\n   */\n  abstract Optional\u003cDependencyRequest\u003e executorRequest();\n\n  /** If this production requires a monitor, this will be the corresponding request.  All\n   * production bindings from {@code @Produces} methods will have a monitor request, but synthetic\n   * production bindings may not.\n   */\n  abstract Optional\u003cDependencyRequest\u003e monitorRequest();\n\n  private static Builder builder() {\n    return new AutoValue_ProductionBinding.Builder()\n        .dependencies(ImmutableList.\u003cDependencyRequest\u003eof())\n        .thrownTypes(ImmutableList.\u003cTypeMirror\u003eof());\n  }\n\n  @AutoValue.Builder\n  @CanIgnoreReturnValue\n  abstract static class Builder extends ContributionBinding.Builder\u003cBuilder\u003e {\n    abstract Builder productionKind(ProductionKind productionKind);\n\n    abstract Builder thrownTypes(Iterable\u003c? extends TypeMirror\u003e thrownTypes);\n\n    abstract Builder executorRequest(DependencyRequest executorRequest);\n\n    abstract Builder monitorRequest(DependencyRequest monitorRequest);\n\n    @CheckReturnValue\n    abstract ProductionBinding build();\n  }\n\n  static final class Factory {\n    private final Types types;\n    private final Key.Factory keyFactory;\n    private final DependencyRequest.Factory dependencyRequestFactory;\n\n    Factory(\n        Types types, Key.Factory keyFactory, DependencyRequest.Factory dependencyRequestFactory) {\n      this.types \u003d types;\n      this.keyFactory \u003d keyFactory;\n      this.dependencyRequestFactory \u003d dependencyRequestFactory;\n    }\n\n    ProductionBinding forProducesMethod(\n        ExecutableElement producesMethod, TypeElement contributedBy) {\n      checkArgument(producesMethod.getKind().equals(METHOD));\n      ContributionType contributionType \u003d ContributionType.fromBindingMethod(producesMethod);\n      Key key \u003d keyFactory.forProducesMethod(producesMethod, contributedBy);\n      ExecutableType resolvedMethod \u003d\n          MoreTypes.asExecutable(\n              types.asMemberOf(MoreTypes.asDeclared(contributedBy.asType()), producesMethod));\n      ImmutableSet\u003cDependencyRequest\u003e dependencies \u003d\n          dependencyRequestFactory.forRequiredResolvedVariables(\n              producesMethod.getParameters(),\n              resolvedMethod.getParameterTypes());\n      DependencyRequest executorRequest \u003d\n          dependencyRequestFactory.forProductionImplementationExecutor();\n      DependencyRequest monitorRequest \u003d dependencyRequestFactory.forProductionComponentMonitor();\n      final ProductionKind productionKind;\n      if (MoreTypes.isTypeOf(ListenableFuture.class, producesMethod.getReturnType())) {\n        productionKind \u003d ProductionKind.FUTURE;\n      } else if (contributionType.equals(ContributionType.SET_VALUES)\n          \u0026\u0026 SetType.from(producesMethod.getReturnType())\n              .elementsAreTypeOf(ListenableFuture.class)) {\n        productionKind \u003d ProductionKind.SET_OF_FUTURE;\n      } else {\n        productionKind \u003d ProductionKind.IMMEDIATE;\n      }\n      // TODO(beder): Add nullability checking with Java 8.\n      return ProductionBinding.builder()\n          .contributionType(contributionType)\n          .bindingElement(producesMethod)\n          .contributingModule(contributedBy)\n          .key(key)\n          .dependencies(dependencies)\n          .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(producesMethod)))\n          .bindingKind(Kind.PRODUCTION)\n          .productionKind(productionKind)\n          .thrownTypes(producesMethod.getThrownTypes())\n          .executorRequest(executorRequest)\n          .monitorRequest(monitorRequest)\n          .build();\n    }\n\n    /**\n     * A synthetic binding of {@code Map\u003cK, V\u003e} or {@code Map\u003cK, Produced\u003cV\u003e\u003e} that depends on\n     * {@code Map\u003cK, Producer\u003cV\u003e\u003e}.\n     */\n    ProductionBinding syntheticMapOfValuesOrProducedBinding(Key mapOfValuesOrProducedKey) {\n      checkNotNull(mapOfValuesOrProducedKey);\n      Optional\u003cKey\u003e mapOfProducersKey \u003d\n          keyFactory.implicitMapProducerKeyFrom(mapOfValuesOrProducedKey);\n      checkArgument(\n          mapOfProducersKey.isPresent(),\n          \"%s is not a key for of Map\u003cK, V\u003e or Map\u003cK, Produced\u003cV\u003e\u003e\",\n          mapOfValuesOrProducedKey);\n      DependencyRequest requestForMapOfProducers \u003d\n          dependencyRequestFactory.forImplicitMapBinding(mapOfProducersKey.get());\n      return ProductionBinding.builder()\n          .contributionType(ContributionType.UNIQUE)\n          .key(mapOfValuesOrProducedKey)\n          .dependencies(requestForMapOfProducers)\n          .bindingKind(Kind.SYNTHETIC_MAP)\n          .build();\n    }\n\n    /**\n     * A synthetic binding that depends explicitly on a set of individual provision or production\n     * multibinding contribution methods.\n     *\n     * \u003cp\u003eNote that these could be set multibindings or map multibindings.\n     */\n    ProductionBinding syntheticMultibinding(\n        Key key, Iterable\u003cContributionBinding\u003e multibindingContributions) {\n      return ProductionBinding.builder()\n          .contributionType(ContributionType.UNIQUE)\n          .key(key)\n          .dependencies(\n              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))\n          .bindingKind(Kind.forMultibindingKey(key))\n          .build();\n    }\n\n    ProductionBinding forComponentMethod(ExecutableElement componentMethod) {\n      checkNotNull(componentMethod);\n      checkArgument(componentMethod.getKind().equals(METHOD));\n      checkArgument(componentMethod.getParameters().isEmpty());\n      checkArgument(MoreTypes.isTypeOf(ListenableFuture.class, componentMethod.getReturnType()));\n      return ProductionBinding.builder()\n          .contributionType(ContributionType.UNIQUE)\n          .bindingElement(componentMethod)\n          .key(keyFactory.forProductionComponentMethod(componentMethod))\n          .bindingKind(Kind.COMPONENT_PRODUCTION)\n          .thrownTypes(componentMethod.getThrownTypes())\n          .build();\n    }\n\n    ProductionBinding delegate(\n        DelegateDeclaration delegateDeclaration, ProductionBinding delegateBinding) {\n      return ProductionBinding.builder()\n          .contributionType(delegateDeclaration.contributionType())\n          .bindingElement(delegateDeclaration.bindingElement().get())\n          .contributingModule(delegateDeclaration.contributingModule().get())\n          .key(keyFactory.forDelegateBinding(delegateDeclaration, Producer.class))\n          .dependencies(delegateDeclaration.delegateRequest())\n          .nullableType(delegateBinding.nullableType())\n          .wrappedMapKey(delegateDeclaration.wrappedMapKey())\n          .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)\n          .build();\n    }\n\n    /**\n     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a\n     * component with a binding for the underlying key.\n     */\n    ProductionBinding syntheticPresentBinding(Key key) {\n      return ProductionBinding.builder()\n          .contributionType(ContributionType.UNIQUE)\n          .key(key)\n          .bindingKind(Kind.SYNTHETIC_OPTIONAL_BINDING)\n          .dependencies(\n              dependencyRequestFactory.forSyntheticPresentOptionalBinding(\n                  key, DependencyRequest.Kind.PRODUCER))\n          .build();\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ProductionExecutorModuleGenerator.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.squareup.javapoet.MethodSpec.methodBuilder;\nimport static com.squareup.javapoet.TypeSpec.classBuilder;\nimport static javax.lang.model.element.Modifier.FINAL;\nimport static javax.lang.model.element.Modifier.STATIC;\n\nimport com.google.common.base.Optional;\nimport com.squareup.javapoet.AnnotationSpec;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.ParameterSpec;\nimport com.squareup.javapoet.TypeSpec;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.producers.Production;\nimport dagger.producers.ProductionScope;\nimport dagger.producers.internal.ProductionImplementation;\nimport java.util.concurrent.Executor;\nimport javax.annotation.processing.Filer;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.util.Elements;\n\n/** Generates a producer executor module for use with production components. */\n// TODO(beder): Replace this with a single class when the producers client library exists.\nfinal class ProductionExecutorModuleGenerator extends SourceFileGenerator\u003cTypeElement\u003e {\n\n  ProductionExecutorModuleGenerator(Filer filer, Elements elements) {\n    super(filer, elements);\n  }\n\n  @Override\n  ClassName nameGeneratedType(TypeElement componentElement) {\n    return SourceFiles.generatedProductionExecutorModuleName(componentElement);\n  }\n\n  @Override\n  Optional\u003c? extends Element\u003e getElementForErrorReporting(TypeElement componentElement) {\n    return Optional.of(componentElement);\n  }\n\n  @Override\n  Optional\u003cTypeSpec.Builder\u003e write(ClassName generatedTypeName, TypeElement componentElement) {\n    return Optional.of(\n        classBuilder(generatedTypeName)\n            .addAnnotation(\n                AnnotationSpec.builder(Module.class)\n                    .build())\n            .addModifiers(FINAL)\n            .addMethod(\n                methodBuilder(\"executor\")\n                    .returns(Executor.class)\n                    .addModifiers(STATIC)\n                    .addAnnotation(Provides.class)\n                    .addAnnotation(ProductionScope.class)\n                    .addAnnotation(ProductionImplementation.class)\n                    .addParameter(\n                        ParameterSpec.builder(Executor.class, \"executor\")\n                            .addAnnotation(Production.class)\n                            .build())\n                    .addStatement(\"return executor\")\n                    .build()));\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ProductionExecutorModuleProcessingStep.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.auto.common.BasicAnnotationProcessor.ProcessingStep;\nimport com.google.auto.common.MoreElements;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.SetMultimap;\nimport dagger.producers.ProductionComponent;\nimport dagger.producers.ProductionSubcomponent;\nimport java.lang.annotation.Annotation;\nimport java.util.Set;\nimport javax.annotation.processing.Messager;\nimport javax.lang.model.element.Element;\n\n/**\n * A processing step that is responsible for generating a special module for a\n * {@link ProductionComponent} or {@link ProductionSubcomponent}.\n */\nfinal class ProductionExecutorModuleProcessingStep implements ProcessingStep {\n  private final Messager messager;\n  private final ProductionExecutorModuleGenerator productionExecutorModuleGenerator;\n\n  ProductionExecutorModuleProcessingStep(\n      Messager messager, ProductionExecutorModuleGenerator productionExecutorModuleGenerator) {\n    this.messager \u003d messager;\n    this.productionExecutorModuleGenerator \u003d productionExecutorModuleGenerator;\n  }\n\n  @Override\n  public Set\u003c? extends Class\u003c? extends Annotation\u003e\u003e annotations() {\n    return ImmutableSet.of(ProductionComponent.class, ProductionSubcomponent.class);\n  }\n\n  @Override\n  public Set\u003cElement\u003e process(\n      SetMultimap\u003cClass\u003c? extends Annotation\u003e, Element\u003e elementsByAnnotation) {\n    for (Element element : elementsByAnnotation.values()) {\n      productionExecutorModuleGenerator.generate(MoreElements.asType(element), messager);\n    }\n    return ImmutableSet.of();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ProviderFieldRequestFulfillment.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static dagger.internal.codegen.BindingKey.Kind.CONTRIBUTION;\n\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\n\n/** Fulfills requests for {@link ProvisionBinding} instances. */\nfinal class ProviderFieldRequestFulfillment extends RequestFulfillment {\n  private final MemberSelect providerFieldSelect;\n\n  ProviderFieldRequestFulfillment(BindingKey bindingKey, MemberSelect frameworkFieldSelect) {\n    super(bindingKey);\n    checkArgument(bindingKey.kind().equals(CONTRIBUTION));\n    this.providerFieldSelect \u003d frameworkFieldSelect;\n  }\n\n  @Override\n  public CodeBlock getSnippetForDependencyRequest(\n      DependencyRequest request, ClassName requestingClass) {\n    return FrameworkType.PROVIDER.to(\n        request.kind(), providerFieldSelect.getExpressionFor(requestingClass));\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ProvidesMethodValidator.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static dagger.internal.codegen.BindingMethodValidator.Abstractness.MUST_BE_CONCRETE;\nimport static dagger.internal.codegen.BindingMethodValidator.AllowsMultibindings.ALLOWS_MULTIBINDINGS;\nimport static dagger.internal.codegen.BindingMethodValidator.ExceptionSuperclass.RUNTIME_EXCEPTION;\nimport static dagger.internal.codegen.ErrorMessages.provisionMayNotDependOnProducerType;\n\nimport com.google.common.collect.ImmutableSet;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.producers.ProducerModule;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/**\n * A validator for {@link Provides} methods.\n *\n * @author Gregory Kick\n * @since 2.0\n */\nfinal class ProvidesMethodValidator extends BindingMethodValidator {\n\n  ProvidesMethodValidator(Elements elements, Types types) {\n    super(\n        elements,\n        types,\n        Provides.class,\n        ImmutableSet.of(Module.class, ProducerModule.class),\n        MUST_BE_CONCRETE,\n        RUNTIME_EXCEPTION,\n        ALLOWS_MULTIBINDINGS);\n  }\n\n  @Override\n  protected void checkMethod(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    super.checkMethod(builder);\n    checkDependsOnProducers(builder);\n  }\n\n  /** Adds an error if a {@link Provides @Provides} method depends on a producer type. */\n  private void checkDependsOnProducers(ValidationReport.Builder\u003cExecutableElement\u003e builder) {\n    for (VariableElement parameter : builder.getSubject().getParameters()) {\n      if (FrameworkTypes.isProducerType(parameter.asType())) {\n        builder.addError(provisionMayNotDependOnProducerType(parameter.asType()), parameter);\n      }\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ProvisionBinding.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static com.google.auto.common.MoreTypes.asDeclared;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static dagger.internal.codegen.InjectionAnnotations.getQualifier;\nimport static dagger.internal.codegen.MapKeys.getMapKey;\nimport static dagger.internal.codegen.MoreAnnotationMirrors.wrapOptionalInEquivalence;\nimport static javax.lang.model.element.ElementKind.CONSTRUCTOR;\nimport static javax.lang.model.element.ElementKind.FIELD;\nimport static javax.lang.model.element.ElementKind.METHOD;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Sets;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.util.Set;\nimport javax.annotation.CheckReturnValue;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ElementKind;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\n/**\n * A value object representing the mechanism by which a {@link Key} can be provided. New instances\n * should be created using an instance of the {@link Factory}.\n *\n * @author Gregory Kick\n * @since 2.0\n */\n@AutoValue\nabstract class ProvisionBinding extends ContributionBinding {\n\n  @Override\n  Set\u003cDependencyRequest\u003e frameworkDependencies() {\n    return membersInjectionRequest().asSet();\n  }\n\n  /** If this provision requires members injection, this will be the corresponding request. */\n  abstract Optional\u003cDependencyRequest\u003e membersInjectionRequest();\n\n  @Override\n  public BindingType bindingType() {\n    return BindingType.PROVISION;\n  }\n\n  @Override\n  abstract Optional\u003cProvisionBinding\u003e unresolved();\n\n  @Override\n  abstract Optional\u003cScope\u003e scope();\n\n  private static Builder builder() {\n    return new AutoValue_ProvisionBinding.Builder()\n        .dependencies(ImmutableSet.\u003cDependencyRequest\u003eof());\n  }\n\n  abstract Builder toBuilder();\n\n  @AutoValue.Builder\n  @CanIgnoreReturnValue\n  abstract static class Builder extends ContributionBinding.Builder\u003cBuilder\u003e {\n\n    abstract Builder membersInjectionRequest(Optional\u003cDependencyRequest\u003e membersInjectionRequest);\n\n    abstract Builder unresolved(ProvisionBinding unresolved);\n\n    abstract Builder scope(Optional\u003cScope\u003e scope);\n\n    @CheckReturnValue\n    abstract ProvisionBinding build();\n  }\n\n  static final class Factory {\n    private final Elements elements;\n    private final Types types;\n    private final Key.Factory keyFactory;\n    private final DependencyRequest.Factory dependencyRequestFactory;\n\n    Factory(Elements elements, Types types, Key.Factory keyFactory,\n        DependencyRequest.Factory dependencyRequestFactory) {\n      this.elements \u003d elements;\n      this.types \u003d types;\n      this.keyFactory \u003d keyFactory;\n      this.dependencyRequestFactory \u003d dependencyRequestFactory;\n    }\n\n    /**\n     * Returns a ProvisionBinding for the given element. If {@code resolvedType} is present, this\n     * will return a resolved binding, with the key \u0026 type resolved to the given type (using\n     * {@link Types#asMemberOf(DeclaredType, Element)}).\n     */\n    ProvisionBinding forInjectConstructor(ExecutableElement constructorElement,\n        Optional\u003cTypeMirror\u003e resolvedType) {\n      checkNotNull(constructorElement);\n      checkArgument(constructorElement.getKind().equals(CONSTRUCTOR));\n      checkArgument(isAnnotationPresent(constructorElement, Inject.class));\n      checkArgument(!getQualifier(constructorElement).isPresent());\n\n      ExecutableType cxtorType \u003d MoreTypes.asExecutable(constructorElement.asType());\n      DeclaredType enclosingCxtorType \u003d\n          MoreTypes.asDeclared(constructorElement.getEnclosingElement().asType());\n      // If the class this is constructing has some type arguments, resolve everything.\n      if (!enclosingCxtorType.getTypeArguments().isEmpty() \u0026\u0026 resolvedType.isPresent()) {\n        DeclaredType resolved \u003d MoreTypes.asDeclared(resolvedType.get());\n        // Validate that we\u0027re resolving from the correct type.\n        checkState(types.isSameType(types.erasure(resolved), types.erasure(enclosingCxtorType)),\n            \"erased expected type: %s, erased actual type: %s\",\n            types.erasure(resolved), types.erasure(enclosingCxtorType));\n        cxtorType \u003d MoreTypes.asExecutable(types.asMemberOf(resolved, constructorElement));\n        enclosingCxtorType \u003d resolved;\n      }\n\n      Key key \u003d keyFactory.forInjectConstructorWithResolvedType(enclosingCxtorType);\n      checkArgument(!key.qualifier().isPresent());\n      ImmutableSet\u003cDependencyRequest\u003e dependencies \u003d\n          dependencyRequestFactory.forRequiredResolvedVariables(\n              constructorElement.getParameters(), cxtorType.getParameterTypes());\n      Optional\u003cDependencyRequest\u003e membersInjectionRequest \u003d\n          membersInjectionRequest(enclosingCxtorType);\n\n      ProvisionBinding.Builder builder \u003d\n          ProvisionBinding.builder()\n              .contributionType(ContributionType.UNIQUE)\n              .bindingElement(constructorElement)\n              .key(key)\n              .dependencies(dependencies)\n              .membersInjectionRequest(membersInjectionRequest)\n              .bindingKind(Kind.INJECTION)\n              .scope(Scope.uniqueScopeOf(constructorElement.getEnclosingElement()));\n\n      TypeElement bindingTypeElement \u003d\n          MoreElements.asType(constructorElement.getEnclosingElement());\n      if (hasNonDefaultTypeParameters(bindingTypeElement, key.type(), types)) {\n        builder.unresolved(forInjectConstructor(constructorElement, Optional.\u003cTypeMirror\u003eabsent()));\n      }\n      return builder.build();\n    }\n\n    private static final ImmutableSet\u003cElementKind\u003e MEMBER_KINDS \u003d\n        Sets.immutableEnumSet(METHOD, FIELD);\n\n    private Optional\u003cDependencyRequest\u003e membersInjectionRequest(DeclaredType type) {\n      TypeElement typeElement \u003d MoreElements.asType(type.asElement());\n      if (!types.isSameType(elements.getTypeElement(Object.class.getCanonicalName()).asType(),\n          typeElement.getSuperclass())) {\n        return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));\n      }\n      for (Element enclosedElement : typeElement.getEnclosedElements()) {\n        if (MEMBER_KINDS.contains(enclosedElement.getKind())\n            \u0026\u0026 (isAnnotationPresent(enclosedElement, Inject.class))) {\n          return Optional.of(dependencyRequestFactory.forMembersInjectedType(type));\n        }\n      }\n      return Optional.absent();\n    }\n\n    ProvisionBinding forProvidesMethod(\n        ExecutableElement providesMethod, TypeElement contributedBy) {\n      checkArgument(providesMethod.getKind().equals(METHOD));\n      ExecutableType resolvedMethod \u003d\n          MoreTypes.asExecutable(\n              types.asMemberOf(MoreTypes.asDeclared(contributedBy.asType()), providesMethod));\n      Key key \u003d keyFactory.forProvidesMethod(providesMethod, contributedBy);\n      ImmutableSet\u003cDependencyRequest\u003e dependencies \u003d\n          dependencyRequestFactory.forRequiredResolvedVariables(\n              providesMethod.getParameters(),\n              resolvedMethod.getParameterTypes());\n      return ProvisionBinding.builder()\n          .contributionType(ContributionType.fromBindingMethod(providesMethod))\n          .bindingElement(providesMethod)\n          .contributingModule(contributedBy)\n          .key(key)\n          .dependencies(dependencies)\n          .nullableType(ConfigurationAnnotations.getNullableType(providesMethod))\n          .wrappedMapKey(wrapOptionalInEquivalence(getMapKey(providesMethod)))\n          .bindingKind(Kind.PROVISION)\n          .scope(Scope.uniqueScopeOf(providesMethod))\n          .build();\n    }\n\n    /** A synthetic binding of {@code Map\u003cK, V\u003e} that depends on {@code Map\u003cK, Provider\u003cV\u003e\u003e}. */\n    ProvisionBinding syntheticMapOfValuesBinding(Key mapOfValuesKey) {\n      checkNotNull(mapOfValuesKey);\n      Optional\u003cKey\u003e mapOfProvidersKey \u003d keyFactory.implicitMapProviderKeyFrom(mapOfValuesKey);\n      checkArgument(mapOfProvidersKey.isPresent(), \"%s is not a key for Map\u003cK, V\u003e\", mapOfValuesKey);\n      DependencyRequest requestForMapOfProviders \u003d\n          dependencyRequestFactory.forImplicitMapBinding(mapOfProvidersKey.get());\n      return ProvisionBinding.builder()\n          .contributionType(ContributionType.UNIQUE)\n          .key(mapOfValuesKey)\n          .dependencies(requestForMapOfProviders)\n          .bindingKind(Kind.SYNTHETIC_MAP)\n          .build();\n    }\n\n    /**\n     * A synthetic binding that depends explicitly on a set of individual provision multibinding\n     * contribution methods.\n     *\n     * \u003cp\u003eNote that these could be set multibindings or map multibindings.\n     */\n    ProvisionBinding syntheticMultibinding(\n        Key key, Iterable\u003cContributionBinding\u003e multibindingContributions) {\n      return ProvisionBinding.builder()\n          .contributionType(ContributionType.UNIQUE)\n          .key(key)\n          .dependencies(\n              dependencyRequestFactory.forMultibindingContributions(multibindingContributions))\n          .bindingKind(Kind.forMultibindingKey(key))\n          .build();\n    }\n\n    ProvisionBinding forComponent(TypeElement componentDefinitionType) {\n      checkNotNull(componentDefinitionType);\n      return ProvisionBinding.builder()\n          .contributionType(ContributionType.UNIQUE)\n          .bindingElement(componentDefinitionType)\n          .key(keyFactory.forComponent(componentDefinitionType.asType()))\n          .bindingKind(Kind.COMPONENT)\n          .build();\n    }\n\n    ProvisionBinding forComponentMethod(ExecutableElement componentMethod) {\n      checkNotNull(componentMethod);\n      checkArgument(componentMethod.getKind().equals(METHOD));\n      checkArgument(componentMethod.getParameters().isEmpty());\n      return ProvisionBinding.builder()\n          .contributionType(ContributionType.UNIQUE)\n          .bindingElement(componentMethod)\n          .key(keyFactory.forComponentMethod(componentMethod))\n          .nullableType(ConfigurationAnnotations.getNullableType(componentMethod))\n          .bindingKind(Kind.COMPONENT_PROVISION)\n          .scope(Scope.uniqueScopeOf(componentMethod))\n          .build();\n    }\n\n    ProvisionBinding forSubcomponentBuilderMethod(\n        ExecutableElement subcomponentBuilderMethod, TypeElement contributedBy) {\n      checkNotNull(subcomponentBuilderMethod);\n      checkArgument(subcomponentBuilderMethod.getKind().equals(METHOD));\n      checkArgument(subcomponentBuilderMethod.getParameters().isEmpty());\n      DeclaredType declaredContainer \u003d asDeclared(contributedBy.asType());\n      return ProvisionBinding.builder()\n          .contributionType(ContributionType.UNIQUE)\n          .bindingElement(subcomponentBuilderMethod)\n          .key(\n              keyFactory.forSubcomponentBuilderMethod(subcomponentBuilderMethod, declaredContainer))\n          .bindingKind(Kind.SUBCOMPONENT_BUILDER)\n          .build();\n    }\n\n    ProvisionBinding syntheticSubcomponentBuilder(\n        ImmutableSet\u003cSubcomponentDeclaration\u003e subcomponentDeclarations) {\n      SubcomponentDeclaration subcomponentDeclaration \u003d subcomponentDeclarations.iterator().next();\n      return ProvisionBinding.builder()\n          .contributionType(ContributionType.UNIQUE)\n          .key(subcomponentDeclaration.key())\n          .bindingKind(Kind.SUBCOMPONENT_BUILDER)\n          .build();\n    }\n\n    ProvisionBinding delegate(\n        DelegateDeclaration delegateDeclaration, ProvisionBinding delegate) {\n      return delegateBuilder(delegateDeclaration).nullableType(delegate.nullableType()).build();\n    }\n\n    /**\n     * A form of {@link #delegate(DelegateDeclaration, ProvisionBinding)} when the right-hand-side\n     * of a {@link dagger.Binds} method cannot be resolved.\n     */\n    ProvisionBinding missingDelegate(DelegateDeclaration delegateDeclaration) {\n      return delegateBuilder(delegateDeclaration).build();\n    }\n\n    private ProvisionBinding.Builder delegateBuilder(DelegateDeclaration delegateDeclaration) {\n      return ProvisionBinding.builder()\n          .contributionType(delegateDeclaration.contributionType())\n          .bindingElement(delegateDeclaration.bindingElement().get())\n          .contributingModule(delegateDeclaration.contributingModule().get())\n          .key(keyFactory.forDelegateBinding(delegateDeclaration, Provider.class))\n          .dependencies(delegateDeclaration.delegateRequest())\n          .wrappedMapKey(delegateDeclaration.wrappedMapKey())\n          .bindingKind(Kind.SYNTHETIC_DELEGATE_BINDING)\n          .scope(Scope.uniqueScopeOf(delegateDeclaration.bindingElement().get()));\n    }\n\n    /**\n     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a\n     * component with no binding for the underlying key.\n     */\n    ProvisionBinding syntheticAbsentBinding(Key key) {\n      return ProvisionBinding.builder()\n          .contributionType(ContributionType.UNIQUE)\n          .key(key)\n          .bindingKind(Kind.SYNTHETIC_OPTIONAL_BINDING)\n          .build();\n    }\n\n    /**\n     * Returns a synthetic binding for an {@linkplain dagger.BindsOptionalOf optional binding} in a\n     * component with a binding for the underlying key.\n     */\n    ProvisionBinding syntheticPresentBinding(Key key) {\n      return syntheticAbsentBinding(key)\n          .toBuilder()\n          .dependencies(\n              dependencyRequestFactory.forSyntheticPresentOptionalBinding(\n                  key, DependencyRequest.Kind.PROVIDER))\n          .build();\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\RequestFulfillment.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\n\n/**\n * A strategy interface for generating a {@link CodeBlock} that represents how a {@link Binding} is\n * used to satisfy a given {@link DependencyRequest}.\n */\nabstract class RequestFulfillment {\n  private final BindingKey bindingKey;\n\n  RequestFulfillment(BindingKey bindingKey) {\n    this.bindingKey \u003d checkNotNull(bindingKey);\n  }\n\n  /** The key for which this instance can fulfill requests. */\n  final BindingKey bindingKey() {\n    return bindingKey;\n  }\n\n  /**\n   * Returns the {@link CodeBlock} that implements the operation represented by the {@link\n   * DependencyRequest request} from the {@code requestingClass}.\n   */\n  abstract CodeBlock getSnippetForDependencyRequest(\n      DependencyRequest request, ClassName requestingClass);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ResolvedBindings.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.collect.Iterables.getOnlyElement;\n\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSetMultimap;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Multimap;\nimport dagger.internal.codegen.BindingType.HasBindingType;\nimport dagger.internal.codegen.ContributionType.HasContributionType;\nimport dagger.internal.codegen.Key.HasKey;\nimport java.util.Map;\n\n/**\n * The collection of bindings that have been resolved for a binding key. For valid graphs, contains\n * exactly one binding.\n *\n * @author Gregory Kick\n */\n@AutoValue\nabstract class ResolvedBindings implements HasBindingType, HasContributionType, HasKey {\n  /**\n   * The binding key for which the {@link #bindings()} have been resolved.\n   */\n  abstract BindingKey bindingKey();\n\n  /**\n   * The component in which the bindings in {@link #ownedBindings()},\n   * {@link #ownedContributionBindings()}, and {@link #ownedMembersInjectionBinding()} were\n   * resolved.\n   */\n  abstract ComponentDescriptor owningComponent();\n\n  /**\n   * The contribution bindings for {@link #bindingKey()} that were resolved in\n   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the\n   * binding was resolved. If {@link #bindingKey()}\u0027s kind is not\n   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.\n   */\n  abstract ImmutableSetMultimap\u003cComponentDescriptor, ContributionBinding\u003e allContributionBindings();\n\n  /**\n   * The members-injection bindings for {@link #bindingKey()} that were resolved in\n   * {@link #owningComponent()} or its ancestor components, keyed by the component in which the\n   * binding was resolved. If {@link #bindingKey()}\u0027s kind is not\n   * {@link BindingKey.Kind#MEMBERS_INJECTION}, this is empty.\n   */\n  abstract ImmutableMap\u003cComponentDescriptor, MembersInjectionBinding\u003e allMembersInjectionBindings();\n\n  @Override\n  public Key key() {\n    return bindingKey().key();\n  }\n  \n  /**\n   * The multibinding declarations for {@link #bindingKey()}. If {@link #bindingKey()}\u0027s kind is not\n   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.\n   */\n  abstract ImmutableSet\u003cMultibindingDeclaration\u003e multibindingDeclarations();\n\n  /**\n   * The subcomponent declarations for {@link #bindingKey()}. If {@link #bindingKey()}\u0027s kind is not\n   * {@link BindingKey.Kind#CONTRIBUTION}, this is empty.\n   */\n  abstract ImmutableSet\u003cSubcomponentDeclaration\u003e subcomponentDeclarations();\n\n  /**\n   * The optional binding declarations for {@link #bindingKey()}. If {@link #bindingKey()}\u0027s kind is\n   * not {@link BindingKey.Kind#CONTRIBUTION}, this is empty.\n   */\n  abstract ImmutableSet\u003cOptionalBindingDeclaration\u003e optionalBindingDeclarations();\n\n  /**\n   * All bindings for {@link #bindingKey()}, regardless of in which component they were resolved.\n   */\n  ImmutableSet\u003c? extends Binding\u003e bindings() {\n    switch (bindingKey().kind()) {\n      case CONTRIBUTION:\n        return contributionBindings();\n\n      case MEMBERS_INJECTION:\n        return ImmutableSet.copyOf(membersInjectionBinding().asSet());\n\n      default:\n        throw new AssertionError(bindingKey());\n    }\n  }\n\n  /**\n   * Returns the single binding.\n   *\n   * @throws IllegalStateException if there is not exactly one element in {@link #bindings()},\n   *     which will never happen for contributions in valid graphs\n   */\n  Binding binding() {\n    return getOnlyElement(bindings());\n  }\n\n  /**\n   * All bindings for {@link #bindingKey()}, together with the component in which they were\n   * resolved.\n   */\n  ImmutableList\u003cMap.Entry\u003cComponentDescriptor, ? extends Binding\u003e\u003e bindingsByComponent() {\n    return new ImmutableList.Builder\u003cMap.Entry\u003cComponentDescriptor, ? extends Binding\u003e\u003e()\n        .addAll(allContributionBindings().entries())\n        .addAll(allMembersInjectionBindings().entrySet())\n        .build();\n  }\n\n  /**\n   * {@code true} if there are no {@link #bindings()}, {@link #multibindingDeclarations()}, or\n   * {@link #subcomponentDeclarations()}.\n   */\n  boolean isEmpty() {\n    return bindings().isEmpty()\n        \u0026\u0026 multibindingDeclarations().isEmpty()\n        \u0026\u0026 subcomponentDeclarations().isEmpty();\n  }\n\n  /**\n   * All bindings for {@link #bindingKey()} that were resolved in {@link #owningComponent()}.\n   */\n  ImmutableSet\u003c? extends Binding\u003e ownedBindings() {\n    switch (bindingKey().kind()) {\n      case CONTRIBUTION:\n        return ownedContributionBindings();\n\n      case MEMBERS_INJECTION:\n        return ImmutableSet.copyOf(ownedMembersInjectionBinding().asSet());\n\n      default:\n        throw new AssertionError(bindingKey());\n    }\n  }\n\n  /**\n   * All contribution bindings, regardless of owning component. Empty if this is a members-injection\n   * binding.\n   */\n  ImmutableSet\u003cContributionBinding\u003e contributionBindings() {\n    return ImmutableSet.copyOf(allContributionBindings().values());\n  }\n\n  /**\n   * The contribution bindings that were resolved in {@link #owningComponent()}. Empty if this is a\n   * members-injection binding.\n   */\n  ImmutableSet\u003cContributionBinding\u003e ownedContributionBindings() {\n    return allContributionBindings().get(owningComponent());\n  }\n\n  /** The component that owns {@code binding}. */\n  ComponentDescriptor owningComponent(ContributionBinding binding) {\n    checkArgument(\n        contributionBindings().contains(binding),\n        \"binding is not resolved for %s: %s\",\n        bindingKey(),\n        binding);\n    return getOnlyElement(allContributionBindings().inverse().get(binding));\n  }\n\n  /**\n   * The members-injection binding, regardless of owning component. Empty if these are contribution\n   * bindings.\n   */\n  Optional\u003cMembersInjectionBinding\u003e membersInjectionBinding() {\n    ImmutableSet\u003cMembersInjectionBinding\u003e membersInjectionBindings \u003d\n        FluentIterable.from(allMembersInjectionBindings().values()).toSet();\n    return membersInjectionBindings.isEmpty()\n        ? Optional.\u003cMembersInjectionBinding\u003eabsent()\n        : Optional.of(Iterables.getOnlyElement(membersInjectionBindings));\n  }\n\n  /**\n   * The members-injection binding that was resolved in {@link #owningComponent()}. Empty if these\n   * are contribution bindings.\n   */\n  Optional\u003cMembersInjectionBinding\u003e ownedMembersInjectionBinding() {\n    return Optional.fromNullable(allMembersInjectionBindings().get(owningComponent()));\n  }\n\n  /** Creates a {@link ResolvedBindings} for contribution bindings. */\n  static ResolvedBindings forContributionBindings(\n      BindingKey bindingKey,\n      ComponentDescriptor owningComponent,\n      Multimap\u003cComponentDescriptor, ? extends ContributionBinding\u003e contributionBindings,\n      Iterable\u003cMultibindingDeclaration\u003e multibindings,\n      Iterable\u003cSubcomponentDeclaration\u003e subcomponentDeclarations,\n      Iterable\u003cOptionalBindingDeclaration\u003e optionalBindingDeclarations) {\n    checkArgument(bindingKey.kind().equals(BindingKey.Kind.CONTRIBUTION));\n    return new AutoValue_ResolvedBindings(\n        bindingKey,\n        owningComponent,\n        ImmutableSetMultimap.\u003cComponentDescriptor, ContributionBinding\u003ecopyOf(contributionBindings),\n        ImmutableMap.\u003cComponentDescriptor, MembersInjectionBinding\u003eof(),\n        ImmutableSet.copyOf(multibindings),\n        ImmutableSet.copyOf(subcomponentDeclarations),\n        ImmutableSet.copyOf(optionalBindingDeclarations));\n  }\n  \n  /**\n   * Creates a {@link ResolvedBindings} for members injection bindings.\n   */\n  static ResolvedBindings forMembersInjectionBinding(\n      BindingKey bindingKey,\n      ComponentDescriptor owningComponent,\n      MembersInjectionBinding ownedMembersInjectionBinding) {\n    checkArgument(bindingKey.kind().equals(BindingKey.Kind.MEMBERS_INJECTION));\n    return new AutoValue_ResolvedBindings(\n        bindingKey,\n        owningComponent,\n        ImmutableSetMultimap.\u003cComponentDescriptor, ContributionBinding\u003eof(),\n        ImmutableMap.of(owningComponent, ownedMembersInjectionBinding),\n        ImmutableSet.\u003cMultibindingDeclaration\u003eof(),\n        ImmutableSet.\u003cSubcomponentDeclaration\u003eof(),\n        ImmutableSet.\u003cOptionalBindingDeclaration\u003eof());\n  }\n\n  /**\n   * Creates a {@link ResolvedBindings} appropriate for when there are no bindings for the key.\n   */\n  static ResolvedBindings noBindings(BindingKey bindingKey, ComponentDescriptor owningComponent) {\n    return new AutoValue_ResolvedBindings(\n        bindingKey,\n        owningComponent,\n        ImmutableSetMultimap.\u003cComponentDescriptor, ContributionBinding\u003eof(),\n        ImmutableMap.\u003cComponentDescriptor, MembersInjectionBinding\u003eof(),\n        ImmutableSet.\u003cMultibindingDeclaration\u003eof(),\n        ImmutableSet.\u003cSubcomponentDeclaration\u003eof(),\n        ImmutableSet.\u003cOptionalBindingDeclaration\u003eof());\n  }\n\n  /**\n   * Returns a {@code ResolvedBindings} with the same {@link #bindingKey()} and {@link #bindings()}\n   * as this one, but no {@link #ownedBindings()}.\n   */\n  ResolvedBindings asInheritedIn(ComponentDescriptor owningComponent) {\n    return new AutoValue_ResolvedBindings(\n        bindingKey(),\n        owningComponent,\n        allContributionBindings(),\n        allMembersInjectionBindings(),\n        multibindingDeclarations(),\n        subcomponentDeclarations(),\n        optionalBindingDeclarations());\n  }\n\n  /**\n   * {@code true} if this is a multibinding contribution.\n   */\n  boolean isMultibindingContribution() {\n    return contributionBindings().size() \u003d\u003d 1\n        \u0026\u0026 contributionBinding().contributionType().isMultibinding();\n  }\n\n  /**\n   * Returns the single contribution binding.\n   *\n   * @throws IllegalStateException if there is not exactly one element in\n   *     {@link #contributionBindings()}, which will never happen for contributions in valid graphs\n   */\n  ContributionBinding contributionBinding() {\n    return getOnlyElement(contributionBindings());\n  }\n\n  /**\n   * The binding type for these bindings. If there are {@link #multibindingDeclarations()} or {@link\n   * #subcomponentDeclarations()} but no {@link #bindings()}, returns {@link BindingType#PROVISION}.\n   *\n   * @throws IllegalStateException if {@link #isEmpty()} or the binding types conflict\n   */\n  @Override\n  public BindingType bindingType() {\n    checkState(!isEmpty(), \"empty bindings for %s\", bindingKey());\n    if (bindings().isEmpty()\n        \u0026\u0026 (!multibindingDeclarations().isEmpty() || !subcomponentDeclarations().isEmpty())) {\n      // Only multibinding declarations, so assume provision.\n      return BindingType.PROVISION;\n    }\n    ImmutableSet\u003cBindingType\u003e bindingTypes \u003d bindingTypes();\n    checkState(bindingTypes.size() \u003d\u003d 1, \"conflicting binding types: %s\", bindings());\n    return getOnlyElement(bindingTypes);\n  }\n\n  /** The binding types for {@link #bindings()}. */\n  ImmutableSet\u003cBindingType\u003e bindingTypes() {\n    return FluentIterable.from(bindings()).transform(HasBindingType::bindingType).toSet();\n  }\n\n  /**\n   * The contribution type for these bindings.\n   *\n   * @throws IllegalStateException if there is not exactly one element in {@link\n   *     #contributionBindings()}, which will never happen for contributions in valid graphs\n   */\n  @Override\n  public ContributionType contributionType() {\n    return contributionBinding().contributionType();\n  }\n\n  /**\n   * The name of the package in which these bindings must be managed, for\n   * example if a binding references non-public types.\n   * \n   * @throws IllegalArgumentException if the bindings must be managed in more than one package\n   */\n  Optional\u003cString\u003e bindingPackage() {\n    ImmutableSet.Builder\u003cString\u003e bindingPackagesBuilder \u003d ImmutableSet.builder();\n    for (Binding binding : bindings()) {\n      bindingPackagesBuilder.addAll(binding.bindingPackage().asSet());\n    }\n    ImmutableSet\u003cString\u003e bindingPackages \u003d bindingPackagesBuilder.build();\n    switch (bindingPackages.size()) {\n      case 0:\n        return Optional.absent();\n      case 1:\n        return Optional.of(bindingPackages.iterator().next());\n      default:\n        throw new IllegalArgumentException();\n    }\n  }\n\n  /**\n   * The framework class associated with these bindings.\n   */\n  Class\u003c?\u003e frameworkClass() {\n    return bindingType().frameworkClass();\n  }\n\n  /**\n   * The scope associated with the single binding.\n   *\n   * @throws IllegalStateException if {@link #bindings()} does not have exactly one element\n   */\n  Optional\u003cScope\u003e scope() {\n    return getOnlyElement(bindings()).scope();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\Scope.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.isAnnotationPresent;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static dagger.internal.codegen.ErrorMessages.stripCommonTypePrefixes;\nimport static dagger.internal.codegen.InjectionAnnotations.getScopes;\n\nimport com.google.auto.common.AnnotationMirrors;\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Equivalence;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport dagger.Reusable;\nimport dagger.producers.ProductionScope;\nimport java.lang.annotation.Annotation;\nimport javax.inject.Singleton;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.util.Elements;\n\n/** A javax.inject.Scope. */\n@AutoValue\nabstract class Scope {\n\n  /** The underlying {@link AnnotationMirror} that represents the scope annotation. */\n  abstract Equivalence.Wrapper\u003cAnnotationMirror\u003e scopeAnnotation();\n\n  /**\n   * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.\n   */\n  static Scope scope(AnnotationMirror scopeAnnotation) {\n    checkArgument(isScope(scopeAnnotation));\n    return new AutoValue_Scope(AnnotationMirrors.equivalence().wrap(scopeAnnotation));\n  }\n\n  /** Returns {@code true} if {@code scopeAnnotation} is a {@link javax.inject.Scope} annotation. */\n  static boolean isScope(AnnotationMirror scopeAnnotation) {\n    return isScope(MoreElements.asType(scopeAnnotation.getAnnotationType().asElement()));\n  }\n\n  /**\n   * Returns {@code true} if {@code scopeAnnotationType} is a {@link javax.inject.Scope} annotation.\n   */\n  static boolean isScope(TypeElement scopeAnnotationType) {\n    return isAnnotationPresent(scopeAnnotationType, javax.inject.Scope.class);\n  }\n\n  /**\n   * Creates a {@link Scope} object from the {@link javax.inject.Scope}-annotated annotation type.\n   */\n  static Scope scope(TypeElement scopeType) {\n    return scope(SimpleAnnotationMirror.of(scopeType));\n  }\n\n  private static Scope scope(Elements elements, Class\u003c? extends Annotation\u003e scopeAnnotationClass) {\n    return scope(elements.getTypeElement(scopeAnnotationClass.getCanonicalName()));\n  }\n\n  /** Returns all of the associated scopes for a source code element. */\n  static ImmutableSet\u003cScope\u003e scopesOf(Element element) {\n    return FluentIterable.from(getScopes(element)).transform(Scope::scope).toSet();\n  }\n\n  /**\n   * Returns at most one associated scoped annotation from the source code element, throwing an\n   * exception if there are more than one.\n   */\n  static Optional\u003cScope\u003e uniqueScopeOf(Element element) {\n    ImmutableSet\u003c? extends AnnotationMirror\u003e scopeAnnotations \u003d getScopes(element);\n    if (scopeAnnotations.isEmpty()) {\n      return Optional.absent();\n    }\n    return Optional.of(scope(Iterables.getOnlyElement(scopeAnnotations)));\n  }\n\n  /**\n   * Returns a representation for {@link ProductionScope @ProductionScope} scope.\n   */\n  static Scope productionScope(Elements elements) {\n    return scope(elements, ProductionScope.class);\n  }\n\n  /**\n   * Returns a representation for {@link Singleton @Singleton} scope.\n   */\n  static Scope singletonScope(Elements elements) {\n    return scope(elements, Singleton.class);\n  }\n\n  /**\n   * Returns a representation for {@link Reusable @Reusable} scope.\n   */\n  static Scope reusableScope(Elements elements) {\n    return scope(elements, Reusable.class);\n  }\n\n  /**\n   * Returns the readable source representation (name with @ prefix) of the annotation type.\n   *\n   * \u003cp\u003eIt\u0027s readable source because it has had common package prefixes removed, e.g.\n   * {@code @javax.inject.Singleton} is returned as {@code @Singleton}.\n   *\n   * \u003cp\u003eDoes not return any annotation values, since {@link javax.inject.Scope @Scope}\n   * annotations are not supposed to have any.\n   */\n  public String getReadableSource() {\n    return stripCommonTypePrefixes(\"@\" + getQualifiedName());\n  }\n\n  /**\n   * Returns the fully qualified name of the annotation type.\n   */\n  public String getQualifiedName() {\n    return scopeAnnotationElement().getQualifiedName().toString();\n  }\n\n  /**\n   * The scope annotation element.\n   */\n  public TypeElement scopeAnnotationElement() {\n    return MoreTypes.asTypeElement(scopeAnnotation().get().getAnnotationType());\n  }\n\n  /**\n   * Returns a debug representation of the scope.\n   */\n  @Override\n  public String toString() {\n    return scopeAnnotation().get().toString();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\SetType.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Equivalence;\nimport java.util.Set;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeMirror;\n\n/**\n * Information about a {@link Set} {@link TypeMirror}.\n */\n@AutoValue\nabstract class SetType {\n  /**\n   * The set type itself, wrapped using {@link MoreTypes#equivalence()}. Use\n   * {@link #declaredSetType()} instead.\n   */\n  protected abstract Equivalence.Wrapper\u003cDeclaredType\u003e wrappedDeclaredSetType();\n  \n  /**\n   * The set type itself.\n   */\n  DeclaredType declaredSetType() {\n    return wrappedDeclaredSetType().get();\n  }\n\n  /**\n   * {@code true} if the set type is the raw {@link Set} type.\n   */\n  boolean isRawType() {\n    return declaredSetType().getTypeArguments().isEmpty();\n  }\n\n  /**\n   * The element type.\n   */\n  TypeMirror elementType() {\n    return declaredSetType().getTypeArguments().get(0);\n  }\n\n  /**\n   * {@code true} if {@link #elementType()} is a {@code clazz}.\n   */\n  boolean elementsAreTypeOf(Class\u003c?\u003e clazz) {\n    return MoreTypes.isType(elementType()) \u0026\u0026 MoreTypes.isTypeOf(clazz, elementType());\n  }\n\n  /**\n   * {@code T} if {@link #elementType()} is a {@code WrappingClass\u003cT\u003e}.\n   *\n   * @throws IllegalStateException if {@link #elementType()} is not a {@code WrappingClass\u003cT\u003e}\n   * @throws IllegalArgumentException if {@code wrappingClass} does not have exactly one type\n   *     parameter\n   */\n  TypeMirror unwrappedElementType(Class\u003c?\u003e wrappingClass) {\n    checkArgument(\n        wrappingClass.getTypeParameters().length \u003d\u003d 1,\n        \"%s must have exactly one type parameter\",\n        wrappingClass);\n    checkArgument(\n        elementsAreTypeOf(wrappingClass),\n        \"expected elements to be %s, but this type is %s\",\n        wrappingClass,\n        declaredSetType());\n    return MoreTypes.asDeclared(elementType()).getTypeArguments().get(0);\n  }\n\n  /**\n   * {@code true} if {@code type} is a {@link Set} type.\n   */\n  static boolean isSet(TypeMirror type) {\n    return MoreTypes.isType(type) \u0026\u0026 MoreTypes.isTypeOf(Set.class, type);\n  }\n\n  /**\n   * {@code true} if {@code key.type()} is a {@link Set} type.\n   */\n  static boolean isSet(Key key) {\n    return isSet(key.type());\n  }\n\n  /**\n   * Returns a {@link SetType} for {@code type}.\n   *\n   * @throws IllegalArgumentException if {@code type} is not a {@link Set} type\n   */\n  static SetType from(TypeMirror type) {\n    checkArgument(isSet(type), \"%s must be a Set\", type);\n    return new AutoValue_SetType(MoreTypes.equivalence().wrap(MoreTypes.asDeclared(type)));\n  }\n\n  /**\n   * Returns a {@link SetType} for {@code key}\u0027s {@link Key#type() type}.\n   *\n   * @throws IllegalArgumentException if {@code key.type()} is not a {@link Set} type\n   */\n  static SetType from(Key key) {\n    return from (key.type());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\SimpleAnnotationMirror.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;\nimport static javax.lang.model.util.ElementFilter.methodsIn;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.base.Functions;\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Maps;\nimport java.util.Map;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.AnnotationValue;\nimport javax.lang.model.element.ElementKind;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.DeclaredType;\n\n/** A representation of an annotation. */\nfinal class SimpleAnnotationMirror implements AnnotationMirror {\n  private final TypeElement annotationType;\n  private final ImmutableMap\u003cString, ? extends AnnotationValue\u003e namedValues;\n  private final ImmutableMap\u003cExecutableElement, ? extends AnnotationValue\u003e elementValues;\n\n  private SimpleAnnotationMirror(\n      TypeElement annotationType, Map\u003cString, ? extends AnnotationValue\u003e namedValues) {\n    checkArgument(\n        annotationType.getKind().equals(ElementKind.ANNOTATION_TYPE),\n        \"annotationType must be an annotation: %s\",\n        annotationType);\n    checkArgument(\n        FluentIterable.from(methodsIn(annotationType.getEnclosedElements()))\n            .transform(ELEMENT_SIMPLE_NAME)\n            .toSet()\n            .equals(namedValues.keySet()),\n        \"namedValues must have values for exactly the members in %s: %s\",\n        annotationType,\n        namedValues);\n    this.annotationType \u003d annotationType;\n    this.namedValues \u003d ImmutableMap.copyOf(namedValues);\n    this.elementValues \u003d\n        Maps.toMap(\n            methodsIn(annotationType.getEnclosedElements()),\n            Functions.compose(Functions.forMap(namedValues), ELEMENT_SIMPLE_NAME));\n  }\n\n  @Override\n  public DeclaredType getAnnotationType() {\n    return MoreTypes.asDeclared(annotationType.asType());\n  }\n\n  @Override\n  public Map\u003cExecutableElement, ? extends AnnotationValue\u003e getElementValues() {\n    return elementValues;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder \u003d new StringBuilder(\"@\").append(annotationType.getQualifiedName());\n    if (!namedValues.isEmpty()) {\n      builder\n          .append(\u0027(\u0027)\n          .append(Joiner.on(\", \").withKeyValueSeparator(\" \u003d \").join(namedValues))\n          .append(\u0027)\u0027);\n    }\n    return builder.toString();\n  }\n\n  /**\n   * An object representing an annotation instance.\n   *\n   * @param annotationType must be an annotation type with no members\n   */\n  static AnnotationMirror of(TypeElement annotationType) {\n    return of(annotationType, ImmutableMap.\u003cString, AnnotationValue\u003eof());\n  }\n\n  /**\n   * An object representing an annotation instance.\n   *\n   * @param annotationType must be an annotation type\n   * @param namedValues a value for every annotation member, including those with defaults, indexed\n   *     by simple name\n   */\n  static AnnotationMirror of(\n      TypeElement annotationType, Map\u003cString, ? extends AnnotationValue\u003e namedValues) {\n    return new SimpleAnnotationMirror(annotationType, namedValues);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\SimpleMethodRequestFulfillment.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.asExecutable;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkState;\nimport static javax.lang.model.element.Modifier.STATIC;\n\nimport com.google.common.util.concurrent.Futures;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport javax.lang.model.element.ExecutableElement;\n\n/**\n * A request fulfillment implementation that invokes methods or constructors directly to fulfill\n * requests whenever possible. In cases where direct invocation is not possible, this implementation\n * delegates to one that uses a {@link javax.inject.Provider}.\n */\nfinal class SimpleMethodRequestFulfillment extends RequestFulfillment {\n  private final ProvisionBinding provisionBinding;\n  private final RequestFulfillment providerDelegate;\n\n  SimpleMethodRequestFulfillment(\n      BindingKey bindingKey,\n      ProvisionBinding provisionBinding,\n      RequestFulfillment providerDelegate) {\n    super(bindingKey);\n    checkArgument(provisionBinding.implicitDependencies().isEmpty());\n    checkArgument(!provisionBinding.scope().isPresent());\n    checkArgument(!provisionBinding.requiresModuleInstance());\n    checkArgument(provisionBinding.bindingElement().isPresent());\n    this.provisionBinding \u003d provisionBinding;\n    this.providerDelegate \u003d providerDelegate;\n  }\n\n  @Override\n  CodeBlock getSnippetForDependencyRequest(DependencyRequest request, ClassName requestingClass) {\n    switch (request.kind()) {\n      case INSTANCE:\n        return invokeMethod();\n      case FUTURE:\n        return CodeBlock.of(\"$T.immediateFuture($L)\", Futures.class, invokeMethod());\n      default:\n        return providerDelegate.getSnippetForDependencyRequest(request, requestingClass);\n    }\n  }\n\n  private CodeBlock invokeMethod() {\n    // we use the type from the key to ensure we get the right generics\n    // TODO(gak): use \u003c\u003e?\n    ExecutableElement method \u003d asExecutable(provisionBinding.bindingElement().get());\n    switch (method.getKind()) {\n      case CONSTRUCTOR:\n        return CodeBlock.of(\"new $T()\", provisionBinding.key().type());\n      case METHOD:\n        checkState(method.getModifiers().contains(STATIC));\n        return CodeBlock.of(\n            \"$T.$L()\", provisionBinding.bindingTypeElement().get(), method.getSimpleName());\n      default:\n        throw new IllegalStateException();\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\SimpleTypeAnnotationValue.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport javax.lang.model.element.AnnotationValue;\nimport javax.lang.model.element.AnnotationValueVisitor;\nimport javax.lang.model.type.TypeMirror;\n\n/** An {@link AnnotationValue} that contains a {@link TypeMirror}. */\nfinal class SimpleTypeAnnotationValue implements AnnotationValue {\n  private final TypeMirror value;\n\n  SimpleTypeAnnotationValue(TypeMirror value) {\n    this.value \u003d value;\n  }\n\n  @Override\n  public TypeMirror getValue() {\n    return value;\n  }\n\n  @Override\n  public String toString() {\n    return value + \".class\";\n  }\n\n  @Override\n  public \u003cR, P\u003e R accept(AnnotationValueVisitor\u003cR, P\u003e visitor, P parameter) {\n    return visitor.visitType(getValue(), parameter);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\SourceFileGenerationException.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static javax.tools.Diagnostic.Kind.ERROR;\n\nimport com.google.common.base.Optional;\nimport com.squareup.javapoet.ClassName;\nimport javax.annotation.processing.Messager;\nimport javax.lang.model.element.Element;\n\n/**\n * An exception thrown to indicate that a source file could not be generated.\n *\n * \u003cp\u003eThis exception \u003cb\u003eshould not\u003c/b\u003e be used to report detectable, logical errors as it may mask\n * other errors that might have been caught upon further processing.  Use a {@link ValidationReport}\n * for that.\n *\n * @author Gregory Kick\n * @since 2.0\n */\nfinal class SourceFileGenerationException extends Exception {\n  // TODO(ronshapiro): remove these unused values\n  private final Optional\u003c? extends Element\u003e associatedElement;\n\n  SourceFileGenerationException(\n      Optional\u003cClassName\u003e generatedClassName,\n      Throwable cause,\n      Optional\u003c? extends Element\u003e associatedElement) {\n    super(createMessage(generatedClassName, cause.getMessage()), cause);\n    this.associatedElement \u003d checkNotNull(associatedElement);\n  }\n\n  private static String createMessage(Optional\u003cClassName\u003e generatedClassName, String message) {\n    return String.format(\"Could not generate %s: %s.\",\n        generatedClassName.isPresent()\n            ? generatedClassName.get()\n            : \"unknown file\",\n        message);\n  }\n\n  void printMessageTo(Messager messager) {\n    if (associatedElement.isPresent()) {\n      messager.printMessage(ERROR, getMessage(), associatedElement.get());\n    } else {\n      messager.printMessage(ERROR, getMessage());\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\SourceFileGenerator.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Optional;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.Iterables;\nimport com.google.common.io.CharSink;\nimport com.google.common.io.CharSource;\nimport com.google.googlejavaformat.java.Formatter;\nimport com.google.googlejavaformat.java.FormatterException;\nimport com.squareup.javapoet.AnnotationSpec;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.JavaFile;\nimport com.squareup.javapoet.TypeSpec;\nimport java.io.IOException;\nimport java.io.Writer;\nimport javax.annotation.Generated;\nimport javax.annotation.processing.Filer;\nimport javax.annotation.processing.Messager;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.util.Elements;\nimport javax.tools.JavaFileObject;\n\n/**\n * A template class that provides a framework for properly handling IO while generating source files\n * from an annotation processor.  Particularly, it makes a best effort to ensure that files that\n * fail to write successfully are deleted.\n *\n * @param \u003cT\u003e The input type from which source is to be generated.\n */\nabstract class SourceFileGenerator\u003cT\u003e {\n  private static final String GENERATED_COMMENTS \u003d \"https://google.github.io/dagger\";\n\n  private static final AnnotationSpec GENERATED \u003d\n      AnnotationSpec.builder(Generated.class)\n          .addMember(\"value\", \"$S\", ComponentProcessor.class.getName())\n          .addMember(\"comments\", \"$S\", GENERATED_COMMENTS)\n          .build();\n\n  private final Filer filer;\n  private final boolean generatedAnnotationAvailable;\n\n  SourceFileGenerator(Filer filer, Elements elements) {\n    this.filer \u003d checkNotNull(filer);\n    generatedAnnotationAvailable \u003d elements.getTypeElement(\"javax.annotation.Generated\") !\u003d null;\n  }\n\n  /**\n   * Generates a source file to be compiled for {@code T}. Writes any generation exception to {@code\n   * messager} and does not throw.\n   */\n  void generate(T input, Messager messager) {\n    try {\n      generate(input);\n    } catch (SourceFileGenerationException e) {\n      e.printMessageTo(messager);\n    }\n  }\n\n  /** Generates a source file to be compiled for {@code T}. */\n  void generate(T input) throws SourceFileGenerationException {\n    ClassName generatedTypeName \u003d nameGeneratedType(input);\n    try {\n      Optional\u003cTypeSpec.Builder\u003e type \u003d write(generatedTypeName, input);\n      if (!type.isPresent()) {\n        return;\n      }\n      JavaFile javaFile \u003d buildJavaFile(generatedTypeName, type.get());\n\n      final JavaFileObject sourceFile \u003d filer.createSourceFile(\n          generatedTypeName.toString(),\n          Iterables.toArray(javaFile.typeSpec.originatingElements, Element.class));\n      try {\n        new Formatter().formatSource(\n            CharSource.wrap(javaFile.toString()),\n            new CharSink() {\n              @Override public Writer openStream() throws IOException {\n                return sourceFile.openWriter();\n              }\n            });\n      } catch (FormatterException e) {\n        throw new SourceFileGenerationException(\n            Optional.of(generatedTypeName), e, getElementForErrorReporting(input));\n      }\n    } catch (Exception e) {\n      // if the code above threw a SFGE, use that\n      Throwables.propagateIfPossible(e, SourceFileGenerationException.class);\n      // otherwise, throw a new one\n      throw new SourceFileGenerationException(\n          Optional.\u003cClassName\u003eabsent(), e, getElementForErrorReporting(input));\n    }\n  }\n\n  private JavaFile buildJavaFile(\n      ClassName generatedTypeName, TypeSpec.Builder typeSpecBuilder) {\n    if (generatedAnnotationAvailable) {\n      typeSpecBuilder.addAnnotation(GENERATED);\n    }\n    JavaFile.Builder javaFileBuilder \u003d\n        JavaFile.builder(generatedTypeName.packageName(), typeSpecBuilder.build())\n            .skipJavaLangImports(true);\n    if (!generatedAnnotationAvailable) {\n      javaFileBuilder.addFileComment(\n          \"Generated by $L ($L).\", ComponentProcessor.class.getName(), GENERATED_COMMENTS);\n    }\n    return javaFileBuilder.build();\n  }\n\n  /**\n   * Implementations should return the {@link ClassName} for the top-level type to be generated.\n   */\n  abstract ClassName nameGeneratedType(T input);\n\n  /**\n   * Returns an optional element to be used for reporting errors. This returns a single element\n   * rather than a collection to reduce output noise.\n   */\n  abstract Optional\u003c? extends Element\u003e getElementForErrorReporting(T input);\n\n  /**\n   * Returns a {@link TypeSpec.Builder type} to be generated for {@code T}, or {@link\n   * Optional#absent()} if no file should be generated.\n   */\n  // TODO(ronshapiro): write() makes more sense in JavaWriter where all writers are mutable.\n  // consider renaming to something like typeBuilder() which conveys the mutability of the result\n  abstract Optional\u003cTypeSpec.Builder\u003e write(ClassName generatedTypeName, T input);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\SourceFiles.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.CaseFormat.UPPER_CAMEL;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static dagger.internal.codegen.FrameworkDependency.frameworkDependenciesForBinding;\nimport static dagger.internal.codegen.TypeNames.DOUBLE_CHECK;\nimport static dagger.internal.codegen.TypeNames.PROVIDER_OF_LAZY;\nimport static dagger.internal.codegen.Util.ELEMENT_SIMPLE_NAME;\nimport static dagger.internal.codegen.Util.optionalComparator;\n\nimport com.google.common.base.CaseFormat;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport com.squareup.javapoet.ParameterizedTypeName;\nimport com.squareup.javapoet.TypeName;\nimport com.squareup.javapoet.TypeVariableName;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.TypeParameterElement;\nimport javax.lang.model.type.TypeMirror;\n\n/**\n * Utilities for generating files.\n *\n * @author Gregory Kick\n * @since 2.0\n */\nclass SourceFiles {\n\n  private static final Joiner CLASS_FILE_NAME_JOINER \u003d Joiner.on(\u0027_\u0027);\n\n  /**\n   * Sorts {@link DependencyRequest} instances in an order likely to reflect their logical\n   * importance.\n   */\n  static final Comparator\u003cDependencyRequest\u003e DEPENDENCY_ORDERING \u003d\n      // put fields before parameters\n      Comparator.comparing(\n              (DependencyRequest request) -\u003e request.requestElement().transform(Element::getKind),\n              optionalComparator())\n          // order by dependency kind\n          .thenComparing(DependencyRequest::kind)\n          // then sort by name\n          .thenComparing(\n              request -\u003e request.requestElement().transform(ELEMENT_SIMPLE_NAME),\n              optionalComparator());\n\n  /**\n   * Generates names and keys for the factory class fields needed to hold the framework classes for\n   * all of the dependencies of {@code binding}. It is responsible for choosing a name that\n   *\n   * \u003cul\u003e\n   * \u003cli\u003erepresents all of the dependency requests for this key\n   * \u003cli\u003eis \u003ci\u003eprobably\u003c/i\u003e associated with the type being bound\n   * \u003cli\u003eis unique within the class\n   * \u003c/ul\u003e\n   *\n   * @param binding must be an unresolved binding (type parameters must match its type element\u0027s)\n   */\n  static ImmutableMap\u003cBindingKey, FrameworkField\u003e generateBindingFieldsForDependencies(\n      Binding binding) {\n    checkArgument(!binding.unresolved().isPresent(), \"binding must be unresolved: %s\", binding);\n\n    ImmutableMap.Builder\u003cBindingKey, FrameworkField\u003e bindingFields \u003d ImmutableMap.builder();\n    for (FrameworkDependency frameworkDependency : frameworkDependenciesForBinding(binding)) {\n      bindingFields.put(\n          frameworkDependency.bindingKey(),\n          FrameworkField.create(\n              ClassName.get(frameworkDependency.frameworkClass()),\n              TypeName.get(frameworkDependency.bindingKey().key().type()),\n              fieldNameForDependency(frameworkDependency)));\n    }\n    return bindingFields.build();\n  }\n\n  private static String fieldNameForDependency(FrameworkDependency frameworkDependency) {\n    // collect together all of the names that we would want to call the provider\n    ImmutableSet\u003cString\u003e dependencyNames \u003d\n        FluentIterable.from(frameworkDependency.dependencyRequests())\n            .transform(new DependencyVariableNamer())\n            .toSet();\n\n    if (dependencyNames.size() \u003d\u003d 1) {\n      // if there\u0027s only one name, great! use it!\n      return Iterables.getOnlyElement(dependencyNames);\n    } else {\n      // in the event that a field is being used for a bunch of deps with different names,\n      // add all the names together with \"And\"s in the middle. E.g.: stringAndS\n      Iterator\u003cString\u003e namesIterator \u003d dependencyNames.iterator();\n      String first \u003d namesIterator.next();\n      StringBuilder compositeNameBuilder \u003d new StringBuilder(first);\n      while (namesIterator.hasNext()) {\n        compositeNameBuilder\n            .append(\"And\")\n            .append(CaseFormat.LOWER_CAMEL.to(UPPER_CAMEL, namesIterator.next()));\n      }\n      return compositeNameBuilder.toString();\n    }\n  }\n\n  static CodeBlock frameworkTypeUsageStatement(\n      CodeBlock frameworkTypeMemberSelect, DependencyRequest.Kind dependencyKind) {\n    switch (dependencyKind) {\n      case LAZY:\n        return CodeBlock.of(\"$T.lazy($L)\", DOUBLE_CHECK, frameworkTypeMemberSelect);\n      case INSTANCE:\n      case FUTURE:\n        return CodeBlock.of(\"$L.get()\", frameworkTypeMemberSelect);\n      case PROVIDER:\n      case PRODUCER:\n      case MEMBERS_INJECTOR:\n        return frameworkTypeMemberSelect;\n      case PROVIDER_OF_LAZY:\n        return CodeBlock.of(\"$T.create($L)\", PROVIDER_OF_LAZY, frameworkTypeMemberSelect);\n      default: // including PRODUCED\n        throw new AssertionError(dependencyKind);\n    }\n  }\n\n  /**\n   * Returns the generated factory or members injector name for a binding.\n   */\n  static ClassName generatedClassNameForBinding(Binding binding) {\n    switch (binding.bindingType()) {\n      case PROVISION:\n      case PRODUCTION:\n        ContributionBinding contribution \u003d (ContributionBinding) binding;\n        checkArgument(contribution.bindingTypeElement().isPresent());\n        ClassName enclosingClassName \u003d ClassName.get(contribution.bindingTypeElement().get());\n        switch (contribution.bindingKind()) {\n          case INJECTION:\n          case PROVISION:\n          case PRODUCTION:\n            return enclosingClassName\n                .topLevelClassName()\n                .peerClass(\n                    classFileName(enclosingClassName)\n                        + \"_\"\n                        + factoryPrefix(contribution)\n                        + \"Factory\");\n\n          default:\n            throw new AssertionError();\n        }\n\n      case MEMBERS_INJECTION:\n        return membersInjectorNameForType(\n            ((MembersInjectionBinding) binding).membersInjectedType());\n\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  static TypeName parameterizedGeneratedTypeNameForBinding(\n      Binding binding) {\n    ClassName className \u003d generatedClassNameForBinding(binding);\n    ImmutableList\u003cTypeName\u003e typeParameters \u003d bindingTypeParameters(binding);\n    if (typeParameters.isEmpty()) {\n      return className;\n    } else {\n      return ParameterizedTypeName.get(\n          className,\n          FluentIterable.from(typeParameters).toArray(TypeName.class));\n    }\n  }\n\n  private static Optional\u003cTypeMirror\u003e typeMirrorForBindingTypeParameters(Binding binding)\n      throws AssertionError {\n    switch (binding.bindingType()) {\n      case PROVISION:\n      case PRODUCTION:\n        ContributionBinding contributionBinding \u003d (ContributionBinding) binding;\n        switch (contributionBinding.bindingKind()) {\n          case INJECTION:\n            return Optional.of(contributionBinding.key().type());\n\n          case PROVISION:\n            // For provision bindings, we parameterize creation on the types of\n            // the module, not the types of the binding.\n            // Consider: Module\u003cA, B, C\u003e { @Provides List\u003cB\u003e provideB(B b) { .. }}\n            // The binding is just parameterized on \u003cB\u003e, but we need all of \u003cA, B, C\u003e.\n            return Optional.of(contributionBinding.bindingTypeElement().get().asType());\n\n          case PRODUCTION:\n            // TODO(beder): Can these be treated just like PROVISION?\n            throw new UnsupportedOperationException();\n            \n          default:\n            return Optional.absent();\n        }\n\n      case MEMBERS_INJECTION:\n        return Optional.of(binding.key().type());\n\n      default:\n        throw new AssertionError();\n    }\n  }\n\n  static ImmutableList\u003cTypeName\u003e bindingTypeParameters(\n      Binding binding) {\n    Optional\u003cTypeMirror\u003e typeMirror \u003d typeMirrorForBindingTypeParameters(binding);\n    if (!typeMirror.isPresent()) {\n      return ImmutableList.of();\n    }\n    TypeName bindingTypeName \u003d TypeName.get(typeMirror.get());\n    return bindingTypeName instanceof ParameterizedTypeName\n        ? ImmutableList.copyOf(((ParameterizedTypeName) bindingTypeName).typeArguments)\n        : ImmutableList.\u003cTypeName\u003eof();\n  }\n\n  static ClassName membersInjectorNameForType(TypeElement typeElement) {\n    return siblingClassName(typeElement,  \"_MembersInjector\");\n  }\n\n  static String classFileName(ClassName className) {\n    return CLASS_FILE_NAME_JOINER.join(className.simpleNames());\n  }\n\n  static ClassName generatedMonitoringModuleName(\n      TypeElement componentElement) {\n    return siblingClassName(componentElement, \"_MonitoringModule\");\n  }\n\n  static ClassName generatedProductionExecutorModuleName(TypeElement componentElement) {\n    return siblingClassName(componentElement, \"_ProductionExecutorModule\");\n  }\n\n  // TODO(ronshapiro): when JavaPoet migration is complete, replace the duplicated code\n  // which could use this.\n  private static ClassName siblingClassName(TypeElement typeElement, String suffix) {\n    ClassName className \u003d ClassName.get(typeElement);\n    return className.topLevelClassName().peerClass(classFileName(className) + suffix);\n  }\n\n  private static String factoryPrefix(ContributionBinding binding) {\n    switch (binding.bindingKind()) {\n      case INJECTION:\n        return \"\";\n\n      case PROVISION:\n      case PRODUCTION:\n        return CaseFormat.LOWER_CAMEL.to(\n            UPPER_CAMEL, binding.bindingElement().get().getSimpleName().toString());\n\n      default:\n        throw new IllegalArgumentException();\n    }\n  }\n\n  static ImmutableList\u003cTypeVariableName\u003e bindingTypeElementTypeVariableNames(Binding binding) {\n    ImmutableList.Builder\u003cTypeVariableName\u003e builder \u003d ImmutableList.builder();\n    for (TypeParameterElement typeParameter :\n        binding.bindingTypeElement().get().getTypeParameters()) {\n      builder.add(TypeVariableName.get(typeParameter));\n    }\n    return builder.build();\n  }\n\n  private SourceFiles() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\SubcomponentDeclaration.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.AnnotationMirrors.getAnnotationElementAndValue;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getModuleAnnotation;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getModuleSubcomponents;\nimport static dagger.internal.codegen.ConfigurationAnnotations.getSubcomponentBuilder;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableSet;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\n\n/**\n * A declaration for a subcomponent that is included in a module via {@link\n * dagger.Module#subcomponents()}.\n */\n@AutoValue\nabstract class SubcomponentDeclaration extends BindingDeclaration {\n  /**\n   * Key for the {@link dagger.Subcomponent.Builder} or {@link\n   * dagger.producers.ProductionSubcomponent.Builder} of {@link #subcomponentType()}.\n   */\n  @Override\n  public abstract Key key();\n\n  /**\n   * The type element that defines the {@link dagger.Subcomponent} or {@link\n   * dagger.producers.ProductionSubcomponent} for this declaration.\n   */\n  abstract TypeElement subcomponentType();\n\n  abstract AnnotationMirror moduleAnnotation();\n\n  static class Factory {\n    private final Key.Factory keyFactory;\n\n    public Factory(Key.Factory keyFactory) {\n      this.keyFactory \u003d keyFactory;\n    }\n\n    ImmutableSet\u003cSubcomponentDeclaration\u003e forModule(TypeElement module) {\n      ImmutableSet.Builder\u003cSubcomponentDeclaration\u003e declarations \u003d ImmutableSet.builder();\n      AnnotationMirror moduleAnnotation \u003d getModuleAnnotation(module).get();\n      ExecutableElement subcomponentAttribute \u003d\n          getAnnotationElementAndValue(moduleAnnotation, \"subcomponents\").getKey();\n      for (TypeElement subcomponent :\n          MoreTypes.asTypeElements(getModuleSubcomponents(moduleAnnotation))) {\n        declarations.add(\n            new AutoValue_SubcomponentDeclaration(\n                Optional.\u003cElement\u003eof(subcomponentAttribute),\n                Optional.of(module),\n                keyFactory.forSubcomponentBuilder(\n                    getSubcomponentBuilder(subcomponent).get().asType()),\n                subcomponent,\n                moduleAnnotation));\n      }\n      return declarations.build();\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\SubcomponentWriter.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.base.CaseFormat.LOWER_CAMEL;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Verify.verify;\nimport static com.google.common.collect.Sets.difference;\nimport static com.squareup.javapoet.MethodSpec.methodBuilder;\nimport static com.squareup.javapoet.TypeSpec.classBuilder;\nimport static dagger.internal.codegen.AbstractComponentWriter.InitializationState.UNINITIALIZED;\nimport static dagger.internal.codegen.CodeBlocks.makeParametersCodeBlock;\nimport static dagger.internal.codegen.MemberSelect.localField;\nimport static dagger.internal.codegen.TypeSpecs.addSupertype;\nimport static javax.lang.model.element.Modifier.FINAL;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.element.Modifier.PUBLIC;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.base.CaseFormat;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableList;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport com.squareup.javapoet.FieldSpec;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.TypeName;\nimport com.squareup.javapoet.TypeSpec;\nimport dagger.internal.Preconditions;\nimport dagger.internal.codegen.ComponentDescriptor.ComponentMethodDescriptor;\nimport java.util.List;\nimport java.util.Set;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.TypeMirror;\n\n/**\n * Creates the nested implementation class for a subcomponent.\n */\nfinal class SubcomponentWriter extends AbstractComponentWriter {\n\n  private final AbstractComponentWriter parent;\n\n  /**\n   * The parent\u0027s factory method to create this subcomponent, or {@link Optional#absent()} if the\n   * subcomponent was added via {@link dagger.Module#subcomponents()}.\n   */\n  private final Optional\u003cComponentMethodDescriptor\u003e subcomponentFactoryMethod;\n\n  SubcomponentWriter(\n      AbstractComponentWriter parent,\n      Optional\u003cComponentMethodDescriptor\u003e subcomponentFactoryMethod,\n      BindingGraph subgraph) {\n    super(parent, subcomponentName(parent, subgraph), subgraph);\n    this.parent \u003d parent;\n    this.subcomponentFactoryMethod \u003d subcomponentFactoryMethod;\n  }\n\n  private static ClassName subcomponentName(AbstractComponentWriter parent, BindingGraph subgraph) {\n    return parent.name.nestedClass(\n        parent.subcomponentNames.get(subgraph.componentDescriptor()) + \"Impl\");\n  }\n\n  @Override\n  protected InitializationState getInitializationState(BindingKey bindingKey) {\n    InitializationState initializationState \u003d super.getInitializationState(bindingKey);\n    return initializationState.equals(UNINITIALIZED)\n        ? parent.getInitializationState(bindingKey)\n        : initializationState;\n  }\n\n  @Override\n  protected Optional\u003cCodeBlock\u003e getOrCreateComponentContributionFieldExpression(\n      TypeElement contributionType) {\n    return super.getOrCreateComponentContributionFieldExpression(contributionType)\n        .or(parent.getOrCreateComponentContributionFieldExpression(contributionType));\n  }\n\n  @Override\n  protected MemberSelect getMemberSelect(BindingKey key) {\n    MemberSelect memberSelect \u003d super.getMemberSelect(key);\n    return memberSelect \u003d\u003d null ? parent.getMemberSelect(key) : memberSelect;\n  }\n\n  private ExecutableType resolvedSubcomponentFactoryMethod() {\n    checkState(\n        subcomponentFactoryMethod.isPresent(),\n        \"%s does not have a factory method for %s\",\n        parent.componentDefinitionType(),\n        componentDefinitionType());\n    return MoreTypes.asExecutable(\n        types.asMemberOf(\n            MoreTypes.asDeclared(parent.componentDefinitionType().asType()),\n            subcomponentFactoryMethod.get().methodElement()));\n  }\n\n  @Override\n  protected void decorateComponent() {\n    component.addModifiers(PRIVATE, FINAL);\n    addSupertype(\n        component,\n        MoreTypes.asTypeElement(\n            graph.componentDescriptor().builderSpec().isPresent()\n                ? graph.componentDescriptor().builderSpec().get().componentType()\n                : resolvedSubcomponentFactoryMethod().getReturnType()));\n  }\n\n  @Override\n  protected void addBuilder() {\n    // Only write subcomponent builders if there is a spec.\n    if (graph.componentDescriptor().builderSpec().isPresent()) {\n      super.addBuilder();\n    }\n  }\n\n  @Override\n  protected ClassName builderName() {\n    return name.peerClass(subcomponentNames.get(graph.componentDescriptor()) + \"Builder\");\n  }\n\n  @Override\n  protected TypeSpec.Builder createBuilder(String builderSimpleName) {\n    // Only write subcomponent builders if there is a spec.\n    verify(graph.componentDescriptor().builderSpec().isPresent());\n    return classBuilder(builderSimpleName);\n  }\n\n  @Override\n  protected void addBuilderClass(TypeSpec builder) {\n    parent.component.addType(builder);\n  }\n\n  @Override\n  protected void addFactoryMethods() {\n    if (!subcomponentFactoryMethod.isPresent()\n        || !subcomponentFactoryMethod.get().kind().isSubcomponentKind()) {\n      // subcomponent builder methods are implemented in\n      // AbstractComponentWriter.implementInterfaceMethods\n      return;\n    }\n    MethodSpec.Builder componentMethod \u003d\n        methodBuilder(subcomponentFactoryMethod.get().methodElement().getSimpleName().toString())\n            .addModifiers(PUBLIC)\n            .addAnnotation(Override.class);\n    ExecutableType resolvedMethod \u003d resolvedSubcomponentFactoryMethod();\n    componentMethod.returns(ClassName.get(resolvedMethod.getReturnType()));\n    writeSubcomponentWithoutBuilder(componentMethod, resolvedMethod);\n    parent.component.addMethod(componentMethod.build());\n  }\n\n  private void writeSubcomponentWithoutBuilder(\n      MethodSpec.Builder componentMethod, ExecutableType resolvedMethod) {\n    ImmutableList.Builder\u003cCodeBlock\u003e subcomponentConstructorParameters \u003d ImmutableList.builder();\n    List\u003c? extends VariableElement\u003e params \u003d\n        subcomponentFactoryMethod.get().methodElement().getParameters();\n    List\u003c? extends TypeMirror\u003e paramTypes \u003d resolvedMethod.getParameterTypes();\n    for (int i \u003d 0; i \u003c params.size(); i++) {\n      VariableElement moduleVariable \u003d params.get(i);\n      TypeElement moduleTypeElement \u003d MoreTypes.asTypeElement(paramTypes.get(i));\n      TypeName moduleType \u003d TypeName.get(paramTypes.get(i));\n      componentMethod.addParameter(moduleType, moduleVariable.getSimpleName().toString());\n      if (!componentContributionFields.containsKey(moduleTypeElement)) {\n        String preferredModuleName \u003d\n            CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleTypeElement.getSimpleName().toString());\n        FieldSpec contributionField \u003d\n            componentField(ClassName.get(moduleTypeElement), preferredModuleName)\n                .addModifiers(PRIVATE, FINAL)\n                .build();\n        component.addField(contributionField);\n\n        String actualModuleName \u003d contributionField.name;\n        constructor\n            .addParameter(moduleType, actualModuleName)\n            .addStatement(\n                \"this.$1L \u003d $2T.checkNotNull($1L)\",\n                actualModuleName,\n                Preconditions.class);\n\n        MemberSelect moduleSelect \u003d localField(name, actualModuleName);\n        componentContributionFields.put(moduleTypeElement, moduleSelect);\n        subcomponentConstructorParameters.add(\n            CodeBlock.of(\"$L\", moduleVariable.getSimpleName()));\n      }\n    }\n\n    Set\u003cTypeElement\u003e uninitializedModules \u003d\n        difference(graph.componentRequirements(), componentContributionFields.keySet());\n\n    for (TypeElement moduleType : uninitializedModules) {\n      String preferredModuleName \u003d\n          CaseFormat.UPPER_CAMEL.to(LOWER_CAMEL, moduleType.getSimpleName().toString());\n      FieldSpec contributionField \u003d\n          componentField(ClassName.get(moduleType), preferredModuleName)\n              .addModifiers(PRIVATE, FINAL)\n              .build();\n      component.addField(contributionField);\n      String actualModuleName \u003d contributionField.name;\n      constructor.addStatement(\n          \"this.$L \u003d new $T()\", actualModuleName, ClassName.get(moduleType));\n      MemberSelect moduleSelect \u003d localField(name, actualModuleName);\n      componentContributionFields.put(moduleType, moduleSelect);\n    }\n\n    componentMethod.addStatement(\"return new $T($L)\",\n        name, makeParametersCodeBlock(subcomponentConstructorParameters.build()));\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\TypeNames.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.common.base.Optional;\nimport com.google.common.util.concurrent.AsyncFunction;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.ParameterizedTypeName;\nimport com.squareup.javapoet.TypeName;\nimport dagger.Lazy;\nimport dagger.MembersInjector;\nimport dagger.internal.DelegateFactory;\nimport dagger.internal.DoubleCheck;\nimport dagger.internal.Factory;\nimport dagger.internal.InstanceFactory;\nimport dagger.internal.MapFactory;\nimport dagger.internal.MapProviderFactory;\nimport dagger.internal.MembersInjectors;\nimport dagger.internal.ProviderOfLazy;\nimport dagger.internal.SetFactory;\nimport dagger.internal.SingleCheck;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport dagger.producers.internal.AbstractProducer;\nimport dagger.producers.internal.MapOfProducedProducer;\nimport dagger.producers.internal.MapOfProducerProducer;\nimport dagger.producers.internal.MapProducer;\nimport dagger.producers.internal.Producers;\nimport dagger.producers.internal.SetOfProducedProducer;\nimport dagger.producers.internal.SetProducer;\nimport dagger.producers.monitoring.ProducerToken;\nimport dagger.producers.monitoring.ProductionComponentMonitor;\nimport java.util.List;\nimport java.util.Set;\nimport javax.inject.Provider;\n\n/**\n * Common names and convenience methods for JavaPoet {@link TypeName} usage.\n */\nfinal class TypeNames {\n\n  static final ClassName ABSTRACT_PRODUCER \u003d ClassName.get(AbstractProducer.class);\n  static final ClassName ASYNC_FUNCTION \u003d ClassName.get(AsyncFunction.class);\n  static final ClassName DELEGATE_FACTORY \u003d ClassName.get(DelegateFactory.class);\n  static final ClassName DOUBLE_CHECK \u003d ClassName.get(DoubleCheck.class);\n  static final ClassName FACTORY \u003d ClassName.get(Factory.class);\n  static final ClassName FUTURES \u003d ClassName.get(Futures.class);\n  static final ClassName ILLEGAL_STATE_EXCEPTION \u003d ClassName.get(IllegalStateException.class);\n  static final ClassName INSTANCE_FACTORY \u003d ClassName.get(InstanceFactory.class);\n  static final ClassName LAZY \u003d ClassName.get(Lazy.class);\n  static final ClassName LIST \u003d ClassName.get(List.class);\n  static final ClassName LISTENABLE_FUTURE \u003d ClassName.get(ListenableFuture.class);\n  static final ClassName MAP_FACTORY \u003d ClassName.get(MapFactory.class);\n  static final ClassName MAP_OF_PRODUCED_PRODUCER \u003d ClassName.get(MapOfProducedProducer.class);\n  static final ClassName MAP_OF_PRODUCER_PRODUCER \u003d ClassName.get(MapOfProducerProducer.class);\n  static final ClassName MAP_PRODUCER \u003d ClassName.get(MapProducer.class);\n  static final ClassName MAP_PROVIDER_FACTORY \u003d ClassName.get(MapProviderFactory.class);\n  static final ClassName MEMBERS_INJECTOR \u003d ClassName.get(MembersInjector.class);\n  static final ClassName MEMBERS_INJECTORS \u003d ClassName.get(MembersInjectors.class);\n  static final ClassName OPTIONAL \u003d ClassName.get(Optional.class);\n  static final ClassName PRODUCER_TOKEN \u003d ClassName.get(ProducerToken.class);\n  static final ClassName PRODUCED \u003d ClassName.get(Produced.class);\n  static final ClassName PRODUCER \u003d ClassName.get(Producer.class);\n  static final ClassName PRODUCERS \u003d ClassName.get(Producers.class);\n  static final ClassName PRODUCTION_COMPONENT_MONITOR_FACTORY \u003d\n      ClassName.get(ProductionComponentMonitor.Factory.class);\n  static final ClassName PROVIDER \u003d ClassName.get(Provider.class);\n  static final ClassName PROVIDER_OF_LAZY \u003d ClassName.get(ProviderOfLazy.class);\n\n  static final ClassName SET \u003d ClassName.get(Set.class);\n  static final ClassName SET_FACTORY \u003d ClassName.get(SetFactory.class);\n  static final ClassName SET_OF_PRODUCED_PRODUCER \u003d ClassName.get(SetOfProducedProducer.class);\n  static final ClassName SET_PRODUCER \u003d ClassName.get(SetProducer.class);\n  static final ClassName SINGLE_CHECK \u003d ClassName.get(SingleCheck.class);\n  static final ClassName STRING \u003d ClassName.get(String.class);\n\n  static final ClassName UNSUPPORTED_OPERATION_EXCEPTION \u003d\n      ClassName.get(UnsupportedOperationException.class);\n\n  /**\n   * {@link TypeName#VOID} is lowercase-v {@code void} whereas this represents the class, {@link\n   * Void}.\n   */\n  static final ClassName VOID_CLASS \u003d ClassName.get(Void.class);\n\n  static ParameterizedTypeName abstractProducerOf(TypeName typeName) {\n    return ParameterizedTypeName.get(ABSTRACT_PRODUCER, typeName);\n  }\n\n  static ParameterizedTypeName factoryOf(TypeName factoryType) {\n    return ParameterizedTypeName.get(FACTORY, factoryType);\n  }\n\n  static ParameterizedTypeName lazyOf(TypeName typeName) {\n    return ParameterizedTypeName.get(LAZY, typeName);\n  }\n\n  static ParameterizedTypeName listOf(TypeName typeName) {\n    return ParameterizedTypeName.get(LIST, typeName);\n  }\n\n  static ParameterizedTypeName listenableFutureOf(TypeName typeName) {\n    return ParameterizedTypeName.get(LISTENABLE_FUTURE, typeName);\n  }\n\n  static ParameterizedTypeName membersInjectorOf(TypeName membersInjectorType) {\n    return ParameterizedTypeName.get(MEMBERS_INJECTOR, membersInjectorType);\n  }\n\n  static ParameterizedTypeName optionalOf(TypeName type) {\n    return ParameterizedTypeName.get(OPTIONAL, type);\n  }\n\n  static ParameterizedTypeName producedOf(TypeName typeName) {\n    return ParameterizedTypeName.get(PRODUCED, typeName);\n  }\n\n  static ParameterizedTypeName producerOf(TypeName typeName) {\n    return ParameterizedTypeName.get(PRODUCER, typeName);\n  }\n\n  static ParameterizedTypeName providerOf(TypeName typeName) {\n    return ParameterizedTypeName.get(PROVIDER, typeName);\n  }\n\n  static ParameterizedTypeName setOf(TypeName elementType) {\n    return ParameterizedTypeName.get(SET, elementType);\n  }\n\n  private TypeNames() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\TypeSpecs.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.TypeSpec;\nimport javax.lang.model.element.TypeElement;\n\n/**\n * Convenience methods for use with JavaPoet\u0027s {@link TypeSpec}.\n */\nfinal class TypeSpecs {\n\n  /**\n   * If {@code supertype} is a class, adds it as a superclass for {@code typeBuilder}; if it is an\n   * interface, adds it as a superinterface.\n   *\n   * @return {@code typeBuilder}\n   */\n  @CanIgnoreReturnValue\n  static TypeSpec.Builder addSupertype(TypeSpec.Builder typeBuilder, TypeElement supertype) {\n    switch (supertype.getKind()) {\n      case CLASS:\n        return typeBuilder.superclass(ClassName.get(supertype));\n      case INTERFACE:\n        return typeBuilder.addSuperinterface(ClassName.get(supertype));\n      default:\n        throw new AssertionError(supertype + \" is neither a class nor an interface.\");\n    }\n  }\n\n  private TypeSpecs() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\UniqueNameSet.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * A collector for names to be used in the same namespace that should not conflict.\n */\nfinal class UniqueNameSet {\n  private final Set\u003cString\u003e uniqueNames \u003d new HashSet\u003c\u003e();\n\n  /**\n   * Generates a unique name using {@code base}. If {@code base} has not yet been added, it will be\n   * returned as-is. If your {@code base} is healthy, this will always return {@code base}.\n   */\n  String getUniqueName(CharSequence base) {\n    String name \u003d base.toString();\n    for (int differentiator \u003d 2; !uniqueNames.add(name); differentiator++) {\n      name \u003d base.toString() + differentiator;\n    }\n    return name;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\UnwrappedMapKeyGenerator.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport dagger.MapKey;\nimport java.util.Set;\nimport javax.annotation.processing.Filer;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.util.Elements;\n\n/**\n * Generates classes that create annotation instances for an unwrapped {@link MapKey} annotation\n * type whose nested value is an annotation. The generated class will have a private empty\n * constructor and a static method that creates each annotation type that is nested in the top-level\n * annotation type.\n *\n * \u003cp\u003eSo for an example {@link MapKey} annotation:\n *\n * \u003cpre\u003e\n *   {@literal @MapKey}(unwrapValue \u003d true)\n *   {@literal @interface} Foo {\n *     Bar bar();\n *   }\n *\n *   {@literal @interface} Bar {\n *     Class\u003c?\u003e baz();\n *   }\n * \u003c/pre\u003e\n *\n * the generated class will look like:\n *\n * \u003cpre\u003e\n *   public final class FooCreator {\n *     private FooCreator() {}\n *\n *     public static Bar createBar(Class\u003c?\u003e baz) { … }\n *   }\n * \u003c/pre\u003e\n */\nfinal class UnwrappedMapKeyGenerator extends AnnotationCreatorGenerator {\n\n  UnwrappedMapKeyGenerator(Filer filer, Elements elements) {\n    super(filer, elements);\n  }\n\n  @Override\n  protected Set\u003cTypeElement\u003e annotationsToCreate(TypeElement annotationElement) {\n    Set\u003cTypeElement\u003e nestedAnnotationElements \u003d super.annotationsToCreate(annotationElement);\n    nestedAnnotationElements.remove(annotationElement);\n    return nestedAnnotationElements;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\Util.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.auto.common.MoreElements.getLocalAndInheritedMethods;\nimport static com.google.auto.common.MoreElements.hasModifiers;\nimport static com.google.auto.common.MoreTypes.asDeclared;\nimport static com.google.common.collect.Lists.asList;\nimport static javax.lang.model.element.ElementKind.CONSTRUCTOR;\nimport static javax.lang.model.element.Modifier.ABSTRACT;\nimport static javax.lang.model.element.Modifier.PRIVATE;\nimport static javax.lang.model.element.Modifier.STATIC;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.base.Function;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableSet;\nimport dagger.Binds;\nimport dagger.Provides;\nimport dagger.producers.Produces;\nimport java.lang.annotation.Annotation;\nimport java.util.Comparator;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ElementVisitor;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.SimpleElementVisitor6;\n\n/**\n * Utilities for handling types in annotation processors\n */\nfinal class Util {\n  /**\n   * Returns true if the passed {@link TypeElement} requires a passed instance in order to be used\n   * within a component.\n   */\n  static boolean requiresAPassedInstance(Elements elements, TypeElement typeElement) {\n    ImmutableSet\u003cExecutableElement\u003e methods \u003d\n        MoreElements.getLocalAndInheritedMethods(typeElement, elements);\n    boolean foundInstanceMethod \u003d false;\n    for (ExecutableElement method : methods) {\n      if (method.getModifiers().contains(ABSTRACT)\n          \u0026\u0026 !MoreElements.isAnnotationPresent(method, Binds.class)) {\n        /* We found an abstract method that isn\u0027t a @Binds method.  That automatically means that\n         * a user will have to provide an instance because we don\u0027t know which subclass to use. */\n        return true;\n      } else if (!method.getModifiers().contains(STATIC)\n          \u0026\u0026 isAnyAnnotationPresent(method, Provides.class, Produces.class)) {\n        foundInstanceMethod \u003d true;\n      }\n    }\n\n    if (foundInstanceMethod) {\n      return !componentCanMakeNewInstances(typeElement);\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns true if and only if a component can instantiate new instances (typically of a module)\n   * rather than requiring that they be passed.\n   */\n  static boolean componentCanMakeNewInstances(TypeElement typeElement) {\n    switch (typeElement.getKind()) {\n      case CLASS:\n        break;\n      case ENUM:\n      case ANNOTATION_TYPE:\n      case INTERFACE:\n        return false;\n      default:\n        throw new AssertionError(\"TypeElement cannot have kind: \" + typeElement.getKind());\n    }\n\n    if (typeElement.getModifiers().contains(ABSTRACT)) {\n      return false;\n    }\n\n    if (requiresEnclosingInstance(typeElement)) {\n      return false;\n    }\n\n    for (Element enclosed : typeElement.getEnclosedElements()) {\n      if (enclosed.getKind().equals(CONSTRUCTOR)\n          \u0026\u0026 ((ExecutableElement) enclosed).getParameters().isEmpty()\n          \u0026\u0026 !enclosed.getModifiers().contains(PRIVATE)) {\n        return true;\n      }\n    }\n\n    // TODO(gak): still need checks for visibility\n\n    return false;\n  }\n\n  private static boolean requiresEnclosingInstance(TypeElement typeElement) {\n    switch (typeElement.getNestingKind()) {\n      case TOP_LEVEL:\n        return false;\n      case MEMBER:\n        return !typeElement.getModifiers().contains(STATIC);\n      case ANONYMOUS:\n      case LOCAL:\n        return true;\n      default:\n        throw new AssertionError(\n            \"TypeElement cannot have nesting kind: \" + typeElement.getNestingKind());\n    }\n  }\n\n  static ImmutableSet\u003cExecutableElement\u003e getUnimplementedMethods(\n      Elements elements, TypeElement type) {\n    return FluentIterable.from(getLocalAndInheritedMethods(type, elements))\n        .filter(hasModifiers(ABSTRACT))\n        .toSet();\n  }\n\n  /** A function that returns the input as a {@link DeclaredType}. */\n  static final Function\u003cTypeElement, DeclaredType\u003e AS_DECLARED_TYPE \u003d\n      typeElement -\u003e asDeclared(typeElement.asType());\n\n  /**\n   * A visitor that returns the input or the closest enclosing element that is a\n   * {@link TypeElement}.\n   */\n  static final ElementVisitor\u003cTypeElement, Void\u003e ENCLOSING_TYPE_ELEMENT \u003d\n      new SimpleElementVisitor6\u003cTypeElement, Void\u003e() {\n        @Override\n        protected TypeElement defaultAction(Element e, Void p) {\n          return visit(e.getEnclosingElement());\n        }\n\n        @Override\n        public TypeElement visitType(TypeElement e, Void p) {\n          return e;\n        }\n      };\n\n  /**\n   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose\n   * {@linkplain AnnotationMirror#getAnnotationType() annotation type} has the same canonical name\n   * as any of that of {@code annotationClasses}.\n   */\n  // TODO(dpb): Move to MoreElements.\n  static boolean isAnyAnnotationPresent(\n      Element element, Iterable\u003c? extends Class\u003c? extends Annotation\u003e\u003e annotationClasses) {\n    for (Class\u003c? extends Annotation\u003e annotation : annotationClasses) {\n      if (MoreElements.isAnnotationPresent(element, annotation)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  @SafeVarargs\n  static boolean isAnyAnnotationPresent(\n      Element element,\n      Class\u003c? extends Annotation\u003e first,\n      Class\u003c? extends Annotation\u003e... otherAnnotations) {\n    return isAnyAnnotationPresent(element, asList(first, otherAnnotations));\n  }\n\n  /**\n   * Returns {@code true} iff the given element has an {@link AnnotationMirror} whose {@linkplain\n   * AnnotationMirror#getAnnotationType() annotation type} is equivalent to {@code annotationType}.\n   */\n  // TODO(dpb): Move to MoreElements.\n  static boolean isAnnotationPresent(Element element, TypeMirror annotationType) {\n    return element\n        .getAnnotationMirrors()\n        .stream()\n        .map(AnnotationMirror::getAnnotationType)\n        .anyMatch(candidate -\u003e MoreTypes.equivalence().equivalent(candidate, annotationType));\n  }\n\n  /**\n   * The elements in {@code elements} that are annotated with an annotation of type\n   * {@code annotation}.\n   */\n  static \u003cE extends Element\u003e FluentIterable\u003cE\u003e elementsWithAnnotation(\n      Iterable\u003cE\u003e elements, final Class\u003c? extends Annotation\u003e annotation) {\n    return FluentIterable.from(elements)\n        .filter(element -\u003e MoreElements.isAnnotationPresent(element, annotation));\n  }\n\n  /** A function that returns the simple name of an element. */\n  static final Function\u003cElement, String\u003e ELEMENT_SIMPLE_NAME \u003d\n      element -\u003e element.getSimpleName().toString();\n\n  /**\n   * A {@link Comparator} that puts absent {@link Optional}s before present ones, and compares\n   * present {@link Optional}s by their values.\n   */\n  static \u003cC extends Comparable\u003cC\u003e\u003e Comparator\u003cOptional\u003cC\u003e\u003e optionalComparator() {\n    return Comparator.comparing((Optional\u003cC\u003e optional) -\u003e optional.isPresent())\n        .thenComparing(Optional::get);\n  }\n\n  private Util() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ValidationReport.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static javax.tools.Diagnostic.Kind.ERROR;\nimport static javax.tools.Diagnostic.Kind.NOTE;\nimport static javax.tools.Diagnostic.Kind.WARNING;\n\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport javax.annotation.CheckReturnValue;\nimport javax.annotation.processing.Messager;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.util.SimpleElementVisitor6;\nimport javax.tools.Diagnostic;\nimport javax.tools.Diagnostic.Kind;\n\n/**\n * A collection of items describing contractual issues with the code as presented to an annotation\n * processor.  A \"clean\" report (i.e. with no issues) is a report with no {@linkplain Item items}\n * and clean subreports. Callers will typically print the results of the report to a\n * {@link Messager} instance using {@link #printMessagesTo}.\n *\n * \u003cp\u003eA report describes a subject {@link Element}.  Callers may choose to add report items about\n * other elements that are contained within or related to the subject. Since {@link Diagnostic}\n * reporting is expected to be associated with elements that are currently being compiled,\n * {@link #printMessagesTo(Messager)} will only associate messages with non-subject elements if they\n * are contained within the subject. Otherwise, they will be associated with the subject and contain\n * a reference to the item\u0027s element in the message string. It is the responsibility of the caller\n * to choose subjects that are part of the compilation.\n *\n * @author Gregory Kick\n * @since 2.0\n */\n@AutoValue\nabstract class ValidationReport\u003cT extends Element\u003e {\n  abstract T subject();\n  abstract ImmutableSet\u003cItem\u003e items();\n  abstract ImmutableSet\u003cValidationReport\u003c?\u003e\u003e subreports();\n\n  boolean isClean() {\n    for (Item item : items()) {\n      switch (item.kind()) {\n        case ERROR:\n          return false;\n        default:\n          break;\n      }\n    }\n    for (ValidationReport\u003c?\u003e subreport : subreports()) {\n      if (!subreport.isClean()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  void printMessagesTo(Messager messager) {\n    for (Item item : items()) {\n      if (isEnclosedIn(subject(), item.element())) {\n        if (item.annotation().isPresent()) {\n          messager.printMessage(\n              item.kind(), item.message(), item.element(), item.annotation().get());\n        } else {\n          messager.printMessage(item.kind(), item.message(), item.element());\n        }\n      } else {\n        String message \u003d String.format(\"[%s] %s\", elementString(item.element()), item.message());\n        if (item.annotation().isPresent()) {\n          messager.printMessage(item.kind(), message, subject(), item.annotation().get());\n        } else {\n          messager.printMessage(item.kind(), message, subject());\n        }\n      }\n    }\n    for (ValidationReport\u003c?\u003e subreport : subreports()) {\n      subreport.printMessagesTo(messager);\n    }\n  }\n\n  private static String elementString(Element element) {\n    return element.accept(\n        new SimpleElementVisitor6\u003cString, Void\u003e() {\n          @Override\n          protected String defaultAction(Element e, Void p) {\n            return e.toString();\n          }\n\n          @Override\n          public String visitExecutable(ExecutableElement e, Void p) {\n            return e.getEnclosingElement().accept(this, null) + \u0027.\u0027 + e.toString();\n          }\n        },\n        null);\n  }\n\n  private static boolean isEnclosedIn(Element parent, Element child) {\n    Element current \u003d child;\n    while (current !\u003d null) {\n      if (current.equals(parent)) {\n        return true;\n      }\n      current \u003d current.getEnclosingElement();\n    }\n    return false;\n  }\n\n  @AutoValue\n  static abstract class Item {\n    abstract String message();\n    abstract Kind kind();\n    abstract Element element();\n    abstract Optional\u003cAnnotationMirror\u003e annotation();\n  }\n\n  static \u003cT extends Element\u003e Builder\u003cT\u003e about(T subject) {\n    return new Builder\u003c\u003e(subject);\n  }\n\n  @CanIgnoreReturnValue\n  static final class Builder\u003cT extends Element\u003e {\n    private final T subject;\n    private final ImmutableSet.Builder\u003cItem\u003e items \u003d ImmutableSet.builder();\n    private final ImmutableSet.Builder\u003cValidationReport\u003c?\u003e\u003e subreports \u003d ImmutableSet.builder();\n\n    private Builder(T subject) {\n      this.subject \u003d subject;\n    }\n\n    @CheckReturnValue\n    T getSubject() {\n      return subject;\n    }\n\n    Builder\u003cT\u003e addItems(Iterable\u003cItem\u003e newItems) {\n      items.addAll(newItems);\n      return this;\n    }\n\n    Builder\u003cT\u003e addError(String message) {\n      return addItem(message, ERROR, subject, Optional.\u003cAnnotationMirror\u003eabsent());\n    }\n\n    Builder\u003cT\u003e addError(String message, Element element) {\n      return addItem(message, ERROR, element, Optional.\u003cAnnotationMirror\u003eabsent());\n    }\n\n    Builder\u003cT\u003e addError(String message, Element element, AnnotationMirror annotation) {\n      return addItem(message, ERROR, element, Optional.of(annotation));\n    }\n\n    Builder\u003cT\u003e addWarning(String message) {\n      return addItem(message, WARNING, subject, Optional.\u003cAnnotationMirror\u003eabsent());\n    }\n\n    Builder\u003cT\u003e addWarning(String message, Element element) {\n      return addItem(message, WARNING, element, Optional.\u003cAnnotationMirror\u003eabsent());\n    }\n\n    Builder\u003cT\u003e addWarning(String message, Element element, AnnotationMirror annotation) {\n      return addItem(message, WARNING, element, Optional.of(annotation));\n    }\n\n    Builder\u003cT\u003e addNote(String message) {\n      return addItem(message, NOTE, subject, Optional.\u003cAnnotationMirror\u003eabsent());\n    }\n\n    Builder\u003cT\u003e addNote(String message, Element element) {\n      return addItem(message, NOTE, element, Optional.\u003cAnnotationMirror\u003eabsent());\n    }\n\n    Builder\u003cT\u003e addNote(String message, Element element, AnnotationMirror annotation) {\n      return addItem(message, NOTE, element, Optional.of(annotation));\n    }\n\n    Builder\u003cT\u003e addItem(String message, Kind kind, Element element) {\n      return addItem(message, kind, element, Optional.\u003cAnnotationMirror\u003eabsent());\n    }\n\n    Builder\u003cT\u003e addItem(String message, Kind kind, Element element, AnnotationMirror annotation) {\n      return addItem(message, kind, element, Optional.of(annotation));\n    }\n\n    private Builder\u003cT\u003e addItem(String message, Kind kind, Element element,\n        Optional\u003cAnnotationMirror\u003e annotation) {\n      items.add(new AutoValue_ValidationReport_Item(message, kind, element, annotation));\n      return this;\n    }\n\n    Builder\u003cT\u003e addSubreport(ValidationReport\u003c?\u003e subreport) {\n      subreports.add(subreport);\n      return this;\n    }\n\n    @CheckReturnValue\n    ValidationReport\u003cT\u003e build() {\n      return new AutoValue_ValidationReport\u003c\u003e(subject, items.build(), subreports.build());\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\main\\java\\dagger\\internal\\codegen\\ValidationType.java",
    "code": "\"/*\n* Copyright (C) 2015 The Dagger Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\npackage dagger.internal.codegen;\n\nimport com.google.common.base.Optional;\nimport javax.tools.Diagnostic;\n\n/**\n * Allows options to control how component process validates things such as scope cycles\n * or nullability.\n */\nenum ValidationType {\n  ERROR,\n  WARNING,\n  NONE;\n\n  Optional\u003cDiagnostic.Kind\u003e diagnosticKind() {\n    switch (this) {\n      case ERROR:\n        return Optional.of(Diagnostic.Kind.ERROR);\n      case WARNING:\n        return Optional.of(Diagnostic.Kind.WARNING);\n      default:\n        return Optional.absent();\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\AccessibilityTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static dagger.internal.codegen.Accessibility.isElementAccessibleFrom;\n\nimport com.google.testing.compile.CompilationRule;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.util.Elements;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\n@SuppressWarnings(\"unused\") // contains a variety things used by the compilation rule for testing\npublic class AccessibilityTest {\n  /* test data */\n  public AccessibilityTest() {}\n  protected AccessibilityTest(Object o) {}\n  AccessibilityTest(Object o1, Object o2) {}\n  private AccessibilityTest(Object o1, Object o2, Object o3) {}\n\n  public String publicField;\n  protected String protectedField;\n  String packagePrivateField;\n  private String privateField;\n\n  public void publicMethod() {}\n  protected void protectedMethod() {}\n  void packagePrivateMethod() {}\n  private void privateMethod() {}\n\n  public static final class PublicNestedClass {}\n  protected static final class ProtectedNestedClass {}\n  static final class PackagePrivateNestedClass {}\n  private static final class PrivateNestedClass {}\n\n  @Rule\n  public final CompilationRule compilationRule \u003d new CompilationRule();\n\n  private TypeElement testElement;\n\n  @Before\n  public void setUp() {\n    Elements elements \u003d compilationRule.getElements();\n    testElement \u003d elements.getTypeElement(AccessibilityTest.class.getCanonicalName());\n  }\n\n  @Test\n  public void isElementAccessibleFrom_publicType() {\n    assertThat(isElementAccessibleFrom(testElement, \"literally.anything\")).isTrue();\n  }\n\n  @Test\n  public void isElementAccessibleFrom_publicMethod() {\n    Element member \u003d getMemberNamed(\"publicMethod\");\n    assertThat(isElementAccessibleFrom(member, \"literally.anything\")).isTrue();\n  }\n\n  @Test\n  public void isElementAccessibleFrom_protectedMethod() {\n    Element member \u003d getMemberNamed(\"protectedMethod\");\n    assertThat(isElementAccessibleFrom(member, \"dagger.internal.codegen\")).isTrue();\n    assertThat(isElementAccessibleFrom(member, \"not.dagger.internal.codegen\")).isFalse();\n  }\n\n  @Test\n  public void isElementAccessibleFrom_packagePrivateMethod() {\n    Element member \u003d getMemberNamed(\"packagePrivateMethod\");\n    assertThat(isElementAccessibleFrom(member, \"dagger.internal.codegen\")).isTrue();\n    assertThat(isElementAccessibleFrom(member, \"not.dagger.internal.codegen\")).isFalse();\n  }\n\n  @Test\n  public void isElementAccessibleFrom_privateMethod() {\n    Element member \u003d getMemberNamed( \"privateMethod\");\n    assertThat(isElementAccessibleFrom(member, \"dagger.internal.codegen\")).isFalse();\n    assertThat(isElementAccessibleFrom(member, \"not.dagger.internal.codegen\")).isFalse();\n  }\n\n  @Test\n  public void isElementAccessibleFrom_publicField() {\n    Element member \u003d getMemberNamed(\"publicField\");\n    assertThat(isElementAccessibleFrom(member, \"literally.anything\")).isTrue();\n  }\n\n  @Test\n  public void isElementAccessibleFrom_protectedField() {\n    Element member \u003d getMemberNamed(\"protectedField\");\n    assertThat(isElementAccessibleFrom(member, \"dagger.internal.codegen\")).isTrue();\n    assertThat(isElementAccessibleFrom(member, \"not.dagger.internal.codegen\")).isFalse();\n  }\n\n  @Test\n  public void isElementAccessibleFrom_packagePrivateField() {\n    Element member \u003d getMemberNamed(\"packagePrivateField\");\n    assertThat(isElementAccessibleFrom(member, \"dagger.internal.codegen\")).isTrue();\n    assertThat(isElementAccessibleFrom(member, \"not.dagger.internal.codegen\")).isFalse();\n  }\n\n  @Test\n  public void isElementAccessibleFrom_privateField() {\n    Element member \u003d getMemberNamed(\"privateField\");\n    assertThat(isElementAccessibleFrom(member, \"dagger.internal.codegen\")).isFalse();\n    assertThat(isElementAccessibleFrom(member, \"not.dagger.internal.codegen\")).isFalse();\n  }\n\n  private Element getMemberNamed(String memberName) {\n    for (Element enclosedElement : testElement.getEnclosedElements()) {\n      if (enclosedElement.getSimpleName().contentEquals(memberName)) {\n        return enclosedElement;\n      }\n    }\n    throw new IllegalArgumentException();\n  }\n}\n\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\BindingTypeMapperTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static dagger.internal.codegen.BindingType.MEMBERS_INJECTION;\nimport static dagger.internal.codegen.BindingType.PRODUCTION;\nimport static dagger.internal.codegen.BindingType.PROVISION;\nimport static dagger.internal.codegen.DependencyRequest.Kind.INSTANCE;\nimport static dagger.internal.codegen.DependencyRequest.Kind.LAZY;\nimport static dagger.internal.codegen.DependencyRequest.Kind.MEMBERS_INJECTOR;\nimport static dagger.internal.codegen.DependencyRequest.Kind.PRODUCED;\nimport static dagger.internal.codegen.DependencyRequest.Kind.PRODUCER;\nimport static dagger.internal.codegen.DependencyRequest.Kind.PROVIDER;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/**\n * Test case for {@link BindingTypeMapper}.\n */\n@RunWith(JUnit4.class)\npublic class BindingTypeMapperTest {\n  @Test public void forProvider() {\n    BindingTypeMapper mapper \u003d BindingTypeMapper.FOR_PROVIDER;\n    assertThat(mapper.getBindingType(INSTANCE))\n        .isEqualTo(PROVISION);\n    assertThat(mapper.getBindingType(LAZY))\n        .isEqualTo(PROVISION);\n    assertThat(mapper.getBindingType(PROVIDER))\n        .isEqualTo(PROVISION);\n    assertThat(mapper.getBindingType(MEMBERS_INJECTOR))\n        .isEqualTo(MEMBERS_INJECTION);\n  }\n\n  @Test public void forProducer() {\n    BindingTypeMapper mapper \u003d BindingTypeMapper.FOR_PRODUCER;\n    assertThat(mapper.getBindingType(INSTANCE))\n        .isEqualTo(PRODUCTION);\n    assertThat(mapper.getBindingType(LAZY))\n        .isEqualTo(PROVISION);\n    assertThat(mapper.getBindingType(PROVIDER))\n        .isEqualTo(PROVISION);\n    assertThat(mapper.getBindingType(MEMBERS_INJECTOR))\n        .isEqualTo(MEMBERS_INJECTION);\n    assertThat(mapper.getBindingType(PRODUCER))\n        .isEqualTo(PRODUCTION);\n    assertThat(mapper.getBindingType(PRODUCED))\n        .isEqualTo(PRODUCTION);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\BindsMethodValidatorTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;\nimport static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;\n\nimport com.google.common.collect.ImmutableList;\nimport dagger.Module;\nimport dagger.multibindings.IntKey;\nimport dagger.multibindings.LongKey;\nimport dagger.producers.ProducerModule;\nimport java.io.IOException;\nimport java.lang.annotation.Annotation;\nimport java.util.Collection;\nimport javax.inject.Qualifier;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\n\n@RunWith(Parameterized.class)\npublic class BindsMethodValidatorTest {\n  @Parameters\n  public static Collection\u003cObject[]\u003e data() {\n    return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});\n  }\n\n  private final String moduleDeclaration;\n\n  public BindsMethodValidatorTest(Class\u003c? extends Annotation\u003e moduleAnnotation) {\n    moduleDeclaration \u003d \"@\" + moduleAnnotation.getCanonicalName() + \" abstract class %s { %s }\";\n  }\n\n  @Test\n  public void nonAbstract() {\n    assertThatMethod(\"@Binds Object concrete(String impl) { return null; }\")\n        .hasError(\"must be abstract\");\n  }\n\n  @Test\n  public void notAssignable() {\n    assertThatMethod(\"@Binds abstract String notAssignable(Object impl);\").hasError(\"assignable\");\n  }\n  \n  @Test\n  public void moreThanOneParameter() {\n    assertThatMethod(\"@Binds abstract Object tooManyParameters(String s1, String s2);\")\n        .hasError(\"one parameter\");\n  }\n\n  @Test\n  public void typeParameters() {\n    assertThatMethod(\"@Binds abstract \u003cS, T extends S\u003e S generic(T t);\")\n        .hasError(\"type parameters\");\n  }\n\n  @Test\n  public void notInModule() {\n    assertThatMethodInUnannotatedClass(\"@Binds abstract Object bindObject(String s);\")\n        .hasError(\"within a @Module or @ProducerModule\");\n  }\n\n  @Test\n  public void throwsException() {\n    assertThatMethod(\"@Binds abstract Object throwsException(String s1) throws IOException;\")\n        .importing(IOException.class)\n        .hasError(\"only throw unchecked\");\n  }\n\n  @Test\n  @Ignore(\"TODO: @Binds methods do not check explicitly for void\")\n  public void returnsVoid() {\n    assertThatMethod(\"@Binds abstract void returnsVoid(Object impl);\").hasError(\"void\");\n  }\n\n  @Test\n  public void tooManyQualifiers() {\n    assertThatMethod(\n            \"@Binds @Qualifier1 @Qualifier2 abstract String tooManyQualifiers(String impl);\")\n        .importing(Qualifier1.class, Qualifier2.class)\n        .hasError(\"more than one @Qualifier\");\n  }\n\n  @Test\n  public void noParameters() {\n    assertThatMethod(\"@Binds abstract Object noParameters();\").hasError(\"one parameter\");\n  }\n\n  @Test\n  public void setElementsNotAssignable() {\n    assertThatMethod(\n            \"@Binds @ElementsIntoSet abstract Set\u003cString\u003e bindSetOfIntegers(Set\u003cInteger\u003e ints);\")\n        .hasError(\"assignable\");\n  }\n\n  @Test\n  public void setElements_primitiveArgument() {\n    assertThatMethod(\"@Binds @ElementsIntoSet abstract Set\u003cNumber\u003e bindInt(int integer);\")\n        .hasError(\"assignable\");\n  }\n\n  @Test\n  public void elementsIntoSet_withRawSets() {\n    assertThatMethod(\"@Binds @ElementsIntoSet abstract Set bindRawSet(HashSet hashSet);\")\n        .hasError(\"cannot return a raw Set\");\n  }\n\n  @Test\n  public void intoMap_noMapKey() {\n    assertThatMethod(\"@Binds @IntoMap abstract Object bindNoMapKey(String string);\")\n         .hasError(\"methods of type map must declare a map key\");\n  }\n\n  @Test\n  public void intoMap_multipleMapKeys() {\n    assertThatMethod(\n            \"@Binds @IntoMap @IntKey(1) @LongKey(2L) abstract Object manyMapKeys(String string);\")\n        .importing(IntKey.class, LongKey.class)\n        .hasError(\"may not have more than one @MapKey-marked annotation\");\n  }\n\n  private DaggerModuleMethodSubject assertThatMethod(String method) {\n    return assertThatModuleMethod(method).withDeclaration(moduleDeclaration);\n  }\n\n  @Qualifier\n  public @interface Qualifier1 {}\n\n  @Qualifier\n  public @interface Qualifier2 {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\BindsOptionalOfMethodValidatorTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;\nimport static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;\n\nimport com.google.common.collect.ImmutableList;\nimport dagger.Module;\nimport dagger.producers.ProducerModule;\nimport java.lang.annotation.Annotation;\nimport java.util.Collection;\nimport javax.inject.Inject;\nimport javax.inject.Qualifier;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\n\n/** Tests {@link BindsOptionalOfMethodValidator}. */\n@RunWith(Parameterized.class)\npublic class BindsOptionalOfMethodValidatorTest {\n  @Parameters(name \u003d \"{0}\")\n  public static Collection\u003cObject[]\u003e data() {\n    return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});\n  }\n\n  private final String moduleDeclaration;\n\n  public BindsOptionalOfMethodValidatorTest(Class\u003c? extends Annotation\u003e moduleAnnotation) {\n    moduleDeclaration \u003d \"@\" + moduleAnnotation.getCanonicalName() + \" abstract class %s { %s }\";\n  }\n\n  @Test\n  public void nonAbstract() {\n    assertThatMethod(\"@BindsOptionalOf Object concrete() { return null; }\")\n        .hasError(\"must be abstract\");\n  }\n\n  @Test\n  public void hasParameters() {\n    assertThatMethod(\"@BindsOptionalOf abstract Object hasParameters(String s1);\")\n        .hasError(\"parameters\");\n  }\n\n  @Test\n  public void typeParameters() {\n    assertThatMethod(\"@BindsOptionalOf abstract \u003cS\u003e S generic();\").hasError(\"type parameters\");\n  }\n\n  @Test\n  public void notInModule() {\n    assertThatMethodInUnannotatedClass(\"@BindsOptionalOf abstract Object notInModule();\")\n        .hasError(\"within a @Module or @ProducerModule\");\n  }\n\n  @Test\n  public void throwsException() {\n    assertThatMethod(\"@BindsOptionalOf abstract Object throwsException() throws RuntimeException;\")\n        .hasError(\"may not throw\");\n  }\n\n  @Test\n  public void returnsVoid() {\n    assertThatMethod(\"@BindsOptionalOf abstract void returnsVoid();\").hasError(\"void\");\n  }\n\n  @Test\n  public void returnsMembersInjector() {\n    assertThatMethod(\"@BindsOptionalOf abstract MembersInjector\u003cObject\u003e returnsMembersInjector();\")\n        .hasError(\"framework\");\n  }\n\n  @Test\n  public void tooManyQualifiers() {\n    assertThatMethod(\n            \"@BindsOptionalOf @Qualifier1 @Qualifier2 abstract String tooManyQualifiers();\")\n        .importing(Qualifier1.class, Qualifier2.class)\n        .hasError(\"more than one @Qualifier\");\n  }\n\n  @Test\n  public void intoSet() {\n    assertThatMethod(\"@BindsOptionalOf @IntoSet abstract String intoSet();\")\n        .hasError(\"Multibinding annotations\");\n  }\n\n  @Test\n  public void elementsIntoSet() {\n    assertThatMethod(\"@BindsOptionalOf @ElementsIntoSet abstract Set\u003cString\u003e elementsIntoSet();\")\n        .hasError(\"Multibinding annotations\");\n  }\n\n  @Test\n  public void intoMap() {\n    assertThatMethod(\"@BindsOptionalOf @IntoMap abstract String intoMap();\")\n        .hasError(\"Multibinding annotations\");\n  }\n\n  /** An injectable value object. */\n  public static final class Thing {\n    @Inject\n    Thing() {}\n  }\n\n  @Test\n  public void implicitlyProvidedType() {\n    assertThatMethod(\"@BindsOptionalOf abstract Thing thing();\")\n        .importing(Thing.class)\n        .hasError(\"return unqualified types that have an @Inject-annotated constructor\");\n  }\n\n  private DaggerModuleMethodSubject assertThatMethod(String method) {\n    return assertThatModuleMethod(method).withDeclaration(moduleDeclaration);\n  }\n\n  /** A qualifier. */\n  @Qualifier\n  public @interface Qualifier1 {}\n\n  /** A qualifier. */\n  @Qualifier\n  public @interface Qualifier2 {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\ComponentBuilderTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/** Tests for {@link dagger.Component.Builder} */\n@RunWith(JUnit4.class)\npublic class ComponentBuilderTest {\n\n  private static final ErrorMessages.ComponentBuilderMessages MSGS \u003d\n      ErrorMessages.ComponentBuilderMessages.INSTANCE;\n\n  @Test\n  public void testEmptyBuilder() {\n    JavaFileObject injectableTypeFile \u003d JavaFileObjects.forSourceLines(\"test.SomeInjectableType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class SomeInjectableType {\",\n        \"  @Inject SomeInjectableType() {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface SimpleComponent {\",\n        \"  SomeInjectableType someInjectableType();\",\n        \"\",\n        \"  @Component.Builder\",\n        \"  static interface Builder {\",\n        \"     SimpleComponent build();\",\n        \"  }\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerSimpleComponent\",\n            \"package test;\",\n            \"\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerSimpleComponent implements SimpleComponent {\",\n            \"  private DaggerSimpleComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"  }\",\n            \"\",\n            \"  public static SimpleComponent.Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static SimpleComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public SomeInjectableType someInjectableType() {\",\n            \"    return new SomeInjectableType();\",\n            \"  }\",\n            \"\",\n            \"  private static final class Builder implements SimpleComponent.Builder {\",\n            \"    @Override\",\n            \"    public SimpleComponent build() {\",\n            \"      return new DaggerSimpleComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test\n  public void testUsesBuildAndSetterNames() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides String string() { return null; }\",\n        \"}\");\n\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(modules \u003d TestModule.class)\",\n        \"interface TestComponent {\",\n        \"  String string();\",\n        \"\",\n        \"  @Component.Builder\",\n        \"  interface Builder {\",\n        \"    Builder setTestModule(TestModule testModule);\",\n        \"    TestComponent create();\",\n        \"  }\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\n        \"test.DaggerTestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Preconditions;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class DaggerTestComponent implements TestComponent {\",\n        \"  private Provider\u003cString\u003e stringProvider;\",\n        \"\",\n        \"  private DaggerTestComponent(Builder builder) {\",\n        \"    assert builder !\u003d null;\",\n        \"    initialize(builder);\",\n        \"  }\",\n        \"\",\n        \"  public static TestComponent.Builder builder() {\",\n        \"    return new Builder();\",\n        \"  }\",\n        \"\",\n        \"  public static TestComponent create() {\",\n        \"    return builder().create();\",\n        \"  }\",\n        \"\",\n        \"  @SuppressWarnings(\\\"unchecked\\\")\",\n        \"  private void initialize(final Builder builder) {\",\n        \"    this.stringProvider \u003d TestModule_StringFactory.create(builder.testModule);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public String string() {\",\n        \"    return stringProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  private static final class Builder implements TestComponent.Builder {\",\n        \"    private TestModule testModule;\",\n        \"\",\n        \"    @Override\",\n        \"    public TestComponent create() {\",\n        \"      if (testModule \u003d\u003d null) {\",\n        \"        this.testModule \u003d new TestModule();\",\n        \"      }\",\n        \"      return new DaggerTestComponent(this);\",\n        \"    }\",\n        \"\",\n        \"    @Override\",\n        \"    public Builder setTestModule(TestModule testModule) {\",\n        \"      this.testModule \u003d Preconditions.checkNotNull(testModule);\",\n        \"      return this;\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(moduleFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test\n  public void testIgnoresModulesNotInApi() {\n    JavaFileObject module1 \u003d JavaFileObjects.forSourceLines(\"test.TestModule1\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule1 {\",\n        \"  @Provides String string() { return null; }\",\n        \"}\");\n    JavaFileObject module2 \u003d JavaFileObjects.forSourceLines(\"test.TestModule2\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule2 {\",\n        \"  @Provides Integer integer() { return null; }\",\n        \"}\");\n\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(modules \u003d {TestModule1.class, TestModule2.class})\",\n        \"interface TestComponent {\",\n        \"  String string();\",\n        \"  Integer integer();\",\n        \"\",\n        \"  @Component.Builder\",\n        \"  interface Builder {\",\n        \"    Builder testModule1(TestModule1 testModule1);\",\n        \"    TestComponent build();\",\n        \"  }\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\n        \"test.DaggerTestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Preconditions;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class DaggerTestComponent implements TestComponent {\",\n        \"  private Provider\u003cString\u003e stringProvider;\",\n        \"  private Provider\u003cInteger\u003e integerProvider;\",\n        \"\",\n        \"  private DaggerTestComponent(Builder builder) {\",\n        \"    assert builder !\u003d null;\",\n        \"    initialize(builder);\",\n        \"  }\",\n        \"\",\n        \"  public static TestComponent.Builder builder() {\",\n        \"    return new Builder();\",\n        \"  }\",\n        \"\",\n        \"  public static TestComponent create() {\",\n        \"    return builder().build();\",\n        \"  }\",\n        \"\",\n        \"  @SuppressWarnings(\\\"unchecked\\\")\",\n        \"  private void initialize(final Builder builder) {\",\n        \"    this.stringProvider \u003d TestModule1_StringFactory.create(builder.testModule1);\",\n        \"    this.integerProvider \u003d TestModule2_IntegerFactory.create(builder.testModule2);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public String string() {\",\n        \"    return stringProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public Integer integer() {\",\n        \"    return integerProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  private static final class Builder implements TestComponent.Builder {\",\n        \"    private TestModule1 testModule1;\",\n        \"    private TestModule2 testModule2;\",\n        \"\",\n        \"    @Override\",\n        \"    public TestComponent build() {\",\n        \"      if (testModule1 \u003d\u003d null) {\",\n        \"        this.testModule1 \u003d new TestModule1();\",\n        \"      }\",\n        \"      if (testModule2 \u003d\u003d null) {\",\n        \"        this.testModule2 \u003d new TestModule2();\",\n        \"      }\",\n        \"      return new DaggerTestComponent(this);\",\n        \"    }\",\n        \"\",\n        \"    @Override\",\n        \"    public Builder testModule1(TestModule1 testModule1) {\",\n        \"      this.testModule1 \u003d Preconditions.checkNotNull(testModule1);\",\n        \"      return this;\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(module1, module2, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test\n  public void testMoreThanOneBuilderFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  static interface Builder {\",\n        \"     SimpleComponent build();\",\n        \"  }\",\n        \"\",\n        \"  @Component.Builder\",\n        \"  interface Builder2 {\",\n        \"     SimpleComponent build();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(String.format(MSGS.moreThanOne(),\n            \"[test.SimpleComponent.Builder, test.SimpleComponent.Builder2]\"))\n        .in(componentFile);\n  }\n\n  @Test\n  public void testBuilderGenericsFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  interface Builder\u003cT\u003e {\",\n        \"     SimpleComponent build();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.generics())\n        .in(componentFile);\n  }\n\n  @Test\n  public void testBuilderNotInComponentFails() {\n    JavaFileObject builder \u003d JavaFileObjects.forSourceLines(\"test.Builder\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component.Builder\",\n        \"interface Builder {}\");\n    assertAbout(javaSource()).that(builder)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.mustBeInComponent())\n        .in(builder);\n  }\n\n  @Test\n  public void testBuilderMissingBuildMethodFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  interface Builder {}\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.missingBuildMethod())\n        .in(componentFile);\n  }\n\n  @Test\n  public void testPrivateBuilderFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  private interface Builder {}\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.isPrivate())\n        .in(componentFile);\n  }\n\n  @Test\n  public void testNonStaticBuilderFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  abstract class Builder {}\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.mustBeStatic())\n        .in(componentFile);\n  }\n\n  @Test\n  public void testNonAbstractBuilderFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  static class Builder {}\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.mustBeAbstract());\n  }\n\n  @Test\n  public void testBuilderOneCxtorWithArgsFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  static abstract class Builder {\",\n        \"    Builder(String unused) {}\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())\n        .in(componentFile);\n  }\n\n  @Test\n  public void testBuilderMoreThanOneCxtorFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  static abstract class Builder {\",\n        \"    Builder() {}\",\n        \"    Builder(String unused) {}\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())\n        .in(componentFile);\n  }\n\n  @Test\n  public void testBuilderEnumFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  enum Builder {}\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.mustBeClassOrInterface())\n        .in(componentFile);\n  }\n\n  @Test\n  public void testBuilderBuildReturnsWrongTypeFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  interface Builder {\",\n        \"    String build();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.buildMustReturnComponentType())\n            .in(componentFile).onLine(10);\n  }\n\n  @Test\n  public void testInheritedBuilderBuildReturnsWrongTypeFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  interface Parent {\",\n        \"    String build();\",\n        \"  }\",\n        \"\",\n        \"  @Component.Builder\",\n        \"  interface Builder extends Parent {}\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.inheritedBuildMustReturnComponentType(), \"build\"))\n            .in(componentFile).onLine(13);\n  }\n\n  @Test\n  public void testTwoBuildMethodsFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  interface Builder {\",\n        \"    SimpleComponent build();\",\n        \"    SimpleComponent create();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(String.format(MSGS.twoBuildMethods(), \"build()\"))\n            .in(componentFile).onLine(11);\n  }\n\n  @Test\n  public void testInheritedTwoBuildMethodsFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  interface Parent {\",\n        \"    SimpleComponent build();\",\n        \"    SimpleComponent create();\",\n        \"  }\",\n        \"\",\n        \"  @Component.Builder\",\n        \"  interface Builder extends Parent {}\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.inheritedTwoBuildMethods(), \"create()\", \"build()\"))\n            .in(componentFile).onLine(14);\n  }\n\n  @Test\n  public void testMoreThanOneArgFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  interface Builder {\",\n        \"    SimpleComponent build();\",\n        \"    Builder set(String s, Integer i);\",\n        \"    Builder set(Number n, Double d);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.methodsMustTakeOneArg())\n            .in(componentFile).onLine(11)\n        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())\n            .in(componentFile).onLine(12);\n  }\n\n  @Test\n  public void testInheritedMoreThanOneArgFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  interface Parent {\",\n        \"    SimpleComponent build();\",\n        \"    Builder set1(String s, Integer i);\",\n        \"  }\",\n        \"\",\n        \"  @Component.Builder\",\n        \"  interface Builder extends Parent {}\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.inheritedMethodsMustTakeOneArg(),\n                \"set1(java.lang.String,java.lang.Integer)\"))\n            .in(componentFile).onLine(14);\n  }\n\n  @Test\n  public void testSetterReturningNonVoidOrBuilderFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  interface Builder {\",\n        \"    SimpleComponent build();\",\n        \"    String set(Integer i);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())\n            .in(componentFile).onLine(11);\n  }\n\n  @Test\n  public void testInheritedSetterReturningNonVoidOrBuilderFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  interface Parent {\",\n        \"    SimpleComponent build();\",\n        \"    String set(Integer i);\",\n        \"  }\",\n        \"\",\n        \"  @Component.Builder\",\n        \"  interface Builder extends Parent {}\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),\n                \"set(java.lang.Integer)\"))\n            .in(componentFile).onLine(14);\n  }\n\n  @Test\n  public void testGenericsOnSetterMethodFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  interface Builder {\",\n        \"    SimpleComponent build();\",\n        \"    \u003cT\u003e Builder set(T t);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())\n            .in(componentFile).onLine(11);\n  }\n\n  @Test\n  public void testGenericsOnInheritedSetterMethodFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  interface Parent {\",\n        \"    SimpleComponent build();\",\n        \"    \u003cT\u003e Builder set(T t);\",\n        \"  }\",\n        \"\",\n        \"  @Component.Builder\",\n        \"  interface Builder extends Parent {}\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), \"\u003cT\u003eset(T)\"))\n            .in(componentFile).onLine(14);\n  }\n\n  @Test\n  public void testMultipleSettersPerTypeFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  @Component.Builder\",\n        \"  interface Builder {\",\n        \"    SimpleComponent build();\",\n        \"    void set1(String s);\",\n        \"    void set2(String s);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.manyMethodsForType(),\n                  \"java.lang.String\", \"[set1(java.lang.String), set2(java.lang.String)]\"))\n            .in(componentFile).onLine(9);\n  }\n\n  @Test\n  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"abstract class SimpleComponent {\",\n        \"  interface Parent\u003cT\u003e {\",\n        \"    void set1(T t);\",\n        \"  }\",\n        \"\",\n        \"  @Component.Builder\",\n        \"  interface Builder extends Parent\u003cString\u003e {\",\n        \"    SimpleComponent build();\",\n        \"    void set2(String s);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.manyMethodsForType(),\n                  \"java.lang.String\", \"[set1(T), set2(java.lang.String)]\"))\n            .in(componentFile).onLine(13);\n  }\n\n  @Test\n  public void testExtraSettersFails() {\n    JavaFileObject componentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.SimpleComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            \"@Component(modules \u003d AbstractModule.class)\",\n            \"abstract class SimpleComponent {\",\n            \"  @Component.Builder\",\n            \"  interface Builder {\",\n            \"    SimpleComponent build();\",\n            \"    void abstractModule(AbstractModule abstractModule);\",\n            \"    void other(String s);\",\n            \"  }\",\n            \"}\");\n    JavaFileObject abstractModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.AbstractModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"\",\n            \"@Module\",\n            \"abstract class AbstractModule {}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(componentFile, abstractModule))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(\n                MSGS.extraSetters(),\n                \"[void test.SimpleComponent.Builder.abstractModule(test.AbstractModule), \"\n                    + \"void test.SimpleComponent.Builder.other(String)]\"))\n        .in(componentFile)\n        .onLine(10);\n  }\n\n  @Test\n  public void testMissingSettersFail() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  TestModule(String unused) {}\",\n        \"  @Provides String s() { return null; }\",\n        \"}\");\n    JavaFileObject module2File \u003d JavaFileObjects.forSourceLines(\"test.Test2Module\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class Test2Module {\",\n        \"  @Provides Integer i() { return null; }\",\n        \"}\");\n    JavaFileObject module3File \u003d JavaFileObjects.forSourceLines(\"test.Test3Module\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class Test3Module {\",\n        \"  Test3Module(String unused) {}\",\n        \"  @Provides Double d() { return null; }\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(modules \u003d {TestModule.class, Test2Module.class, Test3Module.class},\",\n        \"           dependencies \u003d OtherComponent.class)\",\n        \"interface TestComponent {\",\n        \"  String string();\",\n        \"  Integer integer();\",\n        \"\",\n        \"  @Component.Builder\",\n        \"  interface Builder {\",\n        \"    TestComponent create();\",\n        \"  }\",\n        \"}\");\n    JavaFileObject otherComponent \u003d JavaFileObjects.forSourceLines(\"test.OtherComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface OtherComponent {}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(moduleFile, module2File, module3File, componentFile, otherComponent))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            // Ignores Test2Module because we can construct it ourselves.\n            // TODO(sameb): Ignore Test3Module because it\u0027s not used within transitive dependencies.\n            String.format(MSGS.missingSetters(),\n                \"[test.TestModule, test.Test3Module, test.OtherComponent]\"))\n            .in(componentFile).onLine(12);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\ComponentHierarchyValidatorTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.testing.compile.JavaSourcesSubject.assertThat;\n\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/** Tests for {ComponentHierarchyValidator}. */\n@RunWith(JUnit4.class)\npublic class ComponentHierarchyValidatorTest {\n  @Test\n  public void singletonSubcomponent() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Parent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import javax.inject.Singleton;\",\n            \"\",\n            \"@Singleton\",\n            \"@Component\",\n            \"interface Parent {\",\n            \"  Child child();\",\n            \"}\");\n    JavaFileObject subcomponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Child\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"import javax.inject.Singleton;\",\n            \"\",\n            \"@Singleton\",\n            \"@Subcomponent\",\n            \"interface Child {}\");\n\n    assertThat(component, subcomponent)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"conflicting scopes\")\n        .and().withErrorContaining(\"test.Parent also has @Singleton\");\n\n    assertThat(component, subcomponent)\n        .withCompilerOptions(\"-Adagger.disableInterComponentScopeValidation\u003dnone\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n  \n  @Test\n  public void productionComponents_productionScopeImplicitOnBoth() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Parent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.producers.ProductionComponent;\",\n            \"\",\n            \"@ProductionComponent(modules \u003d ParentModule.class)\",\n            \"interface Parent {\",\n            \"  Child child();\",\n            \"  Object productionScopedObject();\",\n            \"}\");\n    JavaFileObject parentModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Provides;\",\n            \"import dagger.producers.ProducerModule;\",\n            \"import dagger.producers.ProductionScope;\",\n            \"\",\n            \"@ProducerModule\",\n            \"class ParentModule {\",\n            \"  @Provides @ProductionScope Object parentScopedObject() { return new Object(); }\",\n            \"}\");\n    JavaFileObject subcomponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Child\",\n            \"package test;\",\n            \"\",\n            \"import dagger.producers.ProductionSubcomponent;\",\n            \"\",\n            \"@ProductionSubcomponent(modules \u003d ChildModule.class)\",\n            \"interface Child {\",\n            \"  String productionScopedString();\",\n            \"}\");\n    JavaFileObject childModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ChildModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Provides;\",\n            \"import dagger.producers.ProducerModule;\",\n            \"import dagger.producers.ProductionScope;\",\n            \"\",\n            \"@ProducerModule\",\n            \"class ChildModule {\",\n            \"  @Provides @ProductionScope String childScopedString() { return new String(); }\",\n            \"}\");\n    assertThat(component, subcomponent, parentModule, childModule)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\ComponentProcessorTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;\nimport static com.google.testing.compile.JavaSourcesSubject.assertThat;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;\nimport static java.util.Arrays.asList;\nimport static javax.tools.StandardLocation.SOURCE_OUTPUT;\n\nimport com.google.auto.common.MoreElements;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Sets;\nimport com.google.testing.compile.JavaFileObjects;\nimport com.squareup.javapoet.CodeBlock;\nimport dagger.MembersInjector;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.lang.annotation.Annotation;\nimport java.util.Set;\nimport javax.annotation.processing.AbstractProcessor;\nimport javax.annotation.processing.ProcessingEnvironment;\nimport javax.annotation.processing.Processor;\nimport javax.annotation.processing.RoundEnvironment;\nimport javax.inject.Inject;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.TypeElement;\nimport javax.tools.JavaFileObject;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class ComponentProcessorTest {\n  private static final CodeBlock NPE_LITERAL \u003d\n      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_COMPONENT_METHOD);\n\n  @Test public void componentOnConcreteClass() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.NotAComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"final class NotAComponent {}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"interface\");\n  }\n\n  @Test public void componentOnEnum() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.NotAComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"enum NotAComponent {\",\n        \"  INSTANCE\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"interface\");\n  }\n\n  @Test public void componentOnAnnotation() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.NotAComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"@interface NotAComponent {}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"interface\");\n  }\n\n  @Test public void nonModuleModule() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.NotAComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(modules \u003d Object.class)\",\n        \"interface NotAComponent {}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"is not annotated with @Module\");\n  }\n\n  @Test public void doubleBindingFromResolvedModules() {\n    JavaFileObject parent \u003d JavaFileObjects.forSourceLines(\"test.ParentModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import java.util.List;\",\n        \"\",\n        \"@Module\",\n        \"abstract class ParentModule\u003cA\u003e {\",\n        \"  @Provides List\u003cA\u003e provideListB(A a) { return null; }\",\n        \"}\");\n    JavaFileObject child \u003d JavaFileObjects.forSourceLines(\"test.ChildModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"class ChildNumberModule extends ParentModule\u003cInteger\u003e {\",\n        \"  @Provides Integer provideInteger() { return null; }\",\n        \"}\");\n    JavaFileObject another \u003d JavaFileObjects.forSourceLines(\"test.AnotherModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import java.util.List;\",\n        \"\",\n        \"@Module\",\n        \"class AnotherModule {\",\n        \"  @Provides List\u003cInteger\u003e provideListOfInteger() { return null; }\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.BadComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import java.util.List;\",\n        \"\",\n        \"@Component(modules \u003d {ChildNumberModule.class, AnotherModule.class})\",\n        \"interface BadComponent {\",\n        \"  List\u003cInteger\u003e listOfInteger();\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(parent, child, another, componentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile().withErrorContaining(\n            \"java.util.List\u003cjava.lang.Integer\u003e is bound multiple times\")\n        .and().withErrorContaining(\n            \"@Provides List\u003cInteger\u003e test.ChildNumberModule.provideListB(Integer)\")\n        .and().withErrorContaining(\n            \"@Provides List\u003cInteger\u003e test.AnotherModule.provideListOfInteger()\");\n  }\n\n  @Test public void privateNestedClassWithWarningThatIsAnErrorInComponent() {\n    JavaFileObject outerClass \u003d JavaFileObjects.forSourceLines(\"test.OuterClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class OuterClass {\",\n        \"  @Inject OuterClass(InnerClass innerClass) {}\",\n        \"\",\n        \"  private static final class InnerClass {\",\n        \"    @Inject InnerClass() {}\",\n        \"  }\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.BadComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface BadComponent {\",\n        \"  OuterClass outerClass();\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(outerClass, componentFile))\n        .withCompilerOptions(\"-Adagger.privateMemberValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Dagger does not support injection into private classes\");\n  }\n\n  @Test public void simpleComponent() {\n    JavaFileObject injectableTypeFile \u003d JavaFileObjects.forSourceLines(\"test.SomeInjectableType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class SomeInjectableType {\",\n        \"  @Inject SomeInjectableType() {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface SimpleComponent {\",\n        \"  SomeInjectableType someInjectableType();\",\n        \"  Lazy\u003cSomeInjectableType\u003e lazySomeInjectableType();\",\n        \"  Provider\u003cSomeInjectableType\u003e someInjectableTypeProvider();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerSimpleComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Lazy;\",\n            \"import dagger.internal.DoubleCheck;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerSimpleComponent implements SimpleComponent {\",\n            \"  private DaggerSimpleComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static SimpleComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public SomeInjectableType someInjectableType() {\",\n            \"    return new SomeInjectableType();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Lazy\u003cSomeInjectableType\u003e lazySomeInjectableType() {\",\n            \"    return DoubleCheck.lazy(SomeInjectableType_Factory.create());\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Provider\u003cSomeInjectableType\u003e someInjectableTypeProvider() {\",\n            \"    return SomeInjectableType_Factory.create();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public SimpleComponent build() {\",\n            \"      return new DaggerSimpleComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void componentWithScope() {\n    JavaFileObject injectableTypeFile \u003d JavaFileObjects.forSourceLines(\"test.SomeInjectableType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Singleton\",\n        \"final class SomeInjectableType {\",\n        \"  @Inject SomeInjectableType() {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Provider;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Singleton\",\n        \"@Component\",\n        \"interface SimpleComponent {\",\n        \"  SomeInjectableType someInjectableType();\",\n        \"  Lazy\u003cSomeInjectableType\u003e lazySomeInjectableType();\",\n        \"  Provider\u003cSomeInjectableType\u003e someInjectableTypeProvider();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerSimpleComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Lazy;\",\n            \"import dagger.internal.DoubleCheck;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerSimpleComponent implements SimpleComponent {\",\n            \"  private Provider\u003cSomeInjectableType\u003e someInjectableTypeProvider;\",\n            \"\",\n            \"  private DaggerSimpleComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static SimpleComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.someInjectableTypeProvider \u003d\",\n            \"        DoubleCheck.provider(SomeInjectableType_Factory.create());\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public SomeInjectableType someInjectableType() {\",\n            \"    return someInjectableTypeProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Lazy\u003cSomeInjectableType\u003e lazySomeInjectableType() {\",\n            \"    return DoubleCheck.lazy(someInjectableTypeProvider);\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Provider\u003cSomeInjectableType\u003e someInjectableTypeProvider() {\",\n            \"    return someInjectableTypeProvider;\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public SimpleComponent build() {\",\n            \"      return new DaggerSimpleComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void simpleComponentWithNesting() {\n    JavaFileObject nestedTypesFile \u003d JavaFileObjects.forSourceLines(\"test.OuterType\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class OuterType {\",\n        \"  static class A {\",\n        \"    @Inject A() {}\",\n        \"  }\",\n        \"  static class B {\",\n        \"    @Inject A a;\",\n        \"  }\",\n        \"  @Component interface SimpleComponent {\",\n        \"    A a();\",\n        \"    void inject(B b);\",\n        \"  }\",\n        \"}\");\n\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerOuterType_SimpleComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MembersInjector;\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerOuterType_SimpleComponent\",\n            \"    implements OuterType.SimpleComponent {\",\n            \"  private MembersInjector\u003cOuterType.B\u003e bMembersInjector;\",\n            \"\",\n            \"  private DaggerOuterType_SimpleComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static OuterType.SimpleComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.bMembersInjector \u003d\",\n            \"        OuterType_B_MembersInjector.create(OuterType_A_Factory.create());\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public OuterType.A a() {\",\n            \"    return new OuterType.A();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public void inject(OuterType.B b) {\",\n            \"    bMembersInjector.injectMembers(b);\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public OuterType.SimpleComponent build() {\",\n            \"      return new DaggerOuterType_SimpleComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void componentWithModule() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject A(B b) {}\",\n        \"}\");\n    JavaFileObject bFile \u003d JavaFileObjects.forSourceLines(\"test.B\",\n        \"package test;\",\n        \"\",\n        \"interface B {}\");\n    JavaFileObject cFile \u003d JavaFileObjects.forSourceLines(\"test.C\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class C {\",\n        \"  @Inject C() {}\",\n        \"}\");\n\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides B b(C c) { return null; }\",\n        \"}\");\n\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component(modules \u003d TestModule.class)\",\n        \"interface TestComponent {\",\n        \"  A a();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\n        \"test.DaggerTestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Preconditions;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class DaggerTestComponent implements TestComponent {\",\n        \"  private Provider\u003cB\u003e bProvider;\",\n        \"  private Provider\u003cA\u003e aProvider;\",\n        \"\",\n        \"  private DaggerTestComponent(Builder builder) {\",\n        \"    assert builder !\u003d null;\",\n        \"    initialize(builder);\",\n        \"  }\",\n        \"\",\n        \"  public static Builder builder() {\",\n        \"    return new Builder();\",\n        \"  }\",\n        \"\",\n        \"  public static TestComponent create() {\",\n        \"    return builder().build();\",\n        \"  }\",\n        \"\",\n        \"  @SuppressWarnings(\\\"unchecked\\\")\",\n        \"  private void initialize(final Builder builder) {\",\n        \"    this.bProvider \u003d TestModule_BFactory.create(builder.testModule,\",\n        \"        C_Factory.create());\",\n        \"    this.aProvider \u003d A_Factory.create(bProvider);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public A a() {\",\n        \"    return aProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static final class Builder {\",\n        \"    private TestModule testModule;\",\n        \"\",\n        \"    private Builder() {\",\n        \"    }\",\n        \"\",\n        \"    public TestComponent build() {\",\n        \"      if (testModule \u003d\u003d null) {\",\n        \"        this.testModule \u003d new TestModule();\",\n        \"      }\",\n        \"      return new DaggerTestComponent(this);\",\n        \"    }\",\n        \"\",\n        \"    public Builder testModule(TestModule testModule) {\",\n        \"      this.testModule \u003d Preconditions.checkNotNull(testModule);\",\n        \"      return this;\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test\n  public void componentWithAbstractModule() {\n    JavaFileObject aFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.A\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class A {\",\n            \"  @Inject A(B b) {}\",\n            \"}\");\n    JavaFileObject bFile \u003d\n        JavaFileObjects.forSourceLines(\"test.B\",\n            \"package test;\",\n            \"\",\n            \"interface B {}\");\n    JavaFileObject cFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.C\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class C {\",\n            \"  @Inject C() {}\",\n            \"}\");\n\n    JavaFileObject moduleFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"\",\n            \"@Module\",\n            \"abstract class TestModule {\",\n            \"  @Provides static B b(C c) { return null; }\",\n            \"}\");\n\n    JavaFileObject componentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            \"@Component(modules \u003d TestModule.class)\",\n            \"interface TestComponent {\",\n            \"  A a();\",\n            \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerTestComponent\",\n            \"package test;\",\n            \"\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerTestComponent implements TestComponent {\",\n            \"  private Provider\u003cB\u003e bProvider;\",\n            \"  private Provider\u003cA\u003e aProvider;\",\n            \"\",\n            \"  private DaggerTestComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static TestComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.bProvider \u003d TestModule_BFactory.create(C_Factory.create());\",\n            \"    this.aProvider \u003d A_Factory.create(bProvider);\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public A a() {\",\n            \"    return aProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public TestComponent build() {\",\n            \"      return new DaggerTestComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(aFile, bFile, cFile, moduleFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(generatedComponent);\n  }\n\n  @Test public void transitiveModuleDeps() {\n    JavaFileObject always \u003d JavaFileObjects.forSourceLines(\"test.AlwaysIncluded\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module\",\n        \"final class AlwaysIncluded {}\");\n    JavaFileObject testModule \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module(includes \u003d {DepModule.class, AlwaysIncluded.class})\",\n        \"final class TestModule extends ParentTestModule {}\");\n    JavaFileObject parentTest \u003d JavaFileObjects.forSourceLines(\"test.ParentTestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module(includes \u003d {ParentTestIncluded.class, AlwaysIncluded.class})\",\n        \"class ParentTestModule {}\");\n    JavaFileObject parentTestIncluded \u003d JavaFileObjects.forSourceLines(\"test.ParentTestIncluded\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module(includes \u003d AlwaysIncluded.class)\",\n        \"final class ParentTestIncluded {}\");\n    JavaFileObject depModule \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module(includes \u003d {RefByDep.class, AlwaysIncluded.class})\",\n        \"final class DepModule extends ParentDepModule {}\");\n    JavaFileObject refByDep \u003d JavaFileObjects.forSourceLines(\"test.RefByDep\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module(includes \u003d AlwaysIncluded.class)\",\n        \"final class RefByDep extends ParentDepModule {}\");\n    JavaFileObject parentDep \u003d JavaFileObjects.forSourceLines(\"test.ParentDepModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module(includes \u003d {ParentDepIncluded.class, AlwaysIncluded.class})\",\n        \"class ParentDepModule {}\");\n    JavaFileObject parentDepIncluded \u003d JavaFileObjects.forSourceLines(\"test.ParentDepIncluded\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module(includes \u003d AlwaysIncluded.class)\",\n        \"final class ParentDepIncluded {}\");\n\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component(modules \u003d TestModule.class)\",\n        \"interface TestComponent {\",\n        \"}\");\n    // Generated code includes all includes, but excludes the parent modules.\n    // The \"always\" module should only be listed once.\n    JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\n        \"test.DaggerTestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Preconditions;\",\n        \"import javax.annotation.Generated;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class DaggerTestComponent implements TestComponent {\",\n        \"\",\n        \"  private DaggerTestComponent(Builder builder) {\",\n        \"    assert builder !\u003d null;\",\n        \"  }\",\n        \"\",\n        \"  public static Builder builder() {\",\n        \"    return new Builder();\",\n        \"  }\",\n        \"\",\n        \"  public static TestComponent create() {\",\n        \"    return builder().build();\",\n        \"  }\",\n        \"\",\n        \"  public static final class Builder {\",\n        \"    private Builder() {\",\n        \"    }\",\n        \"\",\n        \"    public TestComponent build() {\",\n        \"      return new DaggerTestComponent(this);\",\n        \"    }\",\n        \"\",\n        \"    @Deprecated\",\n        \"    public Builder testModule(TestModule testModule) {\",\n        \"      Preconditions.checkNotNull(testModule)\",\n        \"      return this;\",\n        \"    }\",\n        \"\",\n        \"    @Deprecated\",\n        \"    public Builder parentTestIncluded(ParentTestIncluded parentTestIncluded) {\",\n        \"      Preconditions.checkNotNull(parentTestIncluded)\",\n        \"      return this;\",\n        \"    }\",\n        \"\",\n        \"    @Deprecated\",\n        \"    public Builder alwaysIncluded(AlwaysIncluded alwaysIncluded) {\",\n        \"      Preconditions.checkNotNull(alwaysIncluded)\",\n        \"      return this;\",\n        \"    }\",\n        \"\",\n        \"    @Deprecated\",\n        \"    public Builder depModule(DepModule depModule) {\",\n        \"      Preconditions.checkNotNull(depModule)\",\n        \"      return this;\",\n        \"    }\",\n        \"\",\n        \"    @Deprecated\",\n        \"    public Builder parentDepIncluded(ParentDepIncluded parentDepIncluded) {\",\n        \"      Preconditions.checkNotNull(parentDepIncluded)\",\n        \"      return this;\",\n        \"    }\",\n        \"\",\n        \"    @Deprecated\",\n        \"    public Builder refByDep(RefByDep refByDep) {\",\n        \"      Preconditions.checkNotNull(refByDep)\",\n        \"      return this;\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(always,\n            testModule,\n            parentTest,\n            parentTestIncluded,\n            depModule,\n            refByDep,\n            parentDep,\n            parentDepIncluded,\n            componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test\n  public void generatedTransitiveModule() {\n    JavaFileObject rootModule \u003d JavaFileObjects.forSourceLines(\"test.RootModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module(includes \u003d GeneratedModule.class)\",\n        \"final class RootModule {}\");\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(modules \u003d RootModule.class)\",\n        \"interface TestComponent {}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(rootModule, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile();\n    assertAbout(javaSources())\n        .that(ImmutableList.of(rootModule, component))\n        .processedWith(\n            new ComponentProcessor(),\n            new GeneratingProcessor(\n                \"test.GeneratedModule\",\n                \"package test;\",\n                \"\",\n                \"import dagger.Module;\",\n                \"\",\n                \"@Module\",\n                \"final class GeneratedModule {}\"))\n        .compilesWithoutError();\n  }\n\n  @Test\n  public void generatedModuleInSubcomponent() {\n    JavaFileObject subcomponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ChildComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent(modules \u003d GeneratedModule.class)\",\n            \"interface ChildComponent {}\");\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component\",\n            \"interface TestComponent {\",\n            \"  ChildComponent childComponent();\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(subcomponent, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile();\n    assertAbout(javaSources())\n        .that(ImmutableList.of(subcomponent, component))\n        .processedWith(\n            new ComponentProcessor(),\n            new GeneratingProcessor(\n                \"test.GeneratedModule\",\n                \"package test;\",\n                \"\",\n                \"import dagger.Module;\",\n                \"\",\n                \"@Module\",\n                \"final class GeneratedModule {}\"))\n        .compilesWithoutError();\n  }\n\n  @Test\n  public void subcomponentOmitsInheritedBindings() {\n    JavaFileObject parent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Parent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d ParentModule.class)\",\n            \"interface Parent {\",\n            \"  Child child();\",\n            \"}\");\n    JavaFileObject parentModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.IntoSet;\",\n            \"import dagger.multibindings.IntoMap;\",\n            \"import dagger.multibindings.StringKey;\",\n            \"\",\n            \"@Module\",\n            \"class ParentModule {\",\n            \"  @Provides @IntoSet static Object parentObject() {\",\n            \"    return \\\"parent object\\\";\",\n            \"  }\",\n            \"\",\n            \"  @Provides @IntoMap @StringKey(\\\"parent key\\\") Object parentKeyObject() {\",\n            \"    return \\\"parent value\\\";\",\n            \"  }\",\n            \"}\");\n    JavaFileObject child \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Child\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"import java.util.Map;\",\n            \"import java.util.Set;\",\n            \"\",\n            \"@Subcomponent\",\n            \"interface Child {\",\n            \"  Set\u003cObject\u003e objectSet();\",\n            \"  Map\u003cString, Object\u003e objectMap();\",\n            \"}\");\n    JavaFileObject expected \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerParent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.MapFactory;\",\n            \"import dagger.internal.MapProviderFactory;\",\n            \"import dagger.internal.Preconditions;\",\n            \"import dagger.internal.SetFactory;\",\n            \"import java.util.Map;\",\n            \"import java.util.Set;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerParent implements Parent {\",\n            \"  private Provider\u003cObject\u003e parentKeyObjectProvider;\",\n            \"\",\n            \"  private DaggerParent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static Parent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.parentKeyObjectProvider \u003d\",\n            \"        ParentModule_ParentKeyObjectFactory.create(builder.parentModule);\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Child child() {\",\n            \"    return new ChildImpl();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private ParentModule parentModule;\",\n            \"\",\n            \"    private Builder() {}\",\n            \"\",\n            \"    public Parent build() {\",\n            \"      if (parentModule \u003d\u003d null) {\",\n            \"        this.parentModule \u003d new ParentModule();\",\n            \"      }\",\n            \"      return new DaggerParent(this);\",\n            \"    }\",\n            \"\",\n            \"    public Builder parentModule(ParentModule parentModule) {\",\n            \"      this.parentModule \u003d Preconditions.checkNotNull(parentModule);\",\n            \"      return this;\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  private final class ChildImpl implements Child {\",\n            \"    private Provider\u003cSet\u003cObject\u003e\u003e setOfObjectProvider;\",\n            \"    private Provider\u003cMap\u003cString, Provider\u003cObject\u003e\u003e\u003e\",\n            \"        mapOfStringAndProviderOfObjectProvider;\",\n            \"    private Provider\u003cMap\u003cString, Object\u003e\u003e mapOfStringAndObjectProvider;\",\n            \"\",\n            \"    private ChildImpl() {\",\n            \"      initialize();\",\n            \"    }\",\n            \"\",\n            \"    @SuppressWarnings(\\\"unchecked\\\")\",\n            \"    private void initialize() {\",\n            \"      this.setOfObjectProvider \u003d SetFactory.\u003cObject\u003ebuilder(1, 0)\",\n            \"          .addProvider(ParentModule_ParentObjectFactory.create()).build();\",\n            \"      this.mapOfStringAndProviderOfObjectProvider \u003d\",\n            \"          MapProviderFactory.\u003cString, Object\u003ebuilder(1)\",\n            \"              .put(\\\"parent key\\\", DaggerParent.this.parentKeyObjectProvider)\",\n            \"              .build();\",\n            \"      this.mapOfStringAndObjectProvider \u003d MapFactory.create(\",\n            \"          mapOfStringAndProviderOfObjectProvider);\",\n            \"    }\",\n            \"\",\n            \"    @Override\",\n            \"    public Set\u003cObject\u003e objectSet() {\",\n            \"      return setOfObjectProvider.get();\",\n            \"    }\",\n            \"\",\n            \"    @Override\",\n            \"    public Map\u003cString, Object\u003e objectMap() {\",\n            \"      return mapOfStringAndObjectProvider.get();\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(parent, parentModule, child))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(expected);\n  }\n\n  @Test\n  public void subcomponentNotGeneratedIfNotUsedInGraph() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Parent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d ParentModule.class)\",\n            \"interface Parent {\",\n            \"  String notSubcomponent();\",\n            \"}\");\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Parent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"\",\n            \"@Module(subcomponents \u003d Child.class)\",\n            \"class ParentModule {\",\n            \"  @Provides static String notSubcomponent() { return new String(); }\",\n            \"}\");\n\n    JavaFileObject subcomponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Child\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent\",\n            \"interface Child {\",\n            \"  @Subcomponent.Builder\",\n            \"  interface Builder {\",\n            \"    Child build();\",\n            \"  }\",\n            \"}\");\n\n    JavaFileObject generatedComponentWithoutSubcomponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerParent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.Preconditions;\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerParent implements Parent {\",\n            \"\",\n            \"  private DaggerParent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static Parent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public String notSubcomponent() {\",\n            \"    return ParentModule.notSubcomponent();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public Parent build() {\",\n            \"      return new DaggerParent(this);\",\n            \"    }\",\n            \"\",\n            \"    @Deprecated\",\n            \"    public Builder parentModule(ParentModule parentModule) {\",\n            \"      Preconditions.checkNotNull(parentModule);\",\n            \"      return this;\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n\n    assertThat(component, module, subcomponent)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(generatedComponentWithoutSubcomponent);\n  }\n\n  @Test\n  public void testDefaultPackage() {\n    JavaFileObject aClass \u003d JavaFileObjects.forSourceLines(\"AClass\", \"class AClass {}\");\n    JavaFileObject bClass \u003d JavaFileObjects.forSourceLines(\"BClass\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class BClass {\",\n        \"  @Inject BClass(AClass a) {}\",\n        \"}\");\n    JavaFileObject aModule \u003d JavaFileObjects.forSourceLines(\"AModule\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module class AModule {\",\n        \"  @Provides AClass aClass() {\",\n        \"    return new AClass();\",\n        \"  }\",\n        \"}\");\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"SomeComponent\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(modules \u003d AModule.class)\",\n        \"interface SomeComponent {\",\n        \"  BClass bClass();\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(aModule, aClass, bClass, component))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n\n  @Test public void setBindings() {\n    JavaFileObject emptySetModuleFile \u003d JavaFileObjects.forSourceLines(\"test.EmptySetModule\",\n        \"package test;\",\n        \"\",\n        \"import static dagger.Provides.Type.SET_VALUES;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.multibindings.ElementsIntoSet;\",\n        \"import java.util.Collections;\",\n        \"import java.util.Set;\",\n        \"\",\n        \"@Module\",\n        \"final class EmptySetModule {\",\n        \"  @Provides @ElementsIntoSet Set\u003cString\u003e emptySet() { return Collections.emptySet(); }\",\n        \"}\");\n    JavaFileObject setModuleFile \u003d JavaFileObjects.forSourceLines(\"test.SetModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.multibindings.IntoSet;\",\n        \"\",\n        \"@Module\",\n        \"final class SetModule {\",\n        \"  @Provides @IntoSet String string() { return \\\"\\\"; }\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import java.util.Set;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component(modules \u003d {EmptySetModule.class, SetModule.class})\",\n        \"interface TestComponent {\",\n        \"  Set\u003cString\u003e strings();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerTestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.Preconditions;\",\n            \"import dagger.internal.SetFactory;\",\n            \"import java.util.Set;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerTestComponent implements TestComponent {\",\n            \"  private Provider\u003cSet\u003cString\u003e\u003e emptySetProvider;\",\n            \"  private Provider\u003cString\u003e stringProvider;\",\n            \"  private Provider\u003cSet\u003cString\u003e\u003e setOfStringProvider;\",\n            \"\",\n            \"  private DaggerTestComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static TestComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.emptySetProvider \u003d\",\n            \"        EmptySetModule_EmptySetFactory.create(builder.emptySetModule);\",\n            \"    this.stringProvider \u003d\",\n            \"        SetModule_StringFactory.create(builder.setModule);\",\n            \"    this.setOfStringProvider \u003d \",\n            \"        SetFactory.\u003cString\u003ebuilder(1, 1)\",\n            \"            .addCollectionProvider(emptySetProvider)\",\n            \"            .addProvider(stringProvider)\",\n            \"            .build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Set\u003cString\u003e strings() {\",\n            \"    return setOfStringProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private EmptySetModule emptySetModule;\",\n            \"    private SetModule setModule;\",\n            \"\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public TestComponent build() {\",\n            \"      if (emptySetModule \u003d\u003d null) {\",\n            \"        this.emptySetModule \u003d new EmptySetModule();\",\n            \"      }\",\n            \"      if (setModule \u003d\u003d null) {\",\n            \"        this.setModule \u003d new SetModule();\",\n            \"      }\",\n            \"      return new DaggerTestComponent(this);\",\n            \"    }\",\n            \"\",\n            \"    public Builder emptySetModule(EmptySetModule emptySetModule) {\",\n            \"      this.emptySetModule \u003d Preconditions.checkNotNull(emptySetModule);\",\n            \"      return this;\",\n            \"    }\",\n            \"\",\n            \"    public Builder setModule(SetModule setModule) {\",\n            \"      this.setModule \u003d Preconditions.checkNotNull(setModule);\",\n            \"      return this;\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(emptySetModuleFile, setModuleFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void membersInjection() {\n    JavaFileObject injectableTypeFile \u003d JavaFileObjects.forSourceLines(\"test.SomeInjectableType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class SomeInjectableType {\",\n        \"  @Inject SomeInjectableType() {}\",\n        \"}\");\n    JavaFileObject injectedTypeFile \u003d JavaFileObjects.forSourceLines(\"test.SomeInjectedType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class SomeInjectedType {\",\n        \"  @Inject SomeInjectableType injectedField;\",\n        \"  SomeInjectedType() {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface SimpleComponent {\",\n        \"  void inject(SomeInjectedType instance);\",\n        \"  SomeInjectedType injectAndReturn(SomeInjectedType instance);\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\n        \"test.DaggerSimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.MembersInjector;\",\n        \"import javax.annotation.Generated;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class DaggerSimpleComponent implements SimpleComponent {\",\n        \"  private MembersInjector\u003cSomeInjectedType\u003e someInjectedTypeMembersInjector;\",\n        \"\",\n        \"  private DaggerSimpleComponent(Builder builder) {\",\n        \"    assert builder !\u003d null;\",\n        \"    initialize(builder);\",\n        \"  }\",\n        \"\",\n        \"  public static Builder builder() {\",\n        \"    return new Builder();\",\n        \"  }\",\n        \"\",\n        \"  public static SimpleComponent create() {\",\n        \"    return builder().build();\",\n        \"  }\",\n        \"\",\n        \"  @SuppressWarnings(\\\"unchecked\\\")\",\n        \"  private void initialize(final Builder builder) {\",\n        \"    this.someInjectedTypeMembersInjector \u003d\",\n        \"        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public void inject(SomeInjectedType instance) {\",\n        \"    someInjectedTypeMembersInjector.injectMembers(instance);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public SomeInjectedType injectAndReturn(SomeInjectedType instance) {\",\n        \"    someInjectedTypeMembersInjector.injectMembers(instance);\",\n        \"    return instance;\",\n        \"  }\",\n        \"\",\n        \"  public static final class Builder {\",\n        \"    private Builder() {\",\n        \"    }\",\n        \"\",\n        \"    public SimpleComponent build() {\",\n        \"      return new DaggerSimpleComponent(this);\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void componentInjection() {\n    JavaFileObject injectableTypeFile \u003d JavaFileObjects.forSourceLines(\"test.SomeInjectableType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class SomeInjectableType {\",\n        \"  @Inject SomeInjectableType(SimpleComponent component) {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface SimpleComponent {\",\n        \"  SomeInjectableType someInjectableType();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\n        \"test.DaggerSimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.InstanceFactory;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class DaggerSimpleComponent implements SimpleComponent {\",\n        \"  private Provider\u003cSimpleComponent\u003e simpleComponentProvider;\",\n        \"  private Provider\u003cSomeInjectableType\u003e someInjectableTypeProvider;\",\n        \"\",\n        \"  private DaggerSimpleComponent(Builder builder) {\",\n        \"    assert builder !\u003d null;\",\n        \"    initialize(builder);\",\n        \"  }\",\n        \"\",\n        \"  public static Builder builder() {\",\n        \"    return new Builder();\",\n        \"  }\",\n        \"\",\n        \"  public static SimpleComponent create() {\",\n        \"    return builder().build();\",\n        \"  }\",\n        \"\",\n        \"  @SuppressWarnings(\\\"unchecked\\\")\",\n        \"  private void initialize(final Builder builder) {\",\n        \"    this.simpleComponentProvider \u003d InstanceFactory.\u003cSimpleComponent\u003ecreate(this);\",\n        \"    this.someInjectableTypeProvider \u003d\",\n        \"        SomeInjectableType_Factory.create(simpleComponentProvider);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public SomeInjectableType someInjectableType() {\",\n        \"    return someInjectableTypeProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static final class Builder {\",\n        \"    private Builder() {\",\n        \"    }\",\n        \"\",\n        \"    public SimpleComponent build() {\",\n        \"      return new DaggerSimpleComponent(this);\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(injectableTypeFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void membersInjectionInsideProvision() {\n    JavaFileObject injectableTypeFile \u003d JavaFileObjects.forSourceLines(\"test.SomeInjectableType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class SomeInjectableType {\",\n        \"  @Inject SomeInjectableType() {}\",\n        \"}\");\n    JavaFileObject injectedTypeFile \u003d JavaFileObjects.forSourceLines(\"test.SomeInjectedType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class SomeInjectedType {\",\n        \"  @Inject SomeInjectableType injectedField;\",\n        \"  @Inject SomeInjectedType() {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface SimpleComponent {\",\n        \"  SomeInjectedType createAndInject();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\n        \"test.DaggerSimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.MembersInjector;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class DaggerSimpleComponent implements SimpleComponent {\",\n        \"  private MembersInjector\u003cSomeInjectedType\u003e someInjectedTypeMembersInjector;\",\n        \"  private Provider\u003cSomeInjectedType\u003e someInjectedTypeProvider;\",\n        \"\",\n        \"  private DaggerSimpleComponent(Builder builder) {\",\n        \"    assert builder !\u003d null;\",\n        \"    initialize(builder);\",\n        \"  }\",\n        \"\",\n        \"  public static Builder builder() {\",\n        \"    return new Builder();\",\n        \"  }\",\n        \"\",\n        \"  public static SimpleComponent create() {\",\n        \"    return builder().build();\",\n        \"  }\",\n        \"\",\n        \"  @SuppressWarnings(\\\"unchecked\\\")\",\n        \"  private void initialize(final Builder builder) {\",\n        \"    this.someInjectedTypeMembersInjector \u003d\",\n        \"        SomeInjectedType_MembersInjector.create(SomeInjectableType_Factory.create());\",\n        \"    this.someInjectedTypeProvider \u003d\",\n        \"        SomeInjectedType_Factory.create(someInjectedTypeMembersInjector);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public SomeInjectedType createAndInject() {\",\n        \"    return someInjectedTypeProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static final class Builder {\",\n        \"    private Builder() {\",\n        \"    }\",\n        \"\",\n        \"    public SimpleComponent build() {\",\n        \"      return new DaggerSimpleComponent(this);\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(injectableTypeFile, injectedTypeFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void injectionWithGenericBaseClass() {\n    JavaFileObject genericType \u003d JavaFileObjects.forSourceLines(\"test.AbstractGenericType\",\n        \"package test;\",\n        \"\",\n        \"abstract class AbstractGenericType\u003cT\u003e {\",\n        \"}\");\n    JavaFileObject injectableTypeFile \u003d JavaFileObjects.forSourceLines(\"test.SomeInjectableType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class SomeInjectableType extends AbstractGenericType\u003cString\u003e {\",\n        \"  @Inject SomeInjectableType() {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface SimpleComponent {\",\n        \"  SomeInjectableType someInjectableType();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\n        \"test.DaggerSimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.MembersInjectors;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class DaggerSimpleComponent implements SimpleComponent {\",\n        \"  private Provider\u003cSomeInjectableType\u003e someInjectableTypeProvider;\",\n        \"\",\n        \"  private DaggerSimpleComponent(Builder builder) {\",\n        \"    assert builder !\u003d null;\",\n        \"    initialize(builder);\",\n        \"  }\",\n        \"\",\n        \"  public static Builder builder() {\",\n        \"    return new Builder();\",\n        \"  }\",\n        \"\",\n        \"  public static SimpleComponent create() {\",\n        \"    return builder().build();\",\n        \"  }\",\n        \"\",\n        \"  @SuppressWarnings(\\\"unchecked\\\")\",\n        \"  private void initialize(final Builder builder) {\",\n        \"    this.someInjectableTypeProvider \u003d\",\n        \"        SomeInjectableType_Factory.create(MembersInjectors.\u003cSomeInjectableType\u003enoOp());\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public SomeInjectableType someInjectableType() {\",\n        \"    return someInjectableTypeProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static final class Builder {\",\n        \"    private Builder() {\",\n        \"    }\",\n        \"\",\n        \"    public SimpleComponent build() {\",\n        \"      return new DaggerSimpleComponent(this);\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(genericType, injectableTypeFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void componentDependency() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject A() {}\",\n        \"}\");\n    JavaFileObject bFile \u003d JavaFileObjects.forSourceLines(\"test.B\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class B {\",\n        \"  @Inject B(A a) {}\",\n        \"}\");\n    JavaFileObject aComponentFile \u003d JavaFileObjects.forSourceLines(\"test.AComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface AComponent {\",\n        \"  A a();\",\n        \"}\");\n    JavaFileObject bComponentFile \u003d JavaFileObjects.forSourceLines(\"test.AComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component(dependencies \u003d AComponent.class)\",\n        \"interface BComponent {\",\n        \"  B b();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\n        \"test.DaggerBComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import dagger.internal.Preconditions;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class DaggerBComponent implements BComponent {\",\n        \"  private Provider\u003cA\u003e aProvider;\",\n        \"  private Provider\u003cB\u003e bProvider;\",\n        \"\",\n        \"  private DaggerBComponent(Builder builder) {\",\n        \"    assert builder !\u003d null;\",\n        \"    initialize(builder);\",\n        \"  }\",\n        \"\",\n        \"  public static Builder builder() {\",\n        \"    return new Builder();\",\n        \"  }\",\n        \"\",\n        \"  @SuppressWarnings(\\\"unchecked\\\")\",\n        \"  private void initialize(final Builder builder) {\",\n        \"    this.aProvider \u003d new Factory\u003cA\u003e() {\",\n        \"      private final AComponent aComponent \u003d builder.aComponent;\",\n        \"      @Override public A get() {\",\n        \"        return Preconditions.checkNotNull(aComponent.a(), \" + NPE_LITERAL + \");\",\n        \"      }\",\n        \"    };\",\n        \"    this.bProvider \u003d B_Factory.create(aProvider);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public B b() {\",\n        \"    return bProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static final class Builder {\",\n        \"    private AComponent aComponent;\",\n        \"\",\n        \"    private Builder() {\",\n        \"    }\",\n        \"\",\n        \"    public BComponent build() {\",\n        \"      if (aComponent \u003d\u003d null) {\",\n        \"        throw new IllegalStateException(AComponent.class.getCanonicalName()\",\n        \"            + \\\" must be set\\\");\",\n        \"      }\",\n        \"      return new DaggerBComponent(this);\",\n        \"    }\",\n        \"\",\n        \"    public Builder aComponent(AComponent aComponent) {\",\n        \"      this.aComponent \u003d Preconditions.checkNotNull(aComponent);\",\n        \"      return this;\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(aFile, bFile, aComponentFile, bComponentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void moduleNameCollision() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"public final class A {}\");\n    JavaFileObject otherAFile \u003d JavaFileObjects.forSourceLines(\"other.test.A\",\n        \"package other.test;\",\n        \"\",\n        \"public final class A {}\");\n\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"public final class TestModule {\",\n        \"  @Provides A a() { return null; }\",\n        \"}\");\n    JavaFileObject otherModuleFile \u003d JavaFileObjects.forSourceLines(\"other.test.TestModule\",\n        \"package other.test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"public final class TestModule {\",\n        \"  @Provides A a() { return null; }\",\n        \"}\");\n\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component(modules \u003d {TestModule.class, other.test.TestModule.class})\",\n        \"interface TestComponent {\",\n        \"  A a();\",\n        \"  other.test.A otherA();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\n        \"test.DaggerTestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Preconditions;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class DaggerTestComponent implements TestComponent {\",\n        \"  private Provider\u003cA\u003e aProvider;\",\n        \"  private Provider\u003cother.test.A\u003e aProvider2;\",\n        \"\",\n        \"  private DaggerTestComponent(Builder builder) {\",\n        \"    assert builder !\u003d null;\",\n        \"    initialize(builder);\",\n        \"  }\",\n        \"\",\n        \"  public static Builder builder() {\",\n        \"    return new Builder();\",\n        \"  }\",\n        \"\",\n        \"  public static TestComponent create() {\",\n        \"    return builder().build();\",\n        \"  }\",\n        \"\",\n        \"  @SuppressWarnings(\\\"unchecked\\\")\",\n        \"  private void initialize(final Builder builder) {\",\n        \"    this.aProvider \u003d TestModule_AFactory.create(builder.testModule);\",\n        \"    this.aProvider2 \u003d other.test.TestModule_AFactory.create(builder.testModule2);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public A a() {\",\n        \"    return aProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public other.test.A otherA() {\",\n        \"    return aProvider2.get();\",\n        \"  }\",\n        \"\",\n        \"  public static final class Builder {\",\n        \"    private TestModule testModule;\",\n        \"    private other.test.TestModule testModule2;\",\n        \"\",\n        \"    private Builder() {\",\n        \"    }\",\n        \"\",\n        \"    public TestComponent build() {\",\n        \"      if (testModule \u003d\u003d null) {\",\n        \"        this.testModule \u003d new TestModule();\",\n        \"      }\",\n        \"      if (testModule2 \u003d\u003d null) {\",\n        \"        this.testModule2 \u003d new other.test.TestModule();\",\n        \"      }\",\n        \"      return new DaggerTestComponent(this);\",\n        \"    }\",\n        \"\",\n        \"    public Builder testModule(TestModule testModule) {\",\n        \"      this.testModule \u003d Preconditions.checkNotNull(testModule);\",\n        \"      return this;\",\n        \"    }\",\n        \"\",\n        \"    public Builder testModule(other.test.TestModule testModule) {\",\n        \"      this.testModule2 \u003d Preconditions.checkNotNull(testModule);\",\n        \"      return this;\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(aFile, otherAFile, moduleFile, otherModuleFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void resolutionOrder() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject A(B b) {}\",\n        \"}\");\n    JavaFileObject bFile \u003d JavaFileObjects.forSourceLines(\"test.B\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class B {\",\n        \"  @Inject B(C c) {}\",\n        \"}\");\n    JavaFileObject cFile \u003d JavaFileObjects.forSourceLines(\"test.C\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class C {\",\n        \"  @Inject C() {}\",\n        \"}\");\n    JavaFileObject xFile \u003d JavaFileObjects.forSourceLines(\"test.X\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class X {\",\n        \"  @Inject X(C c) {}\",\n        \"}\");\n\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface TestComponent {\",\n        \"  A a();\",\n        \"  C c();\",\n        \"  X x();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerTestComponent\",\n            \"package test;\",\n            \"\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerTestComponent implements TestComponent {\",\n            \"  private Provider\u003cB\u003e bProvider;\",\n            \"  private Provider\u003cA\u003e aProvider;\",\n            \"  private Provider\u003cX\u003e xProvider;\",\n            \"\",\n            \"  private DaggerTestComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static TestComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.bProvider \u003d B_Factory.create(C_Factory.create());\",\n            \"    this.aProvider \u003d A_Factory.create(bProvider);\",\n            \"    this.xProvider \u003d X_Factory.create(C_Factory.create());\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public A a() {\",\n            \"    return aProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public C c() {\",\n            \"    return new C();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public X x() {\",\n            \"    return xProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public TestComponent build() {\",\n            \"      return new DaggerTestComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(aFile, bFile, cFile, xFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void simpleComponent_redundantComponentMethod() {\n    JavaFileObject injectableTypeFile \u003d JavaFileObjects.forSourceLines(\"test.SomeInjectableType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class SomeInjectableType {\",\n        \"  @Inject SomeInjectableType() {}\",\n        \"}\");\n    JavaFileObject componentSupertypeAFile \u003d JavaFileObjects.forSourceLines(\"test.SupertypeA\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface SupertypeA {\",\n        \"  SomeInjectableType someInjectableType();\",\n        \"}\");\n    JavaFileObject componentSupertypeBFile \u003d JavaFileObjects.forSourceLines(\"test.SupertypeB\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface SupertypeB {\",\n        \"  SomeInjectableType someInjectableType();\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface SimpleComponent extends SupertypeA, SupertypeB {\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerSimpleComponent\",\n            \"package test;\",\n            \"\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerSimpleComponent implements SimpleComponent {\",\n            \"  private DaggerSimpleComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static SimpleComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public SomeInjectableType someInjectableType() {\",\n            \"    return new SomeInjectableType();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public SimpleComponent build() {\",\n            \"      return new DaggerSimpleComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(\n            injectableTypeFile, componentSupertypeAFile, componentSupertypeBFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void simpleComponent_inheritedComponentMethodDep() {\n    JavaFileObject injectableTypeFile \u003d JavaFileObjects.forSourceLines(\"test.SomeInjectableType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class SomeInjectableType {\",\n        \"  @Inject SomeInjectableType() {}\",\n        \"}\");\n    JavaFileObject componentSupertype \u003d JavaFileObjects.forSourceLines(\"test.Supertype\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface Supertype {\",\n        \"  SomeInjectableType someInjectableType();\",\n        \"}\");\n    JavaFileObject depComponentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface SimpleComponent extends Supertype {\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.ComponentWithDep\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component(dependencies \u003d SimpleComponent.class)\",\n        \"interface ComponentWithDep {\",\n        \"  SomeInjectableType someInjectableType();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerSimpleComponent\",\n            \"package test;\",\n            \"\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerSimpleComponent implements SimpleComponent {\",\n            \"  private DaggerSimpleComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static SimpleComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public SomeInjectableType someInjectableType() {\",\n            \"    return new SomeInjectableType();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public SimpleComponent build() {\",\n            \"      return new DaggerSimpleComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(\n            injectableTypeFile, componentSupertype, depComponentFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void wildcardGenericsRequiresAtProvides() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject A() {}\",\n        \"}\");\n    JavaFileObject bFile \u003d JavaFileObjects.forSourceLines(\"test.B\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"final class B\u003cT\u003e {\",\n        \"  @Inject B(T t) {}\",\n        \"}\");\n    JavaFileObject cFile \u003d JavaFileObjects.forSourceLines(\"test.C\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"final class C {\",\n        \"  @Inject C(B\u003c? extends A\u003e bA) {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface SimpleComponent {\",\n        \"  C c();\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, cFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"test.B\u003c? extends test.A\u003e cannot be provided without an @Provides-annotated method\");\n  }\n\n  @Test\n  public void componentImplicitlyDependsOnGeneratedType() {\n    JavaFileObject injectableTypeFile \u003d JavaFileObjects.forSourceLines(\"test.SomeInjectableType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class SomeInjectableType {\",\n        \"  @Inject SomeInjectableType(GeneratedType generatedType) {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface SimpleComponent {\",\n        \"  SomeInjectableType someInjectableType();\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(injectableTypeFile, componentFile))\n        .processedWith(\n            new ComponentProcessor(),\n            new GeneratingProcessor(\n                \"test.GeneratedType\",\n                \"package test;\",\n                \"\",\n                \"import javax.inject.Inject;\",\n                \"\",\n                \"final class GeneratedType {\",\n                \"  @Inject GeneratedType() {}\",\n                \"}\"))\n        .compilesWithoutError()\n        .and()\n        .generatesFileNamed(SOURCE_OUTPUT, \"test\", \"DaggerSimpleComponent.java\");\n  }\n\n  @Test\n  public void componentSupertypeDependsOnGeneratedType() {\n    JavaFileObject componentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.SimpleComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component\",\n            \"interface SimpleComponent extends SimpleComponentInterface {}\");\n    JavaFileObject interfaceFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.SimpleComponentInterface\",\n            \"package test;\",\n            \"\",\n            \"interface SimpleComponentInterface {\",\n            \"  GeneratedType generatedType();\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(componentFile, interfaceFile))\n        .processedWith(\n            new ComponentProcessor(),\n            new GeneratingProcessor(\n                \"test.GeneratedType\",\n                \"package test;\",\n                \"\",\n                \"import javax.inject.Inject;\",\n                \"\",\n                \"final class GeneratedType {\",\n                \"  @Inject GeneratedType() {}\",\n                \"}\"))\n        .compilesWithoutError()\n        .and()\n        .generatesFileNamed(SOURCE_OUTPUT, \"test\", \"DaggerSimpleComponent.java\");\n  }\n\n  @Test\n  @Ignore // modify this test as necessary while debugging for your situation.\n  @SuppressWarnings(\"unused\")\n  public void genericTestToLetMeDebugInEclipse() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n         \"import javax.inject.Inject;\",\n         \"\",\n         \"public final class A {\",\n         \"  @Inject A() {}\",\n         \"}\");\n     JavaFileObject bFile \u003d JavaFileObjects.forSourceLines(\"test.B\",\n         \"package test;\",\n         \"\",\n         \"import javax.inject.Inject;\",\n         \"import javax.inject.Provider;\",\n         \"\",\n         \"public class B\u003cT\u003e {\",\n         \"  @Inject B() {}\",\n         \"}\");\n     JavaFileObject dFile \u003d JavaFileObjects.forSourceLines(\"test.sub.D\",\n         \"package test.sub;\",\n         \"\",\n         \"import javax.inject.Inject;\",\n         \"import javax.inject.Provider;\",\n         \"import test.B;\",\n         \"\",\n         \"public class D {\",\n         \"  @Inject D(B\u003cA.InA\u003e ba) {}\",\n         \"}\");\n     JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.SimpleComponent\",\n         \"package test;\",\n         \"\",\n         \"import dagger.Component;\",\n         \"import dagger.Lazy;\",\n         \"\",\n         \"import javax.inject.Provider;\",\n         \"\",\n         \"@Component\",\n         \"interface SimpleComponent {\",\n         \"  B\u003cA\u003e d();\",\n         \"  Provider\u003cB\u003cA\u003e\u003e d2();\",\n         \"}\");\n     JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\n         \"test.DaggerSimpleComponent\",\n         \"package test;\",\n         \"\",\n         \"import javax.annotation.Generated;\",\n         \"import javax.inject.Provider;\",\n         \"\",\n         GENERATED_ANNOTATION,\n         \"public final class DaggerSimpleComponent implements SimpleComponent {\",\n         \"  private Provider\u003cD\u003e dProvider;\",\n         \"\",\n         \"  private DaggerSimpleComponent(Builder builder) {\",\n         \"    assert builder !\u003d null;\",\n         \"    initialize(builder);\",\n         \"  }\",\n         \"\",\n         \"  public static Builder builder() {\",\n         \"    return new Builder();\",\n         \"  }\",\n         \"\",\n         \"  public static SimpleComponent create() {\",\n         \"    return builder().build();\",\n         \"  }\",\n         \"\",\n         \"  @SuppressWarnings(\\\"unchecked\\\")\",\n         \"  private void initialize(final Builder builder) {\",\n         \"    this.dProvider \u003d new D_Factory(B_Factory.INSTANCE);\",\n         \"  }\",\n         \"\",\n         \"  @Override\",\n         \"  public D d() {\",\n         \"    return dProvider.get();\",\n         \"  }\",\n         \"\",\n         \"  public static final class Builder {\",\n         \"    private Builder() {\",\n         \"    }\",\n         \"\",\n         \"    public SimpleComponent build() {\",\n         \"      return new DaggerSimpleComponent(this);\",\n         \"    }\",\n         \"  }\",\n         \"}\");\n     assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile, componentFile))\n         .processedWith(new ComponentProcessor())\n         .compilesWithoutError()\n         .and().generatesSources(generatedComponent);\n   }\n\n  /**\n   * We warn when generating a {@link MembersInjector} for a type post-hoc (i.e., if Dagger wasn\u0027t\n   * invoked when compiling the type). But Dagger only generates {@link MembersInjector}s for types\n   * with {@link Inject @Inject} constructors if they have any injection sites, and it only\n   * generates them for types without {@link Inject @Inject} constructors if they have local\n   * (non-inherited) injection sites. So make sure we warn in only those cases where running the\n   * Dagger processor actually generates a {@link MembersInjector}.\n   */\n  @Test\n  public void unprocessedMembersInjectorNotes() {\n    assertAbout(javaSources())\n        .that(\n            ImmutableList.of(\n                JavaFileObjects.forSourceLines(\n                    \"test.TestComponent\",\n                    \"package test;\",\n                    \"\",\n                    \"import dagger.Component;\",\n                    \"\",\n                    \"@Component(modules \u003d TestModule.class)\",\n                    \"interface TestComponent {\",\n                    \"  void inject(test.inject.NoInjectMemberNoConstructor object);\",\n                    \"  void inject(test.inject.NoInjectMemberWithConstructor object);\",\n                    \"  void inject(test.inject.LocalInjectMemberNoConstructor object);\",\n                    \"  void inject(test.inject.LocalInjectMemberWithConstructor object);\",\n                    \"  void inject(test.inject.ParentInjectMemberNoConstructor object);\",\n                    \"  void inject(test.inject.ParentInjectMemberWithConstructor object);\",\n                    \"}\"),\n                JavaFileObjects.forSourceLines(\n                    \"test.TestModule\",\n                    \"package test;\",\n                    \"\",\n                    \"import dagger.Module;\",\n                    \"import dagger.Provides;\",\n                    \"\",\n                    \"@Module\",\n                    \"class TestModule {\",\n                    \"  @Provides static Object object() {\",\n                    \"    return \\\"object\\\";\",\n                    \"  }\",\n                    \"}\"),\n                JavaFileObjects.forSourceLines(\n                    \"test.inject.NoInjectMemberNoConstructor\",\n                    \"package test.inject;\",\n                    \"\",\n                    \"public class NoInjectMemberNoConstructor {\",\n                    \"}\"),\n                JavaFileObjects.forSourceLines(\n                    \"test.inject.NoInjectMemberWithConstructor\",\n                    \"package test.inject;\",\n                    \"\",\n                    \"import javax.inject.Inject;\",\n                    \"\",\n                    \"public class NoInjectMemberWithConstructor {\",\n                    \"  @Inject NoInjectMemberWithConstructor() {}\",\n                    \"}\"),\n                JavaFileObjects.forSourceLines(\n                    \"test.inject.LocalInjectMemberNoConstructor\",\n                    \"package test.inject;\",\n                    \"\",\n                    \"import javax.inject.Inject;\",\n                    \"\",\n                    \"public class LocalInjectMemberNoConstructor {\",\n                    \"  @Inject Object object;\",\n                    \"}\"),\n                JavaFileObjects.forSourceLines(\n                    \"test.inject.LocalInjectMemberWithConstructor\",\n                    \"package test.inject;\",\n                    \"\",\n                    \"import javax.inject.Inject;\",\n                    \"\",\n                    \"public class LocalInjectMemberWithConstructor {\",\n                    \"  @Inject LocalInjectMemberWithConstructor() {}\",\n                    \"  @Inject Object object;\",\n                    \"}\"),\n                JavaFileObjects.forSourceLines(\n                    \"test.inject.ParentInjectMemberNoConstructor\",\n                    \"package test.inject;\",\n                    \"\",\n                    \"import javax.inject.Inject;\",\n                    \"\",\n                    \"public class ParentInjectMemberNoConstructor\",\n                    \"    extends LocalInjectMemberNoConstructor {}\"),\n                JavaFileObjects.forSourceLines(\n                    \"test.inject.ParentInjectMemberWithConstructor\",\n                    \"package test.inject;\",\n                    \"\",\n                    \"import javax.inject.Inject;\",\n                    \"\",\n                    \"public class ParentInjectMemberWithConstructor\",\n                    \"    extends LocalInjectMemberNoConstructor {\",\n                    \"  @Inject ParentInjectMemberWithConstructor() {}\",\n                    \"}\")))\n        .withCompilerOptions(\"-Xlint:-processing\")\n        .processedWith(\n            new ElementFilteringComponentProcessor(\n                Predicates.not(\n                    element -\u003e\n                        MoreElements.getPackage(element)\n                            .getQualifiedName()\n                            .contentEquals(\"test.inject\"))))\n        .compilesWithoutWarnings()\n        .withNoteContaining(\n            \"Generating a MembersInjector for \"\n                + \"test.inject.LocalInjectMemberNoConstructor. \"\n                + \"Prefer to run the dagger processor over that class instead.\")\n        .and()\n        .withNoteContaining(\n            \"Generating a MembersInjector for \"\n                + \"test.inject.LocalInjectMemberWithConstructor. \"\n                + \"Prefer to run the dagger processor over that class instead.\")\n        .and()\n        .withNoteContaining(\n            \"Generating a MembersInjector for \"\n                + \"test.inject.ParentInjectMemberWithConstructor. \"\n                + \"Prefer to run the dagger processor over that class instead.\")\n        .and()\n        .withNoteCount(3);\n  }\n\n  @Test\n  public void scopeAnnotationOnInjectConstructorNotValid() {\n    JavaFileObject aScope \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.AScope\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Scope;\",\n            \"\",\n            \"@Scope\",\n            \"@interface AScope {}\");\n    JavaFileObject aClass \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.AClass\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class AClass {\",\n            \"  @Inject @AScope AClass() {}\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(aScope, aClass))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"@Scope annotations are not allowed on @Inject constructors.\")\n        .in(aClass)\n        .onLine(6);\n  }\n\n  @Test\n  public void attemptToInjectWildcardGenerics() {\n    JavaFileObject testComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import dagger.Lazy;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            \"@Component\",\n            \"interface TestComponent {\",\n            \"  Lazy\u003c? extends Number\u003e wildcardNumberLazy();\",\n            \"  Provider\u003c? super Number\u003e wildcardNumberProvider();\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(asList(testComponent))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"wildcard type\")\n        .in(testComponent)\n        .onLine(9)\n        .and()\n        .withErrorContaining(\"wildcard type\")\n        .in(testComponent)\n        .onLine(10);\n  }\n\n  @Test\n  public void unusedSubcomponents_dontResolveExtraBindingsInParentComponents() {\n    JavaFileObject foo \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Foo\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"import javax.inject.Singleton;\",\n            \"\",\n            \"@Singleton\",\n            \"class Foo {\",\n            \"  @Inject Foo() {}\",\n            \"}\");\n\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"\",\n            \"@Module(subcomponents \u003d Pruned.class)\",\n            \"class TestModule {}\");\n\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Parent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import javax.inject.Singleton;\",\n            \"\",\n            \"@Singleton\",\n            \"@Component(modules \u003d TestModule.class)\",\n            \"interface Parent {}\");\n\n    JavaFileObject prunedSubcomponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Pruned\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent\",\n            \"interface Pruned {\",\n            \"  @Subcomponent.Builder\",\n            \"  interface Builder {\",\n            \"    Pruned build();\",\n            \"  }\",\n            \"\",\n            \"  Foo foo();\",\n            \"}\");\n    JavaFileObject generated \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerParent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.Preconditions;\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerParent implements Parent {\",\n            \"  private DaggerParent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static Parent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {}\",\n            \"\",\n            \"    public Parent build() {\",\n            \"      return new DaggerParent(this);\",\n            \"    }\",\n            \"\",\n            \"    @Deprecated\",\n            \"    public Builder testModule(TestModule testModule) {\",\n            \"      Preconditions.checkNotNull(testModule);\",\n            \"      return this;\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n\n    assertThat(foo, module, component, prunedSubcomponent)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(generated);\n  }\n\n  public void invalidComponentDependencies() {\n    JavaFileObject testComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(dependencies \u003d int.class)\",\n            \"interface TestComponent {}\");\n    assertAbout(javaSources())\n        .that(asList(testComponent))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"int is not a valid component dependency type\");\n  }\n\n  @Test\n  public void invalidComponentModules() {\n    JavaFileObject testComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d int.class)\",\n            \"interface TestComponent {}\");\n    assertAbout(javaSources())\n        .that(asList(testComponent))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"int is not a valid module type\");\n  }\n\n  /**\n   * A {@link ComponentProcessor} that excludes elements using a {@link Predicate}.\n   */\n  private static final class ElementFilteringComponentProcessor extends AbstractProcessor {\n    private final ComponentProcessor componentProcessor \u003d new ComponentProcessor();\n    private final Predicate\u003c? super Element\u003e filter;\n\n    /**\n     * Creates a {@link ComponentProcessor} that only processes elements that match {@code filter}.\n     */\n    public ElementFilteringComponentProcessor(Predicate\u003c? super Element\u003e filter) {\n      this.filter \u003d filter;\n    }\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n      super.init(processingEnv);\n      componentProcessor.init(processingEnv);\n    }\n\n    @Override\n    public Set\u003cString\u003e getSupportedAnnotationTypes() {\n      return componentProcessor.getSupportedAnnotationTypes();\n    }\n\n    @Override\n    public SourceVersion getSupportedSourceVersion() {\n      return componentProcessor.getSupportedSourceVersion();\n    }\n\n    @Override\n    public boolean process(\n        Set\u003c? extends TypeElement\u003e annotations, final RoundEnvironment roundEnv) {\n      return componentProcessor.process(\n          annotations,\n          new RoundEnvironment() {\n            @Override\n            public boolean processingOver() {\n              return roundEnv.processingOver();\n            }\n\n            @Override\n            public Set\u003c? extends Element\u003e getRootElements() {\n              return Sets.filter(roundEnv.getRootElements(), filter);\n            }\n\n            @Override\n            public Set\u003c? extends Element\u003e getElementsAnnotatedWith(Class\u003c? extends Annotation\u003e a) {\n              return Sets.filter(roundEnv.getElementsAnnotatedWith(a), filter);\n            }\n\n            @Override\n            public Set\u003c? extends Element\u003e getElementsAnnotatedWith(TypeElement a) {\n              return Sets.filter(roundEnv.getElementsAnnotatedWith(a), filter);\n            }\n\n            @Override\n            public boolean errorRaised() {\n              return roundEnv.errorRaised();\n            }\n          });\n    }\n  }\n\n  /**\n   * A simple {@link Processor} that generates one source file.\n   */\n  private static final class GeneratingProcessor extends AbstractProcessor {\n    private final String generatedClassName;\n    private final String generatedSource;\n    private boolean processed;\n\n    GeneratingProcessor(String generatedClassName, String... source) {\n      this.generatedClassName \u003d generatedClassName;\n      this.generatedSource \u003d Joiner.on(\"\\n\").join(source);\n    }\n\n    @Override\n    public Set\u003cString\u003e getSupportedAnnotationTypes() {\n      return ImmutableSet.of(\"*\");\n    }\n\n    @Override\n    public boolean process(Set\u003c? extends TypeElement\u003e annotations, RoundEnvironment roundEnv) {\n      if (!processed) {\n        processed \u003d true;\n        try (Writer writer \u003d\n                processingEnv.getFiler().createSourceFile(generatedClassName).openWriter()) {\n          writer.append(generatedSource);\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return false;\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\DaggerModuleMethodSubject.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\n\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.truth.FailureStrategy;\nimport com.google.common.truth.Subject;\nimport com.google.common.truth.SubjectFactory;\nimport com.google.common.truth.Truth;\nimport com.google.testing.compile.JavaFileObjects;\nimport dagger.Module;\nimport dagger.Multibindings;\nimport dagger.producers.ProducerModule;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.Arrays;\nimport java.util.List;\nimport javax.tools.JavaFileObject;\n\n/** A {@link Truth} subject for testing Dagger module methods. */\nfinal class DaggerModuleMethodSubject extends Subject\u003cDaggerModuleMethodSubject, String\u003e {\n\n  /** A {@link Truth} subject factory for testing Dagger module methods. */\n  static final class Factory extends SubjectFactory\u003cDaggerModuleMethodSubject, String\u003e {\n\n    /** Starts a clause testing a Dagger {@link Module @Module} method. */\n    static DaggerModuleMethodSubject assertThatModuleMethod(String method) {\n      return assertAbout(daggerModuleMethod())\n          .that(method)\n          .withDeclaration(\"@Module abstract class %s { %s }\");\n    }\n\n    /** Starts a clause testing a Dagger {@link ProducerModule @ProducerModule} method. */\n    static DaggerModuleMethodSubject assertThatProductionModuleMethod(String method) {\n      return assertAbout(daggerModuleMethod())\n          .that(method)\n          .withDeclaration(\"@ProducerModule abstract class %s { %s }\");\n    }\n\n    /** Starts a clause testing a Dagger {@link Multibindings @Multibindings} interface method. */\n    static DaggerModuleMethodSubject assertThatMultibindingsMethod(String method) {\n      return assertAbout(daggerModuleMethod())\n          .that(method)\n          .withDeclaration(\"@Module abstract class %s { @Multibindings interface Empties { %s }}\");\n    }\n\n    /** Starts a clause testing a method in an unannotated class. */\n    static DaggerModuleMethodSubject assertThatMethodInUnannotatedClass(String method) {\n      return assertAbout(daggerModuleMethod())\n          .that(method)\n          .withDeclaration(\"abstract class %s { %s }\");\n    }\n\n    static Factory daggerModuleMethod() {\n      return new Factory();\n    }\n\n    private Factory() {}\n\n    @Override\n    public DaggerModuleMethodSubject getSubject(FailureStrategy fs, String that) {\n      return new DaggerModuleMethodSubject(fs, that);\n    }\n  }\n\n  private ImmutableList.Builder\u003cString\u003e imports \u003d\n      new ImmutableList.Builder\u003cString\u003e()\n          .add(\n              \"import dagger.*;\",\n              \"import dagger.multibindings.*;\",\n              \"import dagger.producers.*;\",\n              \"import java.util.*;\",\n              \"import javax.inject.*;\");\n  private String declaration;\n  private ImmutableList\u003cJavaFileObject\u003e additionalSources \u003d ImmutableList.of();\n\n  private DaggerModuleMethodSubject(FailureStrategy failureStrategy, String subject) {\n    super(failureStrategy, subject);\n  }\n\n  /**\n   * Imports classes and interfaces. Note that all types in the following packages are already\n   * imported:\u003cul\u003e\n   * \u003cli\u003e{@code dagger.*}\n   * \u003cli\u003e{@code dagger.multibindings.*}\n   * \u003cli\u003e(@code dagger.producers.*}\n   * \u003cli\u003e{@code java.util.*}\n   * \u003cli\u003e{@code javax.inject.*}\n   * \u003c/ul\u003e\n   */\n  DaggerModuleMethodSubject importing(Class\u003c?\u003e... imports) {\n    return importing(Arrays.asList(imports));\n  }\n\n  /**\n   * Imports classes and interfaces. Note that all types in the following packages are already\n   * imported:\u003cul\u003e\n   * \u003cli\u003e{@code dagger.*}\n   * \u003cli\u003e{@code dagger.multibindings.*}\n   * \u003cli\u003e(@code dagger.producers.*}\n   * \u003cli\u003e{@code java.util.*}\n   * \u003cli\u003e{@code javax.inject.*}\n   * \u003c/ul\u003e\n   */\n  DaggerModuleMethodSubject importing(List\u003c? extends Class\u003c?\u003e\u003e imports) {\n    imports.stream()\n        .map(clazz -\u003e String.format(\"import %s;\", clazz.getCanonicalName()))\n        .forEachOrdered(this.imports::add);\n    return this;\n  }\n\n  /**\n   * Sets the declaration of the module. Must be a string with two {@code %s} parameters. The first\n   * will be replaced with the name of the type, and the second with the method declaration, which\n   * must be within paired braces.\n   */\n  DaggerModuleMethodSubject withDeclaration(String declaration) {\n    this.declaration \u003d declaration;\n    return this;\n  }\n\n  /** Additional source files that must be compiled with the module. */\n  DaggerModuleMethodSubject withAdditionalSources(JavaFileObject... sources) {\n    this.additionalSources \u003d ImmutableList.copyOf(sources);\n    return this;\n  }\n\n  /**\n   * Fails if compiling the module with the method doesn\u0027t report an error at the method\n   * declaration whose message contains {@code errorSubstring}.\n   */\n  void hasError(String errorSubstring) {\n    String source \u003d moduleSource();\n    JavaFileObject module \u003d JavaFileObjects.forSourceLines(\"test.TestModule\", source);\n    assertAbout(javaSources())\n        .that(FluentIterable.from(additionalSources).append(module))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(errorSubstring)\n        .in(module)\n        .onLine(methodLine(source));\n  }\n\n  private int methodLine(String source) {\n    String beforeMethod \u003d source.substring(0, source.indexOf(actual()));\n    int methodLine \u003d 1;\n    for (int nextNewlineIndex \u003d beforeMethod.indexOf(\u0027\\n\u0027);\n        nextNewlineIndex \u003e\u003d 0;\n        nextNewlineIndex \u003d beforeMethod.indexOf(\u0027\\n\u0027, nextNewlineIndex + 1)) {\n      methodLine++;\n    }\n    return methodLine;\n  }\n\n  private String moduleSource() {\n    StringWriter stringWriter \u003d new StringWriter();\n    PrintWriter writer \u003d new PrintWriter(stringWriter);\n    writer.println(\"package test;\");\n    writer.println();\n    for (String importLine : imports.build()) {\n      writer.println(importLine);\n    }\n    writer.println();\n    writer.printf(declaration, \"TestModule\", \"\\n\" + actual() + \"\\n\");\n    writer.println();\n    return stringWriter.toString();\n  }\n\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\ErrorMessagesTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class ErrorMessagesTest {\n  @Test public void stripCommonTypePrefixes() {\n    String typeName \u003d \"com.google.common.collect.ImmutableList\u003cjava.lang.Boolean\u003e\";\n    assertThat(ErrorMessages.stripCommonTypePrefixes(typeName)).isEqualTo(\"ImmutableList\u003cBoolean\u003e\");\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\FrameworkFieldTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static dagger.internal.codegen.TypeNames.MEMBERS_INJECTOR;\nimport static dagger.internal.codegen.TypeNames.PROVIDER;\nimport static dagger.internal.codegen.TypeNames.membersInjectorOf;\nimport static dagger.internal.codegen.TypeNames.providerOf;\n\nimport com.google.testing.compile.CompilationRule;\nimport com.squareup.javapoet.ClassName;\nimport javax.inject.Inject;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/**\n * Test case for {@link FrameworkField}.\n */\n@RunWith(JUnit4.class)\npublic class FrameworkFieldTest {\n  @Rule public CompilationRule compilationRule \u003d new CompilationRule();\n\n  private ClassName xTypeName;\n\n  @Before public void setUp() {\n    xTypeName \u003d\n        ClassName.get(compilationRule.getElements().getTypeElement(X.class.getCanonicalName()));\n  }\n\n  @Test public void frameworkType() {\n    assertThat(FrameworkField.create(PROVIDER, xTypeName, \"test\").type())\n        .isEqualTo(providerOf(xTypeName));\n    assertThat(FrameworkField.create(MEMBERS_INJECTOR, xTypeName, \"test\").type())\n        .isEqualTo(membersInjectorOf(xTypeName));\n  }\n\n  @Test public void nameSuffix() {\n    assertThat(FrameworkField.create(PROVIDER, xTypeName, \"foo\").name())\n        .isEqualTo(\"fooProvider\");\n    assertThat(FrameworkField.create(PROVIDER, xTypeName, \"fooProvider\").name())\n        .isEqualTo(\"fooProvider\");\n  }\n\n  static final class X {\n    @Inject X() {}\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\GeneratedLines.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\n/**\n * Common lines outputted during code generation.\n */\npublic final class GeneratedLines {\n  public static final String GENERATED_ANNOTATION \u003d\n      \"@Generated(\"\n          + \"value \u003d \\\"dagger.internal.codegen.ComponentProcessor\\\", \"\n          + \"comments \u003d \\\"https://google.github.io/dagger\\\")\";\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\GraphValidationScopingTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static java.util.Arrays.asList;\n\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class GraphValidationScopingTest {\n  @Test public void componentWithoutScopeIncludesScopedBindings_Fail() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.MyComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Component(modules \u003d ScopedModule.class)\",\n        \"interface MyComponent {\",\n        \"  ScopedType string();\",\n        \"}\");\n    JavaFileObject typeFile \u003d JavaFileObjects.forSourceLines(\"test.ScopedType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Singleton\",\n        \"class ScopedType {\",\n        \"  @Inject ScopedType(String s, long l, float f) {}\",\n        \"}\");\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.ScopedModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Module\",\n        \"class ScopedModule {\",\n        \"  @Provides @Singleton String string() { return \\\"a string\\\"; }\",\n        \"  @Provides long integer() { return 0L; }\",\n        \"  @Provides float floatingPoint() { return 0.0f; }\",\n        \"}\");\n    String errorMessage \u003d \"test.MyComponent (unscoped) may not reference scoped bindings:\\n\"\n        + \"      @Provides @Singleton String test.ScopedModule.string()\\n\"\n        + \"      @Singleton class test.ScopedType\";\n    assertAbout(javaSources())\n        .that(asList(componentFile, typeFile, moduleFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(errorMessage);\n  }\n\n  @Test public void componentWithScopeIncludesIncompatiblyScopedBindings_Fail() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.MyComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Singleton\",\n        \"@Component(modules \u003d ScopedModule.class)\",\n        \"interface MyComponent {\",\n        \"  ScopedType string();\",\n        \"}\");\n    JavaFileObject scopeFile \u003d JavaFileObjects.forSourceLines(\"test.PerTest\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Scope;\",\n        \"\",\n        \"@Scope\",\n        \"@interface PerTest {}\");\n    JavaFileObject typeFile \u003d JavaFileObjects.forSourceLines(\"test.ScopedType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"@PerTest\", // incompatible scope\n        \"class ScopedType {\",\n        \"  @Inject ScopedType(String s, long l, float f) {}\",\n        \"}\");\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.ScopedModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Module\",\n        \"class ScopedModule {\",\n        \"  @Provides @PerTest String string() { return \\\"a string\\\"; }\", // incompatible scope\n        \"  @Provides long integer() { return 0L; }\", // unscoped - valid\n        \"  @Provides @Singleton float floatingPoint() { return 0.0f; }\", // same scope - valid\n        \"}\");\n    String errorMessage \u003d \"test.MyComponent scoped with @Singleton \"\n        + \"may not reference bindings with different scopes:\\n\"\n        + \"      @Provides @test.PerTest String test.ScopedModule.string()\\n\"\n        + \"      @test.PerTest class test.ScopedType\";\n    assertAbout(javaSources())\n        .that(asList(componentFile, scopeFile, typeFile, moduleFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(errorMessage);\n  }\n\n  @Test public void componentWithScopeMayDependOnOnlyOneScopedComponent() {\n    // If a scoped component will have dependencies, they must only include, at most, a single\n    // scoped component\n    JavaFileObject type \u003d JavaFileObjects.forSourceLines(\"test.SimpleType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class SimpleType {\",\n        \"  @Inject SimpleType() {}\",\n        \"  static class A { @Inject A() {} }\",\n        \"  static class B { @Inject B() {} }\",\n        \"}\");\n    JavaFileObject simpleScope \u003d JavaFileObjects.forSourceLines(\"test.SimpleScope\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Scope;\",\n        \"\",\n        \"@Scope @interface SimpleScope {}\");\n    JavaFileObject singletonScopedA \u003d JavaFileObjects.forSourceLines(\"test.SingletonComponentA\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Singleton\",\n        \"@Component\",\n        \"interface SingletonComponentA {\",\n        \"  SimpleType.A type();\",\n        \"}\");\n    JavaFileObject singletonScopedB \u003d JavaFileObjects.forSourceLines(\"test.SingletonComponentB\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Singleton\",\n        \"@Component\",\n        \"interface SingletonComponentB {\",\n        \"  SimpleType.B type();\",\n        \"}\");\n    JavaFileObject scopeless \u003d JavaFileObjects.forSourceLines(\"test.ScopelessComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface ScopelessComponent {\",\n        \"  SimpleType type();\",\n        \"}\");\n    JavaFileObject simpleScoped \u003d JavaFileObjects.forSourceLines(\"test.SimpleScopedComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@SimpleScope\",\n        \"@Component(dependencies \u003d {SingletonComponentA.class, SingletonComponentB.class})\",\n        \"interface SimpleScopedComponent {\",\n        \"  SimpleType.A type();\",\n        \"}\");\n    String errorMessage \u003d\n        \"@test.SimpleScope test.SimpleScopedComponent depends on more than one scoped component:\\n\"\n        + \"      @Singleton test.SingletonComponentA\\n\"\n        + \"      @Singleton test.SingletonComponentB\";\n    assertAbout(javaSources())\n        .that(\n            asList(type, simpleScope, simpleScoped, singletonScopedA, singletonScopedB, scopeless))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(errorMessage);\n  }\n\n  @Test public void componentWithoutScopeCannotDependOnScopedComponent() {\n    JavaFileObject type \u003d JavaFileObjects.forSourceLines(\"test.SimpleType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class SimpleType {\",\n        \"  @Inject SimpleType() {}\",\n        \"}\");\n    JavaFileObject scopedComponent \u003d JavaFileObjects.forSourceLines(\"test.ScopedComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Singleton\",\n        \"@Component\",\n        \"interface ScopedComponent {\",\n        \"  SimpleType type();\",\n        \"}\");\n    JavaFileObject unscopedComponent \u003d JavaFileObjects.forSourceLines(\"test.UnscopedComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Component(dependencies \u003d ScopedComponent.class)\",\n        \"interface UnscopedComponent {\",\n        \"  SimpleType type();\",\n        \"}\");\n    String errorMessage \u003d\n        \"test.UnscopedComponent (unscoped) cannot depend on scoped components:\\n\"\n        + \"      @Singleton test.ScopedComponent\";\n    assertAbout(javaSources())\n        .that(asList(type, scopedComponent, unscopedComponent))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(errorMessage);\n  }\n\n  @Test public void componentWithSingletonScopeMayNotDependOnOtherScope() {\n    // Singleton must be the widest lifetime of present scopes.\n    JavaFileObject type \u003d JavaFileObjects.forSourceLines(\"test.SimpleType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class SimpleType {\",\n        \"  @Inject SimpleType() {}\",\n        \"}\");\n    JavaFileObject simpleScope \u003d JavaFileObjects.forSourceLines(\"test.SimpleScope\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Scope;\",\n        \"\",\n        \"@Scope @interface SimpleScope {}\");\n    JavaFileObject simpleScoped \u003d JavaFileObjects.forSourceLines(\"test.SimpleScopedComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@SimpleScope\",\n        \"@Component\",\n        \"interface SimpleScopedComponent {\",\n        \"  SimpleType type();\",\n        \"}\");\n    JavaFileObject singletonScoped \u003d JavaFileObjects.forSourceLines(\"test.SingletonComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Singleton\",\n        \"@Component(dependencies \u003d SimpleScopedComponent.class)\",\n        \"interface SingletonComponent {\",\n        \"  SimpleType type();\",\n        \"}\");\n    String errorMessage \u003d\n        \"This @Singleton component cannot depend on scoped components:\\n\"\n        + \"      @test.SimpleScope test.SimpleScopedComponent\";\n    assertAbout(javaSources())\n        .that(asList(type, simpleScope, simpleScoped, singletonScoped))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(errorMessage);\n  }\n\n  @Test public void componentScopeAncestryMustNotCycle() {\n    // The dependency relationship of components is necessarily from shorter lifetimes to\n    // longer lifetimes.  The scoping annotations must reflect this, and so one cannot declare\n    // scopes on components such that they cycle.\n    JavaFileObject type \u003d JavaFileObjects.forSourceLines(\"test.SimpleType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class SimpleType {\",\n        \"  @Inject SimpleType() {}\",\n        \"}\");\n    JavaFileObject scopeA \u003d JavaFileObjects.forSourceLines(\"test.ScopeA\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Scope;\",\n        \"\",\n        \"@Scope @interface ScopeA {}\");\n    JavaFileObject scopeB \u003d JavaFileObjects.forSourceLines(\"test.ScopeB\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Scope;\",\n        \"\",\n        \"@Scope @interface ScopeB {}\");\n    JavaFileObject longLifetime \u003d JavaFileObjects.forSourceLines(\"test.ComponentLong\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@ScopeA\",\n        \"@Component\",\n        \"interface ComponentLong {\",\n        \"  SimpleType type();\",\n        \"}\");\n    JavaFileObject mediumLifetime \u003d JavaFileObjects.forSourceLines(\"test.ComponentMedium\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@ScopeB\",\n        \"@Component(dependencies \u003d ComponentLong.class)\",\n        \"interface ComponentMedium {\",\n        \"  SimpleType type();\",\n        \"}\");\n    JavaFileObject shortLifetime \u003d JavaFileObjects.forSourceLines(\"test.ComponentShort\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@ScopeA\",\n        \"@Component(dependencies \u003d ComponentMedium.class)\",\n        \"interface ComponentShort {\",\n        \"  SimpleType type();\",\n        \"}\");\n    String errorMessage \u003d\n        \"test.ComponentShort depends on scoped components in a non-hierarchical scope ordering:\\n\"\n        + \"      @test.ScopeA test.ComponentLong\\n\"\n        + \"      @test.ScopeB test.ComponentMedium\\n\"\n        + \"      @test.ScopeA test.ComponentShort\";\n    assertAbout(javaSources())\n        .that(asList(type, scopeA, scopeB, longLifetime, mediumLifetime, shortLifetime))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(errorMessage);\n  }\n\n  @Test\n  public void reusableNotAllowedOnComponent() {\n    JavaFileObject someComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.SomeComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import dagger.Reusable;\",\n            \"\",\n            \"@Reusable\",\n            \"@Component\",\n            \"interface SomeComponent {}\");\n    assertAbout(javaSource())\n        .that(someComponent)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"@Reusable cannot be applied to components or subcomponents.\")\n        .in(someComponent)\n        .onLine(6);\n  }\n\n  @Test\n  public void reusableNotAllowedOnSubcomponent() {\n    JavaFileObject someSubcomponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.SomeComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Reusable;\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Reusable\",\n            \"@Subcomponent\",\n            \"interface SomeSubcomponent {}\");\n    assertAbout(javaSource())\n        .that(someSubcomponent)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"@Reusable cannot be applied to components or subcomponents.\")\n        .in(someSubcomponent)\n        .onLine(6);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\GraphValidationTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;\nimport static com.google.testing.compile.JavaSourcesSubject.assertThat;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.ErrorMessages.nullableToNonNullable;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.JavaFileObjects;\nimport java.util.Arrays;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class GraphValidationTest {\n  private static final JavaFileObject NULLABLE \u003d\n      JavaFileObjects.forSourceLines(\n          \"test.Nullable\", // force one-string-per-line format\n          \"package test;\",\n          \"\",\n          \"public @interface Nullable {}\");\n\n  @Test public void componentOnConcreteClass() {\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.MyComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface MyComponent {\",\n        \"  Foo getFoo();\",\n        \"}\");\n    JavaFileObject injectable \u003d JavaFileObjects.forSourceLines(\"test.Foo\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class Foo {\",\n        \"  @Inject Foo(Bar bar) {}\",\n        \"}\");\n    JavaFileObject nonInjectable \u003d JavaFileObjects.forSourceLines(\"test.Bar\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"interface Bar {}\");\n    assertAbout(javaSources()).that(Arrays.asList(component, injectable, nonInjectable))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"test.Bar cannot be provided without an @Provides-annotated method.\")\n            .in(component).onLine(7);\n  }\n\n  @Test public void componentProvisionWithNoDependencyChain() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestClass\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import javax.inject.Qualifier;\",\n            \"\",\n            \"final class TestClass {\",\n            \"  @Qualifier @interface Q {}\",\n            \"  interface A {}\",\n            \"\",\n            \"  @Component()\",\n            \"  interface AComponent {\",\n            \"    A getA();\",\n            \"    @Q A qualifiedA();\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSource())\n        .that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"test.TestClass.A cannot be provided without an @Provides-annotated method.\")\n        .in(component)\n        .onLine(12)\n        .and()\n        .withErrorContaining(\n            \"@test.TestClass.Q test.TestClass.A \"\n                + \"cannot be provided without an @Provides-annotated method.\")\n        .in(component)\n        .onLine(13);\n  }\n\n  @Test public void constructorInjectionWithoutAnnotation() {\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.TestClass\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class TestClass {\",\n        \"  static class A {\",\n        \"    A() {}\",\n        \"  }\",\n        \"\",\n        \"  @Component()\",\n        \"  interface AComponent {\",\n        \"    A getA();\",\n        \"  }\",\n        \"}\");\n    String expectedError \u003d \"test.TestClass.A cannot be provided without an \"\n        + \"@Inject constructor or from an @Provides-annotated method.\";\n    assertAbout(javaSource()).that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError).in(component).onLine(15);\n  }\n\n  @Test public void membersInjectWithoutProvision() {\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.TestClass\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class TestClass {\",\n        \"  static class A {\",\n        \"    @Inject A() {}\",\n        \"  }\",\n        \"\",\n        \"  static class B {\",\n        \"    @Inject A a;\",\n        \"  }\",\n        \"\",\n        \"  @Component()\",\n        \"  interface AComponent {\",\n        \"    B getB();\",\n        \"  }\",\n        \"}\");\n    String expectedError \u003d \"test.TestClass.B cannot be provided without an \"\n        + \"@Inject constructor or from an @Provides-annotated method. \"\n        + \"This type supports members injection but cannot be implicitly provided.\";\n    assertAbout(javaSource()).that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError).in(component).onLine(19);\n  }\n\n  @Test\n  public void membersInjectDependsOnUnboundedType() {\n    JavaFileObject injectsUnboundedType \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.InjectsUnboundedType\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MembersInjector;\",\n            \"import java.util.ArrayList;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"class InjectsUnboundedType {\",\n            \"  @Inject MembersInjector\u003cArrayList\u003c?\u003e\u003e listInjector;\",\n            \"}\");\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component\",\n            \"interface TestComponent {\",\n            \"  void injectsUnboundedType(InjectsUnboundedType injects);\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(injectsUnboundedType, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            Joiner.on(\u0027\\n\u0027)\n                .join(\n                    \"Type parameters must be bounded for members injection.\"\n                        + \" ? required by java.util.ArrayList\u003c?\u003e, via:\",\n                    \"      dagger.MembersInjector\u003cjava.util.ArrayList\u003c?\u003e\u003e is injected at\",\n                    \"          test.InjectsUnboundedType.listInjector\",\n                    \"      test.InjectsUnboundedType is injected at\",\n                    \"          test.TestComponent.injectsUnboundedType(injects)\"))\n        .in(component)\n        .onLine(7);\n  }\n\n  @Test public void cyclicDependency() {\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.Outer\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class Outer {\",\n        \"  static class A {\",\n        \"    @Inject A(C cParam) {}\",\n        \"  }\",\n        \"\",\n        \"  static class B {\",\n        \"    @Inject B(A aParam) {}\",\n        \"  }\",\n        \"\",\n        \"  static class C {\",\n        \"    @Inject C(B bParam) {}\",\n        \"  }\",\n        \"\",\n        \"  @Component()\",\n        \"  interface CComponent {\",\n        \"    C getC();\",\n        \"  }\",\n        \"}\");\n\n    String expectedError \u003d\n        Joiner.on(\u0027\\n\u0027)\n            .join(\n                \"test.Outer.CComponent.getC() contains a dependency cycle:\",\n                \"      test.Outer.C is injected at\",\n                \"          test.Outer.A.\u003cinit\u003e(cParam)\",\n                \"      test.Outer.A is injected at\",\n                \"          test.Outer.B.\u003cinit\u003e(aParam)\",\n                \"      test.Outer.B is injected at\",\n                \"          test.Outer.C.\u003cinit\u003e(bParam)\",\n                \"      test.Outer.C is provided at\",\n                \"          test.Outer.CComponent.getC()\");\n\n    assertAbout(javaSource()).that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError).in(component).onLine(23);\n  }\n\n  @Test public void cyclicDependencyNotIncludingEntryPoint() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Outer\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class Outer {\",\n            \"  static class A {\",\n            \"    @Inject A(C cParam) {}\",\n            \"  }\",\n            \"\",\n            \"  static class B {\",\n            \"    @Inject B(A aParam) {}\",\n            \"  }\",\n            \"\",\n            \"  static class C {\",\n            \"    @Inject C(B bParam) {}\",\n            \"  }\",\n            \"\",\n            \"  static class D {\",\n            \"    @Inject D(C cParam) {}\",\n            \"  }\",\n            \"\",\n            \"  @Component()\",\n            \"  interface DComponent {\",\n            \"    D getD();\",\n            \"  }\",\n            \"}\");\n\n    String expectedError \u003d\n        Joiner.on(\u0027\\n\u0027)\n            .join(\n                \"test.Outer.DComponent.getD() contains a dependency cycle:\",\n                \"      test.Outer.C is injected at\",\n                \"          test.Outer.A.\u003cinit\u003e(cParam)\",\n                \"      test.Outer.A is injected at\",\n                \"          test.Outer.B.\u003cinit\u003e(aParam)\",\n                \"      test.Outer.B is injected at\",\n                \"          test.Outer.C.\u003cinit\u003e(bParam)\",\n                \"      test.Outer.C is injected at\",\n                \"          test.Outer.D.\u003cinit\u003e(cParam)\",\n                \"      test.Outer.D is provided at\",\n                \"          test.Outer.DComponent.getD()\");\n\n    assertAbout(javaSource())\n        .that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError)\n        .in(component)\n        .onLine(27);\n  }\n\n  @Test\n  public void cyclicDependencyNotBrokenByMapBinding() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Outer\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import dagger.MapKey;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.IntoMap;\",\n            \"import java.util.Map;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class Outer {\",\n            \"  static class A {\",\n            \"    @Inject A(Map\u003cString, C\u003e cMap) {}\",\n            \"  }\",\n            \"\",\n            \"  static class B {\",\n            \"    @Inject B(A aParam) {}\",\n            \"  }\",\n            \"\",\n            \"  static class C {\",\n            \"    @Inject C(B bParam) {}\",\n            \"  }\",\n            \"\",\n            \"  @Component(modules \u003d CModule.class)\",\n            \"  interface CComponent {\",\n            \"    C getC();\",\n            \"  }\",\n            \"\",\n            \"  @Module\",\n            \"  static class CModule {\",\n            \"    @Provides @IntoMap\",\n            \"    @StringKey(\\\"C\\\")\",\n            \"    static C c(C c) {\",\n            \"      return c;\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  @MapKey\",\n            \"  @interface StringKey {\",\n            \"    String value();\",\n            \"  }\",\n            \"}\");\n\n    String expectedError \u003d\n        Joiner.on(\u0027\\n\u0027)\n            .join(\n                \"test.Outer.CComponent.getC() contains a dependency cycle:\",\n                \"      test.Outer.C is injected at\",\n                \"          test.Outer.CModule.c(c)\",\n                \"      java.util.Map\u003cjava.lang.String,test.Outer.C\u003e is injected at\",\n                \"          test.Outer.A.\u003cinit\u003e(cMap)\",\n                \"      test.Outer.A is injected at\",\n                \"          test.Outer.B.\u003cinit\u003e(aParam)\",\n                \"      test.Outer.B is injected at\",\n                \"          test.Outer.C.\u003cinit\u003e(bParam)\",\n                \"      test.Outer.C is provided at\",\n                \"          test.Outer.CComponent.getC()\");\n\n    assertAbout(javaSource())\n        .that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError)\n        .in(component)\n        .onLine(26);\n  }\n\n  @Test\n  public void cyclicDependencyWithSetBinding() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Outer\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.IntoSet;\",\n            \"import java.util.Set;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class Outer {\",\n            \"  static class A {\",\n            \"    @Inject A(Set\u003cC\u003e cSet) {}\",\n            \"  }\",\n            \"\",\n            \"  static class B {\",\n            \"    @Inject B(A aParam) {}\",\n            \"  }\",\n            \"\",\n            \"  static class C {\",\n            \"    @Inject C(B bParam) {}\",\n            \"  }\",\n            \"\",\n            \"  @Component(modules \u003d CModule.class)\",\n            \"  interface CComponent {\",\n            \"    C getC();\",\n            \"  }\",\n            \"\",\n            \"  @Module\",\n            \"  static class CModule {\",\n            \"    @Provides @IntoSet\",\n            \"    static C c(C c) {\",\n            \"      return c;\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n\n    String expectedError \u003d\n        Joiner.on(\u0027\\n\u0027)\n            .join(\n                \"test.Outer.CComponent.getC() contains a dependency cycle:\",\n                \"      test.Outer.C is injected at\",\n                \"          test.Outer.CModule.c(c)\",\n                \"      java.util.Set\u003ctest.Outer.C\u003e is injected at\",\n                \"          test.Outer.A.\u003cinit\u003e(cSet)\",\n                \"      test.Outer.A is injected at\",\n                \"          test.Outer.B.\u003cinit\u003e(aParam)\",\n                \"      test.Outer.B is injected at\",\n                \"          test.Outer.C.\u003cinit\u003e(bParam)\",\n                \"      test.Outer.C is provided at\",\n                \"          test.Outer.CComponent.getC()\");\n\n    assertAbout(javaSource())\n        .that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError)\n        .in(component)\n        .onLine(25);\n  }\n\n  @Test\n  public void falsePositiveCyclicDependencyIndirectionDetected() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Outer\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import javax.inject.Inject;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            \"final class Outer {\",\n            \"  static class A {\",\n            \"    @Inject A(C cParam) {}\",\n            \"  }\",\n            \"\",\n            \"  static class B {\",\n            \"    @Inject B(A aParam) {}\",\n            \"  }\",\n            \"\",\n            \"  static class C {\",\n            \"    @Inject C(B bParam) {}\",\n            \"  }\",\n            \"\",\n            \"  static class D {\",\n            \"    @Inject D(Provider\u003cC\u003e cParam) {}\",\n            \"  }\",\n            \"\",\n            \"  @Component()\",\n            \"  interface DComponent {\",\n            \"    D getD();\",\n            \"  }\",\n            \"}\");\n\n    String expectedError \u003d\n        Joiner.on(\u0027\\n\u0027)\n            .join(\n                \"test.Outer.DComponent.getD() contains a dependency cycle:\",\n                \"      test.Outer.C is injected at\",\n                \"          test.Outer.A.\u003cinit\u003e(cParam)\",\n                \"      test.Outer.A is injected at\",\n                \"          test.Outer.B.\u003cinit\u003e(aParam)\",\n                \"      test.Outer.B is injected at\",\n                \"          test.Outer.C.\u003cinit\u003e(bParam)\",\n                \"      javax.inject.Provider\u003ctest.Outer.C\u003e is injected at\",\n                \"          test.Outer.D.\u003cinit\u003e(cParam)\",\n                \"      test.Outer.D is provided at\",\n                \"          test.Outer.DComponent.getD()\");\n\n    assertAbout(javaSource())\n        .that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError)\n        .in(component)\n        .onLine(28);\n  }\n\n  @Test\n  public void circularBindsMethods() {\n    JavaFileObject qualifier \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.SomeQualifier\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Qualifier;\",\n            \"\",\n            \"@Qualifier @interface SomeQualifier {}\");\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Binds;\",\n            \"import dagger.Module;\",\n            \"\",\n            \"@Module\",\n            \"abstract class TestModule {\",\n            \"  @Binds abstract Object bindUnqualified(@SomeQualifier Object qualified);\",\n            \"  @Binds @SomeQualifier abstract Object bindQualified(Object unqualified);\",\n            \"}\");\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d TestModule.class)\",\n            \"interface TestComponent {\",\n            \"  Object unqualified();\",\n            \"  @SomeQualifier Object qualified();\",\n            \"}\");\n\n    assertThat(qualifier, module, component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"test.TestComponent.unqualified() contains a dependency cycle:\\n\"\n                + \"      java.lang.Object is injected at\\n\"\n                + \"          test.TestModule.bindQualified(unqualified)\\n\"\n                + \"      @test.SomeQualifier java.lang.Object is injected at\\n\"\n                + \"          test.TestModule.bindUnqualified(qualified)\\n\"\n                + \"      java.lang.Object is provided at\\n\"\n                + \"          test.TestComponent.unqualified()\")\n        .in(component)\n        .onLine(7)\n        .and()\n        .withErrorContaining(\n            \"test.TestComponent.qualified() contains a dependency cycle:\\n\"\n                + \"      @test.SomeQualifier java.lang.Object is injected at\\n\"\n                + \"          test.TestModule.bindUnqualified(qualified)\\n\"\n                + \"      java.lang.Object is injected at\\n\"\n                + \"          test.TestModule.bindQualified(unqualified)\\n\"\n                + \"      @test.SomeQualifier java.lang.Object is provided at\\n\"\n                + \"          test.TestComponent.qualified()\")\n        .in(component)\n        .onLine(8);\n  }\n\n  @Test\n  public void selfReferentialBinds() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Binds;\",\n            \"import dagger.Module;\",\n            \"\",\n            \"@Module\",\n            \"abstract class TestModule {\",\n            \"  @Binds abstract Object bindToSelf(Object sameKey);\",\n            \"}\");\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d TestModule.class)\",\n            \"interface TestComponent {\",\n            \"  Object selfReferential();\",\n            \"}\");\n\n    assertThat(module, component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            // TODO(gak): cl/126230644 produces a better error message in this case. Here it isn\u0027t\n            // unclear what is going wrong.\n            \"test.TestComponent.selfReferential() contains a dependency cycle:\\n\"\n                + \"      java.lang.Object is injected at\\n\"\n                + \"          test.TestModule.bindToSelf(sameKey)\\n\"\n                + \"      java.lang.Object is provided at\\n\"\n                + \"          test.TestComponent.selfReferential()\")\n        .in(component)\n        .onLine(7);\n  }\n\n  @Test public void duplicateExplicitBindings_ProvidesAndComponentProvision() {\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.Outer\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"final class Outer {\",\n        \"  interface A {}\",\n        \"\",\n        \"  interface B {}\",\n        \"\",\n        \"  @Module\",\n        \"  static class AModule {\",\n        \"    @Provides String provideString() { return \\\"\\\"; }\",\n        \"    @Provides A provideA(String s) { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Component(modules \u003d AModule.class)\",\n        \"  interface Parent {\",\n        \"    A getA();\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class BModule {\",\n        \"    @Provides B provideB(A a) { return new B() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Component(dependencies \u003d Parent.class, modules \u003d { BModule.class, AModule.class})\",\n        \"  interface Child {\",\n        \"    B getB();\",\n        \"  }\",\n        \"}\");\n\n    String expectedError \u003d \"test.Outer.A is bound multiple times:\\n\"\n        + \"      test.Outer.A test.Outer.Parent.getA()\\n\"\n        + \"      @Provides test.Outer.A test.Outer.AModule.provideA(String)\";\n\n    assertAbout(javaSource()).that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError).in(component).onLine(30);\n  }\n\n  @Test public void duplicateExplicitBindings_TwoProvidesMethods() {\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.Outer\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class Outer {\",\n        \"  interface A {}\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module1 {\",\n        \"    @Provides A provideA1() { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module2 {\",\n        \"    @Provides String provideString() { return \\\"\\\"; }\",\n        \"    @Provides A provideA2(String s) { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Component(modules \u003d { Module1.class, Module2.class})\",\n        \"  interface TestComponent {\",\n        \"    A getA();\",\n        \"  }\",\n        \"}\");\n\n    String expectedError \u003d \"test.Outer.A is bound multiple times:\\n\"\n        + \"      @Provides test.Outer.A test.Outer.Module1.provideA1()\\n\"\n        + \"      @Provides test.Outer.A test.Outer.Module2.provideA2(String)\";\n\n    assertAbout(javaSource()).that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError).in(component).onLine(24);\n  }\n\n  @Test\n  public void duplicateExplicitBindings_ProvidesVsBinds() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Outer\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Binds;\",\n            \"import dagger.Component;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class Outer {\",\n            \"  interface A {}\",\n            \"\",\n            \"  static final class B implements A {\",\n            \"    @Inject B() {}\",\n            \"  }\",\n            \"\",\n            \"  @Module\",\n            \"  static class Module1 {\",\n            \"    @Provides A provideA1() { return new A() {}; }\",\n            \"  }\",\n            \"\",\n            \"  @Module\",\n            \"  static abstract class Module2 {\",\n            \"    @Binds abstract A bindA2(B b);\",\n            \"  }\",\n            \"\",\n            \"  @Component(modules \u003d { Module1.class, Module2.class})\",\n            \"  interface TestComponent {\",\n            \"    A getA();\",\n            \"  }\",\n            \"}\");\n\n    assertAbout(javaSource())\n        .that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            Joiner.on(\"\\n      \")\n                .join(\n                    \"test.Outer.A is bound multiple times:\",\n                    \"@Provides test.Outer.A test.Outer.Module1.provideA1()\",\n                    \"@Binds test.Outer.A test.Outer.Module2.bindA2(test.Outer.B)\"))\n        .in(component)\n        .onLine(28);\n  }\n\n  @Test public void duplicateExplicitBindings_MultipleProvisionTypes() {\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.Outer\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Binds;\",\n        \"import dagger.Component;\",\n        \"import dagger.MapKey;\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.MapKey;\",\n        \"import dagger.multibindings.IntoMap;\",\n        \"import dagger.multibindings.IntoSet;\",\n        \"import java.util.HashMap;\",\n        \"import java.util.HashSet;\",\n        \"import java.util.Map;\",\n        \"import java.util.Set;\",\n        \"import javax.inject.Qualifier;\",\n        \"\",\n        \"import static java.lang.annotation.RetentionPolicy.RUNTIME;\",\n        \"final class Outer {\",\n        \"  @MapKey(unwrapValue \u003d true)\",\n        \"  @interface StringKey {\",\n        \"    String value();\",\n        \"  }\",\n        \"\",\n        \"  @Qualifier @interface SomeQualifier {}\",\n        \"\",\n        \"  @Module\",\n        \"  abstract static class TestModule1 {\",\n        \"    @Provides @IntoMap\",\n        \"    @StringKey(\\\"foo\\\")\",\n        \"    static String stringMapEntry() { return \\\"\\\"; }\",\n        \"\",\n        \"    @Binds @IntoMap @StringKey(\\\"bar\\\")\",\n        \"    abstract String bindStringMapEntry(@SomeQualifier String value);\",\n        \"\",\n        \"    @Provides @IntoSet static String stringSetElement() { return \\\"\\\"; }\",\n        \"    @Binds @IntoSet abstract String bindStringSetElement(@SomeQualifier String value);\",\n        \"\",\n        \"    @Provides @SomeQualifier static String provideSomeQualifiedString() { return \\\"\\\"; }\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class TestModule2 {\",\n        \"    @Provides Set\u003cString\u003e stringSet() { return new HashSet\u003cString\u003e(); }\",\n        \"\",\n        \"    @Provides Map\u003cString, String\u003e stringMap() {\",\n        \"      return new HashMap\u003cString, String\u003e();\",\n        \"    }\",\n        \"  }\",\n        \"\",\n        \"  @Component(modules \u003d { TestModule1.class, TestModule2.class })\",\n        \"  interface TestComponent {\",\n        \"    Set\u003cString\u003e getStringSet();\",\n        \"    Map\u003cString, String\u003e getStringMap();\",\n        \"  }\",\n        \"}\");\n\n    String expectedSetError \u003d\n        \"java.util.Set\u003cjava.lang.String\u003e has incompatible bindings or declarations:\\n\"\n            + \"      Set bindings and declarations:\\n\"\n            + \"          @Provides @dagger.multibindings.IntoSet String \"\n            + \"test.Outer.TestModule1.stringSetElement()\\n\"\n            + \"          @Binds @dagger.multibindings.IntoSet String \"\n            + \"test.Outer.TestModule1.bindStringSetElement(@test.Outer.SomeQualifier String)\\n\"\n            + \"      Unique bindings and declarations:\\n\"\n            + \"          @Provides Set\u003cString\u003e test.Outer.TestModule2.stringSet()\";\n\n    String expectedMapError \u003d\n        \"java.util.Map\u003cjava.lang.String,java.lang.String\u003e has incompatible bindings \"\n            + \"or declarations:\\n\"\n            + \"      Map bindings and declarations:\\n\"\n            + \"          @Provides @dagger.multibindings.IntoMap \"\n            + \"@test.Outer.StringKey(\\\"foo\\\") String\"\n            + \" test.Outer.TestModule1.stringMapEntry()\\n\"\n            + \"          @Binds @dagger.multibindings.IntoMap \"\n            + \"@test.Outer.StringKey(\\\"bar\\\") String\"\n            + \" test.Outer.TestModule1.bindStringMapEntry(@test.Outer.SomeQualifier String)\\n\"\n            + \"      Unique bindings and declarations:\\n\"\n            + \"          @Provides Map\u003cString,String\u003e test.Outer.TestModule2.stringMap()\";\n\n    assertAbout(javaSource())\n        .that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedSetError)\n        .in(component)\n        .onLine(52)\n        .and()\n        .withErrorContaining(expectedMapError)\n        .in(component)\n        .onLine(53);\n  }\n\n  @Test\n  public void duplicateExplicitBindings_UniqueBindingAndMultibindingDeclaration() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Outer\",\n            \"package test;\",\n            \"\",\n            \"import static java.lang.annotation.RetentionPolicy.RUNTIME;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import dagger.Module;\",\n            \"import dagger.Multibindings;\",\n            \"import dagger.Provides;\",\n            \"import java.util.HashMap;\",\n            \"import java.util.HashSet;\",\n            \"import java.util.Map;\",\n            \"import java.util.Set;\",\n            \"\",\n            \"final class Outer {\",\n            \"  @Module\",\n            \"  static class TestModule1 {\",\n            \"    @Multibindings\",\n            \"    interface Empties {\",\n            \"      Map\u003cString, String\u003e stringMap();\",\n            \"      Set\u003cString\u003e stringSet();\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  @Module\",\n            \"  static class TestModule2 {\",\n            \"    @Provides Set\u003cString\u003e stringSet() { return new HashSet\u003cString\u003e(); }\",\n            \"\",\n            \"    @Provides Map\u003cString, String\u003e stringMap() {\",\n            \"      return new HashMap\u003cString, String\u003e();\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  @Component(modules \u003d { TestModule1.class, TestModule2.class })\",\n            \"  interface TestComponent {\",\n            \"    Set\u003cString\u003e getStringSet();\",\n            \"    Map\u003cString, String\u003e getStringMap();\",\n            \"  }\",\n            \"}\");\n\n    String expectedSetError \u003d\n        \"java.util.Set\u003cjava.lang.String\u003e has incompatible bindings or declarations:\\n\"\n            + \"      Set bindings and declarations:\\n\"\n            + \"          Set\u003cString\u003e test.Outer.TestModule1.Empties.stringSet()\\n\"\n            + \"      Unique bindings and declarations:\\n\"\n            + \"          @Provides Set\u003cString\u003e test.Outer.TestModule2.stringSet()\";\n\n    String expectedMapError \u003d\n        \"java.util.Map\u003cjava.lang.String,java.lang.String\u003e has incompatible bindings \"\n            + \"or declarations:\\n\"\n            + \"      Map bindings and declarations:\\n\"\n            + \"          Map\u003cString,String\u003e test.Outer.TestModule1.Empties.stringMap()\\n\"\n            + \"      Unique bindings and declarations:\\n\"\n            + \"          @Provides Map\u003cString,String\u003e test.Outer.TestModule2.stringMap()\";\n\n    assertAbout(javaSource())\n        .that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedSetError)\n        .in(component)\n        .onLine(35)\n        .and()\n        .withErrorContaining(expectedMapError)\n        .in(component)\n        .onLine(36);\n  }\n\n  @Test public void duplicateBindings_TruncateAfterLimit() {\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.Outer\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class Outer {\",\n        \"  interface A {}\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module1 {\",\n        \"    @Provides A provideA() { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module2 {\",\n        \"    @Provides A provideA() { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module3 {\",\n        \"    @Provides A provideA() { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module4 {\",\n        \"    @Provides A provideA() { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module5 {\",\n        \"    @Provides A provideA() { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module6 {\",\n        \"    @Provides A provideA() { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module7 {\",\n        \"    @Provides A provideA() { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module8 {\",\n        \"    @Provides A provideA() { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module9 {\",\n        \"    @Provides A provideA() { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module10 {\",\n        \"    @Provides A provideA() { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module11 {\",\n        \"    @Provides A provideA() { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Module\",\n        \"  static class Module12 {\",\n        \"    @Provides A provideA() { return new A() {}; }\",\n        \"  }\",\n        \"\",\n        \"  @Component(modules \u003d {\",\n        \"    Module1.class,\",\n        \"    Module2.class,\",\n        \"    Module3.class,\",\n        \"    Module4.class,\",\n        \"    Module5.class,\",\n        \"    Module6.class,\",\n        \"    Module7.class,\",\n        \"    Module8.class,\",\n        \"    Module9.class,\",\n        \"    Module10.class,\",\n        \"    Module11.class,\",\n        \"    Module12.class\",\n        \"  })\",\n        \"  interface TestComponent {\",\n        \"    A getA();\",\n        \"  }\",\n        \"}\");\n\n    String expectedError \u003d \"test.Outer.A is bound multiple times:\\n\"\n        + \"      @Provides test.Outer.A test.Outer.Module1.provideA()\\n\"\n        + \"      @Provides test.Outer.A test.Outer.Module2.provideA()\\n\"\n        + \"      @Provides test.Outer.A test.Outer.Module3.provideA()\\n\"\n        + \"      @Provides test.Outer.A test.Outer.Module4.provideA()\\n\"\n        + \"      @Provides test.Outer.A test.Outer.Module5.provideA()\\n\"\n        + \"      @Provides test.Outer.A test.Outer.Module6.provideA()\\n\"\n        + \"      @Provides test.Outer.A test.Outer.Module7.provideA()\\n\"\n        + \"      @Provides test.Outer.A test.Outer.Module8.provideA()\\n\"\n        + \"      @Provides test.Outer.A test.Outer.Module9.provideA()\\n\"\n        + \"      @Provides test.Outer.A test.Outer.Module10.provideA()\\n\"\n        + \"      and 2 others\";\n\n    assertAbout(javaSource()).that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError).in(component).onLine(86);\n  }\n\n  @Test public void longChainOfDependencies() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestClass\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import dagger.Lazy;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import javax.inject.Inject;\",\n            \"import javax.inject.Named;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            \"final class TestClass {\",\n            \"  interface A {}\",\n            \"\",\n            \"  static class B {\",\n            \"    @Inject B(A a) {}\",\n            \"  }\",\n            \"\",\n            \"  static class C {\",\n            \"    @Inject B b;\",\n            \"    @Inject C(X x, B b) {}\",\n            \"  }\",\n            \"\",\n            \"  interface D { }\",\n            \"\",\n            \"  static class DImpl implements D {\",\n            \"    @Inject DImpl(C c, B b) {}\",\n            \"  }\",\n            \"\",\n            \"  static class X {\",\n            \"    @Inject X() {}\",\n            \"  }\",\n            \"\",\n            \"  @Module\",\n            \"  static class DModule {\",\n            \"    @Provides @Named(\\\"slim shady\\\") D d(X x1, DImpl impl, X x2) { return impl; }\",\n            \"  }\",\n            \"\",\n            \"  @Component(modules \u003d { DModule.class })\",\n            \"  interface AComponent {\",\n            \"    @Named(\\\"slim shady\\\") D getFoo();\",\n            \"    C injectC(C c);\",\n            \"    Provider\u003cC\u003e cProvider();\",\n            \"    Lazy\u003cC\u003e lazyC();\",\n            \"    Provider\u003cLazy\u003cC\u003e\u003e lazyCProvider();\",\n            \"  }\",\n            \"}\");\n    String errorText \u003d \"test.TestClass.A cannot be provided without an @Provides-annotated method.\";\n    String firstError \u003d\n        Joiner.on(\"\\n      \")\n            .join(\n                errorText,\n                \"test.TestClass.A is injected at\",\n                \"    test.TestClass.B.\u003cinit\u003e(a)\",\n                \"test.TestClass.B is injected at\",\n                \"    test.TestClass.C.b\",\n                \"test.TestClass.C is injected at\",\n                \"    test.TestClass.DImpl.\u003cinit\u003e(c, …)\",\n                \"test.TestClass.DImpl is injected at\",\n                \"    test.TestClass.DModule.d(…, impl, …)\",\n                \"@javax.inject.Named(\\\"slim shady\\\") test.TestClass.D is provided at\",\n                \"    test.TestClass.AComponent.getFoo()\");\n    String otherErrorFormat \u003d\n        Joiner.on(\"\\n      \")\n            .join(\n                errorText,\n                \"test.TestClass.A is injected at\",\n                \"    test.TestClass.B.\u003cinit\u003e(a)\",\n                \"test.TestClass.B is injected at\",\n                \"    test.TestClass.C.b\",\n                \"test.TestClass.C is %s at\",\n                \"    test.TestClass.AComponent.%s\");\n    assertAbout(javaSource())\n        .that(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(firstError)\n        .in(component)\n        .onLine(40)\n        .and()\n        .withErrorContaining(String.format(otherErrorFormat, \"injected\", \"injectC(c)\"))\n        .in(component)\n        .onLine(41)\n        .and()\n        .withErrorContaining(String.format(otherErrorFormat, \"provided\", \"cProvider()\"))\n        .in(component)\n        .onLine(42)\n        .and()\n        .withErrorContaining(String.format(otherErrorFormat, \"provided\", \"lazyC()\"))\n        .in(component)\n        .onLine(43)\n        .and()\n        .withErrorContaining(String.format(otherErrorFormat, \"provided\", \"lazyCProvider()\"))\n        .in(component)\n        .onLine(44);\n  }\n\n  @Test\n  public void bindsMethodAppearsInTrace() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"TestComponent\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d TestModule.class)\",\n            \"interface TestComponent {\",\n            \"  TestInterface testInterface();\",\n            \"}\");\n    JavaFileObject interfaceFile \u003d\n        JavaFileObjects.forSourceLines(\"TestInterface\", \"interface TestInterface {}\");\n    JavaFileObject implementationFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"TestImplementation\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class TestImplementation implements TestInterface {\",\n            \"  @Inject TestImplementation(String missingBinding) {}\",\n            \"}\");\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"TestModule\",\n            \"import dagger.Binds;\",\n            \"import dagger.Module;\",\n            \"\",\n            \"@Module\",\n            \"interface TestModule {\",\n            \"  @Binds abstract TestInterface bindTestInterface(TestImplementation implementation);\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(component, module, interfaceFile, implementationFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            Joiner.on(\"\\n      \")\n                .join(\n                    \"java.lang.String cannot be provided without an @Inject constructor or from \"\n                        + \"an @Provides-annotated method.\",\n                    \"java.lang.String is injected at\",\n                    \"    TestImplementation.\u003cinit\u003e(missingBinding)\",\n                    \"TestImplementation is injected at\",\n                    \"    TestModule.bindTestInterface(implementation)\",\n                    \"TestInterface is provided at\",\n                    \"    TestComponent.testInterface()\"))\n        .in(component)\n        .onLine(5);\n  }\n\n  @Test\n  public void bindsMissingRightHandSide() {\n    JavaFileObject duplicates \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Duplicates\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Binds;\",\n            \"import dagger.Component;\",\n            \"import dagger.Module;\",\n            \"import dagger.multibindings.IntKey;\",\n            \"import dagger.multibindings.IntoSet;\",\n            \"import dagger.multibindings.IntoMap;\",\n            \"import dagger.multibindings.LongKey;\",\n            \"import dagger.Provides;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"interface Duplicates {\",\n            \"\",\n            \"  interface BoundTwice {}\",\n            \"\",\n            \"  class BoundImpl implements BoundTwice {\",\n            \"    @Inject BoundImpl() {}\",\n            \"  }\",\n            \"\",\n            \"  class NotBound implements BoundTwice {}\",\n            \"\",\n            \"  @Module\",\n            \"  abstract class DuplicatesModule {\",\n            \"    @Binds abstract BoundTwice bindWithResolvedKey(BoundImpl impl);\",\n            \"    @Binds abstract BoundTwice bindWithUnresolvedKey(NotBound notBound);\",\n            \"\",\n            \"    @Binds abstract Object bindObject(NotBound notBound);\",\n            \"\",\n            \"    @Binds @IntoSet abstract BoundTwice bindWithUnresolvedKey_set(NotBound notBound);\",\n            \"\",\n            \"    @Binds @IntoMap @IntKey(1)\",\n            \"    abstract BoundTwice bindWithUnresolvedKey_intMap(NotBound notBound);\",\n            \"\",\n            \"    @Provides @IntoMap @LongKey(2L)\",\n            \"    static BoundTwice provideWithUnresolvedKey_longMap(BoundImpl impl) {\",\n            \"      return impl;\",\n            \"    }\",\n            \"    @Binds @IntoMap @LongKey(2L)\",\n            \"    abstract BoundTwice bindWithUnresolvedKey_longMap(NotBound notBound);\",\n            \"  }\",\n            \"}\");\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.C\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import java.util.Set;\",\n            \"import java.util.Map;\",\n            \"import test.Duplicates.BoundTwice;\",\n            \"\",\n            \"@Component(modules \u003d Duplicates.DuplicatesModule.class)\",\n            \"interface C {\",\n            \"  BoundTwice boundTwice();\",\n            \"  Object object();\",\n            \"  Set\u003cBoundTwice\u003e set();\",\n            \"  Map\u003cInteger, BoundTwice\u003e intMap();\",\n            \"  Map\u003cLong, BoundTwice\u003e longMap();\",\n            \"}\");\n\n    assertThat(duplicates, component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"test.Duplicates.BoundTwice is bound multiple times:\")\n            .in(component).onLine(10)\n        .and().withErrorContaining(\"test.Duplicates.DuplicatesModule.bindWithUnresolvedKey\")\n            .in(component).onLine(10)\n        .and().withErrorContaining(\"test.Duplicates.NotBound cannot be provided\")\n            .in(component).onLine(11)\n        .and().withErrorContaining(\"test.Duplicates.NotBound cannot be provided\")\n            .in(component).onLine(12)\n        .and().withErrorContaining(\"test.Duplicates.NotBound cannot be provided\")\n            .in(component).onLine(13)\n        .and().withErrorContaining(\"same map key is bound more than once\")\n            .in(component).onLine(14);\n  }\n\n  @Test public void resolvedParametersInDependencyTrace() {\n    JavaFileObject generic \u003d JavaFileObjects.forSourceLines(\"test.Generic\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"final class Generic\u003cT\u003e {\",\n        \"  @Inject Generic(T t) {}\",\n        \"}\");\n    JavaFileObject testClass \u003d JavaFileObjects.forSourceLines(\"test.TestClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"import java.util.List;\",\n        \"\",\n        \"final class TestClass {\",\n        \"  @Inject TestClass(List list) {}\",\n        \"}\");\n    JavaFileObject usesTest \u003d JavaFileObjects.forSourceLines(\"test.UsesTest\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class UsesTest {\",\n        \"  @Inject UsesTest(Generic\u003cTestClass\u003e genericTestClass) {}\",\n        \"}\");\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface TestComponent {\",\n        \"  UsesTest usesTest();\",\n        \"}\");\n    String expectedMsg \u003d\n        Joiner.on(\"\\n\")\n            .join(\n                \"java.util.List cannot be provided without an @Provides-annotated method.\",\n                \"      java.util.List is injected at\",\n                \"          test.TestClass.\u003cinit\u003e(list)\",\n                \"      test.TestClass is injected at\",\n                \"          test.Generic.\u003cinit\u003e(t)\",\n                \"      test.Generic\u003ctest.TestClass\u003e is injected at\",\n                \"          test.UsesTest.\u003cinit\u003e(genericTestClass)\",\n                \"      test.UsesTest is provided at\",\n                \"          test.TestComponent.usesTest()\");\n    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedMsg);\n  }\n\n  @Test public void resolvedVariablesInDependencyTrace() {\n    JavaFileObject generic \u003d JavaFileObjects.forSourceLines(\"test.Generic\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"final class Generic\u003cT\u003e {\",\n        \"  @Inject T t;\",\n        \"  @Inject Generic() {}\",\n        \"}\");\n    JavaFileObject testClass \u003d JavaFileObjects.forSourceLines(\"test.TestClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"import java.util.List;\",\n        \"\",\n        \"final class TestClass {\",\n        \"  @Inject TestClass(List list) {}\",\n        \"}\");\n    JavaFileObject usesTest \u003d JavaFileObjects.forSourceLines(\"test.UsesTest\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class UsesTest {\",\n        \"  @Inject UsesTest(Generic\u003cTestClass\u003e genericTestClass) {}\",\n        \"}\");\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface TestComponent {\",\n        \"  UsesTest usesTest();\",\n        \"}\");\n    String expectedMsg \u003d\n        Joiner.on(\"\\n\")\n            .join(\n                \"java.util.List cannot be provided without an @Provides-annotated method.\",\n                \"      java.util.List is injected at\",\n                \"          test.TestClass.\u003cinit\u003e(list)\",\n                \"      test.TestClass is injected at\",\n                \"          test.Generic.t\",\n                \"      test.Generic\u003ctest.TestClass\u003e is injected at\",\n                \"          test.UsesTest.\u003cinit\u003e(genericTestClass)\",\n                \"      test.UsesTest is provided at\",\n                \"          test.TestComponent.usesTest()\");\n    assertAbout(javaSources()).that(ImmutableList.of(generic, testClass, usesTest, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedMsg);\n  }\n\n  @Test public void nullCheckForConstructorParameters() {\n    JavaFileObject a \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject A(String string) {}\",\n        \"}\");\n    JavaFileObject module \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"@dagger.Module\",\n        \"final class TestModule {\",\n        \"  @Nullable @Provides String provideString() { return null; }\",\n        \"}\");\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(modules \u003d TestModule.class)\",\n        \"interface TestComponent {\",\n        \"  A a();\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            nullableToNonNullable(\n                \"java.lang.String\",\n                \"@test.Nullable @Provides String test.TestModule.provideString()\"));\n\n    // but if we disable the validation, then it compiles fine.\n    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))\n        .withCompilerOptions(\"-Adagger.nullableValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n\n  @Test public void nullCheckForMembersInjectParam() {\n    JavaFileObject a \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject A() {}\",\n        \"  @Inject void register(String string) {}\",\n        \"}\");\n    JavaFileObject module \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"@dagger.Module\",\n        \"final class TestModule {\",\n        \"  @Nullable @Provides String provideString() { return null; }\",\n        \"}\");\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(modules \u003d TestModule.class)\",\n        \"interface TestComponent {\",\n        \"  A a();\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            nullableToNonNullable(\n                \"java.lang.String\",\n                \"@test.Nullable @Provides String test.TestModule.provideString()\"));\n\n    // but if we disable the validation, then it compiles fine.\n    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))\n        .withCompilerOptions(\"-Adagger.nullableValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n\n  @Test public void nullCheckForVariable() {\n    JavaFileObject a \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject String string;\",\n        \"  @Inject A() {}\",\n        \"}\");\n    JavaFileObject module \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"@dagger.Module\",\n        \"final class TestModule {\",\n        \"  @Nullable @Provides String provideString() { return null; }\",\n        \"}\");\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(modules \u003d TestModule.class)\",\n        \"interface TestComponent {\",\n        \"  A a();\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            nullableToNonNullable(\n                \"java.lang.String\",\n                \"@test.Nullable @Provides String test.TestModule.provideString()\"));\n\n    // but if we disable the validation, then it compiles fine.\n    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, a, module, component))\n        .withCompilerOptions(\"-Adagger.nullableValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n\n  @Test public void nullCheckForComponentReturn() {\n    JavaFileObject module \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"@dagger.Module\",\n        \"final class TestModule {\",\n        \"  @Nullable @Provides String provideString() { return null; }\",\n        \"}\");\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(modules \u003d TestModule.class)\",\n        \"interface TestComponent {\",\n        \"  String string();\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            nullableToNonNullable(\n                \"java.lang.String\",\n                \"@test.Nullable @Provides String test.TestModule.provideString()\"));\n\n    // but if we disable the validation, then it compiles fine.\n    assertAbout(javaSources()).that(ImmutableList.of(NULLABLE, module, component))\n        .withCompilerOptions(\"-Adagger.nullableValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n\n  @Test\n  public void nullCheckForOptionalInstance() {\n    JavaFileObject a \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.A\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.base.Optional;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class A {\",\n            \"  @Inject A(Optional\u003cString\u003e optional) {}\",\n            \"}\");\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.BindsOptionalOf;\",\n            \"import dagger.Provides;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"@dagger.Module\",\n            \"abstract class TestModule {\",\n            \"  @Nullable @Provides static String provideString() { return null; }\",\n            \"  @BindsOptionalOf abstract String optionalString();\",\n            \"}\");\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d TestModule.class)\",\n            \"interface TestComponent {\",\n            \"  A a();\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(NULLABLE, a, module, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            nullableToNonNullable(\n                \"java.lang.String\",\n                \"@test.Nullable @Provides String test.TestModule.provideString()\"));\n  }\n\n  @Test\n  public void nullCheckForOptionalProvider() {\n    JavaFileObject a \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.A\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.base.Optional;\",\n            \"import javax.inject.Inject;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            \"final class A {\",\n            \"  @Inject A(Optional\u003cProvider\u003cString\u003e\u003e optional) {}\",\n            \"}\");\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.BindsOptionalOf;\",\n            \"import dagger.Provides;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"@dagger.Module\",\n            \"abstract class TestModule {\",\n            \"  @Nullable @Provides static String provideString() { return null; }\",\n            \"  @BindsOptionalOf abstract String optionalString();\",\n            \"}\");\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d TestModule.class)\",\n            \"interface TestComponent {\",\n            \"  A a();\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(NULLABLE, a, module, component))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n\n  @Test\n  public void nullCheckForOptionalLazy() {\n    JavaFileObject a \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.A\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.base.Optional;\",\n            \"import dagger.Lazy;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class A {\",\n            \"  @Inject A(Optional\u003cLazy\u003cString\u003e\u003e optional) {}\",\n            \"}\");\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.BindsOptionalOf;\",\n            \"import dagger.Provides;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"@dagger.Module\",\n            \"abstract class TestModule {\",\n            \"  @Nullable @Provides static String provideString() { return null; }\",\n            \"  @BindsOptionalOf abstract String optionalString();\",\n            \"}\");\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d TestModule.class)\",\n            \"interface TestComponent {\",\n            \"  A a();\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(NULLABLE, a, module, component))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n\n  @Test\n  public void nullCheckForOptionalProviderOfLazy() {\n    JavaFileObject a \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.A\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.base.Optional;\",\n            \"import dagger.Lazy;\",\n            \"import javax.inject.Inject;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            \"final class A {\",\n            \"  @Inject A(Optional\u003cProvider\u003cLazy\u003cString\u003e\u003e\u003e optional) {}\",\n            \"}\");\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.BindsOptionalOf;\",\n            \"import dagger.Provides;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"@dagger.Module\",\n            \"abstract class TestModule {\",\n            \"  @Nullable @Provides static String provideString() { return null; }\",\n            \"  @BindsOptionalOf abstract String optionalString();\",\n            \"}\");\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d TestModule.class)\",\n            \"interface TestComponent {\",\n            \"  A a();\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(NULLABLE, a, module, component))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n\n  @Test public void componentDependencyMustNotCycle_Direct() {\n    JavaFileObject shortLifetime \u003d JavaFileObjects.forSourceLines(\"test.ComponentShort\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(dependencies \u003d ComponentShort.class)\",\n        \"interface ComponentShort {\",\n        \"}\");\n    String errorMessage \u003d\n        \"test.ComponentShort contains a cycle in its component dependencies:\\n\"\n            + \"      test.ComponentShort\";\n    assertAbout(javaSource())\n        .that(shortLifetime)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(errorMessage);\n  }\n\n  @Test public void componentDependencyMustNotCycle_Indirect() {\n    JavaFileObject longLifetime \u003d JavaFileObjects.forSourceLines(\"test.ComponentLong\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(dependencies \u003d ComponentMedium.class)\",\n        \"interface ComponentLong {\",\n        \"}\");\n    JavaFileObject mediumLifetime \u003d JavaFileObjects.forSourceLines(\"test.ComponentMedium\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(dependencies \u003d ComponentLong.class)\",\n        \"interface ComponentMedium {\",\n        \"}\");\n    JavaFileObject shortLifetime \u003d JavaFileObjects.forSourceLines(\"test.ComponentShort\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component(dependencies \u003d ComponentMedium.class)\",\n        \"interface ComponentShort {\",\n        \"}\");\n    String longErrorMessage \u003d\n        \"test.ComponentLong contains a cycle in its component dependencies:\\n\"\n            + \"      test.ComponentLong\\n\"\n            + \"      test.ComponentMedium\\n\"\n            + \"      test.ComponentLong\";\n    String mediumErrorMessage \u003d\n        \"test.ComponentMedium contains a cycle in its component dependencies:\\n\"\n            + \"      test.ComponentMedium\\n\"\n            + \"      test.ComponentLong\\n\"\n            + \"      test.ComponentMedium\";\n    String shortErrorMessage \u003d\n        \"test.ComponentShort contains a cycle in its component dependencies:\\n\"\n            + \"      test.ComponentMedium\\n\"\n            + \"      test.ComponentLong\\n\"\n            + \"      test.ComponentMedium\\n\"\n            + \"      test.ComponentShort\";\n    assertAbout(javaSources())\n        .that(ImmutableList.of(longLifetime, mediumLifetime, shortLifetime))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(longErrorMessage).in(longLifetime)\n        .and()\n        .withErrorContaining(mediumErrorMessage).in(mediumLifetime)\n        .and()\n        .withErrorContaining(shortErrorMessage).in(shortLifetime);\n  }\n\n  @Test\n  public void subcomponentBindingConflictsWithParent() {\n    JavaFileObject parentChildConflict \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentChildConflict\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Qualifier;\",\n            \"\",\n            \"@Qualifier @interface ParentChildConflict {}\");\n    JavaFileObject parentGrandchildConflict \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentGrandchildConflict\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Qualifier;\",\n            \"\",\n            \"@Qualifier @interface ParentGrandchildConflict {}\");\n    JavaFileObject childGrandchildConflict \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ChildGrandchildConflict\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Qualifier;\",\n            \"\",\n            \"@Qualifier @interface ChildGrandchildConflict {}\");\n\n    /* Some annotation processor implementations do not report more than one error per element. So\n     * separate parents for testing parent-conflicts-with-child and\n     * parent-conflicts-with-grandchild.\n     */\n    JavaFileObject parentConflictsWithChild \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentConflictsWithChild\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"\",\n            \"@Component(modules \u003d ParentConflictsWithChild.ParentModule.class)\",\n            \"interface ParentConflictsWithChild {\",\n            \"  @ParentChildConflict Object parentChildConflict();\",\n            \"\",\n            \"  Child child();\",\n            \"\",\n            \"  @Module\",\n            \"  static class ParentModule {\",\n            \"    @Provides @ParentChildConflict static Object parentChildConflict() {\",\n            \"      return \\\"parent\\\";\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    JavaFileObject parentConflictsWithGrandchild \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentConflictsWithGrandchild\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"\",\n            \"@Component(modules \u003d ParentConflictsWithGrandchild.ParentModule.class)\",\n            \"interface ParentConflictsWithGrandchild {\",\n            \"  @ParentGrandchildConflict Object parentGrandchildConflict();\",\n            \"\",\n            \"  Child child();\",\n            \"\",\n            \"  @Module\",\n            \"  static class ParentModule {\",\n            \"    @Provides @ParentGrandchildConflict static Object parentGrandchildConflict() {\",\n            \"      return \\\"parent\\\";\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    JavaFileObject child \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Child\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent(modules \u003d Child.ChildModule.class)\",\n            \"interface Child {\",\n            \"  @ParentChildConflict Object parentChildConflict();\",\n            \"  @ChildGrandchildConflict Object childGrandchildConflict();\",\n            \"\",\n            \"  Grandchild grandchild();\",\n            \"\",\n            \"  @Module\",\n            \"  static class ChildModule {\",\n            \"    @Provides @ParentChildConflict static Object parentChildConflict() {\",\n            \"      return \\\"child\\\";\",\n            \"    }\",\n            \"\",\n            \"    @Provides @ChildGrandchildConflict static Object childGrandchildConflict() {\",\n            \"      return \\\"child\\\";\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    JavaFileObject grandchild \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Grandchild\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent(modules \u003d Grandchild.GrandchildModule.class)\",\n            \"interface Grandchild {\",\n            \"  @ParentChildConflict Object parentChildConflict();\",\n            \"  @ParentGrandchildConflict Object parentGrandchildConflict();\",\n            \"  @ChildGrandchildConflict Object childGrandchildConflict();\",\n            \"\",\n            \"  @Module\",\n            \"  static class GrandchildModule {\",\n            \"    @Provides @ParentGrandchildConflict static Object parentGrandchildConflict() {\",\n            \"      return \\\"grandchild\\\";\",\n            \"    }\",\n            \"\",\n            \"    @Provides @ChildGrandchildConflict static Object childGrandchildConflict() {\",\n            \"      return \\\"grandchild\\\";\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(\n            ImmutableList.of(\n                parentChildConflict,\n                parentGrandchildConflict,\n                childGrandchildConflict,\n                parentConflictsWithChild,\n                parentConflictsWithGrandchild,\n                child,\n                grandchild))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"[test.Child.parentChildConflict()] \"\n                + \"@test.ParentChildConflict java.lang.Object is bound multiple times:\\n\"\n                + \"      @Provides @test.ParentChildConflict Object\"\n                + \" test.ParentConflictsWithChild.ParentModule.parentChildConflict()\\n\"\n                + \"      @Provides @test.ParentChildConflict Object\"\n                + \" test.Child.ChildModule.parentChildConflict()\")\n        .in(parentConflictsWithChild)\n        .onLine(8)\n        .and()\n        .withErrorContaining(\n            \"[test.Grandchild.parentGrandchildConflict()] \"\n                + \"@test.ParentGrandchildConflict java.lang.Object is bound multiple times:\\n\"\n                + \"      @Provides @test.ParentGrandchildConflict Object\"\n                + \" test.ParentConflictsWithGrandchild.ParentModule.parentGrandchildConflict()\\n\"\n                + \"      @Provides @test.ParentGrandchildConflict Object\"\n                + \" test.Grandchild.GrandchildModule.parentGrandchildConflict()\")\n        .in(parentConflictsWithGrandchild)\n        .onLine(8)\n        .and()\n        .withErrorContaining(\n            \"[test.Grandchild.childGrandchildConflict()] \"\n                + \"@test.ChildGrandchildConflict java.lang.Object is bound multiple times:\\n\"\n                + \"      @Provides @test.ChildGrandchildConflict Object\"\n                + \" test.Child.ChildModule.childGrandchildConflict()\\n\"\n                + \"      @Provides @test.ChildGrandchildConflict Object\"\n                + \" test.Grandchild.GrandchildModule.childGrandchildConflict()\")\n        .in(child)\n        .onLine(8);\n  }\n\n  @Test\n  public void subcomponentBindingConflictsWithParentWithNullableViolationAsWarning() {\n    JavaFileObject parentConflictsWithChild \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentConflictsWithChild\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import javax.annotation.Nullable;\",\n            \"\",\n            \"@Component(modules \u003d ParentConflictsWithChild.ParentModule.class)\",\n            \"interface ParentConflictsWithChild {\",\n            \"  Child child();\",\n            \"\",\n            \"  @Module\",\n            \"  static class ParentModule {\",\n            \"    @Provides @Nullable static Object nullableParentChildConflict() {\",\n            \"      return \\\"parent\\\";\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    JavaFileObject child \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Child\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent(modules \u003d Child.ChildModule.class)\",\n            \"interface Child {\",\n            \"  Object parentChildConflictThatViolatesNullability();\",\n            \"\",\n            \"  @Module\",\n            \"  static class ChildModule {\",\n            \"    @Provides static Object nonNullableParentChildConflict() {\",\n            \"      return \\\"child\\\";\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(parentConflictsWithChild, child))\n        .withCompilerOptions(\"-Adagger.nullableValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"[test.Child.parentChildConflictThatViolatesNullability()] \"\n                + \"java.lang.Object is bound multiple times:\\n\"\n                + \"      @Provides @javax.annotation.Nullable Object\"\n                + \" test.ParentConflictsWithChild.ParentModule.nullableParentChildConflict()\\n\"\n                + \"      @Provides Object\"\n                + \" test.Child.ChildModule.nonNullableParentChildConflict()\")\n        .in(parentConflictsWithChild)\n        .onLine(9);\n  }\n\n  @Test\n  public void bindingUsedOnlyInSubcomponentDependsOnBindingOnlyInSubcomponent() {\n    JavaFileObject parent \u003d\n        JavaFileObjects.forSourceLines(\n            \"Parent\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d ParentModule.class)\",\n            \"interface Parent {\",\n            \"  Child child();\",\n            \"}\");\n    JavaFileObject parentModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"ParentModule\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"\",\n            \"@Module\",\n            \"class ParentModule {\",\n            \"  @Provides static Object needsString(String string) {\",\n            \"    return \\\"needs string: \\\" + string;\",\n            \"  }\",\n            \"}\");\n    JavaFileObject child \u003d\n        JavaFileObjects.forSourceLines(\n            \"Child\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent(modules \u003d ChildModule.class)\",\n            \"interface Child {\",\n            \"  String string();\",\n            \"  Object needsString();\",\n            \"}\");\n    JavaFileObject childModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"ChildModule\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"\",\n            \"@Module\",\n            \"class ChildModule {\",\n            \"  @Provides static String string() {\",\n            \"    return \\\"child string\\\";\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(parent, parentModule, child, childModule))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"[Child.needsString()] java.lang.String cannot be provided\")\n        .in(parent)\n        .onLine(4);\n  }\n\n  @Test\n  public void multibindingContributionBetweenAncestorComponentAndEntrypointComponent() {\n    JavaFileObject parent \u003d\n        JavaFileObjects.forSourceLines(\n            \"Parent\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d ParentModule.class)\",\n            \"interface Parent {\",\n            \"  Child child();\",\n            \"}\");\n    JavaFileObject child \u003d\n        JavaFileObjects.forSourceLines(\n            \"Child\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent(modules \u003d ChildModule.class)\",\n            \"interface Child {\",\n            \"  Grandchild grandchild();\",\n            \"}\");\n    JavaFileObject grandchild \u003d\n        JavaFileObjects.forSourceLines(\n            \"Grandchild\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent\",\n            \"interface Grandchild {\",\n            \"  Object object();\",\n            \"}\");\n\n    JavaFileObject parentModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"ParentModule\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.IntoSet;\",\n            \"import java.util.Set;\",\n            \"\",\n            \"@Module\",\n            \"class ParentModule {\",\n            \"  @Provides static Object dependsOnSet(Set\u003cString\u003e strings) {\",\n            \"    return \\\"needs strings: \\\" + strings;\",\n            \"  }\",\n            \"\",\n            \"  @Provides @IntoSet static String contributesToSet() {\",\n            \"    return \\\"parent string\\\";\",\n            \"  }\",\n            \"\",\n            \"  @Provides int missingDependency(double dub) {\",\n            \"    return 4;\",\n            \"  }\",\n            \"}\");\n    JavaFileObject childModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"ChildModule\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.IntoSet;\",\n            \"\",\n            \"@Module\",\n            \"class ChildModule {\",\n            \"  @Provides @IntoSet static String contributesToSet(int i) {\",\n            \"    return \\\"\\\" + i;\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(parent, parentModule, child, childModule, grandchild))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"[Grandchild.object()] java.lang.Double cannot be provided\")\n        .in(parent)\n        .onLine(4);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\InaccessibleTypeTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class InaccessibleTypeTest {\n  @Test public void basicInjectedType() {\n    JavaFileObject noDepClassFile \u003d JavaFileObjects.forSourceLines(\"foreign.NoDepClass\",\n        \"package foreign;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"public final class NoDepClass {\",\n        \"  @Inject NoDepClass() {}\",\n        \"}\");\n    JavaFileObject publicClassFile \u003d JavaFileObjects.forSourceLines(\"foreign.PublicClass\",\n        \"package foreign;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"public final class PublicClass {\",\n        \"  @Inject PublicClass(NonPublicClass1 dep1, NonPublicClass2 dep2, NoDepClass dep3) {}\",\n        \"}\");\n    JavaFileObject nonPublicClass1File \u003d JavaFileObjects.forSourceLines(\"foreign.NonPublicClass1\",\n        \"package foreign;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class NonPublicClass1 {\",\n        \"  @Inject NonPublicClass1(NoDepClass dep) {}\",\n        \"}\");\n    JavaFileObject nonPublicClass2File \u003d JavaFileObjects.forSourceLines(\"foreign.NonPublicClass2\",\n        \"package foreign;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class NonPublicClass2 {\",\n        \"  @Inject NonPublicClass2(NoDepClass dep) {}\",\n        \"}\");\n\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import foreign.PublicClass;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface TestComponent {\",\n        \"  PublicClass publicClass();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\n        \"test.DaggerTestComponent\",\n        \"package test;\",\n        \"\",\n        \"import foreign.NoDepClass_Factory;\",\n        \"import foreign.NonPublicClass1_Factory;\",\n        \"import foreign.NonPublicClass2_Factory;\",\n        \"import foreign.PublicClass;\",\n        \"import foreign.PublicClass_Factory;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class DaggerTestComponent implements TestComponent {\",\n        \"  @SuppressWarnings(\\\"rawtypes\\\")\",\n        \"  private Provider nonPublicClass1Provider;\",\n        \"  @SuppressWarnings(\\\"rawtypes\\\")\",\n        \"  private Provider nonPublicClass2Provider;\",\n        \"  private Provider\u003cPublicClass\u003e publicClassProvider;\",\n        \"\",\n        \"  private DaggerTestComponent(Builder builder) {\",\n        \"    assert builder !\u003d null;\",\n        \"    initialize(builder);\",\n        \"  }\",\n        \"\",\n        \"  public static Builder builder() {\",\n        \"    return new Builder();\",\n        \"  }\",\n        \"\",\n        \"  public static TestComponent create() {\",\n        \"    return builder().build();\",\n        \"  }\",\n        \"\",\n        \"  @SuppressWarnings(\\\"unchecked\\\")\",\n        \"  private void initialize(final Builder builder) {\",\n        \"    this.nonPublicClass1Provider \u003d\",\n        \"        NonPublicClass1_Factory.create(NoDepClass_Factory.create());\",\n        \"    this.nonPublicClass2Provider \u003d\",\n        \"        NonPublicClass2_Factory.create(NoDepClass_Factory.create());\",\n        \"    this.publicClassProvider \u003d PublicClass_Factory.create(\",\n        \"        nonPublicClass1Provider,\",\n        \"        nonPublicClass2Provider,\",\n        \"        NoDepClass_Factory.create());\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public PublicClass publicClass() {\",\n        \"    return publicClassProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static final class Builder {\",\n        \"    private Builder() {\",\n        \"    }\",\n        \"\",\n        \"    public TestComponent build() {\",\n        \"      return new DaggerTestComponent(this);\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(\n            noDepClassFile,\n            publicClassFile,\n            nonPublicClass1File,\n            nonPublicClass2File,\n            componentFile))\n        .withCompilerOptions(\"-Xlint:-processing\", \"-Xlint:rawtypes\", \"-Xlint:unchecked\", \"-Werror\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void memberInjectedType() {\n    JavaFileObject noDepClassFile \u003d JavaFileObjects.forSourceLines(\"test.NoDepClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"public final class NoDepClass {\",\n        \"  @Inject NoDepClass() {}\",\n        \"}\");\n    JavaFileObject aClassFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import foreign.B;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A extends B {\",\n        \"  @Inject NoDepClass dep;\",\n        \"}\");\n    JavaFileObject bClassFile \u003d JavaFileObjects.forSourceLines(\"foreign.B\",\n        \"package foreign;\",\n        \"\",\n        \"import test.NoDepClass;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"public class B extends C {\",\n        \"  @Inject NoDepClass dep;\",\n        \"}\");\n    JavaFileObject cClassFile \u003d JavaFileObjects.forSourceLines(\"foreign.C\",\n        \"package foreign;\",\n        \"\",\n        \"import test.D;\",\n        \"import test.NoDepClass;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class C extends D {\",\n        \"  @Inject NoDepClass dep;\",\n        \"}\");\n    JavaFileObject dClassFile \u003d JavaFileObjects.forSourceLines(\"test.D\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"public class D {\",\n        \"  @Inject NoDepClass dep;\",\n        \"}\");\n\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface TestComponent {\",\n        \"  void injectA(A a);\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerTestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MembersInjector;\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerTestComponent implements TestComponent {\",\n            \"  private MembersInjector\u003cA\u003e aMembersInjector;\",\n            \"\",\n            \"  private DaggerTestComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static TestComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"     this.aMembersInjector \u003d A_MembersInjector.create(NoDepClass_Factory.create());\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public void injectA(A a) {\",\n            \"    aMembersInjector.injectMembers(a);\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public TestComponent build() {\",\n            \"      return new DaggerTestComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(\n            noDepClassFile,\n            aClassFile,\n            bClassFile,\n            cClassFile,\n            dClassFile,\n            componentFile))\n        .withCompilerOptions(\"-Xlint:-processing\", \"-Xlint:rawtypes\", \"-Xlint:unchecked\", \"-Werror\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\InjectConstructorFactoryGeneratorTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.ErrorMessages.ABSTRACT_INJECT_METHOD;\nimport static dagger.internal.codegen.ErrorMessages.CHECKED_EXCEPTIONS_ON_CONSTRUCTORS;\nimport static dagger.internal.codegen.ErrorMessages.FINAL_INJECT_FIELD;\nimport static dagger.internal.codegen.ErrorMessages.GENERIC_INJECT_METHOD;\nimport static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS;\nimport static dagger.internal.codegen.ErrorMessages.INJECT_CONSTRUCTOR_ON_INNER_CLASS;\nimport static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;\nimport static dagger.internal.codegen.ErrorMessages.INJECT_ON_PRIVATE_CONSTRUCTOR;\nimport static dagger.internal.codegen.ErrorMessages.MULTIPLE_INJECT_CONSTRUCTORS;\nimport static dagger.internal.codegen.ErrorMessages.MULTIPLE_QUALIFIERS;\nimport static dagger.internal.codegen.ErrorMessages.MULTIPLE_SCOPES;\nimport static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_FIELD;\nimport static dagger.internal.codegen.ErrorMessages.PRIVATE_INJECT_METHOD;\nimport static dagger.internal.codegen.ErrorMessages.QUALIFIER_ON_INJECT_CONSTRUCTOR;\nimport static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_FIELD;\nimport static dagger.internal.codegen.ErrorMessages.STATIC_INJECT_METHOD;\nimport static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\n// TODO(gak): add tests for generation in the default package.\npublic final class InjectConstructorFactoryGeneratorTest {\n  private static final JavaFileObject QUALIFIER_A \u003d\n      JavaFileObjects.forSourceLines(\"test.QualifierA\",\n          \"package test;\",\n          \"\",\n          \"import javax.inject.Qualifier;\",\n          \"\",\n          \"@Qualifier @interface QualifierA {}\");\n  private static final JavaFileObject QUALIFIER_B \u003d\n      JavaFileObjects.forSourceLines(\"test.QualifierB\",\n          \"package test;\",\n          \"\",\n          \"import javax.inject.Qualifier;\",\n          \"\",\n          \"@Qualifier @interface QualifierB {}\");\n  private static final JavaFileObject SCOPE_A \u003d\n      JavaFileObjects.forSourceLines(\"test.ScopeA\",\n          \"package test;\",\n          \"\",\n          \"import javax.inject.Scope;\",\n          \"\",\n          \"@Scope @interface ScopeA {}\");\n  private static final JavaFileObject SCOPE_B \u003d\n      JavaFileObjects.forSourceLines(\"test.ScopeB\",\n          \"package test;\",\n          \"\",\n          \"import javax.inject.Scope;\",\n          \"\",\n          \"@Scope @interface ScopeB {}\");\n\n  @Test public void injectOnPrivateConstructor() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.PrivateConstructor\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class PrivateConstructor {\",\n        \"  @Inject private PrivateConstructor() {}\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(INJECT_ON_PRIVATE_CONSTRUCTOR).in(file).onLine(6);\n  }\n\n  @Test public void injectConstructorOnInnerClass() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.OuterClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class OuterClass {\",\n        \"  class InnerClass {\",\n        \"    @Inject InnerClass() {}\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(INJECT_CONSTRUCTOR_ON_INNER_CLASS).in(file).onLine(7);\n  }\n\n  @Test public void injectConstructorOnAbstractClass() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.AbstractClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"abstract class AbstractClass {\",\n        \"  @Inject AbstractClass() {}\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(INJECT_CONSTRUCTOR_ON_ABSTRACT_CLASS).in(file).onLine(6);\n  }\n\n  @Test public void injectConstructorOnGenericClass() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.GenericClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class GenericClass\u003cT\u003e {\",\n        \"  @Inject GenericClass(T t) {}\",\n        \"}\");\n    JavaFileObject expected \u003d JavaFileObjects.forSourceLines(\"test.GenericClass_Factory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class GenericClass_Factory\u003cT\u003e implements Factory\u003cGenericClass\u003cT\u003e\u003e {\",\n        \"  private final Provider\u003cT\u003e tProvider;\",\n        \"\",\n        \"  public GenericClass_Factory(Provider\u003cT\u003e tProvider) {\",\n        \"    assert tProvider !\u003d null;\",\n        \"    this.tProvider \u003d tProvider;\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public GenericClass\u003cT\u003e get() {\",\n        \"    return new GenericClass\u003cT\u003e(tProvider.get());\",\n        \"  }\",\n        \"\",\n        \"  public static \u003cT\u003e Factory\u003cGenericClass\u003cT\u003e\u003e create(Provider\u003cT\u003e tProvider) {\",\n        \"    return new GenericClass_Factory\u003cT\u003e(tProvider);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(expected);\n  }\n\n  @Test public void fieldAndMethodGenerics() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.GenericClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class GenericClass\u003cA, B\u003e {\",\n        \"  @Inject A a;\",\n        \"\",\n        \"  @Inject GenericClass() {}\",\n        \"\",\n        \" @Inject void register(B b) {}\",\n        \"}\");\n    JavaFileObject expected \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.GenericClass_Factory\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MembersInjector;\",\n            \"import dagger.internal.Factory;\",\n            \"import dagger.internal.MembersInjectors;\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class GenericClass_Factory\u003cA, B\u003e implements Factory\u003cGenericClass\u003cA, B\u003e\u003e {\",\n            \"  private final MembersInjector\u003cGenericClass\u003cA, B\u003e\u003e genericClassMembersInjector;\",\n            \"\",\n            \"  public GenericClass_Factory(\",\n            \"      MembersInjector\u003cGenericClass\u003cA, B\u003e\u003e genericClassMembersInjector) {\",\n            \"    assert genericClassMembersInjector !\u003d null;\",\n            \"    this.genericClassMembersInjector \u003d genericClassMembersInjector;\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public GenericClass\u003cA, B\u003e get() {\",\n            \"    return MembersInjectors.injectMembers(\",\n            \"        genericClassMembersInjector, new GenericClass\u003cA, B\u003e());\",\n            \"  }\",\n            \"\",\n            \"  public static \u003cA, B\u003e Factory\u003cGenericClass\u003cA, B\u003e\u003e create(\",\n            \"      MembersInjector\u003cGenericClass\u003cA, B\u003e\u003e genericClassMembersInjector) {\",\n            \"    return new GenericClass_Factory\u003cA, B\u003e(genericClassMembersInjector);\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(expected);\n  }\n\n  @Test public void genericClassWithNoDependencies() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.GenericClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class GenericClass\u003cT\u003e {\",\n        \"  @Inject GenericClass() {}\",\n        \"}\");\n    JavaFileObject expected \u003d JavaFileObjects.forSourceLines(\"test.GenericClass_Factory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import javax.annotation.Generated;\",\n        \"\",\n        \"@SuppressWarnings(\\\"rawtypes\\\")\",\n        GENERATED_ANNOTATION,\n        \"public enum GenericClass_Factory implements Factory\u003cGenericClass\u003e {\",\n        \"  INSTANCE;\",\n        \"\",\n        \"  @Override\",\n        \"  public GenericClass get() {\",\n        \"    return new GenericClass();\",\n        \"  }\",\n        \"\",\n        \"  @SuppressWarnings(\\\"unchecked\\\")\",\n        \"  public static \u003cT\u003e Factory\u003cGenericClass\u003cT\u003e\u003e create() {\",\n        \"    return (Factory) INSTANCE;\",\n        \"  }\",\n        \"\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(expected);\n  }\n\n  @Test public void twoGenericTypes() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.GenericClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class GenericClass\u003cA, B\u003e {\",\n        \"  @Inject GenericClass(A a, B b) {}\",\n        \"}\");\n    JavaFileObject expected \u003d JavaFileObjects.forSourceLines(\"test.GenericClass_Factory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class GenericClass_Factory\u003cA, B\u003e implements Factory\u003cGenericClass\u003cA, B\u003e\u003e {\",\n        \"  private final Provider\u003cA\u003e aProvider;\",\n        \"  private final Provider\u003cB\u003e bProvider;\",\n        \"\",\n        \"  public GenericClass_Factory(Provider\u003cA\u003e aProvider, Provider\u003cB\u003e bProvider) {\",\n        \"    assert aProvider !\u003d null;\",\n        \"    this.aProvider \u003d aProvider;\",\n        \"    assert bProvider !\u003d null;\",\n        \"    this.bProvider \u003d bProvider;\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public GenericClass\u003cA, B\u003e get() {\",\n        \"    return new GenericClass\u003cA, B\u003e(aProvider.get(), bProvider.get());\",\n        \"  }\",\n        \"\",\n        \"  public static \u003cA, B\u003e Factory\u003cGenericClass\u003cA, B\u003e\u003e create(\",\n        \"      Provider\u003cA\u003e aProvider, Provider\u003cB\u003e bProvider) {\",\n        \"    return new GenericClass_Factory\u003cA, B\u003e(aProvider, bProvider);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(expected);\n  }\n\n  @Test public void boundedGenerics() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.GenericClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"import java.util.List;\",\n        \"\",\n        \"class GenericClass\u003cA extends Number \u0026 Comparable\u003cA\u003e,\",\n        \"    B extends List\u003c? extends String\u003e,\",\n        \"    C extends List\u003c? super String\u003e\u003e {\",\n        \"  @Inject GenericClass(A a, B b, C c) {}\",\n        \"}\");\n    JavaFileObject expected \u003d JavaFileObjects.forSourceLines(\"test.GenericClass_Factory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import java.util.List;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class GenericClass_Factory\u003cA extends Number \u0026 Comparable\u003cA\u003e,\",\n        \"        B extends List\u003c? extends String\u003e,\",\n        \"        C extends List\u003c? super String\u003e\u003e\",\n        \"    implements Factory\u003cGenericClass\u003cA, B, C\u003e\u003e {\",\n        \"  private final Provider\u003cA\u003e aProvider;\",\n        \"  private final Provider\u003cB\u003e bProvider;\",\n        \"  private final Provider\u003cC\u003e cProvider;\",\n        \"\",\n        \"  public GenericClass_Factory(Provider\u003cA\u003e aProvider,\",\n        \"      Provider\u003cB\u003e bProvider,\",\n        \"      Provider\u003cC\u003e cProvider) {\",\n        \"    assert aProvider !\u003d null;\",\n        \"    this.aProvider \u003d aProvider;\",\n        \"    assert bProvider !\u003d null;\",\n        \"    this.bProvider \u003d bProvider;\",\n        \"    assert cProvider !\u003d null;\",\n        \"    this.cProvider \u003d cProvider;\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public GenericClass\u003cA, B, C\u003e get() {\",\n        \"    return new GenericClass\u003cA, B, C\u003e(aProvider.get(), bProvider.get(), cProvider.get());\",\n        \"  }\",\n        \"\",\n        \"  public static \u003cA extends Number \u0026 Comparable\u003cA\u003e,\",\n        \"      B extends List\u003c? extends String\u003e,\",\n        \"      C extends List\u003c? super String\u003e\u003e Factory\u003cGenericClass\u003cA, B, C\u003e\u003e create(\",\n        \"          Provider\u003cA\u003e aProvider, Provider\u003cB\u003e bProvider, Provider\u003cC\u003e cProvider) {\",\n        \"    return new GenericClass_Factory\u003cA, B, C\u003e(aProvider, bProvider, cProvider);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(expected);\n  }\n\n  @Test public void multipleSameTypesWithGenericsAndQualifiersAndLazies() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.GenericClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"import javax.inject.Provider;\",\n        \"import dagger.Lazy;\",\n        \"\",\n        \"class GenericClass\u003cA, B\u003e {\",\n        \"  @Inject GenericClass(A a, A a2, Provider\u003cA\u003e pa, @QualifierA A qa, Lazy\u003cA\u003e la, \",\n        \"                       String s, String s2, Provider\u003cString\u003e ps, \",\n        \"                       @QualifierA String qs, Lazy\u003cString\u003e ls,\",\n        \"                       B b, B b2, Provider\u003cB\u003e pb, @QualifierA B qb, Lazy\u003cB\u003e lb) {}\",\n        \"}\");\n    JavaFileObject expected \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.GenericClass_Factory\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.DoubleCheck;\",\n            \"import dagger.internal.Factory;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class GenericClass_Factory\u003cA, B\u003e implements Factory\u003cGenericClass\u003cA, B\u003e\u003e {\",\n            \"  private final Provider\u003cA\u003e aAndA2AndPaAndLaProvider;\",\n            \"  private final Provider\u003cA\u003e qaProvider;\",\n            \"  private final Provider\u003cString\u003e sAndS2AndPsAndLsProvider;\",\n            \"  private final Provider\u003cString\u003e qsProvider;\",\n            \"  private final Provider\u003cB\u003e bAndB2AndPbAndLbProvider;\",\n            \"  private final Provider\u003cB\u003e qbProvider;\",\n            \"\",\n            \"  public GenericClass_Factory(Provider\u003cA\u003e aAndA2AndPaAndLaProvider,\",\n            \"      Provider\u003cA\u003e qaProvider,\",\n            \"      Provider\u003cString\u003e sAndS2AndPsAndLsProvider,\",\n            \"      Provider\u003cString\u003e qsProvider,\",\n            \"      Provider\u003cB\u003e bAndB2AndPbAndLbProvider,\",\n            \"      Provider\u003cB\u003e qbProvider) {\",\n            \"    assert aAndA2AndPaAndLaProvider !\u003d null;\",\n            \"    this.aAndA2AndPaAndLaProvider \u003d aAndA2AndPaAndLaProvider;\",\n            \"    assert qaProvider !\u003d null;\",\n            \"    this.qaProvider \u003d qaProvider;\",\n            \"    assert sAndS2AndPsAndLsProvider !\u003d null;\",\n            \"    this.sAndS2AndPsAndLsProvider \u003d sAndS2AndPsAndLsProvider;\",\n            \"    assert qsProvider !\u003d null;\",\n            \"    this.qsProvider \u003d qsProvider;\",\n            \"    assert bAndB2AndPbAndLbProvider !\u003d null;\",\n            \"    this.bAndB2AndPbAndLbProvider \u003d bAndB2AndPbAndLbProvider;\",\n            \"    assert qbProvider !\u003d null;\",\n            \"    this.qbProvider \u003d qbProvider;\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public GenericClass\u003cA, B\u003e get() {\",\n            \"    return new GenericClass\u003cA, B\u003e(\",\n            \"      aAndA2AndPaAndLaProvider.get(),\",\n            \"      aAndA2AndPaAndLaProvider.get(),\",\n            \"      aAndA2AndPaAndLaProvider,\",\n            \"      qaProvider.get(),\",\n            \"      DoubleCheck.lazy(aAndA2AndPaAndLaProvider),\",\n            \"      sAndS2AndPsAndLsProvider.get(),\",\n            \"      sAndS2AndPsAndLsProvider.get(),\",\n            \"      sAndS2AndPsAndLsProvider,\",\n            \"      qsProvider.get(),\",\n            \"      DoubleCheck.lazy(sAndS2AndPsAndLsProvider),\",\n            \"      bAndB2AndPbAndLbProvider.get(),\",\n            \"      bAndB2AndPbAndLbProvider.get(),\",\n            \"      bAndB2AndPbAndLbProvider,\",\n            \"      qbProvider.get(),\",\n            \"      DoubleCheck.lazy(bAndB2AndPbAndLbProvider));\",\n            \"  }\",\n            \"\",\n            \"  public static \u003cA, B\u003e Factory\u003cGenericClass\u003cA, B\u003e\u003e create(\",\n            \"      Provider\u003cA\u003e aAndA2AndPaAndLaProvider,\",\n            \"      Provider\u003cA\u003e qaProvider,\",\n            \"      Provider\u003cString\u003e sAndS2AndPsAndLsProvider,\",\n            \"      Provider\u003cString\u003e qsProvider,\",\n            \"      Provider\u003cB\u003e bAndB2AndPbAndLbProvider,\",\n            \"      Provider\u003cB\u003e qbProvider) {\",\n            \"    return new GenericClass_Factory\u003cA, B\u003e(\",\n            \"        aAndA2AndPaAndLaProvider,\",\n            \"        qaProvider,\",\n            \"        sAndS2AndPsAndLsProvider,\",\n            \"        qsProvider,\",\n            \"        bAndB2AndPbAndLbProvider,\",\n            \"        qbProvider);\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(expected);\n  }\n\n  @Test public void multipleInjectConstructors() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.TooManyInjectConstructors\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class TooManyInjectConstructors {\",\n        \"  @Inject TooManyInjectConstructors() {}\",\n        \"  TooManyInjectConstructors(int i) {}\",\n        \"  @Inject TooManyInjectConstructors(String s) {}\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(6)\n        .and().withErrorContaining(MULTIPLE_INJECT_CONSTRUCTORS).in(file).onLine(8);\n  }\n\n  @Test public void multipleQualifiersOnInjectConstructorParameter() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.MultipleQualifierConstructorParam\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class MultipleQualifierConstructorParam {\",\n        \"  @Inject MultipleQualifierConstructorParam(@QualifierA @QualifierB String s) {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))\n        .processedWith(new ComponentProcessor()).failsToCompile()\n        // for whatever reason, javac only reports the error once on the constructor\n        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);\n  }\n\n  @Test public void injectConstructorOnClassWithMultipleScopes() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.MultipleScopeClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"@ScopeA @ScopeB class MultipleScopeClass {\",\n        \"  @Inject MultipleScopeClass() {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(file, SCOPE_A, SCOPE_B))\n        .processedWith(new ComponentProcessor()).failsToCompile()\n        .withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(1)\n        .and().withErrorContaining(MULTIPLE_SCOPES).in(file).onLine(5).atColumn(9);\n  }\n\n  @Test public void injectConstructorWithQualifier() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.MultipleScopeClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class MultipleScopeClass {\",\n        \"  @Inject\",\n        \"  @QualifierA\",\n        \"  @QualifierB\",\n        \"  MultipleScopeClass() {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))\n        .processedWith(new ComponentProcessor()).failsToCompile()\n        .withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(7)\n        .and().withErrorContaining(QUALIFIER_ON_INJECT_CONSTRUCTOR).in(file).onLine(8);\n  }\n\n  @Test public void injectConstructorWithCheckedExceptionsError() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.CheckedExceptionClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class CheckedExceptionClass {\",\n        \"  @Inject CheckedExceptionClass() throws Exception {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(file))\n        .processedWith(new ComponentProcessor()).failsToCompile()\n        .withErrorContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS).in(file).onLine(6);\n  }\n\n  @Test public void injectConstructorWithCheckedExceptionsWarning() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.CheckedExceptionClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class CheckedExceptionClass {\",\n        \"  @Inject CheckedExceptionClass() throws Exception {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(file))\n        .withCompilerOptions(\"-Adagger.privateMemberValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .withWarningContaining(CHECKED_EXCEPTIONS_ON_CONSTRUCTORS).in(file).onLine(6);\n  }\n\n  @Test public void privateInjectClassError() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.OuterClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class OuterClass {\",\n        \"  private static final class InnerClass {\",\n        \"    @Inject InnerClass() {}\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(file))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(7);\n  }\n\n  @Test public void privateInjectClassWarning() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.OuterClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class OuterClass {\",\n        \"  private static final class InnerClass {\",\n        \"    @Inject InnerClass() {}\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(file))\n        .withCompilerOptions(\"-Adagger.privateMemberValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(7);\n  }\n\n  @Test public void nestedInPrivateInjectClassError() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.OuterClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class OuterClass {\",\n        \"  private static final class MiddleClass {\",\n        \"    static final class InnerClass {\",\n        \"      @Inject InnerClass() {}\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(file))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(8);\n  }\n\n  @Test public void nestedInPrivateInjectClassWarning() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.OuterClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class OuterClass {\",\n        \"  private static final class MiddleClass {\",\n        \"    static final class InnerClass {\",\n        \"      @Inject InnerClass() {}\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(file))\n        .withCompilerOptions(\"-Adagger.privateMemberValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(8);\n  }\n\n  @Test public void finalInjectField() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.FinalInjectField\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class FinalInjectField {\",\n        \"  @Inject final String s;\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(FINAL_INJECT_FIELD).in(file).onLine(6);\n  }\n\n  @Test public void privateInjectFieldError() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.PrivateInjectField\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class PrivateInjectField {\",\n        \"  @Inject private String s;\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(PRIVATE_INJECT_FIELD).in(file).onLine(6);\n  }\n\n  @Test public void privateInjectFieldWarning() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.PrivateInjectField\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class PrivateInjectField {\",\n        \"  @Inject private String s;\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .withCompilerOptions(\"-Adagger.privateMemberValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError(); // TODO: Verify warning message when supported\n  }\n\n  @Test public void staticInjectFieldError() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.StaticInjectField\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class StaticInjectField {\",\n        \"  @Inject static String s;\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(STATIC_INJECT_FIELD).in(file).onLine(6);\n  }\n\n  @Test public void staticInjectFieldWarning() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.StaticInjectField\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class StaticInjectField {\",\n        \"  @Inject static String s;\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .withCompilerOptions(\"-Adagger.staticMemberValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError(); // TODO: Verify warning message when supported\n  }\n\n  @Test public void multipleQualifiersOnField() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.MultipleQualifierInjectField\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class MultipleQualifierInjectField {\",\n        \"  @Inject @QualifierA @QualifierB String s;\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))\n        .processedWith(new ComponentProcessor()).failsToCompile()\n        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(11)\n        .and().withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6).atColumn(23);\n  }\n\n  @Test public void abstractInjectMethod() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.AbstractInjectMethod\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"abstract class AbstractInjectMethod {\",\n        \"  @Inject abstract void method();\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(ABSTRACT_INJECT_METHOD).in(file).onLine(6);\n  }\n\n  @Test public void privateInjectMethodError() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.PrivateInjectMethod\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class PrivateInjectMethod {\",\n        \"  @Inject private void method(){}\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(PRIVATE_INJECT_METHOD).in(file).onLine(6);\n  }\n\n  @Test public void privateInjectMethodWarning() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.PrivateInjectMethod\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class PrivateInjectMethod {\",\n        \"  @Inject private void method(){}\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .withCompilerOptions(\"-Adagger.privateMemberValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError(); // TODO: Verify warning message when supported\n  }\n\n  @Test public void staticInjectMethodError() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.StaticInjectMethod\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class StaticInjectMethod {\",\n        \"  @Inject static void method(){}\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(STATIC_INJECT_METHOD).in(file).onLine(6);\n  }\n\n  @Test public void staticInjectMethodWarning() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.StaticInjectMethod\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class StaticInjectMethod {\",\n        \"  @Inject static void method(){}\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .withCompilerOptions(\"-Adagger.staticMemberValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError(); // TODO: Verify warning message when supported\n  }\n\n  @Test public void genericInjectMethod() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.GenericInjectMethod\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class AbstractInjectMethod {\",\n        \"  @Inject \u003cT\u003e void method();\",\n        \"}\");\n    assertAbout(javaSource()).that(file)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(GENERIC_INJECT_METHOD).in(file).onLine(6);\n  }\n\n  @Test public void multipleQualifiersOnInjectMethodParameter() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.MultipleQualifierMethodParam\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class MultipleQualifierMethodParam {\",\n        \"  @Inject void method(@QualifierA @QualifierB String s) {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(file, QUALIFIER_A, QUALIFIER_B))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        // for whatever reason, javac only reports the error once on the method\n        .withErrorContaining(MULTIPLE_QUALIFIERS).in(file).onLine(6);\n  }\n\n  @Test public void injectConstructorDependsOnProduced() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.Produced;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject A(Produced\u003cString\u003e str) {}\",\n        \"}\");\n    assertAbout(javaSource()).that(aFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Produced may only be injected in @Produces methods\");\n  }\n\n  @Test public void injectConstructorDependsOnProducer() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.Producer;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject A(Producer\u003cString\u003e str) {}\",\n        \"}\");\n    assertAbout(javaSource()).that(aFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Producer may only be injected in @Produces methods\");\n  }\n\n  @Test public void injectFieldDependsOnProduced() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.Produced;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject Produced\u003cString\u003e str;\",\n        \"}\");\n    assertAbout(javaSource()).that(aFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Produced may only be injected in @Produces methods\");\n  }\n\n  @Test public void injectFieldDependsOnProducer() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.Producer;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject Producer\u003cString\u003e str;\",\n        \"}\");\n    assertAbout(javaSource()).that(aFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Producer may only be injected in @Produces methods\");\n  }\n\n  @Test public void injectMethodDependsOnProduced() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.Produced;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject void inject(Produced\u003cString\u003e str) {}\",\n        \"}\");\n    assertAbout(javaSource()).that(aFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Produced may only be injected in @Produces methods\");\n  }\n\n  @Test public void injectMethodDependsOnProducer() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.Producer;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject void inject(Producer\u003cString\u003e str) {}\",\n        \"}\");\n    assertAbout(javaSource()).that(aFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Producer may only be injected in @Produces methods\");\n  }\n\n  @Test public void injectConstructor() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.InjectConstructor\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class InjectConstructor {\",\n        \"  @Inject InjectConstructor(String s) {}\",\n        \"}\");\n    JavaFileObject expected \u003d JavaFileObjects.forSourceLines(\n        \"test.InjectConstructor_Factory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class InjectConstructor_Factory \",\n        \"    implements Factory\u003cInjectConstructor\u003e {\",\n        \"\",\n        \"  private final Provider\u003cString\u003e sProvider;\",\n        \"\",\n        \"  public InjectConstructor_Factory(Provider\u003cString\u003e sProvider) {\",\n        \"    assert sProvider !\u003d null;\",\n        \"    this.sProvider \u003d sProvider;\",\n        \"  }\",\n        \"\",\n        \"  @Override public InjectConstructor get() {\",\n        \"    return new InjectConstructor(sProvider.get());\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cInjectConstructor\u003e create(Provider\u003cString\u003e sProvider) {\",\n        \"    return new InjectConstructor_Factory(sProvider);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(expected);\n  }\n\n  @Test public void injectConstructorAndMembersInjection() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.AllInjections\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class AllInjections {\",\n        \"  @Inject String s;\",\n        \"  @Inject AllInjections(String s) {}\",\n        \"  @Inject void s(String s) {}\",\n        \"}\");\n    JavaFileObject expectedFactory \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.AllInjections_Factory\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MembersInjector;\",\n            \"import dagger.internal.Factory;\",\n            \"import dagger.internal.MembersInjectors;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class AllInjections_Factory \",\n            \"    implements Factory\u003cAllInjections\u003e {\",\n            \"\",\n            \"  private final MembersInjector\u003cAllInjections\u003e allInjectionsMembersInjector;\",\n            \"  private final Provider\u003cString\u003e sProvider;\",\n            \"\",\n            \"  public AllInjections_Factory(\",\n            \"      MembersInjector\u003cAllInjections\u003e allInjectionsMembersInjector, \",\n            \"      Provider\u003cString\u003e sProvider) {\",\n            \"    assert allInjectionsMembersInjector !\u003d null;\",\n            \"    this.allInjectionsMembersInjector \u003d allInjectionsMembersInjector;\",\n            \"    assert sProvider !\u003d null;\",\n            \"    this.sProvider \u003d sProvider;\",\n            \"  }\",\n            \"\",\n            \"  @Override public AllInjections get() {\",\n            \"    return MembersInjectors.injectMembers(\",\n            \"        allInjectionsMembersInjector, new AllInjections(sProvider.get()));\",\n            \"  }\",\n            \"\",\n            \"  public static Factory\u003cAllInjections\u003e create(\",\n            \"      MembersInjector\u003cAllInjections\u003e allInjectionsMembersInjector, \",\n            \"      Provider\u003cString\u003e sProvider) {\",\n            \"    return new AllInjections_Factory(allInjectionsMembersInjector, sProvider);\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(expectedFactory);\n  }\n\n  @Test public void supertypeRequiresMemberInjection() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"class A {}\");\n    JavaFileObject bFile \u003d JavaFileObjects.forSourceLines(\"test.B\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class B extends A {\",\n        \"  @Inject B() {}\",\n        \"}\");\n    JavaFileObject expectedFactory \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.B_Factory\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MembersInjector;\",\n            \"import dagger.internal.Factory;\",\n            \"import dagger.internal.MembersInjectors;\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class B_Factory implements Factory\u003cB\u003e {\",\n            \"\",\n            \"  private final MembersInjector\u003cB\u003e bMembersInjector;\",\n            \"\",\n            \"  public B_Factory(MembersInjector\u003cB\u003e bMembersInjector) {\",\n            \"    assert bMembersInjector !\u003d null;\",\n            \"    this.bMembersInjector \u003d bMembersInjector;\",\n            \"  }\",\n            \"\",\n            \"  @Override public B get() {\",\n            \"    return MembersInjectors.injectMembers(bMembersInjector, new B());\",\n            \"  }\",\n            \"\",\n            \"  public static Factory\u003cB\u003e create(MembersInjector\u003cB\u003e bMembersInjector) {\",\n            \"    return new B_Factory(bMembersInjector);\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(aFile, bFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(expectedFactory);\n  }\n\n  @Test\n  public void wildcardDependency() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.InjectConstructor\",\n        \"package test;\",\n        \"\",\n        \"import java.util.List;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class InjectConstructor {\",\n        \"  @Inject InjectConstructor(List\u003c?\u003e objects) {}\",\n        \"}\");\n    JavaFileObject expected \u003d JavaFileObjects.forSourceLines(\n        \"test.InjectConstructor_Factory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import java.util.List;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class InjectConstructor_Factory \",\n        \"    implements Factory\u003cInjectConstructor\u003e {\",\n        \"\",\n        \"  private final Provider\u003cList\u003c?\u003e\u003e objectsProvider;\",\n        \"\",\n        \"  public InjectConstructor_Factory(Provider\u003cList\u003c?\u003e\u003e objectsProvider) {\",\n        \"    assert objectsProvider !\u003d null;\",\n        \"    this.objectsProvider \u003d objectsProvider;\",\n        \"  }\",\n        \"\",\n        \"  @Override public InjectConstructor get() {\",\n        \"    return new InjectConstructor(objectsProvider.get());\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cInjectConstructor\u003e create(\",\n        \"      Provider\u003cList\u003c?\u003e\u003e objectsProvider) {\",\n        \"    return new InjectConstructor_Factory(objectsProvider);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(file).processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(expected);\n  }\n\n  @Test\n  public void basicNameCollision() {\n    JavaFileObject factoryFile \u003d JavaFileObjects.forSourceLines(\"other.pkg.Factory\",\n        \"package other.pkg;\",\n        \"\",\n        \"public class Factory {}\");\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.InjectConstructor\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"import other.pkg.Factory;\",\n        \"\",\n        \"class InjectConstructor {\",\n        \"  @Inject InjectConstructor(Factory factory) {}\",\n        \"}\");\n    JavaFileObject expected \u003d JavaFileObjects.forSourceLines(\n        \"test.InjectConstructor_Factory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class InjectConstructor_Factory \",\n        \"    implements Factory\u003cInjectConstructor\u003e {\",\n        \"\",\n        \"  private final Provider\u003cother.pkg.Factory\u003e factoryProvider;\",\n        \"\",\n        \"  public InjectConstructor_Factory(Provider\u003cother.pkg.Factory\u003e factoryProvider) {\",\n        \"    assert factoryProvider !\u003d null;\",\n        \"    this.factoryProvider \u003d factoryProvider;\",\n        \"  }\",\n        \"\",\n        \"  @Override public InjectConstructor get() {\",\n        \"    return new InjectConstructor(factoryProvider.get());\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cInjectConstructor\u003e create(\",\n        \"      Provider\u003cother.pkg.Factory\u003e factoryProvider) {\",\n        \"    return new InjectConstructor_Factory(factoryProvider);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(factoryFile, file))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(expected);\n  }\n\n  @Test\n  public void nestedNameCollision() {\n    JavaFileObject factoryFile \u003d JavaFileObjects.forSourceLines(\"other.pkg.Outer\",\n        \"package other.pkg;\",\n        \"\",\n        \"public class Outer {\",\n        \"  public class Factory {}\",\n        \"}\");\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.InjectConstructor\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"import other.pkg.Outer;\",\n        \"\",\n        \"class InjectConstructor {\",\n        \"  @Inject InjectConstructor(Outer.Factory factory) {}\",\n        \"}\");\n    JavaFileObject expected \u003d JavaFileObjects.forSourceLines(\n        \"test.InjectConstructor_Factory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"import other.pkg.Outer;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class InjectConstructor_Factory \",\n        \"    implements Factory\u003cInjectConstructor\u003e {\",\n        \"\",\n        \"  private final Provider\u003cOuter.Factory\u003e factoryProvider;\",\n        \"\",\n        \"  public InjectConstructor_Factory(Provider\u003cOuter.Factory\u003e factoryProvider) {\",\n        \"    assert factoryProvider !\u003d null;\",\n        \"    this.factoryProvider \u003d factoryProvider;\",\n        \"  }\",\n        \"\",\n        \"  @Override public InjectConstructor get() {\",\n        \"    return new InjectConstructor(factoryProvider.get());\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cInjectConstructor\u003e create(\",\n        \"      Provider\u003cOuter.Factory\u003e factoryProvider) {\",\n        \"    return new InjectConstructor_Factory(factoryProvider);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(factoryFile, file))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(expected);\n  }\n\n  @Test\n  public void samePackageNameCollision() {\n    JavaFileObject samePackageInterface \u003d JavaFileObjects.forSourceLines(\"test.CommonName\",\n        \"package test;\",\n        \"\",\n        \"public interface CommonName {}\");\n    JavaFileObject differentPackageInterface \u003d JavaFileObjects.forSourceLines(\n        \"other.pkg.CommonName\",\n        \"package other.pkg;\",\n        \"\",\n        \"public interface CommonName {}\");\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.InjectConstructor\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class InjectConstructor implements CommonName {\",\n        \"  @Inject InjectConstructor(other.pkg.CommonName otherPackage, CommonName samePackage) {}\",\n        \"}\");\n    JavaFileObject expected \u003d JavaFileObjects.forSourceLines(\n        \"test.InjectConstructor_Factory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class InjectConstructor_Factory \",\n        \"    implements Factory\u003cInjectConstructor\u003e {\",\n        \"\",\n        \"  private final Provider\u003cother.pkg.CommonName\u003e otherPackageProvider;\",\n        \"  private final Provider\u003cCommonName\u003e samePackageProvider;\",\n        \"\",\n        \"  public InjectConstructor_Factory(Provider\u003cother.pkg.CommonName\u003e otherPackageProvider,\",\n        \"      Provider\u003cCommonName\u003e samePackageProvider) {\",\n        \"    assert otherPackageProvider !\u003d null;\",\n        \"    this.otherPackageProvider \u003d otherPackageProvider;\",\n        \"    assert samePackageProvider !\u003d null;\",\n        \"    this.samePackageProvider \u003d samePackageProvider;\",\n        \"  }\",\n        \"\",\n        \"  @Override public InjectConstructor get() {\",\n        \"    return new InjectConstructor(otherPackageProvider.get(), samePackageProvider.get());\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cInjectConstructor\u003e create(\",\n        \"      Provider\u003cother.pkg.CommonName\u003e otherPackageProvider,\",\n        \"      Provider\u003cCommonName\u003e samePackageProvider) {\",\n        \"    return new InjectConstructor_Factory(otherPackageProvider, samePackageProvider);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(samePackageInterface, differentPackageInterface, file))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(expected);\n  }\n\n  @Test\n  public void noDeps() {\n    JavaFileObject simpleType \u003d JavaFileObjects.forSourceLines(\"test.SimpleType\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class SimpleType {\",\n        \"  @Inject SimpleType() {}\",\n        \"}\");\n    JavaFileObject factory \u003d JavaFileObjects.forSourceLines(\"test.SimpleType_Factory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import javax.annotation.Generated;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public enum SimpleType_Factory implements Factory\u003cSimpleType\u003e {\",\n        \"  INSTANCE;\",\n        \"\",\n        \"  @Override public SimpleType get() {\",\n        \"    return new SimpleType();\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cSimpleType\u003e create() {\",\n        \"    return INSTANCE;\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource())\n        .that(simpleType)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(factory);\n  }\n\n  @Test public void simpleComponentWithNesting() {\n    JavaFileObject nestedTypesFile \u003d JavaFileObjects.forSourceLines(\"test.OuterType\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class OuterType {\",\n        \"  static class A {\",\n        \"    @Inject A() {}\",\n        \"  }\",\n        \"  static class B {\",\n        \"    @Inject A a;\",\n        \"  }\",\n        \"  @Component interface SimpleComponent {\",\n        \"    A a();\",\n        \"    void inject(B b);\",\n        \"  }\",\n        \"}\");\n    JavaFileObject aFactory \u003d JavaFileObjects.forSourceLines(\n        \"test.OuterType_A_Factory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import javax.annotation.Generated;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public enum OuterType_A_Factory implements Factory\u003cOuterType.A\u003e {\",\n        \"  INSTANCE;\",\n        \"\",\n        \"  @Override public OuterType.A get() {\",\n        \"    return new OuterType.A();\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cOuterType.A\u003e create() {\",\n        \"    return INSTANCE;\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(nestedTypesFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(aFactory);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\KeyTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.google.auto.common.MoreTypes;\nimport com.google.common.collect.Iterables;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.testing.compile.CompilationRule;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.internal.codegen.Key.MultibindingContributionIdentifier;\nimport dagger.multibindings.ElementsIntoSet;\nimport dagger.multibindings.IntoSet;\nimport dagger.producers.ProducerModule;\nimport dagger.producers.Produces;\nimport java.util.Set;\nimport javax.inject.Inject;\nimport javax.inject.Qualifier;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.ElementFilter;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/**\n * Tests {@link Key}.\n */\n@RunWith(JUnit4.class)\npublic class KeyTest {\n  @Rule public CompilationRule compilationRule \u003d new CompilationRule();\n\n  private Elements elements;\n  private Types types;\n  private Key.Factory keyFactory;\n\n  @Before public void setUp() {\n    this.types \u003d compilationRule.getTypes();\n    this.elements \u003d compilationRule.getElements();\n    this.keyFactory \u003d new Key.Factory(types, elements);\n  }\n\n  @Test public void forInjectConstructorWithResolvedType() {\n    TypeElement typeElement \u003d\n        compilationRule.getElements().getTypeElement(InjectedClass.class.getCanonicalName());\n    ExecutableElement constructor \u003d\n        Iterables.getOnlyElement(ElementFilter.constructorsIn(typeElement.getEnclosedElements()));\n    Key key \u003d\n        keyFactory.forInjectConstructorWithResolvedType(constructor.getEnclosingElement().asType());\n    assertThat(key).isEqualTo(Key.builder(typeElement.asType()).build());\n    assertThat(key.toString()).isEqualTo(\"dagger.internal.codegen.KeyTest.InjectedClass\");\n  }\n\n  static final class InjectedClass {\n    @SuppressWarnings(\"unused\")\n    @Inject InjectedClass(String s, int i) {}\n  }\n\n  @Test public void forProvidesMethod() {\n    TypeMirror stringType \u003d elements.getTypeElement(String.class.getCanonicalName()).asType();\n    TypeElement moduleElement \u003d\n        elements.getTypeElement(ProvidesMethodModule.class.getCanonicalName());\n    ExecutableElement providesMethod \u003d\n        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));\n    Key key \u003d keyFactory.forProvidesMethod(providesMethod, moduleElement);\n    assertThat(key).isEqualTo(Key.builder(stringType).build());\n    assertThat(key.toString()).isEqualTo(\"java.lang.String\");\n  }\n\n  @Module\n  static final class ProvidesMethodModule {\n    @Provides String provideString() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  @Test public void forProvidesMethod_qualified() {\n    TypeMirror stringType \u003d elements.getTypeElement(String.class.getCanonicalName()).asType();\n    TypeElement qualifierElement \u003d\n        elements.getTypeElement(TestQualifier.class.getCanonicalName());\n    TypeElement moduleElement \u003d\n        elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());\n    ExecutableElement providesMethod \u003d\n        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));\n    Key key \u003d keyFactory.forProvidesMethod(providesMethod, moduleElement);\n    assertThat(MoreTypes.equivalence().wrap(key.qualifier().get().getAnnotationType()))\n        .isEqualTo(MoreTypes.equivalence().wrap(qualifierElement.asType()));\n    assertThat(key.wrappedType()).isEqualTo(MoreTypes.equivalence().wrap(stringType));\n    assertThat(key.toString())\n        .isEqualTo(\n            \"@dagger.internal.codegen.KeyTest.TestQualifier(\"\n                + \"{@dagger.internal.codegen.KeyTest.InnerAnnotation}) java.lang.String\");\n  }\n\n  @Test public void qualifiedKeyEquivalents() {\n    TypeElement moduleElement \u003d\n        elements.getTypeElement(QualifiedProvidesMethodModule.class.getCanonicalName());\n    ExecutableElement providesMethod \u003d\n        Iterables.getOnlyElement(ElementFilter.methodsIn(moduleElement.getEnclosedElements()));\n    Key provisionKey \u003d keyFactory.forProvidesMethod(providesMethod, moduleElement);\n\n    TypeMirror type \u003d elements.getTypeElement(String.class.getCanonicalName()).asType();\n    TypeElement injectableElement \u003d\n        elements.getTypeElement(QualifiedFieldHolder.class.getCanonicalName());\n    Element injectionField \u003d\n        Iterables.getOnlyElement(ElementFilter.fieldsIn(injectableElement.getEnclosedElements()));\n    AnnotationMirror qualifier \u003d Iterables.getOnlyElement(injectionField.getAnnotationMirrors());\n    Key injectionKey \u003d Key.builder(type).qualifier(qualifier).build();\n\n    assertThat(provisionKey).isEqualTo(injectionKey);\n    assertThat(injectionKey.toString())\n        .isEqualTo(\n            \"@dagger.internal.codegen.KeyTest.TestQualifier(\"\n                + \"{@dagger.internal.codegen.KeyTest.InnerAnnotation}) java.lang.String\");\n  }\n\n  @Module\n  static final class QualifiedProvidesMethodModule {\n    @Provides\n    @TestQualifier(@InnerAnnotation)\n    String provideQualifiedString() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  static final class QualifiedFieldHolder {\n    @TestQualifier(@InnerAnnotation) String aString;\n  }\n\n  @Qualifier\n  @interface TestQualifier {\n    InnerAnnotation[] value();\n  }\n\n  @interface InnerAnnotation {}\n\n  @Test public void forProvidesMethod_sets() {\n    TypeElement setElement \u003d elements.getTypeElement(Set.class.getCanonicalName());\n    TypeMirror stringType \u003d elements.getTypeElement(String.class.getCanonicalName()).asType();\n    TypeMirror setOfStringsType \u003d types.getDeclaredType(setElement, stringType);\n    TypeElement moduleElement \u003d\n        elements.getTypeElement(SetProvidesMethodsModule.class.getCanonicalName());\n    for (ExecutableElement providesMethod\n        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {\n      Key key \u003d keyFactory.forProvidesMethod(providesMethod, moduleElement);\n      assertThat(key)\n          .isEqualTo(\n              Key.builder(setOfStringsType)\n                  .multibindingContributionIdentifier(\n                      new MultibindingContributionIdentifier(providesMethod, moduleElement))\n                  .build());\n      assertThat(key.toString())\n          .isEqualTo(\n              String.format(\n                  \"java.util.Set\u003cjava.lang.String\u003e \"\n                      + \"dagger.internal.codegen.KeyTest.SetProvidesMethodsModule#%s\",\n                  providesMethod.getSimpleName()));\n    }\n  }\n\n  @Module\n  static final class SetProvidesMethodsModule {\n    @Provides @IntoSet String provideString() {\n      throw new UnsupportedOperationException();\n    }\n\n    @Provides @ElementsIntoSet Set\u003cString\u003e provideStrings() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  @Module\n  static final class PrimitiveTypes {\n    @Provides int foo() {\n      return 0;\n    }\n  }\n\n  @Module\n  static final class BoxedPrimitiveTypes {\n    @Provides Integer foo() {\n      return 0;\n    }\n  }\n\n  @Test public void primitiveKeysMatchBoxedKeys() {\n    TypeElement primitiveHolder \u003d elements.getTypeElement(PrimitiveTypes.class.getCanonicalName());\n    ExecutableElement intMethod \u003d\n        Iterables.getOnlyElement(ElementFilter.methodsIn(primitiveHolder.getEnclosedElements()));\n    TypeElement boxedPrimitiveHolder \u003d\n        elements.getTypeElement(BoxedPrimitiveTypes.class.getCanonicalName());\n    ExecutableElement integerMethod \u003d Iterables.getOnlyElement(\n        ElementFilter.methodsIn(boxedPrimitiveHolder.getEnclosedElements()));\n\n    // TODO(cgruber): Truth subject for TypeMirror and TypeElement\n    TypeMirror intType \u003d intMethod.getReturnType();\n    assertThat(intType.getKind().isPrimitive()).isTrue();\n    TypeMirror integerType \u003d integerMethod.getReturnType();\n    assertThat(integerType.getKind().isPrimitive()).isFalse();\n    assertThat(types.isSameType(intType, integerType)).named(\"type equality\").isFalse();\n    Key intKey \u003d keyFactory.forProvidesMethod(intMethod, primitiveHolder);\n    Key integerKey \u003d keyFactory.forProvidesMethod(integerMethod, boxedPrimitiveHolder);\n    assertThat(intKey).isEqualTo(integerKey);\n    assertThat(intKey.toString()).isEqualTo(\"java.lang.Integer\");\n    assertThat(integerKey.toString()).isEqualTo(\"java.lang.Integer\");\n  }\n\n  @Test public void forProducesMethod() {\n    TypeMirror stringType \u003d elements.getTypeElement(String.class.getCanonicalName()).asType();\n    TypeElement moduleElement \u003d\n        elements.getTypeElement(ProducesMethodsModule.class.getCanonicalName());\n    for (ExecutableElement producesMethod\n        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {\n      Key key \u003d keyFactory.forProducesMethod(producesMethod, moduleElement);\n      assertThat(key).isEqualTo(Key.builder(stringType).build());\n      assertThat(key.toString()).isEqualTo(\"java.lang.String\");\n    }\n  }\n\n  @ProducerModule\n  static final class ProducesMethodsModule {\n    @Produces String produceString() {\n      throw new UnsupportedOperationException();\n    }\n\n    @Produces ListenableFuture\u003cString\u003e produceFutureString() {\n      throw new UnsupportedOperationException();\n    }\n  }\n\n  @Test public void forProducesMethod_sets() {\n    TypeElement setElement \u003d elements.getTypeElement(Set.class.getCanonicalName());\n    TypeMirror stringType \u003d elements.getTypeElement(String.class.getCanonicalName()).asType();\n    TypeMirror setOfStringsType \u003d types.getDeclaredType(setElement, stringType);\n    TypeElement moduleElement \u003d\n        elements.getTypeElement(SetProducesMethodsModule.class.getCanonicalName());\n    for (ExecutableElement producesMethod\n        : ElementFilter.methodsIn(moduleElement.getEnclosedElements())) {\n      Key key \u003d keyFactory.forProducesMethod(producesMethod, moduleElement);\n      assertThat(key)\n          .isEqualTo(\n              Key.builder(setOfStringsType)\n                  .multibindingContributionIdentifier(\n                      new MultibindingContributionIdentifier(producesMethod, moduleElement))\n                  .build());\n      assertThat(key.toString())\n          .isEqualTo(\n              String.format(\n                  \"java.util.Set\u003cjava.lang.String\u003e \"\n                      + \"dagger.internal.codegen.KeyTest.SetProducesMethodsModule#%s\",\n                  producesMethod.getSimpleName()));\n    }\n  }\n\n  @ProducerModule\n  static final class SetProducesMethodsModule {\n    @Produces @IntoSet String produceString() {\n      throw new UnsupportedOperationException();\n    }\n\n    @Produces @IntoSet ListenableFuture\u003cString\u003e produceFutureString() {\n      throw new UnsupportedOperationException();\n    }\n\n    @Produces @ElementsIntoSet Set\u003cString\u003e produceStrings() {\n      throw new UnsupportedOperationException();\n    }\n\n    @Produces @ElementsIntoSet\n    ListenableFuture\u003cSet\u003cString\u003e\u003e produceFutureStrings() {\n      throw new UnsupportedOperationException();\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\MapBindingComponentProcessorTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;\n\nimport com.google.auto.value.processor.AutoAnnotationProcessor;\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class MapBindingComponentProcessorTest {\n\n  @Test\n  public void mapBindingsWithEnumKey() {\n    JavaFileObject mapModuleOneFile \u003d\n        JavaFileObjects\n            .forSourceLines(\"test.MapModuleOne\",\n                \"package test;\",\n                \"\",\n                \"import dagger.Module;\",\n                \"import dagger.Provides;\",\n                \"import dagger.multibindings.IntoMap;\",\n                \"\",\n                \"@Module\",\n                \"final class MapModuleOne {\",\n                \"  @Provides @IntoMap @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {\",\n                \"    return new AdminHandler();\",\n                \"  }\",\n                \"}\");\n    JavaFileObject mapModuleTwoFile \u003d\n        JavaFileObjects\n            .forSourceLines(\"test.MapModuleTwo\",\n                \"package test;\",\n                \"\",\n                \"import dagger.Module;\",\n                \"import dagger.Provides;\",\n                \"import dagger.multibindings.IntoMap;\",\n                \"\",\n                \"@Module\",\n                \"final class MapModuleTwo {\",\n                \"  @Provides @IntoMap @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {\",\n                \"    return new LoginHandler();\",\n                \"  }\",\n                \"}\");\n    JavaFileObject enumKeyFile \u003d JavaFileObjects.forSourceLines(\"test.PathKey\",\n        \"package test;\",\n        \"import dagger.MapKey;\",\n        \"import java.lang.annotation.Retention;\",\n        \"import static java.lang.annotation.RetentionPolicy.RUNTIME;\",\n        \"\",\n        \"@MapKey(unwrapValue \u003d true)\",\n        \"@Retention(RUNTIME)\",\n        \"public @interface PathKey {\",\n        \"  PathEnum value();\",\n        \"}\");\n    JavaFileObject pathEnumFile \u003d JavaFileObjects.forSourceLines(\"test.PathEnum\",\n        \"package test;\",\n        \"\",\n        \"public enum PathEnum {\",\n        \"    ADMIN,\",\n        \"    LOGIN;\",\n        \"}\");\n\n    JavaFileObject HandlerFile \u003d JavaFileObjects.forSourceLines(\"test.Handler\",\n        \"package test;\",\n        \"\",\n        \"interface Handler {}\");\n    JavaFileObject LoginHandlerFile \u003d JavaFileObjects.forSourceLines(\"test.LoginHandler\",\n        \"package test;\",\n        \"\",\n        \"class LoginHandler implements Handler {\",\n        \"  public LoginHandler() {}\",\n        \"}\");\n    JavaFileObject AdminHandlerFile \u003d JavaFileObjects.forSourceLines(\"test.AdminHandler\",\n        \"package test;\",\n        \"\",\n        \"class AdminHandler implements Handler {\",\n        \"  public AdminHandler() {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import java.util.Map;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component(modules \u003d {MapModuleOne.class, MapModuleTwo.class})\",\n        \"interface TestComponent {\",\n        \"  Map\u003cPathEnum, Provider\u003cHandler\u003e\u003e dispatcher();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerTestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.MapProviderFactory;\",\n            \"import dagger.internal.Preconditions;\",\n            \"import java.util.Map;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerTestComponent implements TestComponent {\",\n            \"  private Provider\u003cHandler\u003e provideAdminHandlerProvider;\",\n            \"  private Provider\u003cHandler\u003e provideLoginHandlerProvider;\",\n            \"  private Provider\u003cMap\u003cPathEnum, Provider\u003cHandler\u003e\u003e\u003e\",\n            \"      mapOfPathEnumAndProviderOfHandlerProvider;\",\n            \"\",\n            \"  private DaggerTestComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static TestComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.provideAdminHandlerProvider \u003d\",\n            \"        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);\",\n            \"    this.provideLoginHandlerProvider \u003d\",\n            \"        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);\",\n            \"    this.mapOfPathEnumAndProviderOfHandlerProvider \u003d\",\n            \"        MapProviderFactory.\u003cPathEnum, Handler\u003ebuilder(2)\",\n            \"            .put(PathEnum.ADMIN, provideAdminHandlerProvider)\",\n            \"            .put(PathEnum.LOGIN, provideLoginHandlerProvider)\",\n            \"            .build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Map\u003cPathEnum, Provider\u003cHandler\u003e\u003e dispatcher() {\",\n            \"    return mapOfPathEnumAndProviderOfHandlerProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private MapModuleOne mapModuleOne;\",\n            \"    private MapModuleTwo mapModuleTwo;\",\n            \"\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public TestComponent build() {\",\n            \"      if (mapModuleOne \u003d\u003d null) {\",\n            \"        this.mapModuleOne \u003d new MapModuleOne();\",\n            \"      }\",\n            \"      if (mapModuleTwo \u003d\u003d null) {\",\n            \"        this.mapModuleTwo \u003d new MapModuleTwo();\",\n            \"      }\",\n            \"      return new DaggerTestComponent(this);\",\n            \"    }\",\n            \"\",\n            \"    public Builder mapModuleOne(MapModuleOne mapModuleOne) {\",\n            \"      this.mapModuleOne \u003d Preconditions.checkNotNull(mapModuleOne);\",\n            \"      return this;\",\n            \"    }\",\n            \"\",\n            \"    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {\",\n            \"      this.mapModuleTwo \u003d Preconditions.checkNotNull(mapModuleTwo);\",\n            \"      return this;\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(mapModuleOneFile,\n            mapModuleTwoFile,\n            enumKeyFile,\n            pathEnumFile,\n            HandlerFile,\n            LoginHandlerFile,\n            AdminHandlerFile,\n            componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(generatedComponent);\n  }\n\n  @Test\n  public void mapBindingsWithStringKey() {\n    JavaFileObject mapModuleOneFile \u003d\n        JavaFileObjects\n            .forSourceLines(\"test.MapModuleOne\",\n                \"package test;\",\n                \"\",\n                \"import dagger.Module;\",\n                \"import dagger.Provides;\",\n                \"import dagger.multibindings.StringKey;\",\n                \"import dagger.multibindings.IntoMap;\",\n                \"\",\n                \"@Module\",\n                \"final class MapModuleOne {\",\n                \"  @Provides @IntoMap @StringKey(\\\"Admin\\\") Handler provideAdminHandler() {\",\n                \"    return new AdminHandler();\",\n                \"  }\",\n                \"}\");\n    JavaFileObject mapModuleTwoFile \u003d\n        JavaFileObjects\n            .forSourceLines(\"test.MapModuleTwo\",\n                \"package test;\",\n                \"\",\n                \"import dagger.Module;\",\n                \"import dagger.Provides;\",\n                \"import dagger.multibindings.IntoMap;\",\n                \"import dagger.multibindings.StringKey;\",\n                \"\",\n                \"@Module\",\n                \"final class MapModuleTwo {\",\n                \"  @Provides @IntoMap @StringKey(\\\"Login\\\") Handler provideLoginHandler() {\",\n                \"    return new LoginHandler();\",\n                \"  }\",\n                \"}\");\n    JavaFileObject HandlerFile \u003d JavaFileObjects.forSourceLines(\"test.Handler\",\n        \"package test;\",\n        \"\",\n        \"interface Handler {}\");\n    JavaFileObject LoginHandlerFile \u003d JavaFileObjects.forSourceLines(\"test.LoginHandler\",\n        \"package test;\",\n        \"\",\n        \"class LoginHandler implements Handler {\",\n        \"  public LoginHandler() {}\",\n        \"}\");\n    JavaFileObject AdminHandlerFile \u003d JavaFileObjects.forSourceLines(\"test.AdminHandler\",\n        \"package test;\",\n        \"\",\n        \"class AdminHandler implements Handler {\",\n        \"  public AdminHandler() {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import java.util.Map;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component(modules \u003d {MapModuleOne.class, MapModuleTwo.class})\",\n        \"interface TestComponent {\",\n        \"  Map\u003cString, Provider\u003cHandler\u003e\u003e dispatcher();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerTestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.MapProviderFactory;\",\n            \"import dagger.internal.Preconditions;\",\n            \"import java.util.Map;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerTestComponent implements TestComponent {\",\n            \"  private Provider\u003cHandler\u003e provideAdminHandlerProvider;\",\n            \"  private Provider\u003cHandler\u003e provideLoginHandlerProvider;\",\n            \"  private Provider\u003cMap\u003cString, Provider\u003cHandler\u003e\u003e\u003e\",\n            \"      mapOfStringAndProviderOfHandlerProvider;\",\n            \"\",\n            \"  private DaggerTestComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static TestComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.provideAdminHandlerProvider \u003d\",\n            \"        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);\",\n            \"    this.provideLoginHandlerProvider \u003d\",\n            \"        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);\",\n            \"    this.mapOfStringAndProviderOfHandlerProvider \u003d\",\n            \"        MapProviderFactory.\u003cString, Handler\u003ebuilder(2)\",\n            \"            .put(\\\"Admin\\\", provideAdminHandlerProvider)\",\n            \"            .put(\\\"Login\\\", provideLoginHandlerProvider)\",\n            \"            .build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Map\u003cString, Provider\u003cHandler\u003e\u003e dispatcher() {\",\n            \"    return mapOfStringAndProviderOfHandlerProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private MapModuleOne mapModuleOne;\",\n            \"    private MapModuleTwo mapModuleTwo;\",\n            \"\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public TestComponent build() {\",\n            \"      if (mapModuleOne \u003d\u003d null) {\",\n            \"        this.mapModuleOne \u003d new MapModuleOne();\",\n            \"      }\",\n            \"      if (mapModuleTwo \u003d\u003d null) {\",\n            \"        this.mapModuleTwo \u003d new MapModuleTwo();\",\n            \"      }\",\n            \"      return new DaggerTestComponent(this);\",\n            \"    }\",\n            \"\",\n            \"    public Builder mapModuleOne(MapModuleOne mapModuleOne) {\",\n            \"      this.mapModuleOne \u003d Preconditions.checkNotNull(mapModuleOne);\",\n            \"      return this;\",\n            \"    }\",\n            \"\",\n            \"    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {\",\n            \"      this.mapModuleTwo \u003d Preconditions.checkNotNull(mapModuleTwo);\",\n            \"      return this;\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(mapModuleOneFile,\n            mapModuleTwoFile,\n            HandlerFile,\n            LoginHandlerFile,\n            AdminHandlerFile,\n            componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(generatedComponent);\n  }\n\n  @Test\n  public void mapBindingsWithWrappedKey() {\n    JavaFileObject mapModuleOneFile \u003d\n        JavaFileObjects\n            .forSourceLines(\"test.MapModuleOne\",\n                \"package test;\",\n                \"\",\n                \"import dagger.Module;\",\n                \"import dagger.Provides;\",\n                \"import dagger.multibindings.IntoMap;\",\n                \"\",\n                \"@Module\",\n                \"final class MapModuleOne {\",\n                \"  @Provides @IntoMap\",\n                \"  @WrappedClassKey(Integer.class) Handler provideAdminHandler() {\",\n                \"    return new AdminHandler();\",\n                \"  }\",\n                \"}\");\n    JavaFileObject mapModuleTwoFile \u003d\n        JavaFileObjects\n            .forSourceLines(\"test.MapModuleTwo\",\n                \"package test;\",\n                \"\",\n                \"import dagger.Module;\",\n                \"import dagger.Provides;\",\n                \"import dagger.multibindings.IntoMap;\",\n                \"\",\n                \"@Module\",\n                \"final class MapModuleTwo {\",\n                \"  @Provides @IntoMap\",\n                \"  @WrappedClassKey(Long.class) Handler provideLoginHandler() {\",\n                \"    return new LoginHandler();\",\n                \"  }\",\n                \"}\");\n    JavaFileObject wrappedClassKeyFile \u003d JavaFileObjects.forSourceLines(\"test.WrappedClassKey\",\n        \"package test;\",\n        \"import dagger.MapKey;\",\n        \"import java.lang.annotation.Retention;\",\n        \"import static java.lang.annotation.RetentionPolicy.RUNTIME;\",\n        \"\",\n        \"@MapKey(unwrapValue \u003d false)\",\n        \"@Retention(RUNTIME)\",\n        \"public @interface WrappedClassKey {\",\n        \"  Class\u003c?\u003e value();\",\n        \"}\");\n    JavaFileObject HandlerFile \u003d JavaFileObjects.forSourceLines(\"test.Handler\",\n        \"package test;\",\n        \"\",\n        \"interface Handler {}\");\n    JavaFileObject LoginHandlerFile \u003d JavaFileObjects.forSourceLines(\"test.LoginHandler\",\n        \"package test;\",\n        \"\",\n        \"class LoginHandler implements Handler {\",\n        \"  public LoginHandler() {}\",\n        \"}\");\n    JavaFileObject AdminHandlerFile \u003d JavaFileObjects.forSourceLines(\"test.AdminHandler\",\n        \"package test;\",\n        \"\",\n        \"class AdminHandler implements Handler {\",\n        \"  public AdminHandler() {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import java.util.Map;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component(modules \u003d {MapModuleOne.class, MapModuleTwo.class})\",\n        \"interface TestComponent {\",\n        \"  Map\u003cWrappedClassKey, Provider\u003cHandler\u003e\u003e dispatcher();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerTestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.MapProviderFactory;\",\n            \"import dagger.internal.Preconditions;\",\n            \"import java.util.Map;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerTestComponent implements TestComponent {\",\n            \"  private Provider\u003cHandler\u003e provideAdminHandlerProvider;\",\n            \"  private Provider\u003cHandler\u003e provideLoginHandlerProvider;\",\n            \"  private Provider\u003cMap\u003cWrappedClassKey, Provider\u003cHandler\u003e\u003e\u003e\",\n            \"      mapOfWrappedClassKeyAndProviderOfHandlerProvider;\",\n            \"\",\n            \"  private DaggerTestComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static TestComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.provideAdminHandlerProvider \u003d\",\n            \"        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);\",\n            \"    this.provideLoginHandlerProvider \u003d\",\n            \"        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);\",\n            \"    this.mapOfWrappedClassKeyAndProviderOfHandlerProvider \u003d\",\n            \"        MapProviderFactory.\u003cWrappedClassKey, Handler\u003ebuilder(2)\",\n            \"            .put(WrappedClassKeyCreator.createWrappedClassKey(Integer.class),\",\n            \"                provideAdminHandlerProvider)\",\n            \"            .put(WrappedClassKeyCreator.createWrappedClassKey(Long.class),\",\n            \"                provideLoginHandlerProvider)\",\n            \"            .build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Map\u003cWrappedClassKey, Provider\u003cHandler\u003e\u003e dispatcher() {\",\n            \"    return mapOfWrappedClassKeyAndProviderOfHandlerProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private MapModuleOne mapModuleOne;\",\n            \"    private MapModuleTwo mapModuleTwo;\",\n            \"\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public TestComponent build() {\",\n            \"      if (mapModuleOne \u003d\u003d null) {\",\n            \"        this.mapModuleOne \u003d new MapModuleOne();\",\n            \"      }\",\n            \"      if (mapModuleTwo \u003d\u003d null) {\",\n            \"        this.mapModuleTwo \u003d new MapModuleTwo();\",\n            \"      }\",\n            \"      return new DaggerTestComponent(this);\",\n            \"    }\",\n            \"\",\n            \"    public Builder mapModuleOne(MapModuleOne mapModuleOne) {\",\n            \"      this.mapModuleOne \u003d Preconditions.checkNotNull(mapModuleOne);\",\n            \"      return this;\",\n            \"    }\",\n            \"\",\n            \"    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {\",\n            \"      this.mapModuleTwo \u003d Preconditions.checkNotNull(mapModuleTwo);\",\n            \"      return this;\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(mapModuleOneFile,\n            mapModuleTwoFile,\n            wrappedClassKeyFile,\n            HandlerFile,\n            LoginHandlerFile,\n            AdminHandlerFile,\n            componentFile))\n        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(generatedComponent);\n  }\n\n  @Test\n  public void mapBindingsWithNonProviderValue() {\n    JavaFileObject mapModuleOneFile \u003d JavaFileObjects.forSourceLines(\"test.MapModuleOne\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.multibindings.IntoMap;\",\n        \"\",\n        \"@Module\",\n        \"final class MapModuleOne {\",\n        \"  @Provides @IntoMap @PathKey(PathEnum.ADMIN) Handler provideAdminHandler() {\",\n        \"    return new AdminHandler();\",\n        \"  }\",\n        \"}\");\n    JavaFileObject mapModuleTwoFile \u003d JavaFileObjects.forSourceLines(\"test.MapModuleTwo\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.multibindings.IntoMap;\",\n        \"\",\n        \"@Module\",\n        \"final class MapModuleTwo {\",\n        \"  @Provides @IntoMap @PathKey(PathEnum.LOGIN) Handler provideLoginHandler() {\",\n        \"    return new LoginHandler();\",\n        \"  }\",\n        \"}\");\n    JavaFileObject enumKeyFile \u003d JavaFileObjects.forSourceLines(\"test.PathKey\",\n        \"package test;\",\n        \"import dagger.MapKey;\",\n        \"import java.lang.annotation.Retention;\",\n        \"import static java.lang.annotation.RetentionPolicy.RUNTIME;\",\n        \"\",\n        \"@MapKey(unwrapValue \u003d true)\",\n        \"@Retention(RUNTIME)\",\n        \"public @interface PathKey {\",\n        \"  PathEnum value();\",\n        \"}\");\n    JavaFileObject pathEnumFile \u003d JavaFileObjects.forSourceLines(\"test.PathEnum\",\n        \"package test;\",\n        \"\",\n        \"public enum PathEnum {\",\n        \"    ADMIN,\",\n        \"    LOGIN;\",\n        \"}\");\n    JavaFileObject HandlerFile \u003d JavaFileObjects.forSourceLines(\"test.Handler\",\n        \"package test;\",\n        \"\",\n        \"interface Handler {}\");\n    JavaFileObject LoginHandlerFile \u003d JavaFileObjects.forSourceLines(\"test.LoginHandler\",\n        \"package test;\",\n        \"\",\n        \"class LoginHandler implements Handler {\",\n        \"  public LoginHandler() {}\",\n        \"}\");\n    JavaFileObject AdminHandlerFile \u003d JavaFileObjects.forSourceLines(\"test.AdminHandler\",\n        \"package test;\",\n        \"\",\n        \"class AdminHandler implements Handler {\",\n        \"  public AdminHandler() {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import java.util.Map;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component(modules \u003d {MapModuleOne.class, MapModuleTwo.class})\",\n        \"interface TestComponent {\",\n        \"  Map\u003cPathEnum, Handler\u003e dispatcher();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerTestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.MapFactory;\",\n            \"import dagger.internal.MapProviderFactory;\",\n            \"import dagger.internal.Preconditions;\",\n            \"import java.util.Map;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerTestComponent implements TestComponent {\",\n            \"  private Provider\u003cHandler\u003e provideAdminHandlerProvider;\",\n            \"  private Provider\u003cHandler\u003e provideLoginHandlerProvider;\",\n            \"  private Provider\u003cMap\u003cPathEnum, Provider\u003cHandler\u003e\u003e\u003e\",\n            \"      mapOfPathEnumAndProviderOfHandlerProvider;\",\n            \"  private Provider\u003cMap\u003cPathEnum, Handler\u003e\u003e mapOfPathEnumAndHandlerProvider;\",\n            \"\",\n            \"  private DaggerTestComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static TestComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.provideAdminHandlerProvider \u003d\",\n            \"        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);\",\n            \"    this.provideLoginHandlerProvider \u003d\",\n            \"        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);\",\n            \"    this.mapOfPathEnumAndProviderOfHandlerProvider \u003d\",\n            \"        MapProviderFactory.\u003cPathEnum, Handler\u003ebuilder(2)\",\n            \"            .put(PathEnum.ADMIN, provideAdminHandlerProvider)\",\n            \"            .put(PathEnum.LOGIN, provideLoginHandlerProvider)\",\n            \"            .build();\",\n            \"    this.mapOfPathEnumAndHandlerProvider \u003d\",\n            \"        MapFactory.create(mapOfPathEnumAndProviderOfHandlerProvider);\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Map\u003cPathEnum, Handler\u003e dispatcher() {\",\n            \"    return mapOfPathEnumAndHandlerProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private MapModuleOne mapModuleOne;\",\n            \"    private MapModuleTwo mapModuleTwo;\",\n            \"\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public TestComponent build() {\",\n            \"      if (mapModuleOne \u003d\u003d null) {\",\n            \"        this.mapModuleOne \u003d new MapModuleOne();\",\n            \"      }\",\n            \"      if (mapModuleTwo \u003d\u003d null) {\",\n            \"        this.mapModuleTwo \u003d new MapModuleTwo();\",\n            \"      }\",\n            \"      return new DaggerTestComponent(this);\",\n            \"    }\",\n            \"\",\n            \"    public Builder mapModuleOne(MapModuleOne mapModuleOne) {\",\n            \"      this.mapModuleOne \u003d Preconditions.checkNotNull(mapModuleOne);\",\n            \"      return this;\",\n            \"    }\",\n            \"\",\n            \"    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {\",\n            \"      this.mapModuleTwo \u003d Preconditions.checkNotNull(mapModuleTwo);\",\n            \"      return this;\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(mapModuleOneFile,\n            mapModuleTwoFile,\n            enumKeyFile,\n            pathEnumFile,\n            HandlerFile,\n            LoginHandlerFile,\n            AdminHandlerFile,\n            componentFile)).\n        processedWith(new ComponentProcessor())\n            .compilesWithoutError()\n            .and().generatesSources(generatedComponent);\n  }\n\n  @Test\n  public void injectMapWithoutMapBinding() {\n    JavaFileObject mapModuleFile \u003d JavaFileObjects.forSourceLines(\"test.MapModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import java.util.HashMap;\",\n        \"import java.util.Map;\",\n        \"\",\n        \"@Module\",\n        \"final class MapModule {\",\n        \"  @Provides Map\u003cString, String\u003e provideAMap() {\",\n        \"    Map\u003cString, String\u003e map \u003d new HashMap\u003cString, String\u003e();\",\n        \"    map.put(\\\"Hello\\\", \\\"World\\\");\",\n        \"    return map;\",\n        \"  }\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import java.util.Map;\",\n        \"\",\n        \"@Component(modules \u003d {MapModule.class})\",\n        \"interface TestComponent {\",\n        \"  Map\u003cString, String\u003e dispatcher();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\"test.DaggerTestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Preconditions;\",\n        \"import java.util.Map;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class DaggerTestComponent implements TestComponent {\",\n        \"  private Provider\u003cMap\u003cString, String\u003e\u003e provideAMapProvider;\",\n        \"\",\n        \"  private DaggerTestComponent(Builder builder) {\",\n        \"    assert builder !\u003d null;\",\n        \"    initialize(builder);\",\n        \"  }\",\n        \"\",\n        \"  public static Builder builder() {\",\n        \"    return new Builder();\",\n        \"  }\",\n        \"\",\n        \"  public static TestComponent create() {\",\n        \"    return builder().build();\",\n        \"  }\",\n        \"\",\n        \"  @SuppressWarnings(\\\"unchecked\\\")\",\n        \"  private void initialize(final Builder builder) {\",\n        \"    this.provideAMapProvider \u003d MapModule_ProvideAMapFactory.create(builder.mapModule);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public Map\u003cString, String\u003e dispatcher() {\",\n        \"    return provideAMapProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static final class Builder {\",\n        \"    private MapModule mapModule;\",\n        \"\",\n        \"    private Builder() {\",\n        \"    }\",\n        \"\",\n        \"    public TestComponent build() {\",\n        \"      if (mapModule \u003d\u003d null) {\",\n        \"        this.mapModule \u003d new MapModule();\",\n        \"      }\",\n        \"      return new DaggerTestComponent(this);\",\n        \"    }\",\n        \"\",\n        \"    public Builder mapModule(MapModule mapModule) {\",\n        \"      this.mapModule \u003d Preconditions.checkNotNull(mapModule);\",\n        \"      return this;\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(mapModuleFile,componentFile))\n        .processedWith(new ComponentProcessor()).compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test\n  public void mapBindingsWithDuplicateKeys() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.MapModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.StringKey;\",\n            \"import dagger.multibindings.IntoMap;\",\n            \"\",\n            \"@Module\",\n            \"final class MapModule {\",\n            \"  @Provides @IntoMap @StringKey(\\\"AKey\\\") Object provideObjectForAKey() {\",\n            \"    return \\\"one\\\";\",\n            \"  }\",\n            \"\",\n            \"  @Provides @IntoMap @StringKey(\\\"AKey\\\") Object provideObjectForAKeyAgain() {\",\n            \"    return \\\"one again\\\";\",\n            \"  }\",\n            \"}\");\n    JavaFileObject componentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import java.util.Map;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            \"@Component(modules \u003d {MapModule.class})\",\n            \"interface TestComponent {\",\n            \"  Map\u003cString, Object\u003e objects();\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(module, componentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"The same map key is bound more than once\")\n        .and()\n        .withErrorContaining(\"provideObjectForAKey()\")\n        .and()\n        .withErrorContaining(\"provideObjectForAKeyAgain()\")\n        .and()\n        .withErrorCount(1);\n  }\n\n  @Test\n  public void mapBindingsWithInconsistentKeyAnnotations() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.MapModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.StringKey;\",\n            \"import dagger.multibindings.IntoMap;\",\n            \"\",\n            \"@Module\",\n            \"final class MapModule {\",\n            \"  @Provides @IntoMap @StringKey(\\\"AKey\\\") Object provideObjectForAKey() {\",\n            \"    return \\\"one\\\";\",\n            \"  }\",\n            \"\",\n            \"  @Provides @IntoMap @StringKeyTwo(\\\"BKey\\\") Object provideObjectForBKey() {\",\n            \"    return \\\"two\\\";\",\n            \"  }\",\n            \"}\");\n    JavaFileObject stringKeyTwoFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.StringKeyTwo\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MapKey;\",\n            \"\",\n            \"@MapKey(unwrapValue \u003d true)\",\n            \"public @interface StringKeyTwo {\",\n            \"  String value();\",\n            \"}\");\n    JavaFileObject componentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import java.util.Map;\",\n            \"\",\n            \"@Component(modules \u003d {MapModule.class})\",\n            \"interface TestComponent {\",\n            \"  Map\u003cString, Object\u003e objects();\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(module, stringKeyTwoFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"uses more than one @MapKey annotation type\")\n        .and()\n        .withErrorContaining(\"provideObjectForAKey()\")\n        .and()\n        .withErrorContaining(\"provideObjectForBKey()\")\n        .and()\n        .withErrorCount(1);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\MapKeyProcessorTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourcesSubject.assertThat;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;\n\nimport com.google.auto.value.processor.AutoAnnotationProcessor;\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class MapKeyProcessorTest {\n  @Test\n  public void mapKeyCreatorFile() {\n    JavaFileObject enumKeyFile \u003d JavaFileObjects.forSourceLines(\"test.PathKey\",\n        \"package test;\",\n        \"import dagger.MapKey;\",\n        \"import java.lang.annotation.Retention;\",\n        \"import static java.lang.annotation.RetentionPolicy.RUNTIME;\",\n        \"\",\n        \"@MapKey(unwrapValue \u003d false)\",\n        \"@Retention(RUNTIME)\",\n        \"public @interface PathKey {\",\n        \"  PathEnum value();\",\n        \"  String relativePath() default \\\"Defaultpath\\\";\",\n        \"}\");\n    JavaFileObject pathEnumFile \u003d JavaFileObjects.forSourceLines(\"test.PathEnum\",\n        \"package test;\",\n        \"\",\n        \"public enum PathEnum {\",\n        \"    ADMIN,\",\n        \"    LOGIN;\",\n        \"}\");\n    JavaFileObject generatedKeyCreator \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.PathKeyCreator\",\n            \"package test;\",\n            \"\",\n            \"import com.google.auto.value.AutoAnnotation;\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class PathKeyCreator {\",\n            \"  private PathKeyCreator() {}\",\n            \"\",\n            \"  @AutoAnnotation\",\n            \"  public static PathKey createPathKey(PathEnum value, String relativePath) {\",\n            \"    return new AutoAnnotation_PathKeyCreator_createPathKey(value, relativePath);\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(enumKeyFile, pathEnumFile))\n        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(generatedKeyCreator);\n  }\n\n  @Test\n  public void nestedMapKeyCreatorFile() {\n    JavaFileObject enumKeyFile \u003d JavaFileObjects.forSourceLines(\"test.Container\",\n        \"package test;\",\n        \"import dagger.MapKey;\",\n        \"import java.lang.annotation.Retention;\",\n        \"import static java.lang.annotation.RetentionPolicy.RUNTIME;\",\n        \"\",\n        \"public interface Container {\",\n        \"@MapKey(unwrapValue \u003d false)\",\n        \"@Retention(RUNTIME)\",\n        \"public @interface PathKey {\",\n        \"  PathEnum value();\",\n        \"  String relativePath() default \\\"Defaultpath\\\";\",\n        \"}\",\n        \"}\");\n    JavaFileObject pathEnumFile \u003d JavaFileObjects.forSourceLines(\"test.PathEnum\",\n        \"package test;\",\n        \"\",\n        \"public enum PathEnum {\",\n        \"    ADMIN,\",\n        \"    LOGIN;\",\n        \"}\");\n    JavaFileObject generatedKeyCreator \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Container_PathKeyCreator\",\n            \"package test;\",\n            \"\",\n            \"import com.google.auto.value.AutoAnnotation;\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class Container_PathKeyCreator {\",\n            \"  private Container_PathKeyCreator() {}\",\n            \"\",\n            \"  @AutoAnnotation\",\n            \"  public static Container.PathKey createPathKey(\"\n                + \"PathEnum value, String relativePath) {\",\n            \"    return new AutoAnnotation_Container_PathKeyCreator_createPathKey(\",\n            \"        value, relativePath);\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(enumKeyFile, pathEnumFile))\n        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(generatedKeyCreator);\n  }\n\n  @Test\n  public void mapKeyComponentFileWithDisorderedKeyField() {\n    JavaFileObject mapModuleOneFile \u003d JavaFileObjects.forSourceLines(\"test.MapModuleOne\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.multibindings.IntoMap;\",\n        \"\",\n        \"@Module\",\n        \"final class MapModuleOne {\",\n        \"  @Provides\",\n        \"  @IntoMap\",\n        \"  @PathKey(relativePath \u003d \\\"AdminPath\\\", value \u003d PathEnum.ADMIN)\",\n        \"  Handler provideAdminHandler() {\",\n        \"    return new AdminHandler();\",\n        \"  }\",\n        \"}\");\n    JavaFileObject mapModuleTwoFile \u003dJavaFileObjects.forSourceLines(\"test.MapModuleTwo\",\n        \"package test;\",\n        \"\",\n        \"import static dagger.Provides.Type.MAP;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.multibindings.IntoMap;\",\n        \"\",\n        \"@Module\",\n        \"final class MapModuleTwo {\",\n        \"  @Provides\",\n        \"  @IntoMap\",\n        \"  @PathKey(value \u003d PathEnum.LOGIN, relativePath \u003d \\\"LoginPath\\\")\",\n        \"  Handler provideLoginHandler() {\",\n        \"    return new LoginHandler();\",\n        \"  }\",\n        \"}\");\n    JavaFileObject enumKeyFile \u003d JavaFileObjects.forSourceLines(\"test.PathKey\",\n        \"package test;\",\n        \"import dagger.MapKey;\",\n        \"import java.lang.annotation.Retention;\",\n        \"import static java.lang.annotation.RetentionPolicy.RUNTIME;\",\n        \"\",\n        \"@MapKey(unwrapValue \u003d false)\",\n        \"@Retention(RUNTIME)\",\n        \"public @interface PathKey {\",\n        \"  PathEnum value();\",\n        \"  String relativePath() default \\\"DefaultPath\\\";\",\n        \"}\");\n    JavaFileObject pathEnumFile \u003d JavaFileObjects.forSourceLines(\"test.PathEnum\",\n        \"package test;\",\n        \"\",\n        \"public enum PathEnum {\",\n        \"    ADMIN,\",\n        \"    LOGIN;\",\n        \"}\");\n    JavaFileObject handlerFile \u003d JavaFileObjects.forSourceLines(\"test.Handler\",\n        \"package test;\",\n        \"\",\n        \"interface Handler {}\");\n    JavaFileObject loginHandlerFile \u003d JavaFileObjects.forSourceLines(\"test.LoginHandler\",\n        \"package test;\",\n        \"\",\n        \"class LoginHandler implements Handler {\",\n        \"  public LoginHandler() {}\",\n        \"}\");\n    JavaFileObject adminHandlerFile \u003d JavaFileObjects.forSourceLines(\"test.AdminHandler\",\n        \"package test;\",\n        \"\",\n        \"class AdminHandler implements Handler {\",\n        \"  public AdminHandler() {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import java.util.Map;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component(modules \u003d {MapModuleOne.class, MapModuleTwo.class})\",\n        \"interface TestComponent {\",\n        \"  Map\u003cPathKey, Provider\u003cHandler\u003e\u003e dispatcher();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerTestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.MapProviderFactory;\",\n            \"import dagger.internal.Preconditions;\",\n            \"import java.util.Map;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerTestComponent implements TestComponent {\",\n            \"  private Provider\u003cHandler\u003e provideAdminHandlerProvider;\",\n            \"  private Provider\u003cHandler\u003e provideLoginHandlerProvider;\",\n            \"  private Provider\u003cMap\u003cPathKey, Provider\u003cHandler\u003e\u003e\u003e\",\n            \"      mapOfPathKeyAndProviderOfHandlerProvider;\",\n            \"\",\n            \"  private DaggerTestComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static TestComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.provideAdminHandlerProvider \u003d\",\n            \"        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);\",\n            \"    this.provideLoginHandlerProvider \u003d\",\n            \"        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);\",\n            \"    this.mapOfPathKeyAndProviderOfHandlerProvider \u003d\",\n            \"        MapProviderFactory.\u003cPathKey, Handler\u003ebuilder(2)\",\n            \"            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \\\"AdminPath\\\"),\",\n            \"                provideAdminHandlerProvider)\",\n            \"            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \\\"LoginPath\\\"),\",\n            \"                provideLoginHandlerProvider)\",\n            \"            .build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Map\u003cPathKey, Provider\u003cHandler\u003e\u003e dispatcher() {\",\n            \"    return mapOfPathKeyAndProviderOfHandlerProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private MapModuleOne mapModuleOne;\",\n            \"    private MapModuleTwo mapModuleTwo;\",\n            \"\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public TestComponent build() {\",\n            \"      if (mapModuleOne \u003d\u003d null) {\",\n            \"        this.mapModuleOne \u003d new MapModuleOne();\",\n            \"      }\",\n            \"      if (mapModuleTwo \u003d\u003d null) {\",\n            \"        this.mapModuleTwo \u003d new MapModuleTwo();\",\n            \"      }\",\n            \"      return new DaggerTestComponent(this);\",\n            \"    }\",\n            \"\",\n            \"    public Builder mapModuleOne(MapModuleOne mapModuleOne) {\",\n            \"      this.mapModuleOne \u003d Preconditions.checkNotNull(mapModuleOne);\",\n            \"      return this;\",\n            \"    }\",\n            \"\",\n            \"    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {\",\n            \"      this.mapModuleTwo \u003d Preconditions.checkNotNull(mapModuleTwo);\",\n            \"      return this;\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(\n            ImmutableList.of(\n                mapModuleOneFile,\n                mapModuleTwoFile,\n                enumKeyFile,\n                pathEnumFile,\n                handlerFile,\n                loginHandlerFile,\n                adminHandlerFile,\n                componentFile))\n        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(generatedComponent);\n  }\n\n  @Test\n  public void mapKeyComponentFileWithDefaultField() {\n    JavaFileObject mapModuleOneFile \u003d JavaFileObjects.forSourceLines(\"test.MapModuleOne\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.multibindings.IntoMap;\",\n        \"\",\n        \"@Module\",\n        \"final class MapModuleOne {\",\n        \"  @Provides\",\n        \"  @IntoMap\",\n        \"  @PathKey(value \u003d PathEnum.ADMIN) Handler provideAdminHandler() {\",\n        \"    return new AdminHandler();\",\n        \"  }\",\n        \"}\");\n    JavaFileObject mapModuleTwoFile \u003dJavaFileObjects.forSourceLines(\"test.MapModuleTwo\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.multibindings.IntoMap;\",\n        \"\",\n        \"@Module\",\n        \"final class MapModuleTwo {\",\n        \"  @Provides\",\n        \"  @IntoMap\",\n        \"  @PathKey(value \u003d PathEnum.LOGIN, relativePath \u003d \\\"LoginPath\\\")\",\n        \"  Handler provideLoginHandler() {\",\n        \"    return new LoginHandler();\",\n        \"  }\",\n        \"}\");\n    JavaFileObject enumKeyFile \u003d JavaFileObjects.forSourceLines(\"test.PathKey\",\n        \"package test;\",\n        \"import dagger.MapKey;\",\n        \"import java.lang.annotation.Retention;\",\n        \"import static java.lang.annotation.RetentionPolicy.RUNTIME;\",\n        \"\",\n        \"@MapKey(unwrapValue \u003d false)\",\n        \"@Retention(RUNTIME)\",\n        \"public @interface PathKey {\",\n        \"  PathEnum value();\",\n        \"  String relativePath() default \\\"DefaultPath\\\";\",\n        \"}\");\n    JavaFileObject pathEnumFile \u003d JavaFileObjects.forSourceLines(\"test.PathEnum\",\n        \"package test;\",\n        \"\",\n        \"public enum PathEnum {\",\n        \"    ADMIN,\",\n        \"    LOGIN;\",\n        \"}\");\n    JavaFileObject handlerFile \u003d JavaFileObjects.forSourceLines(\"test.Handler\",\n        \"package test;\",\n        \"\",\n        \"interface Handler {}\");\n    JavaFileObject loginHandlerFile \u003d JavaFileObjects.forSourceLines(\"test.LoginHandler\",\n        \"package test;\",\n        \"\",\n        \"class LoginHandler implements Handler {\",\n        \"  public LoginHandler() {}\",\n        \"}\");\n    JavaFileObject adminHandlerFile \u003d JavaFileObjects.forSourceLines(\"test.AdminHandler\",\n        \"package test;\",\n        \"\",\n        \"class AdminHandler implements Handler {\",\n        \"  public AdminHandler() {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import java.util.Map;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component(modules \u003d {MapModuleOne.class, MapModuleTwo.class})\",\n        \"interface TestComponent {\",\n        \"  Map\u003cPathKey, Provider\u003cHandler\u003e\u003e dispatcher();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerTestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.MapProviderFactory;\",\n            \"import dagger.internal.Preconditions;\",\n            \"import java.util.Map;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerTestComponent implements TestComponent {\",\n            \"  private Provider\u003cHandler\u003e provideAdminHandlerProvider;\",\n            \"  private Provider\u003cHandler\u003e provideLoginHandlerProvider;\",\n            \"  private Provider\u003cMap\u003cPathKey, Provider\u003cHandler\u003e\u003e\u003e\",\n            \"      mapOfPathKeyAndProviderOfHandlerProvider;\",\n            \"\",\n            \"  private DaggerTestComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static TestComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.provideAdminHandlerProvider \u003d\",\n            \"        MapModuleOne_ProvideAdminHandlerFactory.create(builder.mapModuleOne);\",\n            \"    this.provideLoginHandlerProvider \u003d\",\n            \"        MapModuleTwo_ProvideLoginHandlerFactory.create(builder.mapModuleTwo);\",\n            \"    this.mapOfPathKeyAndProviderOfHandlerProvider \u003d\",\n            \"        MapProviderFactory.\u003cPathKey, Handler\u003ebuilder(2)\",\n            \"            .put(PathKeyCreator.createPathKey(PathEnum.ADMIN, \\\"DefaultPath\\\"),\",\n            \"                provideAdminHandlerProvider)\",\n            \"            .put(PathKeyCreator.createPathKey(PathEnum.LOGIN, \\\"LoginPath\\\"),\",\n            \"                provideLoginHandlerProvider)\",\n            \"            .build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Map\u003cPathKey, Provider\u003cHandler\u003e\u003e dispatcher() {\",\n            \"    return mapOfPathKeyAndProviderOfHandlerProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private MapModuleOne mapModuleOne;\",\n            \"    private MapModuleTwo mapModuleTwo;\",\n            \"\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public TestComponent build() {\",\n            \"      if (mapModuleOne \u003d\u003d null) {\",\n            \"        this.mapModuleOne \u003d new MapModuleOne();\",\n            \"      }\",\n            \"      if (mapModuleTwo \u003d\u003d null) {\",\n            \"        this.mapModuleTwo \u003d new MapModuleTwo();\",\n            \"      }\",\n            \"      return new DaggerTestComponent(this);\",\n            \"    }\",\n            \"\",\n            \"    public Builder mapModuleOne(MapModuleOne mapModuleOne) {\",\n            \"      this.mapModuleOne \u003d Preconditions.checkNotNull(mapModuleOne);\",\n            \"      return this;\",\n            \"    }\",\n            \"\",\n            \"    public Builder mapModuleTwo(MapModuleTwo mapModuleTwo) {\",\n            \"      this.mapModuleTwo \u003d Preconditions.checkNotNull(mapModuleTwo);\",\n            \"      return this;\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(\n            ImmutableList.of(\n                mapModuleOneFile,\n                mapModuleTwoFile,\n                enumKeyFile,\n                pathEnumFile,\n                handlerFile,\n                loginHandlerFile,\n                adminHandlerFile,\n                componentFile))\n        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(generatedComponent);\n  }\n\n  @Test\n  public void mapKeyWithDefaultValue() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.MapModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.IntoMap;\",\n            \"\",\n            \"@Module\",\n            \"final class MapModule {\",\n            \"  @Provides\",\n            \"  @IntoMap\",\n            \"  @BoolKey int provideFalseValue() {\",\n            \"    return -1;\",\n            \"  }\",\n            \"\",\n            \"  @Provides\",\n            \"  @IntoMap\",\n            \"  @BoolKey(true) int provideTrueValue() {\",\n            \"    return 1;\",\n            \"  }\",\n            \"}\");\n    JavaFileObject mapKey \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.BoolKey\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MapKey;\",\n            \"\",\n            \"@MapKey\",\n            \"@interface BoolKey {\",\n            \"  boolean value() default false;\",\n            \"}\");\n    assertThat(module, mapKey)\n        .processedWith(new ComponentProcessor(), new AutoAnnotationProcessor())\n        .compilesWithoutError();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\MembersInjectionTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;\nimport static com.google.testing.compile.JavaSourcesSubject.assertThat;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.ErrorMessages.INJECT_INTO_PRIVATE_CLASS;\nimport static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;\nimport static javax.tools.StandardLocation.CLASS_OUTPUT;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.testing.compile.JavaFileObjects;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.util.Set;\nimport javax.annotation.processing.AbstractProcessor;\nimport javax.annotation.processing.RoundEnvironment;\nimport javax.lang.model.element.TypeElement;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class MembersInjectionTest {\n  @Test\n  public void parentClass_noInjectedMembers() {\n    JavaFileObject childFile \u003d JavaFileObjects.forSourceLines(\"test.Child\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"public final class Child extends Parent {\",\n        \"  @Inject Child() {}\",\n        \"}\");\n    JavaFileObject parentFile \u003d JavaFileObjects.forSourceLines(\"test.Parent\",\n        \"package test;\",\n        \"\",\n        \"public abstract class Parent {}\");\n\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"\",\n        \"@Component\",\n        \"interface TestComponent {\",\n        \"  Child child();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d JavaFileObjects.forSourceLines(\n        \"test.DaggerTestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.MembersInjectors;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class DaggerTestComponent implements TestComponent {\",\n        \"  private Provider\u003cChild\u003e childProvider;\",\n        \"\",\n        \"  private DaggerTestComponent(Builder builder) {\",\n        \"    assert builder !\u003d null;\",\n        \"    initialize(builder);\",\n        \"  }\",\n        \"\",\n        \"  public static Builder builder() {\",\n        \"    return new Builder();\",\n        \"  }\",\n        \"\",\n        \"  public static TestComponent create() {\",\n        \"    return builder().build();\",\n        \"  }\",\n        \"\",\n        \"  @SuppressWarnings(\\\"unchecked\\\")\",\n        \"  private void initialize(final Builder builder) {\",\n        \"    this.childProvider \u003d\",\n        \"        Child_Factory.create(MembersInjectors.\u003cChild\u003enoOp());\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public Child child() {\",\n        \"    return childProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static final class Builder {\",\n        \"    private Builder() {\",\n        \"    }\",\n        \"\",\n        \"    public TestComponent build() {\",\n        \"      return new DaggerTestComponent(this);\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(childFile, parentFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test\n  public void parentClass_injectedMembersInSupertype() {\n    JavaFileObject childFile \u003d JavaFileObjects.forSourceLines(\"test.Child\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"public final class Child extends Parent {\",\n        \"  @Inject Child() {}\",\n        \"}\");\n    JavaFileObject parentFile \u003d JavaFileObjects.forSourceLines(\"test.Parent\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"public abstract class Parent {\",\n        \"  @Inject Dep dep;\",\n        \"}\");\n    JavaFileObject depFile \u003d JavaFileObjects.forSourceLines(\"test.Dep\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class Dep {\",\n        \"  @Inject Dep() {}\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"\",\n        \"@Component\",\n        \"interface TestComponent {\",\n        \"  Child child();\",\n        \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerTestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MembersInjector;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerTestComponent implements TestComponent {\",\n            \"  private MembersInjector\u003cChild\u003e childMembersInjector;\",\n            \"  private Provider\u003cChild\u003e childProvider;\",\n            \"\",\n            \"  private DaggerTestComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static TestComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.childMembersInjector \u003d Child_MembersInjector.create(Dep_Factory.create());\",\n            \"    this.childProvider \u003d Child_Factory.create(childMembersInjector);\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Child child() {\",\n            \"    return childProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {}\",\n            \"\",\n            \"    public TestComponent build() {\",\n            \"      return new DaggerTestComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(childFile, parentFile, depFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(generatedComponent);\n  }\n\n  @Test public void fieldAndMethodGenerics() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.GenericClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class GenericClass\u003cA, B\u003e {\",\n        \"  @Inject A a;\",\n        \"\",\n        \"  @Inject GenericClass() {}\",\n        \"\",\n        \" @Inject void register(B b) {}\",\n        \"}\");\n    JavaFileObject expected \u003d JavaFileObjects.forSourceLines(\n        \"test.GenericClass_MembersInjector\",\n        \"package test;\",\n        \"\",\n        \"import dagger.MembersInjector;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class GenericClass_MembersInjector\u003cA, B\u003e\",\n        \"    implements MembersInjector\u003cGenericClass\u003cA, B\u003e\u003e {\",\n        \"  private final Provider\u003cA\u003e aProvider;\",\n        \"  private final Provider\u003cB\u003e bProvider;\",\n        \"\",\n        \"  public GenericClass_MembersInjector(Provider\u003cA\u003e aProvider, Provider\u003cB\u003e bProvider) {\",\n        \"    assert aProvider !\u003d null;\",\n        \"    this.aProvider \u003d aProvider;\",\n        \"    assert bProvider !\u003d null;\",\n        \"    this.bProvider \u003d bProvider;\",\n        \"  }\",\n        \"\",\n        \"  public static \u003cA, B\u003e MembersInjector\u003cGenericClass\u003cA, B\u003e\u003e create(\",\n        \"      Provider\u003cA\u003e aProvider, Provider\u003cB\u003e bProvider) {\",\n        \"    return new GenericClass_MembersInjector\u003cA, B\u003e(aProvider, bProvider);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public void injectMembers(GenericClass\u003cA, B\u003e instance) {\",\n        \"    if (instance \u003d\u003d null) {\",\n        \"      throw new NullPointerException(\\\"Cannot inject members into a null reference\\\");\",\n        \"    }\",\n        \"    instance.a \u003d aProvider.get();\",\n        \"    instance.register(bProvider.get());\",\n        \"  }\",\n        \"\",\n        \"  public static \u003cA, B\u003e void injectA(GenericClass\u003cA, B\u003e instance, Provider\u003cA\u003e aProvider) {\",\n        \"    instance.a \u003d aProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static \u003cA, B\u003e void injectRegister(\",\n        \"      GenericClass\u003cA, B\u003e instance, Provider\u003cB\u003e bProvider) {\",\n        \"    instance.register(bProvider.get());\",\n        \"  }\",\n        \"\",\n        \"}\");\n    assertAbout(javaSource())\n        .that(file)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(expected);\n  }\n\n  @Test public void subclassedGenericMembersInjectors() {\n    JavaFileObject a \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A {\",\n        \"  @Inject A() {}\",\n        \"}\");\n    JavaFileObject a2 \u003d JavaFileObjects.forSourceLines(\"test.A2\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class A2 {\",\n        \"  @Inject A2() {}\",\n        \"}\");\n    JavaFileObject parent \u003d JavaFileObjects.forSourceLines(\"test.Parent\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class Parent\u003cX, Y\u003e {\",\n        \"  @Inject X x;\",\n        \"  @Inject Y y;\",\n        \"  @Inject A2 a2;\",\n        \"\",\n        \"  @Inject Parent() {}\",\n        \"}\");\n    JavaFileObject child \u003d JavaFileObjects.forSourceLines(\"test.Child\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class Child\u003cT\u003e extends Parent\u003cT, A\u003e {\",\n        \"  @Inject A a;\",\n        \"  @Inject T t;\",\n        \"\",\n        \"  @Inject Child() {}\",\n        \"}\");\n    JavaFileObject expected \u003d JavaFileObjects.forSourceLines(\n        \"test.Child_MembersInjector\",\n        \"package test;\",\n        \"\",\n        \"import dagger.MembersInjector;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class Child_MembersInjector\u003cT\u003e\",\n        \"    implements MembersInjector\u003cChild\u003cT\u003e\u003e {\",\n        \"  private final Provider\u003cT\u003e tAndXProvider;\",\n        \"  private final Provider\u003cA\u003e aAndYProvider;\",\n        \"  private final Provider\u003cA2\u003e a2Provider;\",\n        \"\",\n        \"  public Child_MembersInjector(\",\n        \"      Provider\u003cT\u003e tAndXProvider, Provider\u003cA\u003e aAndYProvider, Provider\u003cA2\u003e a2Provider) {\",\n        \"    assert tAndXProvider !\u003d null;\",\n        \"    this.tAndXProvider \u003d tAndXProvider;\",\n        \"    assert aAndYProvider !\u003d null;\",\n        \"    this.aAndYProvider \u003d aAndYProvider;\",\n        \"    assert a2Provider !\u003d null;\",\n        \"    this.a2Provider \u003d a2Provider;\",\n        \"  }\",\n        \"\",\n        \"  public static \u003cT\u003e MembersInjector\u003cChild\u003cT\u003e\u003e create(\",\n        \"      Provider\u003cT\u003e tAndXProvider, Provider\u003cA\u003e aAndYProvider, Provider\u003cA2\u003e a2Provider) {\",\n        \"    return new Child_MembersInjector\u003cT\u003e(tAndXProvider, aAndYProvider, a2Provider);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public void injectMembers(Child\u003cT\u003e instance) {\",\n        \"    if (instance \u003d\u003d null) {\",\n        \"      throw new NullPointerException(\\\"Cannot inject members into a null reference\\\");\",\n        \"    }\",\n        \"    ((Parent) instance).x \u003d tAndXProvider.get();\",\n        \"    ((Parent) instance).y \u003d aAndYProvider.get();\",\n        \"    ((Parent) instance).a2 \u003d a2Provider.get();\",\n        \"    instance.a \u003d aAndYProvider.get();\",\n        \"    instance.t \u003d tAndXProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static \u003cT\u003e void injectA(Child\u003cT\u003e instance, Provider\u003cA\u003e aProvider) {\",\n        \"    instance.a \u003d aProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static \u003cT\u003e void injectT(Child\u003cT\u003e instance, Provider\u003cT\u003e tProvider) {\",\n        \"    instance.t \u003d tProvider.get();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(a, a2, parent, child))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(expected);\n  }\n\n  @Test public void fieldInjection() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.FieldInjection\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Inject;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"class FieldInjection {\",\n        \"  @Inject String string;\",\n        \"  @Inject Lazy\u003cString\u003e lazyString;\",\n        \"  @Inject Provider\u003cString\u003e stringProvider;\",\n        \"}\");\n    JavaFileObject expected \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.FieldInjection_MembersInjector\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MembersInjector;\",\n            \"import dagger.internal.DoubleCheck;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class FieldInjection_MembersInjector\",\n            \"    implements MembersInjector\u003cFieldInjection\u003e {\",\n            \"  private final Provider\u003cString\u003e stringProvider;\",\n            \"\",\n            \"  public FieldInjection_MembersInjector(Provider\u003cString\u003e stringProvider) {\",\n            \"    assert stringProvider !\u003d null;\",\n            \"    this.stringProvider \u003d stringProvider;\",\n            \"  }\",\n            \"\",\n            \"  public static MembersInjector\u003cFieldInjection\u003e create(Provider\u003cString\u003e stringProvider) {\",\n            \"    return new FieldInjection_MembersInjector(stringProvider);\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public void injectMembers(FieldInjection instance) {\",\n            \"    if (instance \u003d\u003d null) {\",\n            \"      throw new NullPointerException(\\\"Cannot inject members into a null reference\\\");\",\n            \"    }\",\n            \"    instance.string \u003d stringProvider.get();\",\n            \"    instance.lazyString \u003d DoubleCheck.lazy(stringProvider);\",\n            \"    instance.stringProvider \u003d stringProvider;\",\n            \"  }\",\n            \"\",\n            \"  public static void injectString(\",\n            \"      FieldInjection instance, Provider\u003cString\u003e stringProvider) {\",\n            \"    instance.string \u003d stringProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  public static void injectLazyString(\",\n            \"      FieldInjection instance, Provider\u003cString\u003e lazyStringProvider) {\",\n            \"    instance.lazyString \u003d DoubleCheck.lazy(lazyStringProvider);\",\n            \"  }\",\n            \"\",\n            \"  public static void injectStringProvider(\",\n            \"      FieldInjection instance, Provider\u003cString\u003e stringProvider) {\",\n            \"    instance.stringProvider \u003d stringProvider;\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSource())\n        .that(file)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(expected);\n  }\n\n  @Test public void methodInjection() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.MethodInjection\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Inject;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"class MethodInjection {\",\n        \"  @Inject void noArgs() {}\",\n        \"  @Inject void oneArg(String string) {}\",\n        \"  @Inject void manyArgs(\",\n        \"      String string, Lazy\u003cString\u003e lazyString, Provider\u003cString\u003e stringProvider) {}\",\n        \"}\");\n    JavaFileObject expected \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.MethodInjection_MembersInjector\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MembersInjector;\",\n            \"import dagger.internal.DoubleCheck;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class MethodInjection_MembersInjector\",\n            \"     implements MembersInjector\u003cMethodInjection\u003e {\",\n            \"\",\n            \"  private final Provider\u003cString\u003e stringProvider;\",\n            \"\",\n            \"  public MethodInjection_MembersInjector(Provider\u003cString\u003e stringProvider) {\",\n            \"    assert stringProvider !\u003d null;\",\n            \"    this.stringProvider \u003d stringProvider;\",\n            \"  }\",\n            \"\",\n            \"  public static MembersInjector\u003cMethodInjection\u003e create(\",\n            \"      Provider\u003cString\u003e stringProvider) {\",\n            \"    return new MethodInjection_MembersInjector(stringProvider);\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public void injectMembers(MethodInjection instance) {\",\n            \"    if (instance \u003d\u003d null) {\",\n            \"      throw new NullPointerException(\\\"Cannot inject members into a null reference\\\");\",\n            \"    }\",\n            \"    instance.noArgs();\",\n            \"    instance.oneArg(stringProvider.get());\",\n            \"    instance.manyArgs(\",\n            \"        stringProvider.get(),\",\n            \"        DoubleCheck.lazy(stringProvider),\",\n            \"        stringProvider);\",\n            \"  }\",\n            \"\",\n            \"  public static void injectNoArgs(MethodInjection instance) {\",\n            \"    instance.noArgs();\",\n            \"  }\",\n            \"\",\n            \"  public static void injectOneArg(\",\n            \"      MethodInjection instance, Provider\u003cString\u003e stringProvider) {\",\n            \"    instance.oneArg(stringProvider.get());\",\n            \"  }\",\n            \"\",\n            \"  public static void injectManyArgs(\",\n            \"      MethodInjection instance,\",\n            \"      Provider\u003cString\u003e stringProvider,\",\n            \"      Provider\u003cString\u003e lazyStringProvider,\",\n            \"      Provider\u003cString\u003e stringProvider2) {\",\n            \"    instance.manyArgs(\",\n            \"        stringProvider.get(),\",\n            \"        DoubleCheck.lazy(lazyStringProvider),\",\n            \"        stringProvider2);\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSource())\n        .that(file)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(expected);\n  }\n\n  @Test\n  public void mixedMemberInjection() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\n        \"test.MixedMemberInjection\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Lazy;\",\n        \"import javax.inject.Inject;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"class MixedMemberInjection {\",\n        \"  @Inject String string;\",\n        \"  @Inject void setString(String s) {}\",\n        \"  @Inject Object object;\",\n        \"  @Inject void setObject(Object o) {}\",\n        \"}\");\n    JavaFileObject expected \u003d JavaFileObjects.forSourceLines(\n        \"test.MixedMemberInjection_MembersInjector\",\n        \"package test;\",\n        \"\",\n        \"import dagger.MembersInjector;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class MixedMemberInjection_MembersInjector\",\n        \"    implements MembersInjector\u003cMixedMemberInjection\u003e {\",\n        \"\",\n        \"  private final Provider\u003cString\u003e stringAndSProvider;\",\n        \"  private final Provider\u003cObject\u003e objectAndOProvider;\",\n        \"\",\n        \"  public MixedMemberInjection_MembersInjector(\",\n        \"      Provider\u003cString\u003e stringAndSProvider,\",\n        \"      Provider\u003cObject\u003e objectAndOProvider) {\",\n        \"    assert stringAndSProvider !\u003d null;\",\n        \"    this.stringAndSProvider \u003d stringAndSProvider;\",\n        \"    assert objectAndOProvider !\u003d null;\",\n        \"    this.objectAndOProvider \u003d objectAndOProvider;\",\n        \"  }\",\n        \"\",\n        \"  public static MembersInjector\u003cMixedMemberInjection\u003e create(\",\n        \"      Provider\u003cString\u003e stringAndSProvider,\",\n        \"      Provider\u003cObject\u003e objectAndOProvider) {\",\n        \"    return new MixedMemberInjection_MembersInjector(\",\n        \"        stringAndSProvider, objectAndOProvider);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public void injectMembers(MixedMemberInjection instance) {\",\n        \"    if (instance \u003d\u003d null) {\",\n        \"      throw new NullPointerException(\\\"Cannot inject members into a null reference\\\");\",\n        \"    }\",\n        \"    instance.string \u003d stringAndSProvider.get();\",\n        \"    instance.object \u003d objectAndOProvider.get();\",\n        \"    instance.setString(stringAndSProvider.get());\",\n        \"    instance.setObject(objectAndOProvider.get());\",\n        \"  }\",\n        \"\",\n        \"  public static void injectString(\",\n        \"      MixedMemberInjection instance, Provider\u003cString\u003e stringProvider) {\",\n        \"    instance.string \u003d stringProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static void injectObject(\",\n        \"      MixedMemberInjection instance, Provider\u003cObject\u003e objectProvider) {\",\n        \"    instance.object \u003d objectProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static void injectSetString(\",\n        \"      MixedMemberInjection instance, Provider\u003cString\u003e sProvider) {\",\n        \"    instance.setString(sProvider.get());\",\n        \"  }\",\n        \"\",\n        \"  public static void injectSetObject(\",\n        \"      MixedMemberInjection instance, Provider\u003cObject\u003e oProvider) {\",\n        \"    instance.setObject(oProvider.get());\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource())\n        .that(file)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(expected);\n  }\n\n  @Test public void injectConstructorAndMembersInjection() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.AllInjections\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class AllInjections {\",\n        \"  @Inject String s;\",\n        \"  @Inject AllInjections(String s) {}\",\n        \"  @Inject void s(String s) {}\",\n        \"}\");\n    JavaFileObject expectedMembersInjector \u003d JavaFileObjects.forSourceLines(\n        \"test.AllInjections_MembersInjector\",\n        \"package test;\",\n        \"\",\n        \"import dagger.MembersInjector;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class AllInjections_MembersInjector \",\n        \"    implements MembersInjector\u003cAllInjections\u003e {\",\n        \"\",\n        \"  private final Provider\u003cString\u003e sProvider;\",\n        \"\",\n        \"  public AllInjections_MembersInjector(Provider\u003cString\u003e sProvider) {\",\n        \"    assert sProvider !\u003d null;\",\n        \"    this.sProvider \u003d sProvider;\",\n        \"  }\",\n        \"\",\n        \"  public static MembersInjector\u003cAllInjections\u003e create(Provider\u003cString\u003e sProvider) {\",\n        \"      return new AllInjections_MembersInjector(sProvider);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public void injectMembers(AllInjections instance) {\",\n        \"    if (instance \u003d\u003d null) {\",\n        \"      throw new NullPointerException(\\\"Cannot inject members into a null reference\\\");\",\n        \"    }\",\n        \"    instance.s \u003d sProvider.get();\",\n        \"    instance.s(sProvider.get());\",\n        \"  }\",\n        \"\",\n        \"  public static void injectS(AllInjections instance, Provider\u003cString\u003e sProvider) {\",\n        \"    instance.s \u003d sProvider.get();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource())\n        .that(file)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(expectedMembersInjector);\n  }\n\n  @Test public void supertypeMembersInjection() {\n    JavaFileObject aFile \u003d JavaFileObjects.forSourceLines(\"test.A\",\n        \"package test;\",\n        \"\",\n        \"class A {}\");\n    JavaFileObject bFile \u003d JavaFileObjects.forSourceLines(\"test.B\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class B extends A {\",\n        \"  @Inject String s;\",\n        \"}\");\n    JavaFileObject expectedMembersInjector \u003d JavaFileObjects.forSourceLines(\n        \"test.AllInjections_MembersInjector\",\n        \"package test;\",\n        \"\",\n        \"import dagger.MembersInjector;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class B_MembersInjector implements MembersInjector\u003cB\u003e {\",\n        \"  private final Provider\u003cString\u003e sProvider;\",\n        \"\",\n        \"  public B_MembersInjector(Provider\u003cString\u003e sProvider) {\",\n        \"    assert sProvider !\u003d null;\",\n        \"    this.sProvider \u003d sProvider;\",\n        \"  }\",\n        \"\",\n        \"  public static MembersInjector\u003cB\u003e create(Provider\u003cString\u003e sProvider) {\",\n        \"      return new B_MembersInjector(sProvider);\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public void injectMembers(B instance) {\",\n        \"    if (instance \u003d\u003d null) {\",\n        \"      throw new NullPointerException(\\\"Cannot inject members into a null reference\\\");\",\n        \"    }\",\n        \"    instance.s \u003d sProvider.get();\",\n        \"  }\",\n        \"\",\n        \"  public static void injectS(B instance, Provider\u003cString\u003e sProvider) {\",\n        \"    instance.s \u003d sProvider.get();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(aFile, bFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(expectedMembersInjector);\n  }\n\n  @Test\n  public void simpleComponentWithNesting() {\n    JavaFileObject nestedTypesFile \u003d JavaFileObjects.forSourceLines(\n          \"test.OuterType\",\n          \"package test;\",\n          \"\",\n          \"import dagger.Component;\",\n          \"import javax.inject.Inject;\",\n          \"\",\n          \"final class OuterType {\",\n          \"  static class A {\",\n          \"    @Inject A() {}\",\n          \"  }\",\n          \"  static class B {\",\n          \"    @Inject A a;\",\n          \"  }\",\n          \"  @Component interface SimpleComponent {\",\n          \"    A a();\",\n          \"    void inject(B b);\",\n          \"  }\",\n          \"}\");\n    JavaFileObject bMembersInjector \u003d JavaFileObjects.forSourceLines(\n          \"test.OuterType_B_MembersInjector\",\n          \"package test;\",\n          \"\",\n          \"import dagger.MembersInjector;\",\n          \"import javax.annotation.Generated;\",\n          \"import javax.inject.Provider;\",\n          \"\",\n          GENERATED_ANNOTATION,\n          \"public final class OuterType_B_MembersInjector\",\n          \"    implements MembersInjector\u003cOuterType.B\u003e {\",\n          \"  private final Provider\u003cOuterType.A\u003e aProvider;\",\n          \"\",\n          \"  public OuterType_B_MembersInjector(Provider\u003cOuterType.A\u003e aProvider) {\",\n          \"    assert aProvider !\u003d null;\",\n          \"    this.aProvider \u003d aProvider;\",\n          \"  }\",\n          \"\",\n          \"  public static MembersInjector\u003cOuterType.B\u003e create(Provider\u003cOuterType.A\u003e aProvider) {\",\n          \"    return new OuterType_B_MembersInjector(aProvider);\",\n          \"  }\",\n          \"\",\n          \"  @Override\",\n          \"  public void injectMembers(OuterType.B instance) {\",\n          \"    if (instance \u003d\u003d null) {\",\n          \"      throw new NullPointerException(\\\"Cannot inject members into a null reference\\\");\",\n          \"    }\",\n          \"    instance.a \u003d aProvider.get();\",\n          \"  }\",\n          \"\",\n          \"  public static void injectA(OuterType.B instance, Provider\u003cOuterType.A\u003e aProvider) {\",\n          \"    instance.a \u003d aProvider.get();\",\n          \"  }\",\n          \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(nestedTypesFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(bMembersInjector);\n  }\n\n  @Test\n  public void componentWithNestingAndGeneratedType() {\n    JavaFileObject nestedTypesFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.OuterType\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class OuterType {\",\n            \"  @Inject GeneratedType generated;\",\n            \"  static class A {\",\n            \"    @Inject A() {}\",\n            \"  }\",\n            \"  static class B {\",\n            \"    @Inject A a;\",\n            \"  }\",\n            \"  @Component interface SimpleComponent {\",\n            \"    A a();\",\n            \"    void inject(B b);\",\n            \"  }\",\n            \"}\");\n    JavaFileObject bMembersInjector \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.OuterType_B_MembersInjector\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MembersInjector;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class OuterType_B_MembersInjector\",\n            \"    implements MembersInjector\u003cOuterType.B\u003e {\",\n            \"  private final Provider\u003cOuterType.A\u003e aProvider;\",\n            \"\",\n            \"  public OuterType_B_MembersInjector(Provider\u003cOuterType.A\u003e aProvider) {\",\n            \"    assert aProvider !\u003d null;\",\n            \"    this.aProvider \u003d aProvider;\",\n            \"  }\",\n            \"\",\n            \"  public static MembersInjector\u003cOuterType.B\u003e create(Provider\u003cOuterType.A\u003e aProvider) {\",\n            \"    return new OuterType_B_MembersInjector(aProvider);\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public void injectMembers(OuterType.B instance) {\",\n            \"    if (instance \u003d\u003d null) {\",\n            \"      throw new NullPointerException(\\\"Cannot inject members into a null reference\\\");\",\n            \"    }\",\n            \"    instance.a \u003d aProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  public static void injectA(OuterType.B instance, Provider\u003cOuterType.A\u003e aProvider) {\",\n            \"    instance.a \u003d aProvider.get();\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSource())\n        .that(nestedTypesFile)\n        .processedWith(\n            new ComponentProcessor(),\n            new AbstractProcessor() {\n              private boolean done;\n\n              @Override\n              public Set\u003cString\u003e getSupportedAnnotationTypes() {\n                return ImmutableSet.of(\"*\");\n              }\n\n              @Override\n              public boolean process(\n                  Set\u003c? extends TypeElement\u003e annotations, RoundEnvironment roundEnv) {\n                if (!done) {\n                  done \u003d true;\n                  try (Writer writer \u003d\n                          processingEnv\n                              .getFiler()\n                              .createSourceFile(\"test.GeneratedType\")\n                              .openWriter()) {\n                    writer.write(\n                        Joiner.on(\u0027\\n\u0027)\n                            .join(\n                                \"package test;\",\n                                \"\",\n                                \"import javax.inject.Inject;\",\n                                \"\",\n                                \"class GeneratedType {\",\n                                \"  @Inject GeneratedType() {}\",\n                                \"}\"));\n                  } catch (IOException e) {\n                    throw new RuntimeException(e);\n                  }\n                }\n                return false;\n              }\n            })\n        .compilesWithoutError()\n        .and()\n        .generatesSources(bMembersInjector);\n  }\n\n  @Test\n  public void lowerCaseNamedMembersInjector_forLowerCaseType() {\n    JavaFileObject foo \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.foo\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"class foo {\",\n            \"  @Inject String string;\",\n            \"}\");\n    JavaFileObject fooModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.fooModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"\",\n            \"@Module\",\n            \"class fooModule {\",\n            \"  @Provides String string() { return \\\"foo\\\"; }\",\n            \"}\");\n    JavaFileObject fooComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.fooComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d fooModule.class)\",\n            \"interface fooComponent {\",\n            \"  void inject(foo target);\",\n            \"}\");\n\n    assertAbout(javaSources())\n        .that(ImmutableList.of(foo, fooModule, fooComponent))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesFileNamed(CLASS_OUTPUT, \"test\", \"foo_MembersInjector.class\");\n  }\n\n  @Test\n  public void fieldInjectionForShadowedMember() {\n    JavaFileObject foo \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Foo\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"class Foo {\",\n            \"  @Inject Foo() {}\",\n            \"}\");\n    JavaFileObject bar \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Bar\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"class Bar {\",\n            \"  @Inject Bar() {}\",\n            \"}\");\n    JavaFileObject parent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Parent\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"class Parent { \",\n            \"  @Inject Foo object;\",\n            \"}\");\n    JavaFileObject child \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Child\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"class Child extends Parent { \",\n            \"  @Inject Bar object;\",\n            \"}\");\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.C\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component\",\n            \"interface C { \",\n            \"  void inject(Child child);\",\n            \"}\");\n\n    JavaFileObject expectedMembersInjector \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Child_MembersInjector\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MembersInjector;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class Child_MembersInjector implements MembersInjector\u003cChild\u003e {\",\n            \"  private final Provider\u003cFoo\u003e objectProvider;\",\n            \"  private final Provider\u003cBar\u003e objectProvider2;\",\n            \"\",\n            \"  public Child_MembersInjector(\",\n            \"        Provider\u003cFoo\u003e objectProvider, Provider\u003cBar\u003e objectProvider2) {\",\n            \"    assert objectProvider !\u003d null;\",\n            \"    this.objectProvider \u003d objectProvider;\",\n            \"    assert objectProvider2 !\u003d null;\",\n            \"    this.objectProvider2 \u003d objectProvider2;\",\n            \"  }\",\n            \"\",\n            \"  public static MembersInjector\u003cChild\u003e create(\",\n            \"      Provider\u003cFoo\u003e objectProvider, Provider\u003cBar\u003e objectProvider2) {\",\n            \"    return new Child_MembersInjector(objectProvider, objectProvider2);\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public void injectMembers(Child instance) {\",\n            \"    if (instance \u003d\u003d null) {\",\n            \"      throw new NullPointerException(\",\n            \"          \\\"Cannot inject members into a null reference\\\");\",\n            \"    }\",\n            \"    ((Parent) instance).object \u003d objectProvider.get();\",\n            \"    instance.object \u003d objectProvider2.get();\",\n            \"  }\",\n            \"\",\n            \"  public static void injectObject(Child instance, Provider\u003cBar\u003e objectProvider) {\",\n            \"    instance.object \u003d objectProvider.get();\",\n            \"  }\",\n            \"}\");\n\n    assertAbout(javaSources())\n        .that(ImmutableList.of(foo, bar, parent, child, component))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(expectedMembersInjector);\n  }\n\n  @Test public void privateNestedClassError() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.OuterClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class OuterClass {\",\n        \"  private static final class InnerClass {\",\n        \"    @Inject int field;\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource())\n        .that(file)\n        .processedWith(new ComponentProcessor()).failsToCompile()\n        .withErrorContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);\n  }\n\n  @Test public void privateNestedClassWarning() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.OuterClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class OuterClass {\",\n        \"  private static final class InnerClass {\",\n        \"    @Inject int field;\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource())\n        .that(file)\n        .withCompilerOptions(\"-Adagger.privateMemberValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .withWarningContaining(INJECT_INTO_PRIVATE_CLASS).in(file).onLine(6);\n  }\n\n  @Test public void privateSuperclassIsOkIfNotInjectedInto() {\n    JavaFileObject file \u003d JavaFileObjects.forSourceLines(\"test.OuterClass\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class OuterClass {\",\n        \"  private static class BaseClass {}\",\n        \"\",\n        \"  static final class DerivedClass extends BaseClass {\",\n        \"    @Inject int field;\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource())\n        .that(file)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n\n  @Test public void rawFrameworkTypes() {\n    JavaFileObject file \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.RawFrameworkTypes\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import javax.inject.Inject;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            \"class RawProviderField {\",\n            \"  @Inject Provider fieldWithRawProvider;\",\n            \"}\",\n            \"\",\n            \"class RawProviderParameter {\",\n            \"  @Inject void methodInjection(Provider rawProviderParameter) {}\",\n            \"}\",\n            \"\",\n            \"@Component\",\n            \"interface C {\",\n            \"  void inject(RawProviderField rawProviderField);\",\n            \"  void inject(RawProviderParameter rawProviderParameter);\",\n            \"}\");\n    assertThat(file)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"javax.inject.Provider cannot be provided\").in(file).onLine(17)\n        .and()\n        .withErrorContaining(\"javax.inject.Provider cannot be provided\").in(file).onLine(18);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\MethodSignatureFormatterTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static javax.lang.model.util.ElementFilter.methodsIn;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Iterables;\nimport com.google.testing.compile.CompilationRule;\nimport dagger.internal.codegen.MethodSignatureFormatterTest.OuterClass.InnerClass;\nimport javax.inject.Singleton;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.util.Elements;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class MethodSignatureFormatterTest {\n  @Rule public CompilationRule compilationRule \u003d new CompilationRule();\n\n  static class OuterClass {\n    @interface Foo {\n       Class\u003c?\u003e bar();\n    }\n\n    static class InnerClass {\n      @Foo(bar \u003d String.class)\n      @Singleton\n      String foo(\n          @SuppressWarnings(\"unused\") int a,\n          @SuppressWarnings(\"unused\") ImmutableList\u003cBoolean\u003e blah) {\n        return \"foo\";\n      }\n    }\n  }\n\n  @Test public void methodSignatureTest() {\n    Elements elements \u003d compilationRule.getElements();\n    TypeElement inner \u003d elements.getTypeElement(InnerClass.class.getCanonicalName());\n    ExecutableElement method \u003d Iterables.getOnlyElement(methodsIn(inner.getEnclosedElements()));\n    String formatted \u003d new MethodSignatureFormatter(compilationRule.getTypes()).format(method);\n    // This is gross, but it turns out that annotation order is not guaranteed when getting\n    // all the AnnotationMirrors from an Element, so I have to test this chopped-up to make it\n    // less brittle.\n    assertThat(formatted).contains(\"@Singleton\");\n    assertThat(formatted).doesNotContain(\"@javax.inject.Singleton\"); // maybe more importantly\n    assertThat(formatted)\n        .contains(\"@dagger.internal.codegen.MethodSignatureFormatterTest.OuterClass.Foo\"\n            + \"(bar\u003dString.class)\");\n    assertThat(formatted).contains(\" String \"); // return type compressed\n    assertThat(formatted).contains(\"int, ImmutableList\u003cBoolean\u003e)\"); // parameters compressed.\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\MissingBindingSuggestionsTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class MissingBindingSuggestionsTest {\n  private static JavaFileObject injectable(String className, String constructorParams) {\n    return JavaFileObjects.forSourceLines(\"test.\" + className,\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class \" + className +\" {\",\n        \"  @Inject \" + className + \"(\" + constructorParams + \") {}\",\n        \"}\");\n  }\n\n  private static JavaFileObject emptyInterface(String interfaceName) {\n    return JavaFileObjects.forSourceLines(\"test.\" + interfaceName,\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"interface \" + interfaceName +\" {}\");\n  }\n\n  @Test public void suggestsBindingInSeparateComponent() {\n    JavaFileObject fooComponent \u003d JavaFileObjects.forSourceLines(\"test.FooComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"interface FooComponent {\",\n        \"  Foo getFoo();\",\n        \"}\");\n    JavaFileObject barModule \u003d JavaFileObjects.forSourceLines(\"test.BarModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"@dagger.Module\",\n        \"final class BarModule {\",\n        \"  @Provides Bar provideBar() {return null;}\",\n        \"}\");\n    JavaFileObject barComponent \u003d JavaFileObjects.forSourceLines(\"test.BarComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent(modules \u003d {BarModule.class})\",\n        \"interface BarComponent {\",\n        \"  Bar getBar();\",\n        \"}\");\n    JavaFileObject foo \u003d injectable(\"Foo\", \"Bar bar\");\n    JavaFileObject bar \u003d emptyInterface(\"Bar\");\n\n    JavaFileObject topComponent \u003d JavaFileObjects.forSourceLines(\"test.TopComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface TopComponent {\",\n        \"  FooComponent getFoo();\",\n        \"  BarComponent getBar(BarModule barModule);\",\n        \"}\");\n\n    assertAbout(javaSources())\n        .that(ImmutableList.of(\n            fooComponent, barComponent, topComponent, foo, bar, barModule))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"A binding with matching key exists in component: test.BarComponent\");\n  }\n\n  @Test public void suggestsBindingInNestedSubcomponent() {\n    JavaFileObject fooComponent \u003d JavaFileObjects.forSourceLines(\"test.FooComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"interface FooComponent {\",\n        \"  Foo getFoo();\",\n        \"}\");\n    JavaFileObject barComponent \u003d JavaFileObjects.forSourceLines(\"test.BarComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent()\",\n        \"interface BarComponent {\",\n        \"  BazComponent getBaz();\",\n        \"}\");\n    JavaFileObject bazModule \u003d JavaFileObjects.forSourceLines(\"test.BazModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"@dagger.Module\",\n        \"final class BazModule {\",\n        \"  @Provides Baz provideBaz() {return null;}\",\n        \"}\");\n    JavaFileObject bazComponent \u003d JavaFileObjects.forSourceLines(\"test.BazComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent(modules \u003d {BazModule.class})\",\n        \"interface BazComponent {\",\n        \"  Baz getBaz();\",\n        \"}\");\n    JavaFileObject foo \u003d injectable(\"Foo\", \"Baz baz\");\n    JavaFileObject baz \u003d emptyInterface(\"Baz\");\n\n    JavaFileObject topComponent \u003d JavaFileObjects.forSourceLines(\"test.TopComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface TopComponent {\",\n        \"  FooComponent getFoo();\",\n        \"  BarComponent getBar();\",\n        \"}\");\n\n    assertAbout(javaSources())\n        .that(ImmutableList.of(\n            fooComponent, barComponent, bazComponent, topComponent, foo, baz, bazModule))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"A binding with matching key exists in component: test.BazComponent\");\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\ModuleFactoryGeneratorTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;\nimport static com.google.testing.compile.JavaSourcesSubject.assertThat;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;\nimport static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_RETURN_TYPE;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RETURN_SET;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_THROWS_CHECKED;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;\nimport static dagger.internal.codegen.ErrorMessages.MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT;\nimport static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.CompileTester;\nimport com.google.testing.compile.JavaFileObjects;\nimport com.squareup.javapoet.CodeBlock;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class ModuleFactoryGeneratorTest {\n\n  private static final JavaFileObject NULLABLE \u003d\n      JavaFileObjects.forSourceLines(\n          \"test.Nullable\", \"package test;\", \"public @interface Nullable {}\");\n\n  private static final CodeBlock NPE_LITERAL \u003d\n      CodeBlocks.stringLiteral(ErrorMessages.CANNOT_RETURN_NULL_FROM_NON_NULLABLE_PROVIDES_METHOD);\n\n  // TODO(gak): add tests for invalid combinations of scope and qualifier annotations like we have\n  // for @Inject\n\n  private String formatErrorMessage(String msg) {\n    return String.format(msg, \"Provides\");\n  }\n\n  private String formatModuleErrorMessage(String msg) {\n    return String.format(msg, \"Provides\", \"Module\");\n  }\n\n  @Test public void providesMethodNotInModule() {\n    assertThatMethodInUnannotatedClass(\"@Provides String provideString() { return null; }\")\n        .hasError(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));\n  }\n\n  @Test public void providesMethodAbstract() {\n    assertThatModuleMethod(\"@Provides abstract String abstractMethod();\")\n        .hasError(formatErrorMessage(BINDING_METHOD_ABSTRACT));\n  }\n\n  @Test public void providesMethodPrivate() {\n    assertThatModuleMethod(\"@Provides private String privateMethod() { return null; }\")\n        .hasError(formatErrorMessage(BINDING_METHOD_PRIVATE));\n  }\n\n  @Test public void providesMethodReturnVoid() {\n    assertThatModuleMethod(\"@Provides void voidMethod() {}\")\n        .hasError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));\n  }\n\n  @Test\n  public void providesMethodReturnsProvider() {\n    assertThatModuleMethod(\"@Provides Provider\u003cString\u003e provideProvider() {}\")\n        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));\n  }\n\n  @Test\n  public void providesMethodReturnsLazy() {\n    assertThatModuleMethod(\"@Provides Lazy\u003cString\u003e provideLazy() {}\")\n        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));\n  }\n\n  @Test\n  public void providesMethodReturnsMembersInjector() {\n    assertThatModuleMethod(\"@Provides MembersInjector\u003cString\u003e provideMembersInjector() {}\")\n        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));\n  }\n\n  @Test\n  public void providesMethodReturnsProducer() {\n    assertThatModuleMethod(\"@Provides Producer\u003cString\u003e provideProducer() {}\")\n        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));\n  }\n\n  @Test\n  public void providesMethodReturnsProduced() {\n    assertThatModuleMethod(\"@Provides Produced\u003cString\u003e provideProduced() {}\")\n        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));\n  }\n\n  @Test public void providesMethodWithTypeParameter() {\n    assertThatModuleMethod(\"@Provides \u003cT\u003e String typeParameter() { return null; }\")\n        .hasError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));\n  }\n\n  @Test public void providesMethodSetValuesWildcard() {\n    assertThatModuleMethod(\"@Provides @ElementsIntoSet Set\u003c?\u003e provideWildcard() { return null; }\")\n        .hasError(formatErrorMessage(BINDING_METHOD_RETURN_TYPE));\n  }\n\n  @Test public void providesMethodSetValuesRawSet() {\n    assertThatModuleMethod(\"@Provides @ElementsIntoSet Set provideSomething() { return null; }\")\n        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));\n  }\n\n  @Test public void providesMethodSetValuesNotASet() {\n    assertThatModuleMethod(\n            \"@Provides @ElementsIntoSet List\u003cString\u003e provideStrings() { return null; }\")\n        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RETURN_SET));\n  }\n\n  @Test public void modulesWithTypeParamsMustBeAbstract() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule\u003cA\u003e {}\");\n    assertAbout(javaSource())\n        .that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MODULES_WITH_TYPE_PARAMS_MUST_BE_ABSTRACT)\n        .in(moduleFile)\n        .onLine(6);\n  }\n\n  @Test public void provideOverriddenByNoProvide() {\n    JavaFileObject parent \u003d JavaFileObjects.forSourceLines(\"test.Parent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"class Parent {\",\n        \"  @Provides String foo() { return null; }\",\n        \"}\");\n    assertThatModuleMethod(\"String foo() { return null; }\")\n        .withDeclaration(\"@Module class %s extends Parent { %s }\")\n        .withAdditionalSources(parent)\n        .hasError(\n            String.format(\n                ErrorMessages.METHOD_OVERRIDES_PROVIDES_METHOD,\n                \"Provides\",\n                \"@Provides String test.Parent.foo()\"));\n  }\n\n  @Test public void provideOverriddenByProvide() {\n    JavaFileObject parent \u003d JavaFileObjects.forSourceLines(\"test.Parent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"class Parent {\",\n        \"  @Provides String foo() { return null; }\",\n        \"}\");\n    assertThatModuleMethod(\"@Provides String foo() { return null; }\")\n        .withDeclaration(\"@Module class %s extends Parent { %s }\")\n        .withAdditionalSources(parent)\n        .hasError(\n            String.format(\n                ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,\n                \"Provides\",\n                \"@Provides String test.Parent.foo()\"));\n  }\n\n  @Test public void providesOverridesNonProvides() {\n    JavaFileObject parent \u003d JavaFileObjects.forSourceLines(\"test.Parent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module\",\n        \"class Parent {\",\n        \"  String foo() { return null; }\",\n        \"}\");\n    assertThatModuleMethod(\"@Provides String foo() { return null; }\")\n        .withDeclaration(\"@Module class %s extends Parent { %s }\")\n        .withAdditionalSources(parent)\n        .hasError(\n            String.format(\n                ErrorMessages.PROVIDES_METHOD_OVERRIDES_ANOTHER,\n                \"Provides\",\n                \"String test.Parent.foo()\"));\n  }\n\n  @Test public void validatesIncludedModules() {\n    JavaFileObject module \u003d JavaFileObjects.forSourceLines(\"test.Parent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module(includes \u003d Void.class)\",\n        \"class TestModule {}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(module))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(\n                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED, \"java.lang.Void\", \"@Module\"));\n  }\n\n  @Test public void singleProvidesMethodNoArgs() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides String provideString() {\",\n        \"    return \\\"\\\";\",\n        \"  }\",\n        \"}\");\n    JavaFileObject factoryFile \u003d JavaFileObjects.forSourceLines(\"TestModule_ProvideStringFactory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import dagger.internal.Preconditions;\",\n        \"import javax.annotation.Generated;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class TestModule_ProvideStringFactory implements Factory\u003cString\u003e {\",\n        \"  private final TestModule module;\",\n        \"\",\n        \"  public TestModule_ProvideStringFactory(TestModule module) {\",\n        \"    assert module !\u003d null;\",\n        \"    this.module \u003d module;\",\n        \"  }\",\n        \"\",\n        \"  @Override public String get() {\",\n        \"    return Preconditions.checkNotNull(module.provideString(), \" + NPE_LITERAL + \");\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cString\u003e create(TestModule module) {\",\n        \"    return new TestModule_ProvideStringFactory(module);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(factoryFile);\n  }\n\n  @Test public void singleProvidesMethodNoArgs_disableNullable() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides String provideString() {\",\n        \"    return \\\"\\\";\",\n        \"  }\",\n        \"}\");\n    JavaFileObject factoryFile \u003d JavaFileObjects.forSourceLines(\"TestModule_ProvideStringFactory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import javax.annotation.Generated;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class TestModule_ProvideStringFactory implements Factory\u003cString\u003e {\",\n        \"  private final TestModule module;\",\n        \"\",\n        \"  public TestModule_ProvideStringFactory(TestModule module) {\",\n        \"    assert module !\u003d null;\",\n        \"    this.module \u003d module;\",\n        \"  }\",\n        \"\",\n        \"  @Override public String get() {\",\n        \"    return module.provideString();\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cString\u003e create(TestModule module) {\",\n        \"    return new TestModule_ProvideStringFactory(module);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(moduleFile)\n        .withCompilerOptions(\"-Adagger.nullableValidation\u003dWARNING\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(factoryFile);\n  }\n\n  @Test public void nullableProvides() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides @Nullable String provideString() { return null; }\",\n        \"}\");\n    JavaFileObject factoryFile \u003d JavaFileObjects.forSourceLines(\"TestModule_ProvideStringFactory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import javax.annotation.Generated;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class TestModule_ProvideStringFactory implements Factory\u003cString\u003e {\",\n        \"  private final TestModule module;\",\n        \"\",\n        \"  public TestModule_ProvideStringFactory(TestModule module) {\",\n        \"    assert module !\u003d null;\",\n        \"    this.module \u003d module;\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  @Nullable\",\n        \"  public String get() {\",\n        \"    return module.provideString();\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cString\u003e create(TestModule module) {\",\n        \"    return new TestModule_ProvideStringFactory(module);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, NULLABLE))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(factoryFile);\n  }\n\n  private static final JavaFileObject QUALIFIER_A \u003d\n      JavaFileObjects.forSourceLines(\"test.QualifierA\",\n          \"package test;\",\n          \"\",\n          \"import javax.inject.Qualifier;\",\n          \"\",\n          \"@Qualifier @interface QualifierA {}\");\n  private static final JavaFileObject QUALIFIER_B \u003d\n      JavaFileObjects.forSourceLines(\"test.QualifierB\",\n          \"package test;\",\n          \"\",\n          \"import javax.inject.Qualifier;\",\n          \"\",\n          \"@Qualifier @interface QualifierB {}\");\n\n  @Test public void multipleProvidesMethods() {\n    JavaFileObject classXFile \u003d JavaFileObjects.forSourceLines(\"test.X\",\n        \"package test;\",\n        \"\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"class X {\",\n        \"  @Inject public String s;\",\n        \"}\");\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.MembersInjector;\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import java.util.Arrays;\",\n        \"import java.util.List;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides List\u003cObject\u003e provideObjects(\",\n        \"      @QualifierA Object a, @QualifierB Object b, MembersInjector\u003cX\u003e x) {\",\n        \"    return Arrays.asList(a, b);\",\n        \"  }\",\n        \"\",\n        \"  @Provides @QualifierA Object provideAObject() {\",\n        \"    return new Object();\",\n        \"  }\",\n        \"\",\n        \"  @Provides @QualifierB Object provideBObject() {\",\n        \"    return new Object();\",\n        \"  }\",\n        \"}\");\n    JavaFileObject listFactoryFile \u003d JavaFileObjects.forSourceLines(\n        \"TestModule_ProvideObjectsFactory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.MembersInjector;\",\n        \"import dagger.internal.Factory;\",\n        \"import dagger.internal.Preconditions;\",\n        \"import java.util.List;\",\n        \"import javax.annotation.Generated;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class TestModule_ProvideObjectsFactory implements Factory\u003cList\u003cObject\u003e\u003e {\",\n        \"  private final TestModule module;\",\n        \"  private final Provider\u003cObject\u003e aProvider;\",\n        \"  private final Provider\u003cObject\u003e bProvider;\",\n        \"  private final MembersInjector\u003cX\u003e xMembersInjector;\",\n        \"\",\n        \"  public TestModule_ProvideObjectsFactory(\",\n        \"      TestModule module,\",\n        \"      Provider\u003cObject\u003e aProvider,\",\n        \"      Provider\u003cObject\u003e bProvider,\",\n        \"      MembersInjector\u003cX\u003e xMembersInjector) {\",\n        \"    assert module !\u003d null;\",\n        \"    this.module \u003d module;\",\n        \"    assert aProvider !\u003d null;\",\n        \"    this.aProvider \u003d aProvider;\",\n        \"    assert bProvider !\u003d null;\",\n        \"    this.bProvider \u003d bProvider;\",\n        \"    assert xMembersInjector !\u003d null;\",\n        \"    this.xMembersInjector \u003d xMembersInjector;\",\n        \"  }\",\n        \"\",\n        \"  @Override public List\u003cObject\u003e get() {\",\n        \"    return Preconditions.checkNotNull(\",\n        \"        module.provideObjects(aProvider.get(), bProvider.get(), xMembersInjector),\",\n        \"        \" + NPE_LITERAL + \");\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cList\u003cObject\u003e\u003e create(\",\n        \"      TestModule module,\",\n        \"      Provider\u003cObject\u003e aProvider,\",\n        \"      Provider\u003cObject\u003e bProvider,\",\n        \"      MembersInjector\u003cX\u003e xMembersInjector) {\",\n        \"    return new TestModule_ProvideObjectsFactory(\",\n        \"        module, aProvider, bProvider, xMembersInjector);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(\n            ImmutableList.of(classXFile, moduleFile, QUALIFIER_A, QUALIFIER_B))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(listFactoryFile);\n  }\n\n  @Test public void providesSetElement() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import java.util.logging.Logger;\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.multibindings.IntoSet;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides @IntoSet String provideString() {\",\n        \"    return \\\"\\\";\",\n        \"  }\",\n        \"}\");\n    JavaFileObject factoryFile \u003d JavaFileObjects.forSourceLines(\"TestModule_ProvideStringFactory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import dagger.internal.Preconditions;\",\n        \"import javax.annotation.Generated;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class TestModule_ProvideStringFactory implements Factory\u003cString\u003e {\",\n        \"  private final TestModule module;\",\n        \"\",\n        \"  public TestModule_ProvideStringFactory(TestModule module) {\",\n        \"    assert module !\u003d null;\",\n        \"    this.module \u003d module;\",\n        \"  }\",\n        \"\",\n        \"  @Override public String get() {\",\n        \"    return Preconditions.checkNotNull(module.provideString(), \" + NPE_LITERAL + \");\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cString\u003e create(TestModule module) {\",\n        \"    return new TestModule_ProvideStringFactory(module);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(factoryFile);\n  }\n\n  @Test public void providesSetElementWildcard() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import java.util.logging.Logger;\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.multibindings.IntoSet;\",\n        \"import java.util.ArrayList;\",\n        \"import java.util.List;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides @IntoSet List\u003cList\u003c?\u003e\u003e provideWildcardList() {\",\n        \"    return new ArrayList\u003c\u003e();\",\n        \"  }\",\n        \"}\");\n    JavaFileObject factoryFile \u003d JavaFileObjects.forSourceLines(\n        \"TestModule_ProvideWildcardListFactory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import dagger.internal.Preconditions;\",\n        \"import java.util.List;\",\n        \"import javax.annotation.Generated;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class TestModule_ProvideWildcardListFactory implements \"\n            + \"Factory\u003cList\u003cList\u003c?\u003e\u003e\u003e {\",\n        \"  private final TestModule module;\",\n        \"\",\n        \"  public TestModule_ProvideWildcardListFactory(TestModule module) {\",\n        \"    assert module !\u003d null;\",\n        \"    this.module \u003d module;\",\n        \"  }\",\n        \"\",\n        \"  @Override public List\u003cList\u003c?\u003e\u003e get() {\",\n        \"    return Preconditions.checkNotNull(module.provideWildcardList(), \" + NPE_LITERAL + \");\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cList\u003cList\u003c?\u003e\u003e\u003e create(TestModule module) {\",\n        \"    return new TestModule_ProvideWildcardListFactory(module);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(factoryFile);\n  }\n\n  @Test public void providesSetValues() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.multibindings.ElementsIntoSet;\",\n        \"import java.util.Set;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides @ElementsIntoSet Set\u003cString\u003e provideStrings() {\",\n        \"    return null;\",\n        \"  }\",\n        \"}\");\n    JavaFileObject factoryFile \u003d JavaFileObjects.forSourceLines(\"TestModule_ProvideStringsFactory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import dagger.internal.Preconditions;\",\n        \"import java.util.Set;\",\n        \"import javax.annotation.Generated;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class TestModule_ProvideStringsFactory implements Factory\u003cSet\u003cString\u003e\u003e {\",\n        \"  private final TestModule module;\",\n        \"\",\n        \"  public TestModule_ProvideStringsFactory(TestModule module) {\",\n        \"    assert module !\u003d null;\",\n        \"    this.module \u003d module;\",\n        \"  }\",\n        \"\",\n        \"  @Override public Set\u003cString\u003e get() {\",\n        \"    return Preconditions.checkNotNull(module.provideStrings(), \" + NPE_LITERAL + \");\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cSet\u003cString\u003e\u003e create(TestModule module) {\",\n        \"    return new TestModule_ProvideStringsFactory(module);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(factoryFile);\n  }\n\n  @Test public void multipleProvidesMethodsWithSameName() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides Object provide(int i) {\",\n        \"    return i;\",\n        \"  }\",\n        \"\",\n        \"  @Provides String provide() {\",\n        \"    return \\\"\\\";\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n    .withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME)).in(moduleFile).onLine(8)\n        .and().withErrorContaining(formatErrorMessage(BINDING_METHOD_WITH_SAME_NAME))\n        .in(moduleFile).onLine(12);\n  }\n\n  @Test\n  public void providesMethodThrowsChecked() {\n    JavaFileObject moduleFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"\",\n            \"@Module\",\n            \"final class TestModule {\",\n            \"  @Provides int i() throws Exception {\",\n            \"    return 0;\",\n            \"  }\",\n            \"\",\n            \"  @Provides String s() throws Throwable {\",\n            \"    return \\\"\\\";\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSource())\n        .that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))\n        .in(moduleFile)\n        .onLine(8)\n        .and()\n        .withErrorContaining(formatErrorMessage(BINDING_METHOD_THROWS_CHECKED))\n        .in(moduleFile)\n        .onLine(12);\n  }\n\n  @Test\n  public void providedTypes() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import java.io.Closeable;\",\n        \"import java.util.Set;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides String string() {\",\n        \"    return null;\",\n        \"  }\",\n        \"\",\n        \"  @Provides Set\u003cString\u003e strings() {\",\n        \"    return null;\",\n        \"  }\",\n        \"\",\n        \"  @Provides Set\u003c? extends Closeable\u003e closeables() {\",\n        \"    return null;\",\n        \"  }\",\n        \"\",\n        \"  @Provides String[] stringArray() {\",\n        \"    return null;\",\n        \"  }\",\n        \"\",\n        \"  @Provides int integer() {\",\n        \"    return 0;\",\n        \"  }\",\n        \"\",\n        \"  @Provides int[] integers() {\",\n        \"    return null;\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n\n  @Test\n  public void privateModule() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.Enclosing\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"final class Enclosing {\",\n        \"  @Module private static final class PrivateModule {\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource())\n        .that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Modules cannot be private.\")\n        .in(moduleFile).onLine(6);\n  }\n\n  @Test\n  public void enclosedInPrivateModule() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.Enclosing\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"final class Enclosing {\",\n        \"  private static final class PrivateEnclosing {\",\n        \"    @Module static final class TestModule {\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource())\n        .that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Modules cannot be enclosed in private types.\")\n        .in(moduleFile).onLine(7);\n  }\n\n  @Test\n  public void publicModuleNonPublicIncludes() {\n    JavaFileObject publicModuleFile \u003d JavaFileObjects.forSourceLines(\"test.PublicModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module(includes \u003d {\",\n        \"    NonPublicModule1.class, OtherPublicModule.class, NonPublicModule2.class\",\n        \"})\",\n        \"public final class PublicModule {\",\n        \"}\");\n    JavaFileObject nonPublicModule1File \u003d JavaFileObjects.forSourceLines(\"test.NonPublicModule1\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module\",\n        \"final class NonPublicModule1 {\",\n        \"}\");\n    JavaFileObject nonPublicModule2File \u003d JavaFileObjects.forSourceLines(\"test.NonPublicModule2\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module\",\n        \"final class NonPublicModule2 {\",\n        \"}\");\n    JavaFileObject otherPublicModuleFile \u003d JavaFileObjects.forSourceLines(\"test.OtherPublicModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module\",\n        \"public final class OtherPublicModule {\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(\n            publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"This module is public, but it includes non-public \"\n            + \"(or effectively non-public) modules. \"\n            + \"Either reduce the visibility of this module or make \"\n            + \"test.NonPublicModule1 and test.NonPublicModule2 public.\")\n        .in(publicModuleFile).onLine(8);\n  }\n\n  @Test\n  public void genericSubclassedModule() {\n    JavaFileObject parent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.IntoSet;\",\n            \"import dagger.multibindings.IntoMap;\",\n            \"import dagger.multibindings.StringKey;\",\n            \"import java.util.List;\",\n            \"import java.util.ArrayList;\",\n            \"\",\n            \"@Module\",\n            \"abstract class ParentModule\u003cA extends CharSequence,\",\n            \"                            B,\",\n            \"                            C extends Number \u0026 Comparable\u003cC\u003e\u003e {\",\n            \"  @Provides List\u003cB\u003e provideListB(B b) {\",\n            \"    List\u003cB\u003e list \u003d new ArrayList\u003cB\u003e();\",\n            \"    list.add(b);\",\n            \"    return list;\",\n            \"  }\",\n            \"\",\n            \"  @Provides @IntoSet B provideBElement(B b) {\",\n            \"    return b;\",\n            \"  }\",\n            \"\",\n            \"  @Provides @IntoMap @StringKey(\\\"b\\\") B provideBEntry(B b) {\",\n            \"    return b;\",\n            \"  }\",\n            \"}\");\n    JavaFileObject numberChild \u003d JavaFileObjects.forSourceLines(\"test.ChildNumberModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"class ChildNumberModule extends ParentModule\u003cString, Number, Double\u003e {\",\n        \"  @Provides Number provideNumber() { return 1; }\",\n        \"}\");\n    JavaFileObject integerChild \u003d JavaFileObjects.forSourceLines(\"test.ChildIntegerModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"class ChildIntegerModule extends ParentModule\u003cStringBuilder, Integer, Float\u003e {\",\n        \"  @Provides Integer provideInteger() { return 2; }\",\n        \"}\");\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.C\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import java.util.List;\",\n        \"\",\n        \"@Component(modules\u003d{ChildNumberModule.class, ChildIntegerModule.class})\",\n        \"interface C {\",\n        \"  List\u003cNumber\u003e numberList();\",\n        \"  List\u003cInteger\u003e integerList();\",\n        \"}\");\n    JavaFileObject listBFactory \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentModule_ProvideListBFactory\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.Factory;\",\n            \"import dagger.internal.Preconditions;\",\n            \"import java.util.List;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class ParentModule_ProvideListBFactory\u003cA extends CharSequence,\",\n            \"    B, C extends Number \u0026 Comparable\u003cC\u003e\u003e implements Factory\u003cList\u003cB\u003e\u003e {\",\n            \"  private final ParentModule\u003cA, B, C\u003e module;\",\n            \"  private final Provider\u003cB\u003e bProvider;\",\n            \"\",\n            \"  public ParentModule_ProvideListBFactory(\",\n            \"        ParentModule\u003cA, B, C\u003e module, Provider\u003cB\u003e bProvider) {\",\n            \"    assert module !\u003d null;\",\n            \"    this.module \u003d module;\",\n            \"    assert bProvider !\u003d null;\",\n            \"    this.bProvider \u003d bProvider;\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public List\u003cB\u003e get() {  \",\n            \"    return Preconditions.checkNotNull(module.provideListB(bProvider.get()),\",\n            \"        \" + NPE_LITERAL + \");\",\n            \"  }\",\n            \"\",\n            \"  public static \u003cA extends CharSequence, B, C extends Number \u0026 Comparable\u003cC\u003e\u003e\",\n            \"      Factory\u003cList\u003cB\u003e\u003e create(ParentModule\u003cA, B, C\u003e module, Provider\u003cB\u003e bProvider) {\",\n            \"    return new ParentModule_ProvideListBFactory\u003cA, B, C\u003e(module, bProvider);\",\n            \"  }\",\n            \"}\");\n    JavaFileObject bElementFactory \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentModule_ProvideBElementFactory\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.Factory;\",\n            \"import dagger.internal.Preconditions;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class ParentModule_ProvideBElementFactory\u003cA extends CharSequence,\",\n            \"    B, C extends Number \u0026 Comparable\u003cC\u003e\u003e implements Factory\u003cB\u003e {\",\n            \"  private final ParentModule\u003cA, B, C\u003e module;\",\n            \"  private final Provider\u003cB\u003e bProvider;\",\n            \"\",\n            \"  public ParentModule_ProvideBElementFactory(\",\n            \"        ParentModule\u003cA, B, C\u003e module, Provider\u003cB\u003e bProvider) {\",\n            \"    assert module !\u003d null;\",\n            \"    this.module \u003d module;\",\n            \"    assert bProvider !\u003d null;\",\n            \"    this.bProvider \u003d bProvider;\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public B get() {  \",\n            \"    return Preconditions.checkNotNull(\",\n            \"        module.provideBElement(bProvider.get()), \" + NPE_LITERAL + \");\",\n            \"  }\",\n            \"\",\n            \"  public static \u003cA extends CharSequence, B, C extends Number \u0026 Comparable\u003cC\u003e\u003e\",\n            \"      Factory\u003cB\u003e create(ParentModule\u003cA, B, C\u003e module, Provider\u003cB\u003e bProvider) {\",\n            \"    return new ParentModule_ProvideBElementFactory\u003cA, B, C\u003e(module, bProvider);\",\n            \"  }\",\n            \"}\");\n    JavaFileObject bEntryFactory \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentModule_ProvideBEntryFactory\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.Factory;\",\n            \"import dagger.internal.Preconditions;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class ParentModule_ProvideBEntryFactory\u003cA extends CharSequence,\",\n            \"    B, C extends Number \u0026 Comparable\u003cC\u003e\u003e implements Factory\u003cB\u003e\u003e {\",\n            \"  private final ParentModule\u003cA, B, C\u003e module;\",\n            \"  private final Provider\u003cB\u003e bProvider;\",\n            \"\",\n            \"  public ParentModule_ProvideBEntryFactory(\",\n            \"        ParentModule\u003cA, B, C\u003e module, Provider\u003cB\u003e bProvider) {\",\n            \"    assert module !\u003d null;\",\n            \"    this.module \u003d module;\",\n            \"    assert bProvider !\u003d null;\",\n            \"    this.bProvider \u003d bProvider;\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public B get() {  \",\n            \"    return Preconditions.checkNotNull(module.provideBEntry(bProvider.get()), \",\n            \"        \" + NPE_LITERAL + \");\",\n            \"  }\",\n            \"\",\n            \"  public static \u003cA extends CharSequence, B, C extends Number \u0026 Comparable\u003cC\u003e\u003e\",\n            \"      Factory\u003cB\u003e create(ParentModule\u003cA, B, C\u003e module, Provider\u003cB\u003e bProvider) {\",\n            \"    return new ParentModule_ProvideBEntryFactory\u003cA, B, C\u003e(module, bProvider);\",\n            \"  }\",\n            \"}\");\n    JavaFileObject numberFactory \u003d JavaFileObjects.forSourceLines(\n        \"test.ChildNumberModule_ProvideNumberFactory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import dagger.internal.Preconditions;\",\n        \"import javax.annotation.Generated;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class ChildNumberModule_ProvideNumberFactory implements Factory\u003cNumber\u003e {\",\n        \"  private final ChildNumberModule module;\",\n        \"\",\n        \"  public ChildNumberModule_ProvideNumberFactory(ChildNumberModule module) {\",\n        \"    assert module !\u003d null;\",\n        \"    this.module \u003d module;\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public Number get() {  \",\n        \"    return Preconditions.checkNotNull(module.provideNumber(), \" + NPE_LITERAL + \");\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cNumber\u003e create(ChildNumberModule module) {\",\n        \"    return new ChildNumberModule_ProvideNumberFactory(module);\",\n        \"  }\",\n        \"}\");\n    JavaFileObject integerFactory \u003d JavaFileObjects.forSourceLines(\n        \"test.ChildIntegerModule_ProvideIntegerFactory\",\n        \"package test;\",\n        \"\",\n        \"import dagger.internal.Factory;\",\n        \"import dagger.internal.Preconditions;\",\n        \"import javax.annotation.Generated;\",\n        \"\",\n        GENERATED_ANNOTATION,\n        \"public final class ChildIntegerModule_ProvideIntegerFactory\",\n        \"    implements Factory\u003cInteger\u003e {\",\n        \"  private final ChildIntegerModule module;\",\n        \"\",\n        \"  public ChildIntegerModule_ProvideIntegerFactory(ChildIntegerModule module) {\",\n        \"    assert module !\u003d null;\",\n        \"    this.module \u003d module;\",\n        \"  }\",\n        \"\",\n        \"  @Override\",\n        \"  public Integer get() {  \",\n        \"    return Preconditions.checkNotNull(module.provideInteger(), \" + NPE_LITERAL + \");\",\n        \"  }\",\n        \"\",\n        \"  public static Factory\u003cInteger\u003e create(ChildIntegerModule module) {\",\n        \"    return new ChildIntegerModule_ProvideIntegerFactory(module);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(parent, numberChild, integerChild, component))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(\n            listBFactory, bElementFactory, bEntryFactory, numberFactory, integerFactory);\n  }\n\n  @Test public void parameterizedModuleWithStaticProvidesMethodOfGenericType() {\n    JavaFileObject moduleFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParameterizedModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import java.util.List;\",\n            \"import java.util.ArrayList;\",\n            \"import java.util.Map;\",\n            \"import java.util.HashMap;\",\n            \"\",\n            \"@Module abstract class ParameterizedModule\u003cT\u003e {\",\n            \"  @Provides List\u003cT\u003e provideListT() {\",\n            \"    return new ArrayList\u003c\u003e();\",\n            \"  }\",\n            \"\",\n            \"  @Provides static Map\u003cString, Number\u003e provideMapStringNumber() {\",\n            \"    return new HashMap\u003c\u003e();\",\n            \"  }\",\n            \"\",\n            \"  @Provides static Object provideNonGenericType() {\",\n            \"    return new Object();\",\n            \"  }\",\n            \"}\");\n\n    JavaFileObject provideMapStringNumberFactory \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParameterizedModule_ProvideMapStringNumberFactory;\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.Factory;\",\n            \"import dagger.internal.Preconditions;\",\n            \"import java.util.Map;\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public enum ParameterizedModule_ProvideMapStringNumberFactory\",\n            \"    implements Factory\u003cMap\u003cString, Number\u003e\u003e {\",\n            \"  INSTANCE;\",\n            \"\",\n            \"  @Override\",\n            \"  public Map\u003cString, Number\u003e get() {\",\n            \"    return Preconditions.checkNotNull(ParameterizedModule.provideMapStringNumber(),\",\n            \"        \" + NPE_LITERAL + \");\",\n            \"  }\",\n            \"\",\n            \"  public static Factory\u003cMap\u003cString, Number\u003e\u003e create() {\",\n            \"    return INSTANCE;\",\n            \"  }\",\n            \"}\");\n\n    JavaFileObject provideNonGenericTypeFactory \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParameterizedModule_ProvideNonGenericTypeFactory;\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.Factory;\",\n            \"import dagger.internal.Preconditions;\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public enum ParameterizedModule_ProvideNonGenericTypeFactory\",\n            \"    implements Factory\u003cObject\u003e {\",\n            \"  INSTANCE;\",\n            \"\",\n            \"  @Override\",\n            \"  public Object get() {\",\n            \"    return Preconditions.checkNotNull(ParameterizedModule.provideNonGenericType(),\",\n            \"        \" + NPE_LITERAL + \");\",\n            \"  }\",\n            \"\",\n            \"  public static Factory\u003cObject\u003e create() {\",\n            \"    return INSTANCE;\",\n            \"  }\",\n            \"}\");\n\n    assertAbout(javaSource())\n        .that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(provideMapStringNumberFactory, provideNonGenericTypeFactory);\n  }\n\n  @Test public void providesMethodMultipleQualifiers() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import javax.annotation.Nullable;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides @QualifierA @QualifierB String provideString() {\",\n        \"    return \\\"foo\\\";\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, QUALIFIER_A, QUALIFIER_B))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(BINDING_METHOD_MULTIPLE_QUALIFIERS);\n  }\n\n  @Test public void providerDependsOnProduced() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.producers.Producer;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides String provideString(Producer\u003cInteger\u003e producer) {\",\n        \"    return \\\"foo\\\";\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Producer may only be injected in @Produces methods\");\n  }\n\n  @Test public void providerDependsOnProducer() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.producers.Produced;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides String provideString(Produced\u003cInteger\u003e produced) {\",\n        \"    return \\\"foo\\\";\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Produced may only be injected in @Produces methods\");\n  }\n\n  private static final String BINDS_METHOD \u003d \"@Binds abstract Foo bindFoo(FooImpl impl);\";\n  private static final String MULTIBINDS_METHOD \u003d \"@Multibinds abstract Set\u003cFoo\u003e foos();\";\n  private static final String STATIC_PROVIDES_METHOD \u003d\n      \"@Provides static Bar provideBar() { return new Bar(); }\";\n  private static final String INSTANCE_PROVIDES_METHOD \u003d\n      \"@Provides Baz provideBaz() { return new Baz(); }\";\n  private static final String SOME_ABSTRACT_METHOD \u003d \"abstract void blah();\";\n\n  @Test\n  public void moduleMethodPermutations() {\n    assertThatMethodCombination(BINDS_METHOD, INSTANCE_PROVIDES_METHOD)\n        .failsToCompile()\n        .withErrorContaining(\n            \"A @Module may not contain both non-static @Provides methods and \"\n                + \"abstract @Binds or @Multibinds declarations\");\n    assertThatMethodCombination(MULTIBINDS_METHOD, INSTANCE_PROVIDES_METHOD)\n        .failsToCompile()\n        .withErrorContaining(\n            \"A @Module may not contain both non-static @Provides methods and \"\n                + \"abstract @Binds or @Multibinds declarations\");\n    assertThatMethodCombination(BINDS_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();\n    assertThatMethodCombination(BINDS_METHOD, MULTIBINDS_METHOD).compilesWithoutError();\n    assertThatMethodCombination(MULTIBINDS_METHOD, STATIC_PROVIDES_METHOD).compilesWithoutError();\n    assertThatMethodCombination(INSTANCE_PROVIDES_METHOD, SOME_ABSTRACT_METHOD)\n        .compilesWithoutError();\n  }\n\n  private CompileTester assertThatMethodCombination(String... methodLines) {\n    JavaFileObject fooFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Foo\",\n            \"package test;\",\n            \"\",\n            \"interface Foo {}\");\n    JavaFileObject fooImplFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.FooImpl\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class FooImpl implements Foo {\",\n            \"  @Inject FooImpl() {}\",\n            \"}\");\n    JavaFileObject barFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Bar\",\n            \"package test;\",\n            \"\",\n            \"final class Bar {}\");\n    JavaFileObject bazFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Baz\",\n            \"package test;\",\n            \"\",\n            \"final class Baz {}\");\n\n    ImmutableList\u003cString\u003e moduleLines \u003d\n        new ImmutableList.Builder\u003cString\u003e()\n            .add(\n                \"package test;\",\n                \"\",\n                \"import dagger.Binds;\",\n                \"import dagger.Module;\",\n                \"import dagger.Provides;\",\n                \"import dagger.multibindings.Multibinds;\",\n                \"import java.util.Set;\",\n                \"\",\n                \"@Module abstract class TestModule {\")\n            .add(methodLines)\n            .add(\"}\")\n            .build();\n\n    JavaFileObject bindsMethodAndInstanceProvidesMethodModuleFile \u003d\n        JavaFileObjects.forSourceLines(\"test.TestModule\", moduleLines);\n    return assertThat(\n            fooFile, fooImplFile, barFile, bazFile, bindsMethodAndInstanceProvidesMethodModuleFile)\n        .processedWith(new ComponentProcessor());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\ModuleValidatorTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.testing.compile.JavaSourcesSubject.assertThat;\n\nimport com.google.testing.compile.JavaFileObjects;\nimport dagger.Module;\nimport dagger.producers.ProducerModule;\nimport java.lang.annotation.Annotation;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\n\n@RunWith(Parameterized.class)\npublic final class ModuleValidatorTest {\n\n  @Parameterized.Parameters\n  public static Collection\u003cObject[]\u003e parameters() {\n    return Arrays.asList(new Object[][] {{ModuleType.MODULE}, {ModuleType.PRODUCER_MODULE}});\n  }\n\n  private enum ModuleType {\n    MODULE(Module.class),\n    PRODUCER_MODULE(ProducerModule.class),\n    ;\n\n    private final Class\u003c? extends Annotation\u003e annotation;\n\n    ModuleType(Class\u003c? extends Annotation\u003e annotation) {\n      this.annotation \u003d annotation;\n    }\n\n    String annotationWithSubcomponent(String subcomponent) {\n      return String.format(\"@%s(subcomponents \u003d %s)\", annotation.getSimpleName(), subcomponent);\n    }\n\n    String importStatement() {\n      return String.format(\"import %s;\", annotation.getName());\n    }\n\n    String simpleName() {\n      return annotation.getSimpleName();\n    }\n  }\n\n  private final ModuleType moduleType;\n\n  public ModuleValidatorTest(ModuleType moduleType) {\n    this.moduleType \u003d moduleType;\n  }\n\n  @Test\n  public void moduleSubcomponents_notASubcomponent() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            moduleType.importStatement(),\n            \"\",\n            moduleType.annotationWithSubcomponent(\"NotASubcomponent.class\"),\n            \"class TestModule {}\");\n    JavaFileObject notASubcomponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.NotASubcomponent\", \"package test;\", \"\", \"class NotASubcomponent {}\");\n    assertThat(module, notASubcomponent)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"test.NotASubcomponent is not a @Subcomponent or @ProductionSubcomponent\")\n        .in(module)\n        .onLine(5);\n  }\n\n  @Test\n  public void moduleSubcomponents_listsSubcomponentBuilder() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            moduleType.importStatement(),\n            \"\",\n            moduleType.annotationWithSubcomponent(\"Sub.Builder.class\"),\n            \"class TestModule {}\");\n    JavaFileObject subcomponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Sub\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent\",\n            \"interface Sub {\",\n            \"  @Subcomponent.Builder\",\n            \"  interface Builder {\",\n            \"    Sub build();\",\n            \"  }\",\n            \"}\");\n    assertThat(module, subcomponent)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"test.Sub.Builder is a @Subcomponent.Builder. Did you mean to use test.Sub?\")\n        .in(module)\n        .onLine(5);\n  }\n\n  @Test\n  public void moduleSubcomponents_listsProductionSubcomponentBuilder() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            moduleType.importStatement(),\n            \"\",\n            moduleType.annotationWithSubcomponent(\"Sub.Builder.class\"),\n            \"class TestModule {}\");\n    JavaFileObject subcomponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Sub\",\n            \"package test;\",\n            \"\",\n            \"import dagger.producers.ProductionSubcomponent;\",\n            \"\",\n            \"@ProductionSubcomponent\",\n            \"interface Sub {\",\n            \"  @ProductionSubcomponent.Builder\",\n            \"  interface Builder {\",\n            \"    Sub build();\",\n            \"  }\",\n            \"}\");\n    assertThat(module, subcomponent)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"test.Sub.Builder is a @ProductionSubcomponent.Builder. Did you mean to use test.Sub?\")\n        .in(module)\n        .onLine(5);\n  }\n\n  @Test\n  public void moduleSubcomponents_noSubcomponentBuilder() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            moduleType.importStatement(),\n            \"\",\n            moduleType.annotationWithSubcomponent(\"NoBuilder.class\"),\n            \"class TestModule {}\");\n    JavaFileObject subcomponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.NoBuilder\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent\",\n            \"interface NoBuilder {}\");\n    assertThat(module, subcomponent)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"test.NoBuilder doesn\u0027t have a @Subcomponent.Builder, which is required when used \"\n                + \"with @\"\n                + moduleType.simpleName()\n                + \".subcomponents\")\n        .in(module)\n        .onLine(5);\n  }\n\n  @Test\n  public void moduleSubcomponents_noProductionSubcomponentBuilder() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            moduleType.importStatement(),\n            \"\",\n            moduleType.annotationWithSubcomponent(\"NoBuilder.class\"),\n            \"class TestModule {}\");\n    JavaFileObject subcomponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.NoBuilder\",\n            \"package test;\",\n            \"\",\n            \"import dagger.producers.ProductionSubcomponent;\",\n            \"\",\n            \"@ProductionSubcomponent\",\n            \"interface NoBuilder {}\");\n    assertThat(module, subcomponent)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"test.NoBuilder doesn\u0027t have a @ProductionSubcomponent.Builder, which is required \"\n                + \"when used with @\"\n                + moduleType.simpleName()\n                + \".subcomponents\")\n        .in(module)\n        .onLine(5);\n  }\n\n  @Test\n  public void moduleSubcomponentsAreTypes() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"\",\n            \"@Module(subcomponents \u003d int.class)\",\n            \"class TestModule {}\");\n    assertThat(module)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"int is not a valid subcomponent type\")\n        .in(module)\n        .onLine(5);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\MultibindingsValidatorTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMultibindingsMethod;\nimport static java.util.Arrays.asList;\n\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.inject.Qualifier;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class MultibindingsValidatorTest {\n\n  private static final JavaFileObject SOME_QUALIFIER \u003d\n      JavaFileObjects.forSourceLines(\n          \"test.SomeQualifier\",\n          \"package test;\",\n          \"\",\n          \"import javax.inject.Qualifier;\",\n          \"\",\n          \"@Qualifier\",\n          \"@interface SomeQualifier {}\");\n\n  private static final JavaFileObject OTHER_QUALIFIER \u003d\n      JavaFileObjects.forSourceLines(\n          \"test.OtherQualifier\",\n          \"package test;\",\n          \"\",\n          \"import javax.inject.Qualifier;\",\n          \"\",\n          \"@Qualifier\",\n          \"@interface OtherQualifier {}\");\n\n  @Test\n  public void abstractClass() {\n    JavaFileObject testModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Multibindings;\",\n            \"import java.util.Map;\",\n            \"import java.util.Set;\",\n            \"\",\n            \"@Module\",\n            \"class TestModule {\",\n            \"  @Multibindings\",\n            \"  static abstract class Empties {\",\n            \"    abstract Set\u003cObject\u003e emptySet();\",\n            \"    @SomeQualifier abstract Set\u003cObject\u003e emptyQualifiedSet();\",\n            \"    abstract Map\u003cString, Object\u003e emptyMap();\",\n            \"    @SomeQualifier abstract Map\u003cString, Object\u003e emptyQualifiedMap();\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(asList(testModule, SOME_QUALIFIER))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"@Multibindings can be applied only to interfaces\")\n        .in(testModule)\n        .onLine(11);\n  }\n\n  @Test\n  public void concreteClass() {\n    JavaFileObject testModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Multibindings;\",\n            \"import java.util.Map;\",\n            \"import java.util.Set;\",\n            \"\",\n            \"@Module\",\n            \"class TestModule {\",\n            \"  @Multibindings\",\n            \"  static class Empties {\",\n            \"    Set\u003cObject\u003e emptySet() { return null; }\",\n            \"    @SomeQualifier Set\u003cObject\u003e emptyQualifiedSet() { return null; }\",\n            \"    Map\u003cString, Object\u003e emptyMap() { return null; }\",\n            \"    @SomeQualifier Map\u003cString, Object\u003e emptyQualifiedMap() { return null; }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(asList(testModule, SOME_QUALIFIER))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"@Multibindings can be applied only to interfaces\")\n        .in(testModule)\n        .onLine(11);\n  }\n\n  @Test\n  public void interfaceHasTypeParameters() {\n    JavaFileObject testModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Multibindings;\",\n            \"import java.util.Map;\",\n            \"import java.util.Set;\",\n            \"\",\n            \"@Module\",\n            \"class TestModule {\",\n            \"  @Multibindings\",\n            \"  interface Empties\u003cT\u003e {\",\n            \"    Set\u003cT\u003e emptySet();\",\n            \"    @SomeQualifier Set\u003cT\u003e emptyQualifiedSet();\",\n            \"    Map\u003cString, T\u003e emptyMap();\",\n            \"    @SomeQualifier Map\u003cString, T\u003e emptyQualifiedMap();\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(asList(testModule, SOME_QUALIFIER))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"@Multibindings types must not have type parameters\")\n        .in(testModule)\n        .onLine(11);\n  }\n\n  @Test\n  public void topLevel() {\n    JavaFileObject testInterface \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestInterface\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Multibindings;\",\n            \"import java.util.Map;\",\n            \"import java.util.Set;\",\n            \"\",\n            \"@Multibindings\",\n            \"interface Empties {\",\n            \"  Set\u003cObject\u003e emptySet();\",\n            \"  @SomeQualifier Set\u003cObject\u003e emptyQualifiedSet();\",\n            \"  Map\u003cString, Object\u003e emptyMap();\",\n            \"  @SomeQualifier Map\u003cString, Object\u003e emptyQualifiedMap();\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(asList(testInterface, SOME_QUALIFIER))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"@Multibindings types must be nested within a @Module or @ProducerModule\")\n        .in(testInterface)\n        .onLine(8);\n  }\n\n  @Test\n  public void notWithinModule() {\n    JavaFileObject testModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Multibindings;\",\n            \"import java.util.Map;\",\n            \"import java.util.Set;\",\n            \"\",\n            \"class TestModule {\",\n            \"  @Multibindings\",\n            \"  interface Empties {\",\n            \"    Set\u003cObject\u003e emptySet();\",\n            \"    @SomeQualifier Set\u003cObject\u003e emptyQualifiedSet();\",\n            \"    Map\u003cString, Object\u003e emptyMap();\",\n            \"    @SomeQualifier Map\u003cString, Object\u003e emptyQualifiedMap();\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(asList(testModule, SOME_QUALIFIER))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"@Multibindings types must be nested within a @Module or @ProducerModule\")\n        .in(testModule)\n        .onLine(9);\n  }\n\n  @Test\n  public void voidMethod() {\n    assertThatMultibindingsMethod(\"void voidMethod();\")\n        .hasError(\"@Multibindings methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void primitiveMethod() {\n    assertThatMultibindingsMethod(\"int primitive();\")\n        .hasError(\"@Multibindings methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void rawMap() {\n    assertThatMultibindingsMethod(\"Map rawMap();\")\n        .hasError(\"@Multibindings methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void wildcardMap() {\n    assertThatMultibindingsMethod(\"Map\u003c?, ?\u003e wildcardMap();\")\n        .hasError(\"@Multibindings methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void providerMap() {\n    assertThatMultibindingsMethod(\"Map\u003cString, Provider\u003cObject\u003e\u003e providerMap();\")\n        .hasError(\"@Multibindings methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void producerMap() {\n    assertThatMultibindingsMethod(\"Map\u003cString, Producer\u003cObject\u003e\u003e producerMap();\")\n        .hasError(\"@Multibindings methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void producedMap() {\n    assertThatMultibindingsMethod(\"Map\u003cString, Produced\u003cObject\u003e\u003e producedMap();\")\n        .hasError(\"@Multibindings methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void rawSet() {\n    assertThatMultibindingsMethod(\"Set rawSet();\")\n        .hasError(\"@Multibindings methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void wildcardSet() {\n    assertThatMultibindingsMethod(\"Set\u003c?\u003e wildcardSet();\")\n        .hasError(\"@Multibindings methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void providerSet() {\n    assertThatMultibindingsMethod(\"Set\u003cProvider\u003cObject\u003e\u003e providerSet();\")\n        .hasError(\"@Multibindings methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void producerSet() {\n    assertThatMultibindingsMethod(\"Set\u003cProducer\u003cObject\u003e\u003e producerSet();\")\n        .hasError(\"@Multibindings methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void producedSet() {\n    assertThatMultibindingsMethod(\"Set\u003cProduced\u003cObject\u003e\u003e producedSet();\")\n        .hasError(\"@Multibindings methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void overqualifiedSet() {\n    assertThatMultibindingsMethod(\n            \"@SomeQualifier @OtherQualifier Set\u003cObject\u003e tooManyQualifiersSet();\")\n        .importing(SomeQualifier.class, OtherQualifier.class)\n        .hasError(\"Cannot use more than one @Qualifier\");\n  }\n\n  @Test\n  public void overqualifiedMap() {\n    assertThatMultibindingsMethod(\n            \"@SomeQualifier @OtherQualifier Map\u003cString, Object\u003e tooManyQualifiersMap();\")\n        .importing(SomeQualifier.class, OtherQualifier.class)\n        .hasError(\"Cannot use more than one @Qualifier\");\n  }\n\n  @Test\n  public void hasParameters() {\n    assertThatMultibindingsMethod(\"Set\u003cString\u003e parameters(Object param);\")\n        .hasError(\"@Multibindings methods cannot have parameters\");\n  }\n\n  @Test\n  public void badMethodsOnSupertype() {\n    JavaFileObject testModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Multibindings;\",\n            \"import dagger.producers.Produced;\",\n            \"import dagger.producers.Producer;\",\n            \"import java.util.Map;\",\n            \"import java.util.Set;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            \"@Module\",\n            \"class TestModule {\",\n            \"  interface BaseEmpties {\",\n            \"    void voidMethod();\",\n            \"  }\",\n            \"\",\n            \"  @Multibindings\",\n            \"  interface Empties extends BaseEmpties {}\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(asList(testModule, SOME_QUALIFIER, OTHER_QUALIFIER))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"[test.TestModule.BaseEmpties.voidMethod()] \"\n                + \"@Multibindings methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\")\n        .in(testModule)\n        .onLine(18);\n  }\n\n  @Test\n  public void duplicateKeys() {\n    JavaFileObject testModule \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Multibindings;\",\n            \"import java.util.Map;\",\n            \"import java.util.Set;\",\n            \"\",\n            \"@Module\",\n            \"class TestModule {\",\n            \"  @Multibindings\",\n            \"  interface EmptySets {\",\n            \"    Set\u003cObject\u003e emptySet();\",\n            \"    Set\u003cObject\u003e emptySet2();\",\n            \"  }\",\n            \"\",\n            \"  @Multibindings\",\n            \"  interface EmptyQualifiedSets {\",\n            \"    @SomeQualifier Set\u003cObject\u003e emptyQualifiedSet();\",\n            \"    @SomeQualifier Set\u003cObject\u003e emptyQualifiedSet2();\",\n            \"  }\",\n            \"\",\n            \"  @Multibindings\",\n            \"  interface EmptyMaps {\",\n            \"    Map\u003cString, Object\u003e emptyMap();\",\n            \"    Map\u003cString, Object\u003e emptyMap2();\",\n            \"  }\",\n            \"\",\n            \"  @Multibindings\",\n            \"  interface EmptyQualifiedMaps {\",\n            \"    @SomeQualifier Map\u003cString, Object\u003e emptyQualifiedMap();\",\n            \"    @SomeQualifier Map\u003cString, Object\u003e emptyQualifiedMap2();\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(asList(testModule, SOME_QUALIFIER))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Too many @Multibindings methods for Set\u003cObject\u003e:\")\n        .in(testModule)\n        .onLine(11)\n        .and()\n        .withErrorContaining(\"Too many @Multibindings methods for @test.SomeQualifier Set\u003cObject\u003e:\")\n        .in(testModule)\n        .onLine(17)\n        .and()\n        .withErrorContaining(\"Too many @Multibindings methods for Map\u003cString,Provider\u003cObject\u003e\u003e:\")\n        .in(testModule)\n        .onLine(23)\n        .and()\n        .withErrorContaining(\n            \"Too many @Multibindings methods for @test.SomeQualifier Map\u003cString,Provider\u003cObject\u003e\u003e:\")\n        .in(testModule)\n        .onLine(29);\n  }\n\n  @Qualifier\n  public @interface SomeQualifier {}\n\n  @Qualifier\n  public @interface OtherQualifier {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\MultibindingTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.testing.compile.JavaSourcesSubject.assertThat;\n\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class MultibindingTest {\n  @Test\n  public void providesTypeAndAnnotationOnSameMethod_failsToCompile() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.MultibindingModule\",\n            \"package test;\",\n            \"\",\n            \"import static dagger.Provides.Type.SET;\",\n            \"import static dagger.Provides.Type.UNIQUE;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.IntoSet;\",\n            \"\",\n            \"@Module\",\n            \"class MultibindingModule {\",\n            \"  @Provides(type \u003d SET) @IntoSet Integer provideInt() { \",\n            \"    return 1;\",\n            \"  }\",\n            \"  @Provides(type \u003d UNIQUE) @IntoSet Integer provideConflictingMultibindingTypes() { \",\n            \"    return 2;\",\n            \"  }\",\n            \"}\");\n\n    assertThat(module)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"@Provides.type cannot be used with multibinding annotations\")\n        .in(module)\n        .onLine(12)\n        .and()\n        .withErrorContaining(\"@Provides.type cannot be used with multibinding annotations\")\n        .in(module)\n        .onLine(15);\n  }\n\n  @Test\n  public void providesWithTwoMultibindingAnnotations_failsToCompile() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.MultibindingModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.IntoSet;\",\n            \"import dagger.multibindings.IntoMap;\",\n            \"\",\n            \"@Module\",\n            \"class MultibindingModule {\",\n            \"  @Provides @IntoSet @IntoMap Integer provideInt() { \",\n            \"    return 1;\",\n            \"  }\",\n            \"}\");\n\n    assertThat(module)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"Multiple multibinding annotations cannot be placed on the same Provides method\")\n        .in(module)\n        .onLine(10);\n  }\n\n  @Test\n  public void producesTypeAndAnnotationOnSameMethod_failsToCompile() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.MultibindingModule\",\n            \"package test;\",\n            \"\",\n            \"import static dagger.producers.Produces.Type.SET;\",\n            \"\",\n            \"import dagger.producers.ProducerModule;\",\n            \"import dagger.producers.Produces;\",\n            \"import dagger.multibindings.IntoSet;\",\n            \"\",\n            \"@ProducerModule\",\n            \"class MultibindingModule {\",\n            \"  @Produces(type \u003d SET) @IntoSet Integer produceInt() { \",\n            \"    return 1;\",\n            \"  }\",\n            \"}\");\n\n    assertThat(module)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"@Produces.type cannot be used with multibinding annotations\")\n        .in(module)\n        .onLine(11);\n  }\n\n  @Test\n  public void appliedOnInvalidMethods_failsToCompile() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.SomeType\",\n            \"package test;\",\n            \"\",\n            \"import java.util.Set;\",\n            \"import java.util.Map;\",\n            \"import dagger.Component;\",\n            \"import dagger.multibindings.IntoSet;\",\n            \"import dagger.multibindings.ElementsIntoSet;\",\n            \"import dagger.multibindings.IntoMap;\",\n            \"\",\n            \"interface SomeType {\",\n            \"  @IntoSet Set\u003cInteger\u003e ints();\",\n            \"  @ElementsIntoSet Set\u003cDouble\u003e doubles();\",\n            \"  @IntoMap Map\u003cInteger, Double\u003e map();\",\n            \"}\");\n\n    assertThat(component)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"Multibinding annotations may only be on @Provides, @Produces, or @Binds methods\")\n        .in(component)\n        .onLine(11)\n        .and()\n        .withErrorContaining(\n            \"Multibinding annotations may only be on @Provides, @Produces, or @Binds methods\")\n        .in(component)\n        .onLine(12)\n        .and()\n        .withErrorContaining(\n            \"Multibinding annotations may only be on @Provides, @Produces, or @Binds methods\")\n        .in(component)\n        .onLine(13);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\MultibindsValidatorTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;\nimport static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatModuleMethod;\n\nimport com.google.common.collect.ImmutableList;\nimport dagger.Module;\nimport dagger.producers.ProducerModule;\nimport java.lang.annotation.Annotation;\nimport java.util.Collection;\nimport javax.inject.Qualifier;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\n\n@RunWith(Parameterized.class)\npublic class MultibindsValidatorTest {\n\n  @Parameters(name \u003d \"{0}\")\n  public static Collection\u003cObject[]\u003e parameters() {\n    return ImmutableList.copyOf(new Object[][] {{Module.class}, {ProducerModule.class}});\n  }\n\n  private final String moduleDeclaration;\n\n  public MultibindsValidatorTest(Class\u003c? extends Annotation\u003e moduleAnnotation) {\n    moduleDeclaration \u003d \"@\" + moduleAnnotation.getCanonicalName() + \" abstract class %s { %s }\";\n  }\n\n  @Test\n  public void notWithinModule() {\n    assertThatMethodInUnannotatedClass(\"@Multibinds abstract Set\u003cObject\u003e emptySet();\")\n        .hasError(\"@Multibinds methods can only be present within a @Module or @ProducerModule\");\n  }\n\n  @Test\n  public void voidMethod() {\n    assertThatModuleMethod(\"@Multibinds abstract void voidMethod();\")\n        .withDeclaration(moduleDeclaration)\n        .hasError(\"@Multibinds methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void primitiveMethod() {\n    assertThatModuleMethod(\"@Multibinds abstract int primitive();\")\n        .withDeclaration(moduleDeclaration)\n        .hasError(\"@Multibinds methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void rawMap() {\n    assertThatModuleMethod(\"@Multibinds abstract Map rawMap();\")\n        .withDeclaration(moduleDeclaration)\n        .hasError(\"@Multibinds methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void wildcardMap() {\n    assertThatModuleMethod(\"@Multibinds abstract Map\u003c?, ?\u003e wildcardMap();\")\n        .withDeclaration(moduleDeclaration)\n        .hasError(\"@Multibinds methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void providerMap() {\n    assertThatModuleMethod(\"@Multibinds abstract Map\u003cString, Provider\u003cObject\u003e\u003e providerMap();\")\n        .withDeclaration(moduleDeclaration)\n        .hasError(\"@Multibinds methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void producerMap() {\n    assertThatModuleMethod(\"@Multibinds abstract Map\u003cString, Producer\u003cObject\u003e\u003e producerMap();\")\n        .withDeclaration(moduleDeclaration)\n        .hasError(\"@Multibinds methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void producedMap() {\n    assertThatModuleMethod(\"@Multibinds abstract Map\u003cString, Produced\u003cObject\u003e\u003e producedMap();\")\n        .withDeclaration(moduleDeclaration)\n        .hasError(\"@Multibinds methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void rawSet() {\n    assertThatModuleMethod(\"@Multibinds abstract Set rawSet();\")\n        .withDeclaration(moduleDeclaration)\n        .hasError(\"@Multibinds methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void wildcardSet() {\n    assertThatModuleMethod(\"@Multibinds abstract Set\u003c?\u003e wildcardSet();\")\n        .withDeclaration(moduleDeclaration)\n        .hasError(\"@Multibinds methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void providerSet() {\n    assertThatModuleMethod(\"@Multibinds abstract Set\u003cProvider\u003cObject\u003e\u003e providerSet();\")\n        .withDeclaration(moduleDeclaration)\n        .hasError(\"@Multibinds methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void producerSet() {\n    assertThatModuleMethod(\"@Multibinds abstract Set\u003cProducer\u003cObject\u003e\u003e producerSet();\")\n        .withDeclaration(moduleDeclaration)\n        .hasError(\"@Multibinds methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void producedSet() {\n    assertThatModuleMethod(\"@Multibinds abstract Set\u003cProduced\u003cObject\u003e\u003e producedSet();\")\n        .withDeclaration(moduleDeclaration)\n        .hasError(\"@Multibinds methods must return Map\u003cK, V\u003e or Set\u003cT\u003e\");\n  }\n\n  @Test\n  public void overqualifiedSet() {\n    assertThatModuleMethod(\n            \"@Multibinds @SomeQualifier @OtherQualifier \"\n                + \"abstract Set\u003cObject\u003e tooManyQualifiersSet();\")\n        .withDeclaration(moduleDeclaration)\n        .importing(SomeQualifier.class, OtherQualifier.class)\n        .hasError(\"Cannot use more than one @Qualifier\");\n  }\n\n  @Test\n  public void overqualifiedMap() {\n    assertThatModuleMethod(\n            \"@Multibinds @SomeQualifier @OtherQualifier \"\n                + \"abstract Map\u003cString, Object\u003e tooManyQualifiersMap();\")\n        .withDeclaration(moduleDeclaration)\n        .importing(SomeQualifier.class, OtherQualifier.class)\n        .hasError(\"Cannot use more than one @Qualifier\");\n  }\n\n  @Test\n  public void hasParameters() {\n    assertThatModuleMethod(\"@Multibinds abstract Set\u003cString\u003e parameters(Object param);\")\n        .hasError(\"@Multibinds methods cannot have parameters\");\n  }\n\n  @Qualifier\n  public @interface SomeQualifier {}\n\n  @Qualifier\n  public @interface OtherQualifier {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\MultipleRequestTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class MultipleRequestTest {\n  private static final JavaFileObject DEP_FILE \u003d JavaFileObjects.forSourceLines(\"test.Dep\",\n      \"package test;\",\n      \"\",\n      \"import javax.inject.Inject;\",\n      \"\",\n      \"class Dep {\",\n      \"  @Inject Dep() {}\",\n      \"}\");\n\n  @Test public void multipleRequests_constructor() {\n    assertAbout(javaSources())\n        .that(\n            ImmutableList.of(\n                DEP_FILE,\n                JavaFileObjects.forSourceLines(\n                    \"test.ConstructorInjectsMultiple\",\n                    \"package test;\",\n                    \"\",\n                    \"import javax.inject.Inject;\",\n                    \"\",\n                    \"class ConstructorInjectsMultiple {\",\n                    \"  @Inject ConstructorInjectsMultiple(Dep d1, Dep d2) {}\",\n                    \"}\"),\n                JavaFileObjects.forSourceLines(\n                    \"test.SimpleComponent\",\n                    \"package test;\",\n                    \"\",\n                    \"import dagger.Component;\",\n                    \"\",\n                    \"@Component\",\n                    \"interface SimpleComponent {\",\n                    \"  ConstructorInjectsMultiple get();\",\n                    \"}\")))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n\n  @Test public void multipleRequests_field() {\n    assertAbout(javaSources())\n        .that(\n            ImmutableList.of(\n                DEP_FILE,\n                JavaFileObjects.forSourceLines(\n                    \"test.FieldInjectsMultiple\",\n                    \"package test;\",\n                    \"\",\n                    \"import javax.inject.Inject;\",\n                    \"\",\n                    \"class FieldInjectsMultiple {\",\n                    \"  @Inject Dep d1;\",\n                    \"  @Inject Dep d2;\",\n                    \"  @Inject FieldInjectsMultiple() {}\",\n                    \"}\"),\n                JavaFileObjects.forSourceLines(\n                    \"test.SimpleComponent\",\n                    \"package test;\",\n                    \"\",\n                    \"import dagger.Component;\",\n                    \"\",\n                    \"@Component\",\n                    \"interface SimpleComponent {\",\n                    \"  FieldInjectsMultiple get();\",\n                    \"}\")))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n\n  @Test public void multipleRequests_providesMethod() {\n    assertAbout(javaSources())\n        .that(\n            ImmutableList.of(\n                DEP_FILE,\n                JavaFileObjects.forSourceLines(\n                    \"test.FieldInjectsMultiple\",\n                    \"package test;\",\n                    \"\",\n                    \"import dagger.Module;\",\n                    \"import dagger.Provides;\",\n                    \"\",\n                    \"@Module\",\n                    \"class SimpleModule {\",\n                    \"  @Provides Object provide(Dep d1, Dep d2) {\",\n                    \"    return null;\",\n                    \"  }\",\n                    \"}\"),\n                JavaFileObjects.forSourceLines(\n                    \"test.SimpleComponent\",\n                    \"package test;\",\n                    \"\",\n                    \"import dagger.Component;\",\n                    \"\",\n                    \"@Component(modules \u003d SimpleModule.class)\",\n                    \"interface SimpleComponent {\",\n                    \"  Object get();\",\n                    \"}\")))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\ProducerModuleFactoryGeneratorTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// TODO(beder): Merge the error-handling tests with the ModuleFactoryGeneratorTest.\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatMethodInUnannotatedClass;\nimport static dagger.internal.codegen.DaggerModuleMethodSubject.Factory.assertThatProductionModuleMethod;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_ABSTRACT;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MULTIPLE_QUALIFIERS;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_MUST_RETURN_A_VALUE;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_NOT_IN_MODULE;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_PRIVATE;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_SET_VALUES_RAW_SET;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_TYPE_PARAMETER;\nimport static dagger.internal.codegen.ErrorMessages.BINDING_METHOD_WITH_SAME_NAME;\nimport static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RAW_FUTURE;\nimport static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_RETURN_TYPE;\nimport static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SCOPE;\nimport static dagger.internal.codegen.ErrorMessages.PRODUCES_METHOD_SET_VALUES_RETURN_SET;\nimport static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.inject.Qualifier;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class ProducerModuleFactoryGeneratorTest {\n\n  private String formatErrorMessage(String msg) {\n    return String.format(msg, \"Produces\");\n  }\n\n  private String formatModuleErrorMessage(String msg) {\n    return String.format(msg, \"Produces\", \"ProducerModule\");\n  }\n\n  @Test public void producesMethodNotInModule() {\n    assertThatMethodInUnannotatedClass(\"@Produces String produceString() { return null; }\")\n        .hasError(formatModuleErrorMessage(BINDING_METHOD_NOT_IN_MODULE));\n  }\n\n  @Test public void producesMethodAbstract() {\n    assertThatProductionModuleMethod(\"@Produces abstract String produceString();\")\n        .hasError(formatErrorMessage(BINDING_METHOD_ABSTRACT));\n  }\n\n  @Test public void producesMethodPrivate() {\n    assertThatProductionModuleMethod(\"@Produces private String produceString() { return null; }\")\n        .hasError(formatErrorMessage(BINDING_METHOD_PRIVATE));\n  }\n\n  @Test public void producesMethodReturnVoid() {\n    assertThatProductionModuleMethod(\"@Produces void produceNothing() {}\")\n        .hasError(formatErrorMessage(BINDING_METHOD_MUST_RETURN_A_VALUE));\n  }\n\n  @Test\n  public void producesProvider() {\n    assertThatProductionModuleMethod(\"@Produces Provider\u003cString\u003e produceProvider() {}\")\n        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));\n  }\n\n  @Test\n  public void producesLazy() {\n    assertThatProductionModuleMethod(\"@Produces Lazy\u003cString\u003e produceLazy() {}\")\n        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));\n  }\n\n  @Test\n  public void producesMembersInjector() {\n    assertThatProductionModuleMethod(\n            \"@Produces MembersInjector\u003cString\u003e produceMembersInjector() {}\")\n        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));\n  }\n\n  @Test\n  public void producesProducer() {\n    assertThatProductionModuleMethod(\"@Produces Producer\u003cString\u003e produceProducer() {}\")\n        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));\n  }\n\n  @Test\n  public void producesProduced() {\n    assertThatProductionModuleMethod(\"@Produces Produced\u003cString\u003e produceProduced() {}\")\n        .hasError(formatErrorMessage(BINDING_METHOD_MUST_NOT_BIND_FRAMEWORK_TYPES));\n  }\n\n  @Test public void producesMethodReturnRawFuture() {\n    assertThatProductionModuleMethod(\"@Produces ListenableFuture produceRaw() {}\")\n        .importing(ListenableFuture.class)\n        .hasError(PRODUCES_METHOD_RAW_FUTURE);\n  }\n\n  @Test public void producesMethodReturnWildcardFuture() {\n    assertThatProductionModuleMethod(\"@Produces ListenableFuture\u003c?\u003e produceRaw() {}\")\n        .importing(ListenableFuture.class)\n        .hasError(PRODUCES_METHOD_RETURN_TYPE);\n  }\n\n  @Test public void producesMethodWithTypeParameter() {\n    assertThatProductionModuleMethod(\"@Produces \u003cT\u003e String produceString() { return null; }\")\n        .hasError(formatErrorMessage(BINDING_METHOD_TYPE_PARAMETER));\n  }\n\n  @Test public void producesMethodSetValuesWildcard() {\n    assertThatProductionModuleMethod(\n            \"@Produces @ElementsIntoSet Set\u003c?\u003e produceWildcard() { return null; }\")\n        .hasError(PRODUCES_METHOD_RETURN_TYPE);\n  }\n\n  @Test public void producesMethodSetValuesRawSet() {\n    assertThatProductionModuleMethod(\n            \"@Produces @ElementsIntoSet Set produceSomething() { return null; }\")\n        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));\n  }\n\n  @Test public void producesMethodSetValuesNotASet() {\n    assertThatProductionModuleMethod(\n            \"@Produces @ElementsIntoSet List\u003cString\u003e produceStrings() { return null; }\")\n        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);\n  }\n\n  @Test public void producesMethodSetValuesWildcardInFuture() {\n    assertThatProductionModuleMethod(\n            \"@Produces @ElementsIntoSet \"\n                + \"ListenableFuture\u003cSet\u003c?\u003e\u003e produceWildcard() { return null; }\")\n        .importing(ListenableFuture.class)\n        .hasError(PRODUCES_METHOD_RETURN_TYPE);\n  }\n\n  @Test public void producesMethodSetValuesFutureRawSet() {\n    assertThatProductionModuleMethod(\n            \"@Produces @ElementsIntoSet ListenableFuture\u003cSet\u003e produceSomething() { return null; }\")\n        .importing(ListenableFuture.class)\n        .hasError(formatErrorMessage(BINDING_METHOD_SET_VALUES_RAW_SET));\n  }\n\n  @Test public void producesMethodSetValuesFutureNotASet() {\n    assertThatProductionModuleMethod(\n            \"@Produces @ElementsIntoSet \"\n                + \"ListenableFuture\u003cList\u003cString\u003e\u003e produceStrings() { return null; }\")\n        .importing(ListenableFuture.class)\n        .hasError(PRODUCES_METHOD_SET_VALUES_RETURN_SET);\n  }\n\n  @Test public void multipleProducesMethodsWithSameName() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.ProducerModule;\",\n        \"import dagger.producers.Produces;\",\n        \"\",\n        \"@ProducerModule\",\n        \"final class TestModule {\",\n        \"  @Produces Object produce(int i) {\",\n        \"    return i;\",\n        \"  }\",\n        \"\",\n        \"  @Produces String produce() {\",\n        \"    return \\\"\\\";\",\n        \"  }\",\n        \"}\");\n    String errorMessage \u003d String.format(BINDING_METHOD_WITH_SAME_NAME, \"Produces\");\n    assertAbout(javaSource()).that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(errorMessage).in(moduleFile).onLine(8)\n        .and().withErrorContaining(errorMessage).in(moduleFile).onLine(12);\n  }\n\n  @Test\n  public void producesMethodThrowsThrowable() {\n    assertThatProductionModuleMethod(\"@Produces int produceInt() throws Throwable { return 0; }\")\n        .hasError(\n            \"@Produces methods may only throw unchecked exceptions or exceptions subclassing \"\n                + \"Exception\");\n  }\n\n  @Test public void producesMethodWithScope() {\n    assertThatProductionModuleMethod(\"@Produces @Singleton String str() { return \\\"\\\"; }\")\n        .hasError(PRODUCES_METHOD_SCOPE);\n  }\n\n  @Test\n  public void privateModule() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.Enclosing\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.ProducerModule;\",\n        \"\",\n        \"final class Enclosing {\",\n        \"  @ProducerModule private static final class PrivateModule {\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource())\n        .that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Modules cannot be private.\")\n        .in(moduleFile).onLine(6);\n  }\n\n  @Test\n  public void enclosedInPrivateModule() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.Enclosing\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.ProducerModule;\",\n        \"\",\n        \"final class Enclosing {\",\n        \"  private static final class PrivateEnclosing {\",\n        \"    @ProducerModule static final class TestModule {\",\n        \"    }\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource())\n        .that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"Modules cannot be enclosed in private types.\")\n        .in(moduleFile).onLine(7);\n  }\n\n  @Test\n  public void includesNonModule() {\n    JavaFileObject xFile \u003d\n        JavaFileObjects.forSourceLines(\"test.X\", \"package test;\", \"\", \"public final class X {}\");\n    JavaFileObject moduleFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.FooModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.producers.ProducerModule;\",\n            \"\",\n            \"@ProducerModule(includes \u003d X.class)\",\n            \"public final class FooModule {\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(xFile, moduleFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(\n                ErrorMessages.REFERENCED_MODULE_NOT_ANNOTATED,\n                \"X\",\n                \"one of @Module, @ProducerModule\"));\n  }\n\n  @Test\n  public void publicModuleNonPublicIncludes() {\n    JavaFileObject publicModuleFile \u003d JavaFileObjects.forSourceLines(\"test.PublicModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.ProducerModule;\",\n        \"\",\n        \"@ProducerModule(includes \u003d {\",\n        \"    NonPublicModule1.class, OtherPublicModule.class, NonPublicModule2.class\",\n        \"})\",\n        \"public final class PublicModule {\",\n        \"}\");\n    JavaFileObject nonPublicModule1File \u003d JavaFileObjects.forSourceLines(\"test.NonPublicModule1\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.ProducerModule;\",\n        \"\",\n        \"@ProducerModule\",\n        \"final class NonPublicModule1 {\",\n        \"}\");\n    JavaFileObject nonPublicModule2File \u003d JavaFileObjects.forSourceLines(\"test.NonPublicModule2\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.ProducerModule;\",\n        \"\",\n        \"@ProducerModule\",\n        \"final class NonPublicModule2 {\",\n        \"}\");\n    JavaFileObject otherPublicModuleFile \u003d JavaFileObjects.forSourceLines(\"test.OtherPublicModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.ProducerModule;\",\n        \"\",\n        \"@ProducerModule\",\n        \"public final class OtherPublicModule {\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(\n            publicModuleFile, nonPublicModule1File, nonPublicModule2File, otherPublicModuleFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"This module is public, but it includes non-public \"\n            + \"(or effectively non-public) modules. \"\n            + \"Either reduce the visibility of this module or make \"\n            + \"test.NonPublicModule1 and test.NonPublicModule2 public.\")\n        .in(publicModuleFile).onLine(8);\n  }\n\n  @Test public void argumentNamedModuleCompiles() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.ProducerModule;\",\n        \"import dagger.producers.Produces;\",\n        \"\",\n        \"@ProducerModule\",\n        \"final class TestModule {\",\n        \"  @Produces String produceString(int module) {\",\n        \"    return null;\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource())\n        .that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n\n  @Test public void singleProducesMethodNoArgsFuture() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import com.google.common.util.concurrent.ListenableFuture;\",\n        \"import dagger.producers.ProducerModule;\",\n        \"import dagger.producers.Produces;\",\n        \"\",\n        \"@ProducerModule\",\n        \"final class TestModule {\",\n        \"  @Produces ListenableFuture\u003cString\u003e produceString() {\",\n        \"    return null;\",\n        \"  }\",\n        \"}\");\n    JavaFileObject factoryFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"TestModule_ProduceStringFactory\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.util.concurrent.AsyncFunction;\",\n            \"import com.google.common.util.concurrent.Futures;\",\n            \"import com.google.common.util.concurrent.ListenableFuture;\",\n            \"import dagger.producers.internal.AbstractProducer;\",\n            \"import dagger.producers.monitoring.ProducerToken;\",\n            \"import dagger.producers.monitoring.ProductionComponentMonitor;\",\n            \"import java.util.concurrent.Executor;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class TestModule_ProduceStringFactory\",\n            \"    extends AbstractProducer\u003cString\u003e implements AsyncFunction\u003cVoid, String\u003e {\",\n            \"  private final TestModule module;\",\n            \"  private final Provider\u003cExecutor\u003e executorProvider;\",\n            \"  private final Provider\u003cProductionComponentMonitor\u003e monitorProvider;\",\n            \"\",\n            \"  public TestModule_ProduceStringFactory(\",\n            \"      TestModule module,\",\n            \"      Provider\u003cExecutor\u003e executorProvider,\",\n            \"      Provider\u003cProductionComponentMonitor\u003e monitorProvider) {\",\n            \"    super(\",\n            \"        monitorProvider,\",\n            \"        ProducerToken.create(TestModule_ProduceStringFactory.class));\",\n            \"    assert module !\u003d null;\",\n            \"    this.module \u003d module;\",\n            \"    assert executorProvider !\u003d null;\",\n            \"    this.executorProvider \u003d executorProvider;\",\n            \"    assert monitorProvider !\u003d null;\",\n            \"    this.monitorProvider \u003d monitorProvider;\",\n            \"  }\",\n            \"\",\n            \"  @Override protected ListenableFuture\u003cString\u003e compute() {\",\n            \"    return Futures.transformAsync(\",\n            \"        Futures.\u003cVoid\u003eimmediateFuture(null), this, executorProvider.get());\",\n            \"  }\",\n            \"\",\n            \"  @Deprecated\",\n            \"  @Override public ListenableFuture\u003cString\u003e apply(Void ignoredVoidArg) {\",\n            \"    assert monitor !\u003d null :\",\n            \"        \\\"apply() may only be called internally from compute(); \\\"\",\n            \"        + \\\"if it\u0027s called explicitly, the monitor might be null\\\";\",\n            \"    monitor.methodStarting();\",\n            \"    try {\",\n            \"      return TestModule_ProduceStringFactory.this.module.produceString();\",\n            \"    } finally {\",\n            \"      monitor.methodFinished();\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSource())\n        .that(moduleFile)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(factoryFile);\n  }\n\n  @Test\n  public void singleProducesMethodNoArgsFutureWithProducerName() {\n    JavaFileObject moduleFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.util.concurrent.Futures;\",\n            \"import com.google.common.util.concurrent.ListenableFuture;\",\n            \"import dagger.producers.ProducerModule;\",\n            \"import dagger.producers.Produces;\",\n            \"\",\n            \"@ProducerModule\",\n            \"final class TestModule {\",\n            \"  @Produces ListenableFuture\u003cString\u003e produceString() {\",\n            \"    return Futures.immediateFuture(\\\"\\\");\",\n            \"  }\",\n            \"}\");\n    JavaFileObject factoryFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"TestModule_ProduceStringFactory\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.util.concurrent.AsyncFunction;\",\n            \"import com.google.common.util.concurrent.Futures;\",\n            \"import com.google.common.util.concurrent.ListenableFuture;\",\n            \"import dagger.producers.internal.AbstractProducer;\",\n            \"import dagger.producers.monitoring.ProducerToken;\",\n            \"import dagger.producers.monitoring.ProductionComponentMonitor;\",\n            \"import java.util.concurrent.Executor;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class TestModule_ProduceStringFactory\",\n            \"    extends AbstractProducer\u003cString\u003e implements AsyncFunction\u003cVoid, String\u003e {\",\n            \"  private final TestModule module;\",\n            \"  private final Provider\u003cExecutor\u003e executorProvider;\",\n            \"  private final Provider\u003cProductionComponentMonitor\u003e monitorProvider;\",\n            \"\",\n            \"  public TestModule_ProduceStringFactory(\",\n            \"      TestModule module,\",\n            \"      Provider\u003cExecutor\u003e executorProvider,\",\n            \"      Provider\u003cProductionComponentMonitor\u003e monitorProvider) {\",\n            \"    super(\",\n            \"        monitorProvider,\",\n            \"        ProducerToken.create(\\\"test.TestModule#produceString\\\"));\",\n            \"    assert module !\u003d null;\",\n            \"    this.module \u003d module;\",\n            \"    assert executorProvider !\u003d null;\",\n            \"    this.executorProvider \u003d executorProvider;\",\n            \"    assert monitorProvider !\u003d null;\",\n            \"    this.monitorProvider \u003d monitorProvider;\",\n            \"  }\",\n            \"\",\n            \"  @Override protected ListenableFuture\u003cString\u003e compute() {\",\n            \"    return Futures.transformAsync(\",\n            \"      Futures.\u003cVoid\u003eimmediateFuture(null), this, executorProvider.get());\",\n            \"  }\",\n            \"\",\n            \"  @Deprecated\",\n            \"  @Override public ListenableFuture\u003cString\u003e apply(Void ignoredVoidArg) {\",\n            \"    assert monitor !\u003d null :\",\n            \"        \\\"apply() may only be called internally from compute(); \\\"\",\n            \"        + \\\"if it\u0027s called explicitly, the monitor might be null\\\";\",\n            \"    monitor.methodStarting();\",\n            \"    try {\",\n            \"      return TestModule_ProduceStringFactory.this.module.produceString();\",\n            \"    } finally {\",\n            \"      monitor.methodFinished();\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSource())\n        .that(moduleFile)\n        .withCompilerOptions(\"-Adagger.writeProducerNameInToken\u003dENABLED\")\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(factoryFile);\n  }\n\n  @Test public void producesMethodMultipleQualifiers() {\n    assertThatProductionModuleMethod(\n            \"@Produces @QualifierA @QualifierB abstract String produceString() { return null; }\")\n        .importing(ListenableFuture.class, QualifierA.class, QualifierB.class)\n        .hasError(BINDING_METHOD_MULTIPLE_QUALIFIERS);\n  }\n  \n  @Qualifier\n  public @interface QualifierA {}\n\n  @Qualifier\n  public @interface QualifierB {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\ProductionComponentProcessorTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class ProductionComponentProcessorTest {\n  @Test public void componentOnConcreteClass() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.NotAComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.ProductionComponent;\",\n        \"\",\n        \"@ProductionComponent\",\n        \"final class NotAComponent {}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"interface\");\n  }\n\n  @Test public void componentOnEnum() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.NotAComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.ProductionComponent;\",\n        \"\",\n        \"@ProductionComponent\",\n        \"enum NotAComponent {\",\n        \"  INSTANCE\",\n        \"}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"interface\");\n  }\n\n  @Test public void componentOnAnnotation() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.NotAComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.ProductionComponent;\",\n        \"\",\n        \"@ProductionComponent\",\n        \"@interface NotAComponent {}\");\n    assertAbout(javaSource()).that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"interface\");\n  }\n\n  @Test public void nonModuleModule() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.NotAComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.ProductionComponent;\",\n        \"\",\n        \"@ProductionComponent(modules \u003d Object.class)\",\n        \"interface NotAComponent {}\");\n    assertAbout(javaSource())\n        .that(componentFile)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"is not annotated with one of @Module, @ProducerModule\");\n  }\n\n  @Test\n  public void dependsOnProductionExecutor() {\n    JavaFileObject moduleFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ExecutorModule\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.util.concurrent.MoreExecutors;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.producers.Production;\",\n            \"import java.util.concurrent.Executor;\",\n            \"\",\n            \"@Module\",\n            \"final class ExecutorModule {\",\n            \"  @Provides @Production Executor executor() {\",\n            \"    return MoreExecutors.directExecutor();\",\n            \"  }\",\n            \"}\");\n    JavaFileObject producerModuleFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.SimpleModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.producers.ProducerModule;\",\n            \"import dagger.producers.Produces;\",\n            \"import dagger.producers.Production;\",\n            \"import java.util.concurrent.Executor;\",\n            \"\",\n            \"@ProducerModule\",\n            \"final class SimpleModule {\",\n            \"  @Produces String str(@Production Executor executor) {\",\n            \"    return \\\"\\\";\",\n            \"  }\",\n            \"}\");\n    JavaFileObject componentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.SimpleComponent\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.util.concurrent.ListenableFuture;\",\n            \"import dagger.producers.ProductionComponent;\",\n            \"import java.util.concurrent.Executor;\",\n            \"\",\n            \"@ProductionComponent(modules \u003d {ExecutorModule.class, SimpleModule.class})\",\n            \"interface SimpleComponent {\",\n            \"  ListenableFuture\u003cString\u003e str();\",\n            \"\",\n            \"  @ProductionComponent.Builder\",\n            \"  interface Builder {\",\n            \"    SimpleComponent build();\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(moduleFile, producerModuleFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"may not depend on the production executor\");\n  }\n\n  @Test\n  public void simpleComponent() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestClass\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.util.concurrent.ListenableFuture;\",\n            \"import com.google.common.util.concurrent.MoreExecutors;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.producers.ProducerModule;\",\n            \"import dagger.producers.Produces;\",\n            \"import dagger.producers.Production;\",\n            \"import dagger.producers.ProductionComponent;\",\n            \"import java.util.concurrent.Executor;\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class TestClass {\",\n            \"  static final class C {\",\n            \"    @Inject C() {}\",\n            \"  }\",\n            \"\",\n            \"  interface A {}\",\n            \"  interface B {}\",\n            \"\",\n            \"  @Module\",\n            \"  static final class BModule {\",\n            \"    @Provides B b(C c) {\",\n            \"      return null;\",\n            \"    }\",\n            \"\",\n            \"    @Provides @Production Executor executor() {\",\n            \"      return MoreExecutors.directExecutor();\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  @ProducerModule\",\n            \"  static final class AModule {\",\n            \"    @Produces ListenableFuture\u003cA\u003e a(B b) {\",\n            \"      return null;\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  @ProductionComponent(modules \u003d {AModule.class, BModule.class})\",\n            \"  interface SimpleComponent {\",\n            \"    ListenableFuture\u003cA\u003e a();\",\n            \"  }\",\n            \"}\");\n    JavaFileObject generatedComponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerTestClass_SimpleComponent\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.util.concurrent.ListenableFuture;\",\n            \"import dagger.internal.DoubleCheck;\",\n            \"import dagger.internal.InstanceFactory;\",\n            \"import dagger.internal.Preconditions;\",\n            \"import dagger.internal.SetFactory;\",\n            \"import dagger.producers.Producer;\",\n            \"import dagger.producers.internal.Producers;\",\n            \"import dagger.producers.monitoring.ProductionComponentMonitor;\",\n            \"import java.util.concurrent.Executor;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerTestClass_SimpleComponent\",\n            \"    implements TestClass.SimpleComponent {\",\n            \"  private Provider\u003cExecutor\u003e executorProvider;\",\n            \"  private Provider\u003cExecutor\u003e executorProvider2;\",\n            \"  private Provider\u003cTestClass.SimpleComponent\u003e simpleComponentProvider;\",\n            \"  private Provider\u003cProductionComponentMonitor\u003e monitorProvider;\",\n            \"  private Provider\u003cTestClass.B\u003e bProvider;\",\n            \"  private Producer\u003cTestClass.A\u003e aProducer;\",\n            \"  private Producer\u003cTestClass.B\u003e bProducer;\",\n            \"\",\n            \"  private DaggerTestClass_SimpleComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static TestClass.SimpleComponent create() {\",\n            \"    return builder().build()\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.executorProvider \u003d\",\n            \"        TestClass_BModule_ExecutorFactory.create(builder.bModule);\",\n            \"     this.executorProvider2 \u003d\",\n            \"         DoubleCheck.provider(\",\n            \"             TestClass_SimpleComponent_ProductionExecutorModule_ExecutorFactory\",\n            \"                 .create(executorProvider));\",\n            \"    this.simpleComponentProvider \u003d\",\n            \"        InstanceFactory.\u003cTestClass.SimpleComponent\u003ecreate(this);\",\n            \"    this.monitorProvider \u003d\",\n            \"        DoubleCheck.provider(\",\n            \"            TestClass_SimpleComponent_MonitoringModule_MonitorFactory.create(\",\n            \"                simpleComponentProvider,\",\n            \"                SetFactory.\u003cProductionComponentMonitor.Factory\u003eempty());\",\n            \"    this.bProvider \u003d TestClass_BModule_BFactory.create(\",\n            \"        builder.bModule, TestClass_C_Factory.create());\",\n            \"    this.bProducer \u003d Producers.producerFromProvider(bProvider);\",\n            \"    this.aProducer \u003d new TestClass_AModule_AFactory(\",\n            \"        builder.aModule,\",\n            \"        executorProvider2,\",\n            \"        monitorProvider,\",\n            \"        bProducer);\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public ListenableFuture\u003cTestClass.A\u003e a() {\",\n            \"    return aProducer.get();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private TestClass.BModule bModule;\",\n            \"    private TestClass.AModule aModule;\",\n            \"\",\n            \"    private Builder() {\",\n            \"    }\",\n            \"\",\n            \"    public TestClass.SimpleComponent build() {\",\n            \"      if (bModule \u003d\u003d null) {\",\n            \"        this.bModule \u003d new TestClass.BModule();\",\n            \"      }\",\n            \"      if (aModule \u003d\u003d null) {\",\n            \"        this.aModule \u003d new TestClass.AModule();\",\n            \"      }\",\n            \"      return new DaggerTestClass_SimpleComponent(this);\",\n            \"    }\",\n            \"\",\n            \"    public Builder aModule(TestClass.AModule aModule) {\",\n            \"      this.aModule \u003d Preconditions.checkNotNull(aModule);\",\n            \"      return this;\",\n            \"    }\",\n            \"\",\n            \"    public Builder bModule(TestClass.BModule bModule) {\",\n            \"      this.bModule \u003d Preconditions.checkNotNull(bModule);\",\n            \"      return this;\",\n            \"    }\",\n            \"\",\n            \"    @Deprecated\",\n            \"    public Builder testClass_SimpleComponent_ProductionExecutorModule(\",\n            \"        TestClass_SimpleComponent_ProductionExecutorModule\",\n            \"        testClass_SimpleComponent_ProductionExecutorModule) {\",\n            \"      Preconditions.checkNotNull(testClass_SimpleComponent_ProductionExecutorModule);\",\n            \"      return this;\",\n            \"    }\",\n            \"}\");\n    assertAbout(javaSource()).that(component)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and().generatesSources(generatedComponent);\n  }\n\n  @Test public void nullableProducersAreNotErrors() {\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.TestClass\",\n        \"package test;\",\n        \"\",\n        \"import com.google.common.util.concurrent.ListenableFuture;\",\n        \"import com.google.common.util.concurrent.MoreExecutors;\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.producers.ProducerModule;\",\n        \"import dagger.producers.Produces;\",\n        \"import dagger.producers.Production;\",\n        \"import dagger.producers.ProductionComponent;\",\n        \"import java.util.concurrent.Executor;\",\n        \"import javax.annotation.Nullable;\",\n        \"import javax.inject.Inject;\",\n        \"\",\n        \"final class TestClass {\",\n        \"  interface A {}\",\n        \"  interface B {}\",\n        \"  interface C {}\",\n        \"\",\n        \"  @Module\",\n        \"  static final class CModule {\",\n        \"    @Provides @Nullable C c() {\",\n        \"      return null;\",\n        \"    }\",\n        \"\",\n        \"    @Provides @Production Executor executor() {\",\n        \"      return MoreExecutors.directExecutor();\",\n        \"    }\",\n        \"  }\",\n        \"\",\n        \"  @ProducerModule\",\n        \"  static final class ABModule {\",\n        \"    @Produces @Nullable B b(@Nullable C c) {\",\n        \"      return null;\",\n        \"    }\",\n\n        \"    @Produces @Nullable ListenableFuture\u003cA\u003e a(B b) {\",  // NOTE: B not injected as nullable\n        \"      return null;\",\n        \"    }\",\n        \"  }\",\n        \"\",\n        \"  @ProductionComponent(modules \u003d {ABModule.class, CModule.class})\",\n        \"  interface SimpleComponent {\",\n        \"    ListenableFuture\u003cA\u003e a();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSource()).that(component)\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .withWarningContaining(\"@Nullable on @Produces methods does not do anything\")\n        .in(component)\n        .onLine(33)\n        .and()\n        .withWarningContaining(\"@Nullable on @Produces methods does not do anything\")\n        .in(component)\n        .onLine(36);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\ProductionGraphValidationTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/**\n * Unit tests for {@link BindingGraphValidator} that exercise producer-specific logic.\n */\n@RunWith(JUnit4.class)\npublic class ProductionGraphValidationTest {\n  private static final JavaFileObject EXECUTOR_MODULE \u003d\n      JavaFileObjects.forSourceLines(\n          \"test.ExecutorModule\",\n          \"package test;\",\n          \"\",\n          \"import com.google.common.util.concurrent.MoreExecutors;\",\n          \"import dagger.Module;\",\n          \"import dagger.Provides;\",\n          \"import dagger.producers.Production;\",\n          \"import java.util.concurrent.Executor;\",\n          \"\",\n          \"@Module\",\n          \"class ExecutorModule {\",\n          \"  @Provides @Production Executor executor() {\",\n          \"    return MoreExecutors.directExecutor();\",\n          \"  }\",\n          \"}\");\n\n  @Test public void componentWithUnprovidedInput() {\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.MyComponent\",\n        \"package test;\",\n        \"\",\n        \"import com.google.common.util.concurrent.ListenableFuture;\",\n        \"import dagger.producers.ProductionComponent;\",\n        \"\",\n        \"@ProductionComponent(modules \u003d {ExecutorModule.class, FooModule.class})\",\n        \"interface MyComponent {\",\n        \"  ListenableFuture\u003cFoo\u003e getFoo();\",\n        \"}\");\n    JavaFileObject module \u003d JavaFileObjects.forSourceLines(\"test.FooModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.producers.ProducerModule;\",\n        \"import dagger.producers.Produces;\",\n        \"\",\n        \"class Foo {}\",\n        \"class Bar {}\",\n        \"\",\n        \"@ProducerModule\",\n        \"class FooModule {\",\n        \"  @Produces Foo foo(Bar bar) {\",\n        \"    return null;\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, module, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"test.Bar cannot be provided without an @Inject constructor or from \"\n            + \"an @Provides- or @Produces-annotated method.\")\n            .in(component).onLine(8);\n  }\n\n  @Test public void componentProductionWithNoDependencyChain() {\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.TestClass\",\n        \"package test;\",\n        \"\",\n        \"import com.google.common.util.concurrent.ListenableFuture;\",\n        \"import dagger.producers.ProductionComponent;\",\n        \"\",\n        \"final class TestClass {\",\n        \"  interface A {}\",\n        \"\",\n        \"  @ProductionComponent(modules \u003d ExecutorModule.class)\",\n        \"  interface AComponent {\",\n        \"    ListenableFuture\u003cA\u003e getA();\",\n        \"  }\",\n        \"}\");\n    String expectedError \u003d\n        \"test.TestClass.A cannot be provided without an @Provides- or @Produces-annotated method.\";\n    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError).in(component).onLine(11);\n  }\n\n  @Test public void provisionDependsOnProduction() {\n    JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.TestClass\",\n        \"package test;\",\n        \"\",\n        \"import com.google.common.util.concurrent.ListenableFuture;\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import dagger.producers.ProducerModule;\",\n        \"import dagger.producers.Produces;\",\n        \"import dagger.producers.ProductionComponent;\",\n        \"\",\n        \"final class TestClass {\",\n        \"  interface A {}\",\n        \"  interface B {}\",\n        \"\",\n        \"  @Module\",\n        \"  final class AModule {\",\n        \"    @Provides A a(B b) {\",\n        \"      return null;\",\n        \"    }\",\n        \"  }\",\n        \"\",\n        \"  @ProducerModule\",\n        \"  final class BModule {\",\n        \"    @Produces ListenableFuture\u003cB\u003e b() {\",\n        \"      return null;\",\n        \"    }\",\n        \"  }\",\n        \"\",\n        \"  @ProductionComponent(modules \u003d {ExecutorModule.class, AModule.class, BModule.class})\",\n        \"  interface AComponent {\",\n        \"    ListenableFuture\u003cA\u003e getA();\",\n        \"  }\",\n        \"}\");\n    String expectedError \u003d\n        \"test.TestClass.A is a provision, which cannot depend on a production.\";\n    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError).in(component).onLine(30);\n  }\n\n  @Test public void provisionEntryPointDependsOnProduction() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestClass\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.util.concurrent.ListenableFuture;\",\n            \"import dagger.producers.ProducerModule;\",\n            \"import dagger.producers.Produces;\",\n            \"import dagger.producers.ProductionComponent;\",\n            \"\",\n            \"final class TestClass {\",\n            \"  interface A {}\",\n            \"\",\n            \"  @ProducerModule\",\n            \"  static final class AModule {\",\n            \"    @Produces ListenableFuture\u003cA\u003e a() {\",\n            \"      return null;\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  @ProductionComponent(modules \u003d {ExecutorModule.class, AModule.class})\",\n            \"  interface AComponent {\",\n            \"    A getA();\",\n            \"  }\",\n            \"}\");\n    String expectedError \u003d\n        \"test.TestClass.A is a provision entry-point, which cannot depend on a production.\";\n    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError).in(component).onLine(20);\n  }\n\n  @Test\n  public void providingMultibindingWithProductions() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestClass\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.util.concurrent.ListenableFuture;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.IntoMap;\",\n            \"import dagger.multibindings.StringKey;\",\n            \"import dagger.producers.ProducerModule;\",\n            \"import dagger.producers.Produces;\",\n            \"import dagger.producers.ProductionComponent;\",\n            \"import java.util.Map;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            \"final class TestClass {\",\n            \"  interface A {}\",\n            \"  interface B {}\",\n            \"\",\n            \"  @Module\",\n            \"  static final class AModule {\",\n            \"    @Provides static A a(Map\u003cString, Provider\u003cObject\u003e\u003e map) {\",\n            \"      return null;\",\n            \"    }\",\n            \"\",\n            \"    @Provides @IntoMap @StringKey(\\\"a\\\") static Object aEntry() {\",\n            \"      return \\\"a\\\";\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  @ProducerModule\",\n            \"  static final class BModule {\",\n            \"    @Produces static B b(A a) {\",\n            \"      return null;\",\n            \"    }\",\n            \"\",\n            \"    @Produces @IntoMap @StringKey(\\\"b\\\") static Object bEntry() {\",\n            \"      return \\\"b\\\";\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  @ProductionComponent(\",\n            \"      modules \u003d {ExecutorModule.class, AModule.class, BModule.class})\",\n            \"  interface AComponent {\",\n            \"    ListenableFuture\u003cB\u003e b();\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(EXECUTOR_MODULE, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"test.TestClass.A is a provision, which cannot depend on a production\")\n        .in(component)\n        .onLine(43);\n  }\n\n  @Test\n  public void monitoringDependsOnUnboundType() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestClass\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.util.concurrent.ListenableFuture;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.IntoSet;\",\n            \"import dagger.producers.ProducerModule;\",\n            \"import dagger.producers.Produces;\",\n            \"import dagger.producers.ProductionComponent;\",\n            \"import dagger.producers.monitoring.ProductionComponentMonitor;\",\n            \"\",\n            \"final class TestClass {\",\n            \"  interface A {}\",\n            \"\",\n            \"  @Module\",\n            \"  final class MonitoringModule {\",\n            \"    @Provides @IntoSet\",\n            \"    ProductionComponentMonitor.Factory monitorFactory(A unbound) {\",\n            \"      return null;\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  @ProducerModule\",\n            \"  final class StringModule {\",\n            \"    @Produces ListenableFuture\u003cString\u003e str() {\",\n            \"      return null;\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  @ProductionComponent(\",\n            \"    modules \u003d {ExecutorModule.class, MonitoringModule.class, StringModule.class}\",\n            \"  )\",\n            \"  interface StringComponent {\",\n            \"    ListenableFuture\u003cString\u003e getString();\",\n            \"  }\",\n            \"}\");\n    String expectedError \u003d\n        \"test.TestClass.A cannot be provided without an @Provides-annotated method.\";\n    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError)\n        .in(component)\n        .onLine(34);\n  }\n\n  @Test\n  public void monitoringDependsOnProduction() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestClass\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.util.concurrent.ListenableFuture;\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"import dagger.multibindings.IntoSet;\",\n            \"import dagger.producers.ProducerModule;\",\n            \"import dagger.producers.Produces;\",\n            \"import dagger.producers.ProductionComponent;\",\n            \"import dagger.producers.monitoring.ProductionComponentMonitor;\",\n            \"\",\n            \"final class TestClass {\",\n            \"  interface A {}\",\n            \"\",\n            \"  @Module\",\n            \"  final class MonitoringModule {\",\n            \"    @Provides @IntoSet ProductionComponentMonitor.Factory monitorFactory(A a) {\",\n            \"      return null;\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  @ProducerModule\",\n            \"  final class StringModule {\",\n            \"    @Produces A a() {\",\n            \"      return null;\",\n            \"    }\",\n            \"\",\n            \"    @Produces ListenableFuture\u003cString\u003e str() {\",\n            \"      return null;\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  @ProductionComponent(\",\n            \"    modules \u003d {ExecutorModule.class, MonitoringModule.class, StringModule.class}\",\n            \"  )\",\n            \"  interface StringComponent {\",\n            \"    ListenableFuture\u003cString\u003e getString();\",\n            \"  }\",\n            \"}\");\n    String expectedError \u003d\n        \"java.util.Set\u003cdagger.producers.monitoring.ProductionComponentMonitor.Factory\u003e\"\n            + \" test.TestClass.MonitoringModule#monitorFactory is a provision,\"\n            + \" which cannot depend on a production.\";\n    assertAbout(javaSources()).that(ImmutableList.of(EXECUTOR_MODULE, component))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(expectedError)\n        .in(component)\n        .onLine(37);\n  }\n\n  @Test\n  public void cycleNotBrokenByMap() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.util.concurrent.ListenableFuture;\",\n            \"import dagger.producers.ProductionComponent;\",\n            \"\",\n            \"@ProductionComponent(modules \u003d {ExecutorModule.class, TestModule.class})\",\n            \"interface TestComponent {\",\n            \"  ListenableFuture\u003cString\u003e string();\",\n            \"}\");\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.producers.ProducerModule;\",\n            \"import dagger.producers.Produces;\",\n            \"import dagger.multibindings.IntoMap;\",\n            \"import dagger.multibindings.StringKey;\",\n            \"import java.util.Map;\",\n            \"\",\n            \"@ProducerModule\",\n            \"final class TestModule {\",\n            \"  @Produces static String string(Map\u003cString, String\u003e map) {\",\n            \"    return \\\"string\\\";\",\n            \"  }\",\n            \"\",\n            \"  @Produces @IntoMap @StringKey(\\\"key\\\")\",\n            \"  static String entry(String string) {\",\n            \"    return string;\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(EXECUTOR_MODULE, component, module))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"cycle\")\n        .in(component)\n        .onLine(8);\n  }\n\n  @Test\n  public void cycleNotBrokenByProducerMap() {\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import com.google.common.util.concurrent.ListenableFuture;\",\n            \"import dagger.producers.ProductionComponent;\",\n            \"\",\n            \"@ProductionComponent(modules \u003d {ExecutorModule.class, TestModule.class})\",\n            \"interface TestComponent {\",\n            \"  ListenableFuture\u003cString\u003e string();\",\n            \"}\");\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.producers.Producer;\",\n            \"import dagger.producers.ProducerModule;\",\n            \"import dagger.producers.Produces;\",\n            \"import dagger.multibindings.StringKey;\",\n            \"import dagger.multibindings.IntoMap;\",\n            \"import java.util.Map;\",\n            \"\",\n            \"@ProducerModule\",\n            \"final class TestModule {\",\n            \"  @Produces static String string(Map\u003cString, Producer\u003cString\u003e\u003e map) {\",\n            \"    return \\\"string\\\";\",\n            \"  }\",\n            \"\",\n            \"  @Produces @IntoMap @StringKey(\\\"key\\\")\",\n            \"  static String entry(String string) {\",\n            \"    return string;\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(EXECUTOR_MODULE, component, module))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"cycle\")\n        .in(component)\n        .onLine(8);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\RepeatedModuleValidationTest.java",
    "code": "\"package dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class RepeatedModuleValidationTest {\n  private static final JavaFileObject MODULE_FILE \u003d\n      JavaFileObjects.forSourceLines(\n          \"test.TestModule\",\n          \"package test;\",\n          \"\",\n          \"import dagger.Module;\",\n          \"\",\n          \"@Module\",\n          \"final class TestModule {}\");\n\n  @Test\n  public void moduleRepeatedInSubcomponentFactoryMethod() {\n    JavaFileObject subcomponentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestSubcomponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent(modules \u003d TestModule.class)\",\n            \"interface TestSubcomponent {\",\n            \"}\");\n    JavaFileObject componentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d TestModule.class)\",\n            \"interface TestComponent {\",\n            \"  TestSubcomponent newTestSubcomponent(TestModule module);\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"TestModule is present in test.TestComponent.\")\n        .in(componentFile)\n        .onLine(7)\n        .atColumn(51);\n  }\n\n  @Test\n  public void moduleRepeatedInSubcomponentBuilderMethod() {\n    JavaFileObject subcomponentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestSubcomponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent(modules \u003d TestModule.class)\",\n            \"interface TestSubcomponent {\",\n            \"  @Subcomponent.Builder\",\n            \"  interface Builder {\",\n            \"    Builder testModule(TestModule testModule);\",\n            \"    TestSubcomponent build();\",\n            \"  }\",\n            \"}\");\n    JavaFileObject componentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d TestModule.class)\",\n            \"interface TestComponent {\",\n            \"  TestSubcomponent.Builder newTestSubcomponentBuilder();\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n    // TODO(gak): assert about the warning when we have that ability\n  }\n\n  @Test\n  public void moduleRepeatedButNotPassed() {\n    JavaFileObject subcomponentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestSubcomponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent(modules \u003d TestModule.class)\",\n            \"interface TestSubcomponent {\",\n            \"}\");\n    JavaFileObject componentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d TestModule.class)\",\n            \"interface TestComponent {\",\n            \"  TestSubcomponent newTestSubcomponent();\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(MODULE_FILE, subcomponentFile, componentFile))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\SubcomponentBuilderValidationTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/** Tests for {@link dagger.Subcomponent.Builder} validation. */\n@RunWith(JUnit4.class)\npublic class SubcomponentBuilderValidationTest {\n\n  private static final ErrorMessages.SubcomponentBuilderMessages MSGS \u003d\n      new ErrorMessages.SubcomponentBuilderMessages();\n\n  @Test\n  public void testRefSubcomponentAndSubBuilderFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.ParentComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface ParentComponent {\",\n        \"  ChildComponent child();\",\n        \"  ChildComponent.Builder builder();\",\n        \"}\");\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"interface ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  static interface Builder {\",\n        \"    ChildComponent build();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),\n            \"test.ChildComponent\", \"[child(), builder()]\"))\n        .in(componentFile);\n  }\n\n  @Test\n  public void testRefSubBuilderTwiceFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.ParentComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface ParentComponent {\",\n        \"  ChildComponent.Builder builder1();\",\n        \"  ChildComponent.Builder builder2();\",\n        \"}\");\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"interface ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  static interface Builder {\",\n        \"    ChildComponent build();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(String.format(MSGS.moreThanOneRefToSubcomponent(),\n            \"test.ChildComponent\", \"[builder1(), builder2()]\"))\n        .in(componentFile);\n  }\n\n  @Test\n  public void testMoreThanOneBuilderFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.ParentComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface ParentComponent {\",\n        \"  ChildComponent.Builder1 build();\",\n        \"}\");\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"interface ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  static interface Builder1 {\",\n        \"    ChildComponent build();\",\n        \"  }\",\n        \"\",\n        \"  @Subcomponent.Builder\",\n        \"  static interface Builder2 {\",\n        \"    ChildComponent build();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(String.format(MSGS.moreThanOne(),\n            \"[test.ChildComponent.Builder1, test.ChildComponent.Builder2]\"))\n        .in(childComponentFile);\n  }\n\n  @Test\n  public void testBuilderGenericsFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.ParentComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface ParentComponent {\",\n        \"  ChildComponent.Builder1 build();\",\n        \"}\");\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"interface ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder\u003cT\u003e {\",\n        \"     ChildComponent build();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.generics())\n        .in(childComponentFile);\n  }\n\n  @Test\n  public void testBuilderNotInComponentFails() {\n    JavaFileObject builder \u003d JavaFileObjects.forSourceLines(\"test.Builder\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent.Builder\",\n        \"interface Builder {}\");\n    assertAbout(javaSource()).that(builder)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.mustBeInComponent())\n        .in(builder);\n  }\n\n  @Test\n  public void testBuilderMissingBuildMethodFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.ParentComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface ParentComponent {\",\n        \"  ChildComponent.Builder1 build();\",\n        \"}\");\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"interface ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.missingBuildMethod())\n        .in(childComponentFile);\n  }\n\n  @Test\n  public void testPrivateBuilderFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  private interface Builder {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.isPrivate())\n        .in(childComponentFile);\n  }\n\n  @Test\n  public void testNonStaticBuilderFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  abstract class Builder {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.mustBeStatic())\n        .in(childComponentFile);\n  }\n\n  @Test\n  public void testNonAbstractBuilderFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  static class Builder {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.mustBeAbstract())\n        .in(childComponentFile);\n  }\n\n  @Test\n  public void testBuilderOneCxtorWithArgsFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  static abstract class Builder {\",\n        \"    Builder(String unused) {}\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())\n        .in(childComponentFile);\n  }\n\n  @Test\n  public void testBuilderMoreThanOneCxtorFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  static abstract class Builder {\",\n        \"    Builder() {}\",\n        \"    Builder(String unused) {}\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.cxtorOnlyOneAndNoArgs())\n        .in(childComponentFile);\n  }\n\n  @Test\n  public void testBuilderEnumFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  enum Builder {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.mustBeClassOrInterface())\n        .in(childComponentFile);\n  }\n\n  @Test\n  public void testBuilderBuildReturnsWrongTypeFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder {\",\n        \"    String build();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.buildMustReturnComponentType())\n            .in(childComponentFile).onLine(9);\n  }\n\n  @Test\n  public void testInheritedBuilderBuildReturnsWrongTypeFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  interface Parent {\",\n        \"    String build();\",\n        \"  }\",\n        \"\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder extends Parent {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.inheritedBuildMustReturnComponentType(), \"build\"))\n            .in(childComponentFile).onLine(12);\n  }\n\n  @Test\n  public void testTwoBuildMethodsFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder {\",\n        \"    ChildComponent build();\",\n        \"    ChildComponent create();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(String.format(MSGS.twoBuildMethods(), \"build()\"))\n            .in(childComponentFile).onLine(10);\n  }\n\n  @Test\n  public void testInheritedTwoBuildMethodsFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  interface Parent {\",\n        \"    ChildComponent build();\",\n        \"    ChildComponent create();\",\n        \"  }\",\n        \"\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder extends Parent {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.inheritedTwoBuildMethods(), \"create()\", \"build()\"))\n            .in(childComponentFile).onLine(13);\n  }\n\n  @Test\n  public void testMoreThanOneArgFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder {\",\n        \"    ChildComponent build();\",\n        \"    Builder set(String s, Integer i);\",\n        \"    Builder set(Number n, Double d);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.methodsMustTakeOneArg())\n            .in(childComponentFile).onLine(10)\n        .and().withErrorContaining(MSGS.methodsMustTakeOneArg())\n            .in(childComponentFile).onLine(11);\n  }\n\n  @Test\n  public void testInheritedMoreThanOneArgFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  interface Parent {\",\n        \"    ChildComponent build();\",\n        \"    Builder set1(String s, Integer i);\",\n        \"  }\",\n        \"\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder extends Parent {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.inheritedMethodsMustTakeOneArg(),\n                \"set1(java.lang.String,java.lang.Integer)\"))\n            .in(childComponentFile).onLine(13);\n  }\n\n  @Test\n  public void testSetterReturningNonVoidOrBuilderFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder {\",\n        \"    ChildComponent build();\",\n        \"    String set(Integer i);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.methodsMustReturnVoidOrBuilder())\n            .in(childComponentFile).onLine(10);\n  }\n\n  @Test\n  public void testInheritedSetterReturningNonVoidOrBuilderFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  interface Parent {\",\n        \"    ChildComponent build();\",\n        \"    String set(Integer i);\",\n        \"  }\",\n        \"\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder extends Parent {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.inheritedMethodsMustReturnVoidOrBuilder(),\n                \"set(java.lang.Integer)\"))\n            .in(childComponentFile).onLine(13);\n  }\n\n  @Test\n  public void testGenericsOnSetterMethodFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder {\",\n        \"    ChildComponent build();\",\n        \"    \u003cT\u003e Builder set(T t);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(MSGS.methodsMayNotHaveTypeParameters())\n            .in(childComponentFile).onLine(10);\n  }\n\n  @Test\n  public void testGenericsOnInheritedSetterMethodFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  interface Parent {\",\n        \"    ChildComponent build();\",\n        \"    \u003cT\u003e Builder set(T t);\",\n        \"  }\",\n        \"\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder extends Parent {}\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.inheritedMethodsMayNotHaveTypeParameters(), \"\u003cT\u003eset(T)\"))\n            .in(childComponentFile).onLine(13);\n  }\n\n  @Test\n  public void testMultipleSettersPerTypeFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder {\",\n        \"    ChildComponent build();\",\n        \"    void set1(String s);\",\n        \"    void set2(String s);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.manyMethodsForType(),\n                  \"java.lang.String\", \"[set1(java.lang.String), set2(java.lang.String)]\"))\n            .in(childComponentFile).onLine(8);\n  }\n\n  @Test\n  public void testMultipleSettersPerTypeIncludingResolvedGenericsFails() {\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"abstract class ChildComponent {\",\n        \"  interface Parent\u003cT\u003e {\",\n        \"    void set1(T t);\",\n        \"  }\",\n        \"\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder extends Parent\u003cString\u003e {\",\n        \"    ChildComponent build();\",\n        \"    void set2(String s);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.manyMethodsForType(),\n                  \"java.lang.String\", \"[set1(T), set2(java.lang.String)]\"))\n            .in(childComponentFile).onLine(12);\n  }\n\n  @Test\n  public void testExtraSettersFails() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.ParentComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface ParentComponent {\",\n        \"  ChildComponent.Builder build();\",\n        \"}\");\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"interface ChildComponent {\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder {\",\n        \"    ChildComponent build();\",\n        \"    void set1(String s);\",\n        \"    void set2(Integer s);\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            String.format(MSGS.extraSetters(),\n                  \"[void test.ChildComponent.Builder.set1(String),\"\n                  + \" void test.ChildComponent.Builder.set2(Integer)]\"))\n            .in(childComponentFile).onLine(8);\n  }\n\n  @Test\n  public void testMissingSettersFail() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  TestModule(String unused) {}\",\n        \"  @Provides String s() { return null; }\",\n        \"}\");\n    JavaFileObject module2File \u003d JavaFileObjects.forSourceLines(\"test.Test2Module\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class Test2Module {\",\n        \"  @Provides Integer i() { return null; }\",\n        \"}\");\n    JavaFileObject module3File \u003d JavaFileObjects.forSourceLines(\"test.Test3Module\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class Test3Module {\",\n        \"  Test3Module(String unused) {}\",\n        \"  @Provides Double d() { return null; }\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.ParentComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Provider;\",\n        \"\",\n        \"@Component\",\n        \"interface ParentComponent {\",\n        \"  ChildComponent.Builder build();\",\n        \"}\");\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent(modules \u003d {TestModule.class, Test2Module.class, Test3Module.class})\",\n        \"interface ChildComponent {\",\n        \"  String string();\",\n        \"  Integer integer();\",\n        \"\",\n        \"  @Subcomponent.Builder\",\n        \"  interface Builder {\",\n        \"    ChildComponent create();\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources())\n        .that(ImmutableList.of(moduleFile,\n            module2File,\n            module3File,\n            componentFile,\n            childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            // Ignores Test2Module because we can construct it ourselves.\n            // TODO(sameb): Ignore Test3Module because it\u0027s not used within transitive dependencies.\n            String.format(MSGS.missingSetters(), \"[test.TestModule, test.Test3Module]\"))\n            .in(childComponentFile).onLine(11);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\SubcomponentValidationTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourcesSubject.assertThat;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.testing.compile.JavaFileObjects;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic final class SubcomponentValidationTest {\n  @Test public void factoryMethod_missingModulesWithParameters() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface TestComponent {\",\n        \"  ChildComponent newChildComponent();\",\n        \"}\");\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent(modules \u003d ModuleWithParameters.class)\",\n        \"interface ChildComponent {\",\n        \"  Object object();\",\n        \"}\");\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.ModuleWithParameters\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class ModuleWithParameters {\",\n        \"  private final Object object;\",\n        \"\",\n        \"  ModuleWithParameters(Object object) {\",\n        \"    this.object \u003d object;\",\n        \"  }\",\n        \"\",\n        \"  @Provides Object object() {\",\n        \"    return object;\",\n        \"  }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile, moduleFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"test.ChildComponent requires modules which have no visible default constructors. \"\n                + \"Add the following modules as parameters to this method: \"\n                + \"test.ModuleWithParameters\")\n        .in(componentFile).onLine(7);\n  }\n\n  @Test public void factoryMethod_nonModuleParameter() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface TestComponent {\",\n        \"  ChildComponent newChildComponent(String someRandomString);\",\n        \"}\");\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"interface ChildComponent {}\");\n    assertAbout(javaSources()).that(ImmutableList.of(componentFile, childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"Subcomponent factory methods may only accept modules, but java.lang.String is not.\")\n        .in(componentFile).onLine(7).atColumn(43);\n  }\n\n  @Test public void factoryMethod_duplicateParameter() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface TestComponent {\",\n        \"  ChildComponent newChildComponent(TestModule testModule1, TestModule testModule2);\",\n        \"}\");\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent(modules \u003d TestModule.class)\",\n        \"interface ChildComponent {}\");\n    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"A module may only occur once an an argument in a Subcomponent factory method, \"\n                + \"but test.TestModule was already passed.\")\n        .in(componentFile).onLine(7).atColumn(71);\n  }\n\n  @Test public void factoryMethod_superflouousModule() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface TestComponent {\",\n        \"  ChildComponent newChildComponent(TestModule testModule);\",\n        \"}\");\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"interface ChildComponent {}\");\n    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))\n    .processedWith(new ComponentProcessor())\n    .failsToCompile()\n    .withErrorContaining(\n        \"test.TestModule is present as an argument to the test.ChildComponent factory method, but \"\n            + \"is not one of the modules used to implement the subcomponent.\")\n                .in(componentFile).onLine(7);\n  }\n\n  @Test public void missingBinding() {\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.TestModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"\",\n        \"@Module\",\n        \"final class TestModule {\",\n        \"  @Provides String provideString(int i) {\",\n        \"    return Integer.toString(i);\",\n        \"  }\",\n        \"}\");\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.TestComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"\",\n        \"@Component\",\n        \"interface TestComponent {\",\n        \"  ChildComponent newChildComponent();\",\n        \"}\");\n    JavaFileObject childComponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent(modules \u003d TestModule.class)\",\n        \"interface ChildComponent {\",\n        \"  String getString();\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(moduleFile, componentFile, childComponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\n            \"java.lang.Integer cannot be provided without an @Inject constructor or from an \"\n                + \"@Provides-annotated method\");\n  }\n\n  @Test public void subcomponentOnConcreteType() {\n    JavaFileObject subcomponentFile \u003d JavaFileObjects.forSourceLines(\"test.NotASubcomponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent\",\n        \"final class NotASubcomponent {}\");\n    assertAbout(javaSources()).that(ImmutableList.of(subcomponentFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"interface\");\n  }\n\n  @Test public void scopeMismatch() {\n    JavaFileObject componentFile \u003d JavaFileObjects.forSourceLines(\"test.ParentComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Component;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Component\",\n        \"@Singleton\",\n        \"interface ParentComponent {\",\n        \"  ChildComponent childComponent();\",\n        \"}\");\n    JavaFileObject subcomponentFile \u003d JavaFileObjects.forSourceLines(\"test.ChildComponent\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Subcomponent;\",\n        \"\",\n        \"@Subcomponent(modules \u003d ChildModule.class)\",\n        \"interface ChildComponent {\",\n        \"  Object getObject();\",\n        \"}\");\n    JavaFileObject moduleFile \u003d JavaFileObjects.forSourceLines(\"test.ChildModule\",\n        \"package test;\",\n        \"\",\n        \"import dagger.Module;\",\n        \"import dagger.Provides;\",\n        \"import javax.inject.Singleton;\",\n        \"\",\n        \"@Module\",\n        \"final class ChildModule {\",\n        \"  @Provides @Singleton Object provideObject() { return null; }\",\n        \"}\");\n    assertAbout(javaSources()).that(ImmutableList.of(componentFile, subcomponentFile, moduleFile))\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"@Singleton\");\n  }\n\n  @Test\n  public void delegateFactoryNotCreatedForSubcomponentWhenProviderExistsInParent() {\n    JavaFileObject parentComponentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component\",\n            \"interface ParentComponent {\",\n            \"  ChildComponent childComponent();\",\n            \"  Dep1 getDep1();\",\n            \"  Dep2 getDep2();\",\n            \"}\");\n    JavaFileObject childComponentFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ChildComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent(modules \u003d ChildModule.class)\",\n            \"interface ChildComponent {\",\n            \"  Object getObject();\",\n            \"}\");\n    JavaFileObject childModuleFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ChildModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"\",\n            \"@Module\",\n            \"final class ChildModule {\",\n            \"  @Provides Object provideObject(A a) { return null; }\",\n            \"}\");\n    JavaFileObject aFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.A\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class A {\",\n            \"  @Inject public A(NeedsDep1 a, Dep1 b, Dep2 c) { }\",\n            \"  @Inject public void methodA() { }\",\n            \"}\");\n    JavaFileObject needsDep1File \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.NeedsDep1\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class NeedsDep1 {\",\n            \"  @Inject public NeedsDep1(Dep1 d) { }\",\n            \"}\");\n    JavaFileObject dep1File \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Dep1\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class Dep1 {\",\n            \"  @Inject public Dep1() { }\",\n            \"  @Inject public void dep1Method() { }\",\n            \"}\");\n    JavaFileObject dep2File \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Dep2\",\n            \"package test;\",\n            \"\",\n            \"import javax.inject.Inject;\",\n            \"\",\n            \"final class Dep2 {\",\n            \"  @Inject public Dep2() { }\",\n            \"  @Inject public void dep2Method() { }\",\n            \"}\");\n\n    JavaFileObject componentGeneratedFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerParentComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.MembersInjector;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerParentComponent implements ParentComponent {\",\n            \"  private MembersInjector\u003cDep1\u003e dep1MembersInjector;\",\n            \"  private Provider\u003cDep1\u003e dep1Provider;\",\n            \"  private MembersInjector\u003cDep2\u003e dep2MembersInjector;\",\n            \"  private Provider\u003cDep2\u003e dep2Provider;\",\n            \"\",\n            \"  private DaggerParentComponent(Builder builder) {  \",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {  \",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static ParentComponent create() {  \",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {  \",\n            \"    this.dep1MembersInjector \u003d Dep1_MembersInjector.create();\",\n            \"    this.dep1Provider \u003d Dep1_Factory.create(dep1MembersInjector);\",\n            \"    this.dep2MembersInjector \u003d Dep2_MembersInjector.create();\",\n            \"    this.dep2Provider \u003d Dep2_Factory.create(dep2MembersInjector);\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Dep1 getDep1() {  \",\n            \"    return dep1Provider.get();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Dep2 getDep2() {  \",\n            \"    return dep2Provider.get();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public ChildComponent childComponent() {  \",\n            \"    return new ChildComponentImpl();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {  \",\n            \"    }\",\n            \"  \",\n            \"    public ParentComponent build() {  \",\n            \"      return new DaggerParentComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  private final class ChildComponentImpl implements ChildComponent {\",\n            \"    private final ChildModule childModule;\",\n            \"    private MembersInjector\u003cA\u003e aMembersInjector;\",\n            \"    private Provider\u003cNeedsDep1\u003e needsDep1Provider;\",\n            \"    private Provider\u003cA\u003e aProvider;\",\n            \"    private Provider\u003cObject\u003e provideObjectProvider;\",\n            \"  \",\n            \"    private ChildComponentImpl() {  \",\n            \"      this.childModule \u003d new ChildModule();\",\n            \"      initialize();\",\n            \"    }\",\n            \"\",\n            \"    @SuppressWarnings(\\\"unchecked\\\")\",\n            \"    private void initialize() {  \",\n            \"      this.aMembersInjector \u003d A_MembersInjector.create();\",\n            \"      this.needsDep1Provider \u003d NeedsDep1_Factory.create(\",\n            \"          DaggerParentComponent.this.dep1Provider);\",\n            \"      this.aProvider \u003d A_Factory.create(\",\n            \"          aMembersInjector,\",\n            \"          needsDep1Provider,\",\n            \"          DaggerParentComponent.this.dep1Provider,\",\n            \"          DaggerParentComponent.this.dep2Provider);\",\n            \"      this.provideObjectProvider \u003d ChildModule_ProvideObjectFactory.create(\",\n            \"          childModule, aProvider);\",\n            \"    }\",\n            \"  \",\n            \"    @Override\",\n            \"    public Object getObject() {  \",\n            \"      return provideObjectProvider.get();\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    assertAbout(javaSources())\n        .that(\n            ImmutableList.of(\n                parentComponentFile,\n                childComponentFile,\n                childModuleFile,\n                aFile,\n                needsDep1File,\n                dep1File,\n                dep2File))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(componentGeneratedFile);\n  }\n\n  @Test\n  public void multipleSubcomponentsWithSameSimpleNamesCanExistInSameComponent() {\n    JavaFileObject parent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component\",\n            \"interface ParentComponent {\",\n            \"  Foo.Sub newFooSubcomponent();\",\n            \"  NoConflict newNoConflictSubcomponent();\",\n            \"}\");\n    JavaFileObject foo \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Foo\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"interface Foo {\",\n            \"  @Subcomponent interface Sub {\",\n            \"    Bar.Sub newBarSubcomponent();\",\n            \"  }\",\n            \"}\");\n    JavaFileObject bar \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Bar\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"interface Bar {\",\n            \"  @Subcomponent interface Sub {\",\n            \"    test.subpackage.Sub newSubcomponentInSubpackage();\",\n            \"  }\",\n            \"}\");\n    JavaFileObject baz \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.subpackage.Sub\",\n            \"package test.subpackage;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent public interface Sub {}\");\n    JavaFileObject noConflict \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.NoConflict\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent interface NoConflict {}\");\n\n    JavaFileObject componentGeneratedFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerParentComponent\",\n            \"package test;\",\n            \"\",\n            \"import javax.annotation.Generated;\",\n            \"import test.subpackage.Sub;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerParentComponent implements ParentComponent {\",\n            \"  private DaggerParentComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static ParentComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Foo.Sub newFooSubcomponent() {\",\n            \"    return new Foo_SubImpl();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public NoConflict newNoConflictSubcomponent() {\",\n            \"    return new NoConflictImpl();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {}\",\n            \"\",\n            \"    public ParentComponent build() {\",\n            \"      return new DaggerParentComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  private final class Foo_SubImpl implements Foo.Sub {\",\n            \"\",\n            \"    private Foo_SubImpl() {}\",\n            \"\",\n            \"    @Override\",\n            \"    public Bar.Sub newBarSubcomponent() {\",\n            \"      return new Bar_SubImpl();\",\n            \"    }\",\n            \"\",\n            \"    private final class Bar_SubImpl implements Bar.Sub {\",\n            \"\",\n            \"      private Bar_SubImpl() {}\",\n            \"\",\n            \"      @Override\",\n            \"      public Sub newSubcomponentInSubpackage() {\",\n            \"        return new subpackage_SubImpl();\",\n            \"      }\",\n            \"\",\n            \"      private final class subpackage_SubImpl implements Sub {\",\n            \"        private subpackage_SubImpl() {}\",\n            \"      }\",\n            \"    }\",\n            \"  }\",\n            \"  private final class NoConflictImpl implements NoConflict {\",\n            \"    private NoConflictImpl() {}\",\n            \"  }\",\n            \"}\");\n\n    assertAbout(javaSources())\n        .that(ImmutableList.of(parent, foo, bar, baz, noConflict))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(componentGeneratedFile);\n  }\n\n  @Test\n  public void subcomponentSimpleNamesDisambiguated() {\n    JavaFileObject parent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component\",\n            \"interface ParentComponent {\",\n            \"  Sub newSubcomponent();\",\n            \"}\");\n    JavaFileObject sub \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Sub\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent interface Sub {\",\n            \"  test.deep.many.levels.that.match.test.Sub newDeepSubcomponent();\",\n            \"}\");\n    JavaFileObject deepSub \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.deep.many.levels.that.match.test.Sub\",\n            \"package test.deep.many.levels.that.match.test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent public interface Sub {}\");\n\n    JavaFileObject componentGeneratedFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerParentComponent\",\n            \"package test;\",\n            \"\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerParentComponent implements ParentComponent {\",\n            \"  private DaggerParentComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static ParentComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Sub newSubcomponent() {\",\n            \"    return new test_SubImpl();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {}\",\n            \"\",\n            \"    public ParentComponent build() {\",\n            \"      return new DaggerParentComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  private final class test_SubImpl implements Sub {\",\n            \"\",\n            \"    private test_SubImpl() {}\",\n            \"\",\n            \"    @Override\",\n            \"    public test.deep.many.levels.that.match.test.Sub newDeepSubcomponent() {\",\n            \"      return new match_test_SubImpl();\",\n            \"    }\",\n            \"\",\n            \"    private final class match_test_SubImpl implements \",\n            \"        test.deep.many.levels.that.match.test.Sub {\",\n            \"      private match_test_SubImpl() {}\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n\n    assertAbout(javaSources())\n        .that(ImmutableList.of(parent, sub, deepSub))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(componentGeneratedFile);\n  }\n\n  @Test\n  public void subcomponentImplNameUsesFullyQualifiedClassNameIfNecessary() {\n    JavaFileObject parent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.ParentComponent\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component\",\n            \"interface ParentComponent {\",\n            \"  top1.a.b.c.d.E.F.Sub top1();\",\n            \"  top2.a.b.c.d.E.F.Sub top2();\",\n            \"}\");\n    JavaFileObject top1 \u003d\n        JavaFileObjects.forSourceLines(\n            \"top1.a.b.c.d.E\",\n            \"package top1.a.b.c.d;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"public interface E {\",\n            \"  interface F {\",\n            \"    @Subcomponent interface Sub {}\",\n            \"  }\",\n            \"}\");\n    JavaFileObject top2 \u003d\n        JavaFileObjects.forSourceLines(\n            \"top2.a.b.c.d.E\",\n            \"package top2.a.b.c.d;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"public interface E {\",\n            \"  interface F {\",\n            \"    @Subcomponent interface Sub {}\",\n            \"  }\",\n            \"}\");\n\n    JavaFileObject componentGeneratedFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerParentComponent\",\n            \"package test;\",\n            \"\",\n            \"import javax.annotation.Generated;\",\n            \"import top1.a.b.c.d.E;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerParentComponent implements ParentComponent {\",\n            \"  private DaggerParentComponent(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static ParentComponent create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public E.F.Sub top1() {\",\n            \"    return new top1_a_b_c_d_E_F_SubImpl();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public top2.a.b.c.d.E.F.Sub top2() {\",\n            \"    return new top2_a_b_c_d_E_F_SubImpl();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {}\",\n            \"\",\n            \"    public ParentComponent build() {\",\n            \"      return new DaggerParentComponent(this);\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  private final class top1_a_b_c_d_E_F_SubImpl implements E.F.Sub {\",\n            \"    private top1_a_b_c_d_E_F_SubImpl() {}\",\n            \"  }\",\n            \"  private final class top2_a_b_c_d_E_F_SubImpl implements top2.a.b.c.d.E.F.Sub {\",\n            \"    private top2_a_b_c_d_E_F_SubImpl() {}\",\n            \"  }\",\n            \"}\");\n\n    assertAbout(javaSources())\n        .that(ImmutableList.of(parent, top1, top2))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(componentGeneratedFile);\n  }\n\n  @Test\n  public void parentComponentNameShouldNotBeDisambiguatedWhenItConflictsWithASubcomponent() {\n    JavaFileObject parent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.C\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component\",\n            \"interface C {\",\n            \"  test.Foo.C newFooC();\",\n            \"}\");\n    JavaFileObject subcomponentWithSameSimpleNameAsParent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Foo\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"interface Foo {\",\n            \"  @Subcomponent interface C {}\",\n            \"}\");\n\n    JavaFileObject componentGeneratedFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerC\",\n            \"package test;\",\n            \"\",\n            \"import javax.annotation.Generated;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerC implements C {\",\n            \"  private DaggerC(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static C create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public Foo.C newFooC() {\",\n            \"    return new Foo_CImpl();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {}\",\n            \"\",\n            \"    public C build() {\",\n            \"      return new DaggerC(this);\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  private final class Foo_CImpl implements Foo.C {\",\n            \"    private Foo_CImpl() {}\",\n            \"  }\",\n            \"}\");\n\n    assertAbout(javaSources())\n        .that(ImmutableList.of(parent, subcomponentWithSameSimpleNameAsParent))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(componentGeneratedFile);\n  }\n\n  @Test\n  public void subcomponentBuilderNamesShouldNotConflict() {\n    JavaFileObject parent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.C\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Component\",\n            \"interface C {\",\n            \"  Foo.Sub.Builder fooBuilder();\",\n            \"  Bar.Sub.Builder barBuilder();\",\n            \"\",\n            \"  interface Foo {\",\n            \"    @Subcomponent\",\n            \"    interface Sub {\",\n            \"      @Subcomponent.Builder\",\n            \"      interface Builder {\",\n            \"        Sub build();\",\n            \"      }\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  interface Bar {\",\n            \"    @Subcomponent\",\n            \"    interface Sub {\",\n            \"      @Subcomponent.Builder\",\n            \"      interface Builder {\",\n            \"        Sub build();\",\n            \"      }\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n    JavaFileObject componentGeneratedFile \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.DaggerC\",\n            \"package test;\",\n            \"\",\n            \"import dagger.internal.Factory;\",\n            \"import javax.annotation.Generated;\",\n            \"import javax.inject.Provider;\",\n            \"\",\n            GENERATED_ANNOTATION,\n            \"public final class DaggerC implements C {\",\n            \"\",\n            \"  private Provider\u003cC.Foo.Sub.Builder\u003e fooBuilderProvider;\",\n            \"  private Provider\u003cC.Bar.Sub.Builder\u003e barBuilderProvider;\",\n            \"\",\n            \"  private DaggerC(Builder builder) {\",\n            \"    assert builder !\u003d null;\",\n            \"    initialize(builder);\",\n            \"  }\",\n            \"\",\n            \"  public static Builder builder() {\",\n            \"    return new Builder();\",\n            \"  }\",\n            \"\",\n            \"  public static C create() {\",\n            \"    return builder().build();\",\n            \"  }\",\n            \"\",\n            \"  @SuppressWarnings(\\\"unchecked\\\")\",\n            \"  private void initialize(final Builder builder) {\",\n            \"    this.fooBuilderProvider \u003d \",\n            \"        new Factory\u003cC.Foo.Sub.Builder\u003e() {\",\n            \"          @Override\",\n            \"          public C.Foo.Sub.Builder get() {\",\n            \"            return new Foo_SubBuilder();\",\n            \"          }\",\n            \"        };\",\n            \"\",\n            \"    this.barBuilderProvider \u003d \",\n            \"        new Factory\u003cC.Bar.Sub.Builder\u003e() {\",\n            \"          @Override\",\n            \"          public C.Bar.Sub.Builder get() {\",\n            \"            return new Bar_SubBuilder();\",\n            \"          }\",\n            \"        };\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public C.Foo.Sub.Builder fooBuilder() {\",\n            \"    return fooBuilderProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  @Override\",\n            \"  public C.Bar.Sub.Builder barBuilder() {\",\n            \"    return barBuilderProvider.get();\",\n            \"  }\",\n            \"\",\n            \"  public static final class Builder {\",\n            \"    private Builder() {}\",\n            \"\",\n            \"    public C build() {\",\n            \"      return new DaggerC(this);\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  private final class Foo_SubBuilder implements C.Foo.Sub.Builder {\",\n            \"    @Override\",\n            \"    public C.Foo.Sub build() {\",\n            \"      return new Foo_SubImpl(this);\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  private final class Foo_SubImpl implements C.Foo.Sub {\",\n            \"    private Foo_SubImpl(Foo_SubBuilder builder) {\",\n            \"      assert builder !\u003d null;\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  private final class Bar_SubBuilder implements C.Bar.Sub.Builder {\",\n            \"    @Override\",\n            \"    public C.Bar.Sub build() {\",\n            \"      return new Bar_SubImpl(this);\",\n            \"    }\",\n            \"  }\",\n            \"\",\n            \"  private final class Bar_SubImpl implements C.Bar.Sub {\",\n            \"    private Bar_SubImpl(Bar_SubBuilder builder) {\",\n            \"      assert builder !\u003d null;\",\n            \"    }\",\n            \"  }\",\n            \"}\");\n\n    assertAbout(javaSources())\n        .that(ImmutableList.of(parent))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(componentGeneratedFile);\n  }\n\n  @Test\n  public void duplicateBindingWithSubcomponentDeclaration() {\n    JavaFileObject module \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.TestModule\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Module;\",\n            \"import dagger.Provides;\",\n            \"\",\n            \"@Module(subcomponents \u003d Sub.class)\",\n            \"class TestModule {\",\n            \"  @Provides Sub.Builder providesConflictsWithModuleSubcomponents() { return null; }\",\n            \"  @Provides Object usesSubcomponentBuilder(Sub.Builder builder) {\",\n            \"    return builder.toString();\",\n            \"  }\",\n            \"}\");\n\n    JavaFileObject subcomponent \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Sub\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Subcomponent;\",\n            \"\",\n            \"@Subcomponent\",\n            \"interface Sub {\",\n            \"  @Subcomponent.Builder\",\n            \"  interface Builder {\",\n            \"    Sub build();\",\n            \"  }\",\n            \"}\");\n\n    JavaFileObject component \u003d\n        JavaFileObjects.forSourceLines(\n            \"test.Sub\",\n            \"package test;\",\n            \"\",\n            \"import dagger.Component;\",\n            \"\",\n            \"@Component(modules \u003d TestModule.class)\",\n            \"interface C {\",\n            \"  Object dependsOnBuilder();\",\n            \"}\");\n\n    assertThat(module, component, subcomponent)\n        .processedWith(new ComponentProcessor())\n        .failsToCompile()\n        .withErrorContaining(\"test.Sub.Builder is bound multiple times:\")\n        .and()\n        .withErrorContaining(\n            \"@Provides test.Sub.Builder test.TestModule.providesConflictsWithModuleSubcomponents()\")\n        .and()\n        .withErrorContaining(\"@Module(subcomponents \u003d test.Sub.class) for test.TestModule\");\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\internal\\codegen\\ValidationReportTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal.codegen;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.common.truth.Truth.assertThat;\nimport static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;\n\nimport com.google.common.collect.ImmutableSet;\nimport com.google.testing.compile.JavaFileObjects;\nimport dagger.internal.codegen.ValidationReport.Builder;\nimport java.util.Set;\nimport javax.annotation.processing.AbstractProcessor;\nimport javax.annotation.processing.RoundEnvironment;\nimport javax.lang.model.element.TypeElement;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class ValidationReportTest {\n  private static final JavaFileObject TEST_CLASS_FILE \u003d\n      JavaFileObjects.forSourceLines(\"test.TestClass\",\n          \"package test;\",\n          \"\",\n          \"final class TestClass {}\");\n\n  @Test\n  public void basicReport() {\n    assertAbout(javaSource())\n        .that(TEST_CLASS_FILE)\n        .processedWith(\n            new SimpleTestProcessor() {\n              @Override\n              void test() {\n                Builder\u003cTypeElement\u003e reportBuilder \u003d\n                    ValidationReport.about(getTypeElement(\"test.TestClass\"));\n                reportBuilder.addError(\"simple error\");\n                reportBuilder.build().printMessagesTo(processingEnv.getMessager());\n              }\n            })\n        .failsToCompile()\n        .withErrorContaining(\"simple error\")\n        .in(TEST_CLASS_FILE)\n        .onLine(3);\n  }\n\n  @Test\n  public void messageOnDifferentElement() {\n    assertAbout(javaSource())\n        .that(TEST_CLASS_FILE)\n        .processedWith(\n            new SimpleTestProcessor() {\n              @Override\n              void test() {\n                Builder\u003cTypeElement\u003e reportBuilder \u003d\n                    ValidationReport.about(getTypeElement(\"test.TestClass\"));\n                reportBuilder.addError(\"simple error\", getTypeElement(String.class));\n                reportBuilder.build().printMessagesTo(processingEnv.getMessager());\n              }\n            })\n        .failsToCompile()\n        .withErrorContaining(\"[java.lang.String] simple error\")\n        .in(TEST_CLASS_FILE)\n        .onLine(3);\n  }\n\n  @Test\n  public void subreport() {\n    assertAbout(javaSource())\n        .that(TEST_CLASS_FILE)\n        .processedWith(\n            new SimpleTestProcessor() {\n              @Override\n              void test() {\n                Builder\u003cTypeElement\u003e reportBuilder \u003d\n                    ValidationReport.about(getTypeElement(\"test.TestClass\"));\n                reportBuilder.addError(\"simple error\");\n                ValidationReport\u003cTypeElement\u003e parentReport \u003d\n                    ValidationReport.about(getTypeElement(String.class))\n                        .addSubreport(reportBuilder.build())\n                        .build();\n                assertThat(parentReport.isClean()).isFalse();\n                parentReport.printMessagesTo(processingEnv.getMessager());\n              }\n            })\n        .failsToCompile()\n        .withErrorContaining(\"simple error\")\n        .in(TEST_CLASS_FILE)\n        .onLine(3);\n  }\n\n  private static abstract class SimpleTestProcessor extends AbstractProcessor {\n    @Override\n    public Set\u003cString\u003e getSupportedAnnotationTypes() {\n      return ImmutableSet.of(\"*\");\n    }\n\n    @Override\n    public boolean process(Set\u003c? extends TypeElement\u003e annotations, RoundEnvironment roundEnv) {\n      test();\n      return false;\n    }\n\n    protected final TypeElement getTypeElement(Class\u003c?\u003e clazz) {\n      return getTypeElement(clazz.getCanonicalName());\n    }\n\n    protected final TypeElement getTypeElement(String canonicalName) {\n      return processingEnv.getElementUtils().getTypeElement(canonicalName);\n    }\n\n    abstract void test();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\compiler\\src\\test\\java\\dagger\\tests\\integration\\operation\\PrimitiveInjectionTest.java",
    "code": "\"/**\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.tests.integration.operation;\n\nimport static com.google.common.truth.Truth.assertAbout;\nimport static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;\nimport static dagger.internal.codegen.GeneratedLines.GENERATED_ANNOTATION;\nimport static java.util.Arrays.asList;\n\nimport com.google.testing.compile.JavaFileObjects;\nimport dagger.internal.codegen.ComponentProcessor;\nimport javax.tools.JavaFileObject;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic final class PrimitiveInjectionTest {\n\n  // TODO(cgruber): Use @test.ForTest to qualify primitives once qualifier equivalence is working.\n  /*\n  JavaFileObject annotation \u003d JavaFileObjects.forSourceLines(\"test.ForTest\",\n      \"package test;\",\n      \"import javax.inject.Qualifier;\",\n      \"@Qualifier\",\n      \"public @interface ForTest {\",\n      \"}\");\n  */\n\n  // TODO(cgruber): Expand test to support more primitive types when b/15512877 is fixed.\n  JavaFileObject primitiveInjectable \u003d JavaFileObjects.forSourceLines(\"test.PrimitiveInjectable\",\n      \"package test;\",\n      \"import javax.inject.Inject;\",\n      \"class PrimitiveInjectable {\",\n      \"  @Inject PrimitiveInjectable(int ignored) {}\",\n      \"}\");\n\n  JavaFileObject primitiveModule \u003d JavaFileObjects.forSourceLines(\"test.PrimitiveModule\",\n      \"package test;\",\n      \"import dagger.Module;\",\n      \"import dagger.Provides;\",\n      \"@Module\",\n      \"class PrimitiveModule {\",\n      \"  @Provides int primitiveInt() { return Integer.MAX_VALUE; }\",\n      \"}\");\n\n  JavaFileObject component \u003d JavaFileObjects.forSourceLines(\"test.PrimitiveComponent\",\n      \"package test;\",\n      \"import dagger.Component;\",\n      \"import dagger.Provides;\",\n      \"@Component(modules \u003d PrimitiveModule.class)\",\n      \"interface PrimitiveComponent {\",\n      \"  int primitiveInt();\",\n      \"  PrimitiveInjectable primitiveInjectable();\",\n      \"}\");\n\n  JavaFileObject expectedComponent \u003d JavaFileObjects.forSourceLines(\n      \"test.DaggerPrimitiveComponent\",\n      \"package test;\",\n      \"\",\n      \"import dagger.internal.Preconditions;\",\n      \"import javax.annotation.Generated;\",\n      \"import javax.inject.Provider;\",\n      \"\",\n      GENERATED_ANNOTATION,\n      \"public final class DaggerPrimitiveComponent implements PrimitiveComponent {\",\n      \"  private Provider\u003cInteger\u003e primitiveIntProvider;\",\n      \"  private Provider\u003cPrimitiveInjectable\u003e primitiveInjectableProvider;\",\n      \"\",\n      \"  private DaggerPrimitiveComponent(Builder builder) {\",\n      \"    assert builder !\u003d null;\",\n      \"    initialize(builder);\",\n      \"  }\",\n      \"\",\n      \"  public static Builder builder() {\",\n      \"    return new Builder();\",\n      \"  }\",\n      \"\",\n      \"  public static PrimitiveComponent create() {\",\n      \"    return builder().build();\",\n      \"  }\",\n      \"\",\n      \"  @SuppressWarnings(\\\"unchecked\\\")\",\n      \"  private void initialize(final Builder builder) {\",\n      \"    this.primitiveIntProvider \u003d\",\n      \"        PrimitiveModule_PrimitiveIntFactory.create(builder.primitiveModule);\",\n      \"    this.primitiveInjectableProvider \u003d\",\n      \"        PrimitiveInjectable_Factory.create(primitiveIntProvider);\",\n      \"  }\",\n      \"\",\n      \"  @Override\",\n      \"  public int primitiveInt() {\",\n      \"    return primitiveIntProvider.get();\",\n      \"  }\",\n      \"\",\n      \"  @Override\",\n      \"  public PrimitiveInjectable primitiveInjectable() {\",\n      \"    return primitiveInjectableProvider.get();\",\n      \"  }\",\n      \"\",\n      \"  public static final class Builder {\",\n      \"    private PrimitiveModule primitiveModule;\",\n      \"\",\n      \"    private Builder() {\",\n      \"    }\",\n      \"\",\n      \"    public PrimitiveComponent build() {\",\n      \"      if (primitiveModule \u003d\u003d null) {\",\n      \"        this.primitiveModule \u003d new PrimitiveModule();\",\n      \"      }\",\n      \"      return new DaggerPrimitiveComponent(this);\",\n      \"    }\",\n      \"\",\n      \"    public Builder primitiveModule(PrimitiveModule primitiveModule) {\",\n      \"      this.primitiveModule \u003d Preconditions.checkNotNull(primitiveModule);\",\n      \"      return this;\",\n      \"    }\",\n      \"  }\",\n      \"}\");\n\n  @Test public void primitiveArrayTypesAllInjected() {\n    assertAbout(javaSources())\n        .that(asList(component, primitiveInjectable, primitiveModule))\n        .processedWith(new ComponentProcessor())\n        .compilesWithoutError()\n        .and()\n        .generatesSources(expectedComponent);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\Binds.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n/**\n * Annotates \u003cem\u003eabstract\u003c/em\u003e methods of a {@link Module} that delegate bindings. For example, to\n * bind {@link java.util.Random} to {@link java.security.SecureRandom} a module could declare the\n * following: {@code @Binds abstract Random bindRandom(SecureRandom secureRandom);}\n *\n * \u003cp\u003e{@code @Binds} methods are a drop-in replacement for {@link Provides} methods that simply\n * return an injected parameter.  Prefer {@code @Binds} because the generated implementation is\n * likely to be more efficient.\n *\n * \u003cp\u003eA {@code @Binds} method:\n * \u003cul\u003e\n * \u003cli\u003eMust be {@code abstract}.\n * \u003cli\u003eMust have a single parameter whose type is assignable to the return type.  The return type is\n * the bound type and the parameter is the type to which it is bound.\n * \u003cli\u003eMay be {@linkplain javax.inject.Scope scoped}.\n * \u003cli\u003eMay be {@linkplain javax.inject.Qualifier qualified}.\n * \u003c/ul\u003e\n */\n@Documented\n@Retention(RUNTIME)\n@Target(METHOD)\npublic @interface Binds {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\BindsOptionalOf.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger;\n\nimport static java.lang.annotation.ElementType.METHOD;\n\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Target;\nimport javax.inject.Inject;\nimport javax.inject.Qualifier;\n\n/**\n * Annotates methods that declare bindings for {@code Optional} containers of values from bindings\n * that may or may not be present in the component.\n *\n * \u003cp\u003eIf a module contains a method declaration like this:\n *\n * \u003cpre\u003e\n * {@literal @BindsOptionalOf} abstract Foo optionalFoo();\u003c/pre\u003e\n *\n * then any binding in the component can depend on an {@code Optional} of {@code Foo}. If there is\n * no binding for {@code Foo} in the component, the {@code Optional} will be absent. If there is a\n * binding for {@code Foo} in the component, the {@code Optional} will be present, and its value\n * will be the value given by the binding for {@code Foo}.\n *\n * \u003cp\u003eA {@code @BindsOptionalOf} method:\n *\n * \u003cul\u003e\n * \u003cli\u003emust be {@code abstract}\n * \u003cli\u003emay have a {@linkplain Qualifier qualifier} annotation\n * \u003cli\u003emust not return {@code void}\n * \u003cli\u003emust not have parameters\n * \u003cli\u003emust not throw exceptions\n * \u003cli\u003emust not return an unqualified type with an {@link Inject @Inject}-annotated constructor,\n *     since such a type is always present\n * \u003c/ul\u003e\n *\n * \u003cp\u003eOther bindings may inject any of:\n *\n * \u003cul\u003e\n * \u003cli\u003e{@code Optional\u003cFoo\u003e}\n * \u003cli\u003e{@code Optional\u003cProvider\u003cFoo\u003e\u003e}\n * \u003cli\u003e{@code Optional\u003cLazy\u003cFoo\u003e\u003e}\n * \u003cli\u003e{@code Optional\u003cProvider\u003cLazy\u003cFoo\u003e\u003e\u003e}\n * \u003c/ul\u003e\n *\n * \u003cp\u003eExplicit bindings for any of the above will conflict with a {@code @BindsOptionalOf} binding.\n *\n * \u003cp\u003eIf the binding for {@code Foo} is a {@code @Produces} binding, then another {@code @Produces}\n * binding can depend on any of:\n *\n * \u003cul\u003e\n * \u003cli\u003e{@code Optional\u003cFoo\u003e}\n * \u003cli\u003e{@code Optional\u003cProducer\u003cFoo\u003e\u003e}\n * \u003cli\u003e{@code Optional\u003cProduced\u003cFoo\u003e\u003e}\n * \u003c/ul\u003e\n *\n * \u003cp\u003eYou can inject either {@code com.google.common.base.Optional} or {@code java.util.Optional}.\n */\n@Documented\n@Beta\n@Target(METHOD)\npublic @interface BindsOptionalOf {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\Component.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger;\n\nimport static java.lang.annotation.ElementType.TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport javax.inject.Qualifier;\nimport javax.inject.Scope;\nimport javax.inject.Singleton;\n\n/**\n * Annotates an interface or abstract class for which a fully-formed, dependency-injected\n * implementation is to be generated from a set of {@linkplain #modules}. The generated class will\n * have the name of the type annotated with {@code @Component} prepended with {@code Dagger}. For\n * example, {@code @Component interface MyComponent {...}} will produce an implementation named\n * {@code DaggerMyComponent}.\n *\n * \u003ca name\u003d\"component-methods\"\u003e\u003c/a\u003e\n * \u003ch2\u003eComponent methods\u003c/h2\u003e\n *\n * \u003cp\u003eEvery type annotated with {@code @Component} must contain at least one abstract component\n * method. Component methods may have any name, but must have signatures that conform to either\n * {@linkplain Provider provision} or {@linkplain MembersInjector members-injection} contracts.\n *\n * \u003ca name\u003d\"provision-methods\"\u003e\u003c/a\u003e\n * \u003ch3\u003eProvision methods\u003c/h3\u003e\n *\n * \u003cp\u003eProvision methods have no parameters and return an {@link Inject injected} or\n * {@link Provides provided} type. Each method may have a {@link Qualifier} annotation as well. The\n * following are all valid provision method declarations: \u003cpre\u003e\u003ccode\u003e\n *   SomeType getSomeType();\n *   {@literal Set\u003cSomeType\u003e} getSomeTypes();\n *   {@literal @PortNumber} int getPortNumber();\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003cp\u003eProvision methods, like typical {@link Inject injection} sites, may use {@link Provider} or\n * {@link Lazy} to more explicitly control provision requests. A {@link Provider} allows the user\n * of the component to request provision any number of times by calling {@link Provider#get}. A\n * {@link Lazy} will only ever request a single provision, but will defer it until the first call to\n * {@link Lazy#get}. The following provision methods all request provision of the same type, but\n * each implies different semantics: \u003cpre\u003e\u003ccode\u003e\n *   SomeType getSomeType();\n *   {@literal Provider\u003cSomeType\u003e} getSomeTypeProvider();\n *   {@literal Lazy\u003cSomeType\u003e} getLazySomeType();\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003ca name\u003d\"members-injection-methods\"\u003e\u003c/a\u003e\n * \u003ch3\u003eMembers-injection methods\u003c/h3\u003e\n *\n * \u003cp\u003eMembers-injection methods have a single parameter and inject dependencies into each of the\n * {@link Inject}-annotated fields and methods of the passed instance. A members-injection method\n * may be void or return its single parameter as a convenience for chaining. The following are all\n * valid members-injection method declarations: \u003cpre\u003e\u003ccode\u003e\n *   void injectSomeType(SomeType someType);\n *   SomeType injectAndReturnSomeType(SomeType someType);\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003cp\u003eA method with no parameters that returns a {@link MembersInjector} is equivalent to a members\n * injection method. Calling {@link MembersInjector#injectMembers} on the returned object will\n * perform the same work as a members injection method. For example: \u003cpre\u003e\u003ccode\u003e\n *   {@literal MembersInjector\u003cSomeType\u003e} getSomeTypeMembersInjector();\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003ch4\u003eA note about covariance\u003c/h4\u003e\n *\n * \u003cp\u003eWhile a members-injection method for a type will accept instances of its subtypes, only\n * {@link Inject}-annotated members of the parameter type and its supertypes will be injected;\n * members of subtypes will not. For example, given the following types, only {@code a} and\n * {@code b} will be injected into an instance of {@code Child} when it is passed to the\n * members-injection method {@code injectSelf(Self instance)}: \u003cpre\u003e\u003ccode\u003e\n *   class Parent {\n *     {@literal @}Inject A a;\n *   }\n *\n *   class Self extends Parent {\n *     {@literal @}Inject B b;\n *   }\n *\n *   class Child extends Self {\n *     {@literal @}Inject C c;\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003ca name\u003d\"instantiation\"\u003e\u003c/a\u003e\n * \u003ch2\u003eInstantiation\u003c/h2\u003e\n *\n * \u003cp\u003eComponent implementations are primarily instantiated via a generated\n * \u003ca href\u003d\"http://en.wikipedia.org/wiki/Builder_pattern\"\u003ebuilder\u003c/a\u003e. An instance of the builder\n * is obtained using the {@code builder()} method on the component implementation.\n * If a nested {@code @Component.Builder} type exists in the component, the {@code builder()}\n * method will return a generated implementation of that type.  If no nested\n * {@code @Component.Builder} exists, the returned builder has a method to set each of the\n * {@linkplain #modules} and component {@linkplain #dependencies} named with the\n * \u003ca href\u003d\"http://en.wikipedia.org/wiki/CamelCase\"\u003elower camel case\u003c/a\u003e version of the module\n * or dependency type. Each component dependency and module without a visible default constructor\n * must be set explicitly, but any module with a default or no-args constructor accessible to the\n * component implementation may be elided. This is an example usage of a component builder:\n * \u003cpre\u003e\u003ccode\u003e\n *   public static void main(String[] args) {\n *     OtherComponent otherComponent \u003d ...;\n *     MyComponent component \u003d DaggerMyComponent.builder()\n *         // required because component dependencies must be set\n *         .otherComponent(otherComponent)\n *         // required because FlagsModule has constructor parameters\n *         .flagsModule(new FlagsModule(args))\n *         // may be elided because a no-args constructor is visible\n *         .myApplicationModule(new MyApplicationModule())\n *         .build();\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003cp\u003eIn the case that a component has no component dependencies and only no-arg modules, the\n * generated component will also have a factory method {@code create()}.\n * {@code SomeComponent.create()} and {@code SomeComponent.builder().build()} are both valid and\n * equivalent.\n *\n * \u003ca name\u003d\"scope\"\u003e\u003c/a\u003e\n * \u003ch2\u003eScope\u003c/h2\u003e\n *\n * \u003cp\u003eEach Dagger component can be associated with a scope by annotating it with the\n * {@linkplain Scope scope annotation}. The component implementation ensures that there is only one\n * provision of each scoped binding per instance of the component. If the component declares a\n * scope, it may only contain unscoped bindings or bindings of that scope anywhere in the graph. For\n * example: \u003cpre\u003e\u003ccode\u003e\n *   {@literal @}Singleton {@literal @}Component\n *   interface MyApplicationComponent {\n *     // this component can only inject types using unscoped or {@literal @}Singleton bindings\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003cp\u003eIn order to get the proper behavior associated with a scope annotation, it is the caller\u0027s\n * responsibility to instantiate new component instances when appropriate. A {@link Singleton}\n * component, for instance, should only be instantiated once per application, while a\n * {@code RequestScoped} component should be instantiated once per request. Because components are\n * self-contained implementations, exiting a scope is as simple as dropping all references to the\n * component instance.\n *\n * \u003ca name\u003d\"component-relationships\"\u003e\u003c/a\u003e\n * \u003ch2\u003eComponent relationships\u003c/h2\u003e\n *\n * \u003cp\u003eWhile there is much utility in isolated components with purely unscoped bindings, many\n * applications will call for multiple components with multiple scopes to interact. Dagger provides\n * two mechanisms for relating components.\n *\n * \u003ca name\u003d\"subcomponents\"\u003e\u003c/a\u003e\n * \u003ch3\u003eSubcomponents\u003c/h3\u003e\n *\n * \u003cp\u003eThe simplest way to relate two components is by declaring a {@link Subcomponent}. A\n * subcomponent behaves exactly like a component, but has its implementation generated within\n * a parent component or subcomponent. That relationship allows the subcomponent implementation to\n * inherit the \u003cem\u003eentire\u003c/em\u003e binding graph from its parent when it is declared. For that reason,\n * a subcomponent isn\u0027t evaluated for completeness until it is associated with a parent.\n *\n * \u003cp\u003eSubcomponents are declared by listing the class in the {@link Module#subcomponents()}\n * attribute of one of the parent component\u0027s modules. This binds the {@link Subcomponent.Builder}\n * within the parent component.\n *\n * \u003cp\u003eSubcomponents may also be declared via a factory method on a parent component or subcomponent.\n * The method may have any name, but must return the subcomponent. The factory method\u0027s parameters\n * may be any number of the subcomponent\u0027s modules, but must at least include those without visible\n * no-arg constructors. The following is an example of a factory method that creates a\n * request-scoped subcomponent from a singleton-scoped parent: \u003cpre\u003e\u003ccode\u003e\n *   {@literal @}Singleton {@literal @}Component\n *   interface ApplicationComponent {\n *     // component methods...\n *\n *     RequestComponent newRequestComponent(RequestModule requestModule);\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003ca name\u003d\"component-dependencies\"\u003e\u003c/a\u003e\n * \u003ch3\u003eComponent dependencies\u003c/h3\u003e\n *\n * \u003cp\u003eWhile subcomponents are the simplest way to compose subgraphs of bindings, subcomponents are\n * tightly coupled with the parents; they may use any binding defined by their ancestor component\n * and subcomponents. As an alternative, components can use bindings only from another\n * \u003cem\u003ecomponent interface\u003c/em\u003e by declaring a {@linkplain #dependencies component dependency}. When\n * a type is used as a component dependency, each \u003ca href\u003d\"#provision-methods\"\u003eprovision method\u003c/a\u003e\n * on the dependency is bound as a provider. Note that \u003cem\u003eonly\u003c/em\u003e the bindings exposed as\n * provision methods are available through component dependencies.\n *\n * @author Gregory Kick\n * @since 2.0\n */\n@Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.\n@Target(TYPE)\n@Documented\npublic @interface Component {\n  /**\n   * A list of classes annotated with {@link Module} whose bindings are used to generate the\n   * component implementation. Note that through the use of {@link Module#includes} the full set of\n   * modules used to implement the component may include more modules that just those listed here.\n   */\n  Class\u003c?\u003e[] modules() default {};\n\n  /**\n   * A list of types that are to be used as \u003ca href\u003d\"#component-dependencies\"\u003ecomponent\n   * dependencies\u003c/a\u003e.\n   */\n  Class\u003c?\u003e[] dependencies() default {};\n\n  /**\n   * A builder for a component. Components may have a single nested static abstract class or\n   * interface annotated with {@code @Component.Builder}.  If they do, then the component\u0027s\n   * generated builder will match the API in the type.  Builders must follow some rules:\n   * \u003cul\u003e\n   * \u003cli\u003e A single abstract method with no arguments must exist, and must return the component.\n   *      (This is typically the {@code build()} method.)\n   * \u003cli\u003e All other abstract methods must take a single argument and must return void,\n   *      the Builder type, or a supertype of the builder.\n   * \u003cli\u003e Each component dependency \u003cb\u003emust\u003c/b\u003e have an abstract setter method.\n   * \u003cli\u003e Each module dependency that Dagger can\u0027t instantiate itself (e.g, the module\n   *      doesn\u0027t have a visible no-args constructor) \u003cb\u003emust\u003c/b\u003e have an abstract setter method.\n   *      Other module dependencies (ones that Dagger can instantiate) are allowed, but not required.\n   * \u003cli\u003e Non-abstract methods are allowed, but ignored as far as validation and builder generation\n   *      are concerned.\n   * \u003c/ul\u003e\n   * \n   * For example, this could be a valid Component with a Builder: \u003cpre\u003e\u003ccode\u003e\n   * {@literal @}Component(modules \u003d {BackendModule.class, FrontendModule.class})\n   * interface MyComponent {\n   *   MyWidget myWidget();\n   *   \n   *   {@literal @}Component.Builder\n   *   interface Builder {\n   *     MyComponent build();\n   *     Builder backendModule(BackendModule bm);\n   *     Builder frontendModule(FrontendModule fm);\n   *   }\n   * }\u003c/code\u003e\u003c/pre\u003e\n   */\n  @Target(TYPE)\n  @Documented\n  @interface Builder {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\Beta.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport static java.lang.annotation.RetentionPolicy.SOURCE;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\n\n/**\n * Signifies that a public API (public class, method or field) is subject to\n * incompatible changes, or even removal, in a future release. An API bearing\n * this annotation is exempt from any compatibility guarantees made by its\n * containing library. Note that the presence of this annotation implies nothing\n * about the quality or performance of the API in question, only the fact that\n * it is not \"API-frozen.\"\n */\n@Documented\n@Retention(SOURCE)\npublic @interface Beta {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\DaggerCollections.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Collection utility methods in service of Dagger internal classes. \u003cem\u003eDo not use\u003c/em\u003e in client\n * code.\n */\npublic final class DaggerCollections {\n  /**\n   * The maximum value for a signed 32-bit integer that is equal to a power of 2.\n   */\n  private static final int MAX_POWER_OF_TWO \u003d 1 \u003c\u003c (Integer.SIZE - 2);\n\n  private DaggerCollections() {}\n\n  /**\n   * Returns a new list that is pre-sized to {@code size}, or {@link Collections#emptyList()} if\n   * empty. The list returned is never intended to grow beyond {@code size}, so adding to a list\n   * when the size is 0 is an error.\n   */\n  public static \u003cT\u003e List\u003cT\u003e presizedList(int size) {\n    if (size \u003d\u003d 0) {\n      return Collections.emptyList();\n    }\n    return new ArrayList\u003cT\u003e(size);\n  }\n\n  /**\n   * Returns true if at least one pair of items in {@code list} are equals.\n   */\n  public static boolean hasDuplicates(List\u003c?\u003e list) {\n    if (list.size() \u003c 2) {\n      return false;\n    }\n    Set\u003cObject\u003e asSet \u003d new HashSet\u003cObject\u003e(list);\n    return list.size() !\u003d asSet.size();\n  }\n\n  /**\n   * Creates a {@link HashSet} instance, with a high enough \"intial capcity\" that it \u003cem\u003eshould\u003c/em\u003e\n   * hold {@code expectedSize} elements without growth.\n   */\n  static \u003cT\u003e HashSet\u003cT\u003e newHashSetWithExpectedSize(int expectedSize) {\n    return new HashSet\u003cT\u003e(calculateInitialCapacity(expectedSize));\n  }\n\n  /**\n   * Creates a {@link LinkedHashMap} instance, with a high enough \"initial capacity\" that it\n   * \u003cem\u003eshould\u003c/em\u003e hold {@code expectedSize} elements without growth.\n   */\n  static \u003cK, V\u003e LinkedHashMap\u003cK, V\u003e newLinkedHashMapWithExpectedSize(int expectedSize) {\n    return new LinkedHashMap\u003cK, V\u003e(calculateInitialCapacity(expectedSize));\n  }\n\n  private static int calculateInitialCapacity(int expectedSize) {\n    if (expectedSize \u003c 3) {\n      return expectedSize + 1;\n    }\n    if (expectedSize \u003c MAX_POWER_OF_TWO) {\n      // This is the calculation used in JDK8 to resize when a putAll\n      // happens; it seems to be the most conservative calculation we\n      // can make.  0.75 is the default load factor.\n      return (int) (expectedSize / 0.75F + 1.0F);\n    }\n    return Integer.MAX_VALUE; // any large value\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\DelegateFactory.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport javax.inject.Provider;\n\n/**\n * A DelegateFactory that is used to stitch Provider/Lazy indirection based dependency cycles.\n * \n * @since 2.0.1\n */\npublic final class DelegateFactory\u003cT\u003e implements Factory\u003cT\u003e {\n  private Provider\u003cT\u003e delegate;\n\n  @Override\n  public T get() {\n    if (delegate \u003d\u003d null) {\n      throw new IllegalStateException();\n    }\n    return delegate.get();\n  }\n\n  public void setDelegatedProvider(Provider\u003cT\u003e delegate) {\n    if (delegate \u003d\u003d null) {\n      throw new IllegalArgumentException();\n    }\n    if (this.delegate !\u003d null) {\n      throw new IllegalStateException();\n    }\n    this.delegate \u003d delegate;\n  }\n}\n\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\DoubleCheck.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport static dagger.internal.Preconditions.checkNotNull;\n\nimport dagger.Lazy;\nimport javax.inject.Provider;\n\n/**\n * A {@link Lazy} and {@link Provider} implementation that memoizes the value returned from a\n * delegate using the double-check idiom described in Item 71 of \u003ci\u003eEffective Java 2\u003c/i\u003e.\n */\npublic final class DoubleCheck\u003cT\u003e implements Provider\u003cT\u003e, Lazy\u003cT\u003e {\n  private static final Object UNINITIALIZED \u003d new Object();\n\n  private volatile Provider\u003cT\u003e provider;\n  private volatile Object instance \u003d UNINITIALIZED;\n\n  private DoubleCheck(Provider\u003cT\u003e provider) {\n    assert provider !\u003d null;\n    this.provider \u003d provider;\n  }\n\n  @SuppressWarnings(\"unchecked\") // cast only happens when result comes from the provider\n  @Override\n  public T get() {\n    Object result \u003d instance;\n    if (result \u003d\u003d UNINITIALIZED) {\n      synchronized (this) {\n        result \u003d instance;\n        if (result \u003d\u003d UNINITIALIZED) {\n          result \u003d provider.get();\n          /* Get the current instance and test to see if the call to provider.get() has resulted\n           * in a recursive call.  If it returns the same instance, we\u0027ll allow it, but if the\n           * instances differ, throw. */\n          Object currentInstance \u003d instance;\n          if (currentInstance !\u003d UNINITIALIZED \u0026\u0026 currentInstance !\u003d result) {\n            throw new IllegalStateException(\"Scoped provider was invoked recursively returning \"\n                + \"different results: \" + currentInstance + \" \u0026 \" + result);\n          }\n          instance \u003d result;\n          /* Null out the reference to the provider. We are never going to need it again, so we\n           * can make it eligible for GC. */\n          provider \u003d null;\n        }\n      }\n    }\n    return (T) result;\n  }\n\n  /** Returns a {@link Provider} that caches the value from the given delegate provider. */\n  public static \u003cT\u003e Provider\u003cT\u003e provider(Provider\u003cT\u003e delegate) {\n    checkNotNull(delegate);\n    if (delegate instanceof DoubleCheck) {\n      /* This should be a rare case, but if we have a scoped @Binds that delegates to a scoped\n       * binding, we shouldn\u0027t cache the value again. */\n      return delegate;\n    }\n    return new DoubleCheck\u003cT\u003e(delegate);\n  }\n\n  /** Returns a {@link Lazy} that caches the value from the given provider. */\n  public static \u003cT\u003e Lazy\u003cT\u003e lazy(Provider\u003cT\u003e provider) {\n    if (provider instanceof Lazy) {\n      @SuppressWarnings(\"unchecked\")\n      final Lazy\u003cT\u003e lazy \u003d (Lazy\u003cT\u003e) provider;\n      // Avoids memoizing a value that is already memoized.\n      // NOTE: There is a pathological case where Provider\u003cP\u003e may implement Lazy\u003cL\u003e, but P and L\n      // are different types using covariant return on get(). Right now this is used with\n      // DoubleCheck\u003cT\u003e exclusively, which is implemented such that P and L are always\n      // the same, so it will be fine for that case.\n      return lazy;\n    }\n    return new DoubleCheck\u003cT\u003e(checkNotNull(provider));\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\Factory.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport dagger.Provides;\nimport javax.inject.Inject;\nimport javax.inject.Provider;\nimport javax.inject.Scope;\n\n/**\n * An {@linkplain Scope unscoped} {@link Provider}. While a {@link Provider} \u003ci\u003emay\u003c/i\u003e apply\n * scoping semantics while providing an instance, a factory implementation is guaranteed to exercise\n * the binding logic ({@link Inject} constructors, {@link Provides} methods) upon each call to\n * {@link #get}.\n *\n * \u003cp\u003eNote that while subsequent calls to {@link #get} will create new instances for bindings such\n * as those created by {@link Inject} constructors, a new instance is not guaranteed by all\n * bindings. For example, {@link Provides} methods may be implemented in ways that return the same\n * instance for each call.\n *\n * @author Gregory Kick\n * @since 2.0\n */\npublic interface Factory\u003cT\u003e extends Provider\u003cT\u003e {\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\GwtIncompatible.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\n/** Marks an element incompatible with GWT. */\npublic @interface GwtIncompatible {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\InstanceFactory.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\n/**\n * A {@link Factory} implementation that returns a single instance for all invocations of\n * {@link #get}.\n *\n * \u003cp\u003eNote that while this is a {@link Factory} implementation, and thus unscoped, each call to\n * {@link #get} will always return the same instance.  As such, any scoping applied to this factory\n * is redundant and unnecessary.  However, using this with {@link DoubleCheck#provider} is valid and\n * may be desired for testing or contractual guarantees.\n *\n * @author Gregory Kick\n * @since 2.0\n */\npublic final class InstanceFactory\u003cT\u003e implements Factory\u003cT\u003e {\n  public static \u003cT\u003e Factory\u003cT\u003e create(T instance) {\n    if (instance \u003d\u003d null) {\n      throw new NullPointerException();\n    }\n    return new InstanceFactory\u003cT\u003e(instance);\n  }\n\n  private final T instance;\n\n  private InstanceFactory(T instance) {\n    this.instance \u003d instance;\n  }\n\n  @Override\n  public T get() {\n    return instance;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\MapFactory.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;\nimport static java.util.Collections.unmodifiableMap;\n\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport javax.inject.Provider;\n\n/**\n * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a\n * {@code Map\u003cK, V\u003e} when calling {@link #get} (as specified by {@link Factory}).\n *\n * @author Chenying Hou\n * @since 2.0\n *\n */\npublic final class MapFactory\u003cK, V\u003e implements Factory\u003cMap\u003cK, V\u003e\u003e {\n  private final Map\u003cK, Provider\u003cV\u003e\u003e contributingMap;\n\n  private MapFactory(Map\u003cK, Provider\u003cV\u003e\u003e map) {\n    this.contributingMap \u003d unmodifiableMap(map);\n  }\n\n  /**\n   * Returns a new MapFactory.\n   */\n  public static \u003cK, V\u003e MapFactory\u003cK, V\u003e create(Provider\u003cMap\u003cK, Provider\u003cV\u003e\u003e\u003e mapProviderFactory) {\n    Map\u003cK, Provider\u003cV\u003e\u003e map \u003d mapProviderFactory.get();\n    return new MapFactory\u003cK, V\u003e(map);\n  }\n\n  /**\n   * Returns a {@code Map\u003cK, V\u003e} whose iteration order is that of the elements\n   * given by each of the providers, which are invoked in the order given at creation.\n   */\n  @Override\n  public Map\u003cK, V\u003e get() {\n    Map\u003cK, V\u003e result \u003d newLinkedHashMapWithExpectedSize(contributingMap.size());\n    for (Entry\u003cK, Provider\u003cV\u003e\u003e entry: contributingMap.entrySet()) {\n      result.put(entry.getKey(), entry.getValue().get());\n    }\n    return unmodifiableMap(result);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\MapProviderFactory.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport static dagger.internal.DaggerCollections.newLinkedHashMapWithExpectedSize;\nimport static java.util.Collections.unmodifiableMap;\n\nimport dagger.Lazy;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport javax.inject.Provider;\n\n/**\n * A {@link Factory} implementation used to implement {@link Map} bindings. This factory returns a\n * {@code Map\u003cK, Provider\u003cV\u003e\u003e} when calling {@link #get} (as specified by {@link Factory}).\n *\n * @author Chenying Hou\n * @since 2.0\n */\npublic final class MapProviderFactory\u003cK, V\u003e\n    implements Factory\u003cMap\u003cK, Provider\u003cV\u003e\u003e\u003e, Lazy\u003cMap\u003cK, Provider\u003cV\u003e\u003e\u003e {\n  private static final MapProviderFactory\u003cObject, Object\u003e EMPTY \u003d\n      new MapProviderFactory\u003cObject, Object\u003e(Collections.\u003cObject, Provider\u003cObject\u003e\u003eemptyMap());\n\n  private final Map\u003cK, Provider\u003cV\u003e\u003e contributingMap;\n\n  /**\n   * Returns a new {@link Builder}\n   */\n  public static \u003cK, V\u003e Builder\u003cK, V\u003e builder(int size) {\n    return new Builder\u003cK, V\u003e(size);\n  }\n\n  /**\n   * Returns a factory of an empty map.\n   */\n  @SuppressWarnings(\"unchecked\") // safe contravariant cast\n  public static \u003cK, V\u003e MapProviderFactory\u003cK, V\u003e empty() {\n    return (MapProviderFactory\u003cK, V\u003e) EMPTY;\n  }\n\n  private MapProviderFactory(Map\u003cK, Provider\u003cV\u003e\u003e contributingMap) {\n    this.contributingMap \u003d unmodifiableMap(contributingMap);\n  }\n\n  /**\n   * Returns a {@code Map\u003cK, Provider\u003cV\u003e\u003e} whose iteration order is that of the elements\n   * given by each of the providers, which are invoked in the order given at creation.\n   *\n   */\n  @Override\n  public Map\u003cK, Provider\u003cV\u003e\u003e get() {\n    return this.contributingMap;\n  }\n\n  /**\n   * A builder to help build the {@link MapProviderFactory}\n   */\n  public static final class Builder\u003cK, V\u003e {\n    private final LinkedHashMap\u003cK, Provider\u003cV\u003e\u003e mapBuilder;\n\n    private Builder(int size) {\n      // TODO(user): consider which way to initialize mapBuilder is better\n      this.mapBuilder \u003d newLinkedHashMapWithExpectedSize(size);\n    }\n\n    /**\n     * Returns a new {@link MapProviderFactory}\n     */\n    public MapProviderFactory\u003cK, V\u003e build() {\n      return new MapProviderFactory\u003cK, V\u003e(this.mapBuilder);\n    }\n\n    /**\n     * Associate k with providerOfValue in {@code Builder}\n     */\n    public Builder\u003cK, V\u003e put(K key, Provider\u003cV\u003e providerOfValue) {\n      if (key \u003d\u003d null) {\n        throw new NullPointerException(\"The key is null\");\n      }\n      if (providerOfValue \u003d\u003d null) {\n        throw new NullPointerException(\"The provider of the value is null\");\n      }\n\n      this.mapBuilder.put(key, providerOfValue);\n      return this;\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\MembersInjectors.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport static dagger.internal.Preconditions.checkNotNull;\n\nimport dagger.MembersInjector;\nimport javax.inject.Inject;\n\n/**\n * Basic {@link MembersInjector} implementations used by the framework.\n *\n * @author Gregory Kick\n * @since 2.0\n */\npublic final class MembersInjectors {\n  /**\n   * Injects members into {@code instance} using {@code membersInjector}.  This method is a\n   * convenience for cases in which you would want to chain members injection, but can\u0027t because\n   * {@link MembersInjector#injectMembers} returns {@code void}.\n   */\n  public static \u003cT\u003e T injectMembers(MembersInjector\u003cT\u003e membersInjector, T instance) {\n    membersInjector.injectMembers(instance);\n    return instance;\n  }\n\n  /**\n   * Returns a {@link MembersInjector} implementation that injects no members\n   *\n   * \u003cp\u003eNote that there is no verification that the type being injected does not have {@link Inject}\n   * members, so care should be taken to ensure appropriate use.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static \u003cT\u003e MembersInjector\u003cT\u003e noOp() {\n    return (MembersInjector\u003cT\u003e) NoOpMembersInjector.INSTANCE;\n  }\n\n  private static enum NoOpMembersInjector implements MembersInjector\u003cObject\u003e {\n    INSTANCE;\n\n    @Override public void injectMembers(Object instance) {\n      checkNotNull(instance);\n    }\n  }\n\n  /**\n   * Returns a {@link MembersInjector} that delegates to the {@link MembersInjector} of its\n   * supertype.  This is useful for cases where a type is known not to have its own {@link Inject}\n   * members, but must still inject members on its supertype(s).\n   *\n   * \u003cp\u003eNote that there is no verification that the type being injected does not have {@link Inject}\n   * members, so care should be taken to ensure appropriate use.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static \u003cT\u003e MembersInjector\u003cT\u003e delegatingTo(MembersInjector\u003c? super T\u003e delegate) {\n    return (MembersInjector\u003cT\u003e) checkNotNull(delegate);\n  }\n\n  private MembersInjectors() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\Preconditions.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\n/**\n * An adaptation of Guava\u0027s {@code com.google.common.base.Preconditions} that is specially tailored\n * to support checks applied in Dagger\u0027s generated code.\n */\npublic final class Preconditions {\n  /**\n   * Ensures that an object reference passed as a parameter to the calling method is not null.\n   *\n   * @param reference an object reference\n   * @return the non-null reference that was validated\n   * @throws NullPointerException if {@code reference} is null\n   */\n  public static \u003cT\u003e T checkNotNull(T reference) {\n    if (reference \u003d\u003d null) {\n      throw new NullPointerException();\n    }\n    return reference;\n  }\n\n  /**\n   * Ensures that an object reference passed as a parameter to the calling method is not null.\n   *\n   * @param reference an object reference\n   * @param errorMessage the exception message to use if the check fails\n   * @return the non-null reference that was validated\n   * @throws NullPointerException if {@code reference} is null\n   */\n  public static \u003cT\u003e T checkNotNull(T reference, String errorMessage) {\n    if (reference \u003d\u003d null) {\n      throw new NullPointerException(errorMessage);\n    }\n    return reference;\n  }\n\n  private Preconditions() {}\n}\n\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\ProviderOfLazy.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport static dagger.internal.Preconditions.checkNotNull;\n\nimport dagger.Lazy;\nimport javax.inject.Provider;\n\n/**\n * A {@link Provider} of {@link Lazy} instances that each delegate to a given {@link Provider}.\n */\npublic final class ProviderOfLazy\u003cT\u003e implements Provider\u003cLazy\u003cT\u003e\u003e {\n\n  private final Provider\u003cT\u003e provider;\n\n  private ProviderOfLazy(Provider\u003cT\u003e provider) {\n    assert provider !\u003d null;\n    this.provider \u003d provider;\n  }\n\n  /**\n   * Returns a new instance of {@link Lazy Lazy\u0026lt;T\u0026gt;}, which calls {@link Provider#get()} at\n   * most once on the {@link Provider} held by this object.\n   */\n  @Override\n  public Lazy\u003cT\u003e get() {\n    return DoubleCheck.lazy(provider);\n  }\n\n  /**\n   * Creates a new {@link Provider Provider\u0026lt;Lazy\u0026lt;T\u0026gt;\u0026gt;} that decorates the given\n   * {@link Provider}.\n   *\n   * @see #get()\n   */\n  public static \u003cT\u003e Provider\u003cLazy\u003cT\u003e\u003e create(Provider\u003cT\u003e provider) {\n    return new ProviderOfLazy\u003cT\u003e(checkNotNull(provider));\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\SetFactory.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport static dagger.internal.DaggerCollections.hasDuplicates;\nimport static dagger.internal.DaggerCollections.newHashSetWithExpectedSize;\nimport static dagger.internal.DaggerCollections.presizedList;\nimport static dagger.internal.Preconditions.checkNotNull;\nimport static java.util.Collections.emptySet;\nimport static java.util.Collections.unmodifiableSet;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport javax.inject.Provider;\n\n/**\n * A {@link Factory} implementation used to implement {@link Set} bindings. This factory always\n * returns a new {@link Set} instance for each call to {@link #get} (as required by {@link Factory})\n * whose elements are populated by subsequent calls to their {@link Provider#get} methods.\n *\n * @author Gregory Kick\n * @since 2.0\n */\npublic final class SetFactory\u003cT\u003e implements Factory\u003cSet\u003cT\u003e\u003e {\n  private static final Factory\u003cSet\u003cObject\u003e\u003e EMPTY_FACTORY \u003d\n      new Factory\u003cSet\u003cObject\u003e\u003e() {\n        @Override\n        public Set\u003cObject\u003e get() {\n          return emptySet();\n        }\n      };\n\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // safe covariant cast\n  public static \u003cT\u003e Factory\u003cSet\u003cT\u003e\u003e empty() {\n    return (Factory) EMPTY_FACTORY;\n  }\n\n  /**\n   * Constructs a new {@link Builder} for a {@link SetFactory} with {@code individualProviderSize}\n   * individual {@code Provider\u003cT\u003e} and {@code collectionProviderSize} {@code\n   * Provider\u003cCollection\u003cT\u003e\u003e} instances.\n   */\n  public static \u003cT\u003e Builder\u003cT\u003e builder(int individualProviderSize, int collectionProviderSize) {\n    return new Builder\u003cT\u003e(individualProviderSize, collectionProviderSize);\n  }\n\n  /**\n   * A builder to accumulate {@code Provider\u003cT\u003e} and {@code Provider\u003cCollection\u003cT\u003e\u003e} instances.\n   * These are only intended to be single-use and from within generated code. Do \u003cem\u003eNOT\u003c/em\u003e add\n   * providers after calling {@link #build()}.\n   */\n  public static final class Builder\u003cT\u003e {\n    private final List\u003cProvider\u003cT\u003e\u003e individualProviders;\n    private final List\u003cProvider\u003cCollection\u003cT\u003e\u003e\u003e collectionProviders;\n\n    private Builder(int individualProviderSize, int collectionProviderSize) {\n      individualProviders \u003d presizedList(individualProviderSize);\n      collectionProviders \u003d presizedList(collectionProviderSize);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public Builder\u003cT\u003e addProvider(Provider\u003c? extends T\u003e individualProvider) {\n      assert individualProvider !\u003d null : \"Codegen error? Null provider\";\n      // TODO(ronshapiro): Store a List\u003c? extends Provider\u003cT\u003e\u003e and avoid the cast to Provider\u003cT\u003e\n      individualProviders.add((Provider\u003cT\u003e) individualProvider);\n      return this;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public Builder\u003cT\u003e addCollectionProvider(\n        Provider\u003c? extends Collection\u003c? extends T\u003e\u003e collectionProvider) {\n      assert collectionProvider !\u003d null : \"Codegen error? Null provider\";\n      collectionProviders.add((Provider\u003cCollection\u003cT\u003e\u003e) collectionProvider);\n      return this;\n    }\n\n    public SetFactory\u003cT\u003e build() {\n      assert !hasDuplicates(individualProviders)\n          : \"Codegen error?  Duplicates in the provider list\";\n      assert !hasDuplicates(collectionProviders)\n          : \"Codegen error?  Duplicates in the provider list\";\n\n      return new SetFactory\u003cT\u003e(individualProviders, collectionProviders);\n    }\n  }\n\n  private final List\u003cProvider\u003cT\u003e\u003e individualProviders;\n  private final List\u003cProvider\u003cCollection\u003cT\u003e\u003e\u003e collectionProviders;\n\n  private SetFactory(\n      List\u003cProvider\u003cT\u003e\u003e individualProviders, List\u003cProvider\u003cCollection\u003cT\u003e\u003e\u003e collectionProviders) {\n    this.individualProviders \u003d individualProviders;\n    this.collectionProviders \u003d collectionProviders;\n  }\n\n  /**\n   * Returns a {@link Set} whose iteration order is that of the elements given by each of the\n   * providers, which are invoked in the order given at creation.\n   *\n   * @throws NullPointerException if any of the delegate {@link Set} instances or elements therein\n   *     are {@code null}\n   */\n  @Override\n  public Set\u003cT\u003e get() {\n    int size \u003d individualProviders.size();\n    // Profiling revealed that this method was a CPU-consuming hotspot in some applications, so\n    // these loops were changed to use c-style for.  Versus enhanced for-each loops, C-style for is\n    // faster for ArrayLists, at least through Java 8.\n\n    List\u003cCollection\u003cT\u003e\u003e providedCollections \u003d\n        new ArrayList\u003cCollection\u003cT\u003e\u003e(collectionProviders.size());\n    for (int i \u003d 0, c \u003d collectionProviders.size(); i \u003c c; i++) {\n      Collection\u003cT\u003e providedCollection \u003d collectionProviders.get(i).get();\n      size +\u003d providedCollection.size();\n      providedCollections.add(providedCollection);\n    }\n\n    Set\u003cT\u003e providedValues \u003d newHashSetWithExpectedSize(size);\n    for (int i \u003d 0, c \u003d individualProviders.size(); i \u003c c; i++) {\n      providedValues.add(checkNotNull(individualProviders.get(i).get()));\n    }\n    for (int i \u003d 0, c \u003d providedCollections.size(); i \u003c c; i++) {\n      for (T element : providedCollections.get(i)) {\n        providedValues.add(checkNotNull(element));\n      }\n    }\n\n    return unmodifiableSet(providedValues);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\internal\\SingleCheck.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport static dagger.internal.Preconditions.checkNotNull;\n\nimport dagger.Lazy;\nimport javax.inject.Provider;\n\n/**\n * A {@link Provider} implementation that memoizes the result of another {@link Provider} using\n * simple lazy initialization, not the double-checked lock pattern.\n */\npublic final class SingleCheck\u003cT\u003e implements Provider\u003cT\u003e, Lazy\u003cT\u003e {\n  private static final Object UNINITIALIZED \u003d new Object();\n\n  private volatile Provider\u003cT\u003e provider;\n  private volatile Object instance \u003d UNINITIALIZED;\n\n  private SingleCheck(Provider\u003cT\u003e provider) {\n    assert provider !\u003d null;\n    this.provider \u003d provider;\n  }\n\n  @SuppressWarnings(\"unchecked\") // cast only happens when result comes from the delegate provider\n  @Override\n  public T get() {\n    // provider is volatile and might become null after the check to instance \u003d\u003d UNINITIALIZED, so\n    // retrieve the provider first, which should not be null if instance is UNINITIALIZED.\n    // This relies upon instance also being volatile so that the reads and writes of both variables\n    // cannot be reordered.\n    Provider\u003cT\u003e providerReference \u003d provider;\n    if (instance \u003d\u003d UNINITIALIZED) {\n      instance \u003d providerReference.get();\n      // Null out the reference to the provider. We are never going to need it again, so we can make\n      // it eligible for GC.\n      provider \u003d null;\n    }\n    return (T) instance;\n  }\n\n  /** Returns a {@link Provider} that caches the value from the given delegate provider. */\n  public static \u003cT\u003e Provider\u003cT\u003e provider(Provider\u003cT\u003e provider) {\n    // If a scoped @Binds delegates to a scoped binding, don\u0027t cache the value again.\n    if (provider instanceof SingleCheck || provider instanceof DoubleCheck) {\n      return provider;\n    }\n    return new SingleCheck\u003cT\u003e(checkNotNull(provider));\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\Lazy.java",
    "code": "\"/*\n * Copyright (C) 2012 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger;\n\n/**\n * A handle to a lazily-computed value. Each {@code Lazy} computes its value on\n * the first call to {@code get()} and remembers that same value for all\n * subsequent calls to {@code get()}.\n *\n * \u003ch2\u003eExample\u003c/h2\u003e\n * The differences between \u003cstrong\u003edirect injection\u003c/strong\u003e, \u003cstrong\u003eprovider\n * injection\u003c/strong\u003e and \u003cstrong\u003elazy injection\u003c/strong\u003e are best demonstrated\n * with an example. Start with a module that computes a different integer for\n * each use:\u003cpre\u003e\u003ccode\u003e\n *   {@literal @Module}\n *   final class CounterModule {\n *     int next \u003d 100;\n *\n *     {@literal @Provides} Integer provideInteger() {\n *       System.out.println(\"computing...\");\n *       return next++;\n *     }\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003ch3\u003eDirect Injection\u003c/h3\u003e\n * This class injects that integer and prints it 3 times:\u003cpre\u003e\u003ccode\u003e\n *   final class DirectCounter {\n *     {@literal @Inject} Integer value;\n *\n *     void print() {\n *       System.out.println(\"printing...\");\n *       System.out.println(value);\n *       System.out.println(value);\n *       System.out.println(value);\n *     }\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n * Injecting a {@code DirectCounter} and invoking {@code print()} reveals that\n * the value is computed \u003ci\u003ebefore\u003c/i\u003e it is required:\u003cpre\u003e\u003ccode\u003e\n *   computing...\n *   printing...\n *   100\n *   100\n *   100\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003ch3\u003eProvider Injection\u003c/h3\u003e\n * This class injects a {@linkplain javax.inject.Provider provider} for the\n * integer. It calls {@code Provider.get()} 3 times and prints each result:\n * \u003cpre\u003e\u003ccode\u003e\n *   final class ProviderCounter {\n *     {@literal @Inject Provider\u003cInteger\u003e provider;}\n *\n *     void print() {\n *       System.out.println(\"printing...\");\n *       System.out.println(provider.get());\n *       System.out.println(provider.get());\n *       System.out.println(provider.get());\n *     }\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n * Injecting a {@code ProviderCounter} and invoking {@code print()} shows that\n * a new value is computed each time {@code Provider.get()} is used:\u003cpre\u003e\u003ccode\u003e\n *   printing...\n *   computing...\n *   100\n *   computing...\n *   101\n *   computing...\n *   102\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003ch3\u003eLazy Injection\u003c/h3\u003e\n * This class injects a {@code Lazy} for the integer. Like the provider above,\n * it calls {@code Lazy.get()} 3 times and prints each result:\u003cpre\u003e\u003ccode\u003e\n *   final class LazyCounter {\n *     {@literal @Inject Lazy\u003cInteger\u003e lazy;}\n *\n *     void print() {\n *       System.out.println(\"printing...\");\n *       System.out.println(lazy.get());\n *       System.out.println(lazy.get());\n *       System.out.println(lazy.get());\n *     }\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n * Injecting a {@code LazyCounter} and invoking {@code print()} shows that a new\n * value is computed immediately before it is needed. The same value is returned\n * for all subsequent uses:\u003cpre\u003e\u003ccode\u003e\n *   printing...\n *   computing...\n *   100\n *   100\n *   100\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003ch3\u003eLazy !\u003d Singleton\u003c/h3\u003e\n * Note that each injected {@code Lazy} is independent, and remembers its value\n * in isolation of other {@code Lazy} instances. In this example, two {@code\n * LazyCounter} objects are created and {@code print()} is called on each:\n * \u003cpre\u003e\u003ccode\u003e\n *   final class LazyCounters {\n *     {@literal @Inject} LazyCounter counter1;\n *     {@literal @Inject} LazyCounter counter2;\n *\n *     void print() {\n *       counter1.print();\n *       counter2.print();\n *     }\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n * The output demonstrates that each {@code Lazy} works independently:\n * \u003cpre\u003e\u003ccode\u003e\n *   printing...\n *   computing...\n *   100\n *   100\n *   100\n *   printing...\n *   computing...\n *   101\n *   101\n *   101\n * \u003c/code\u003e\u003c/pre\u003e\n * Use {@link javax.inject.Singleton @Singleton} to share one instance among all\n * clients, and {@code Lazy} for lazy computation in a single client.\n */\npublic interface Lazy\u003cT\u003e {\n  /**\n   * Return the underlying value, computing the value if necessary. All calls to\n   * the same {@code Lazy} instance will return the same result.\n   */\n  T get();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\MapKey.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger;\n\nimport static java.lang.annotation.ElementType.ANNOTATION_TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.util.Map;\n\n/**\n * Identifies annotation types that are used to associate keys with values returned by\n * {@linkplain Provides provider methods} in order to compose a {@linkplain\n * dagger.multibindings.IntoMap map}.\n *\n * \u003cp\u003eEvery provider method annotated with {@code @Provides} and {@code @IntoMap} must also have an\n * annotation that identifies the key for that map entry. That annotation\u0027s type must be annotated\n * with {@code @MapKey}.\n *\n * \u003cp\u003eTypically, the key annotation has a single member, whose value is used as the map key.\n *\n * \u003cp\u003eFor example, to add an entry to a {@code Map\u003cSomeEnum, Integer\u003e} with key\n * {@code SomeEnum.FOO}, you could use an annotation called {@code @SomeEnumKey}:\n *\n * \u003cpre\u003e\u003ccode\u003e\n * {@literal @}MapKey\n * {@literal @}interface SomeEnumKey {\n *   SomeEnum value();\n * }\n *\n * {@literal @}Module\n * class SomeModule {\n *   {@literal @}Provides\n *   {@literal @}IntoMap\n *   {@literal @}SomeEnumKey(SomeEnum.FOO)\n *   Integer provideFooValue() {\n *     return 2;\n *   }\n * }\n *\n * class SomeInjectedType {\n *   {@literal @}Inject\n *   SomeInjectedType({@literal Map\u003cSomeEnum, Integer\u003e} map) {\n *     assert map.get(SomeEnum.FOO) \u003d\u003d 2;\n *   }\n * }\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003cp\u003eIf {@code unwrapValue} is true, the annotation\u0027s single member can be any type except an\n * array.\n * \n * \u003cp\u003eSee {@link dagger.multibindings} for standard unwrapped map key annotations for keys that are\n * boxed primitives, strings, or classes.\n *\n * \u003ch2\u003eAnnotations as keys\u003c/h2\u003e\n *\n * \u003cp\u003eIf {@link #unwrapValue} is false, then the annotation itself is used as the map key. For\n * example, to add an entry to a {@code Map\u003cMyMapKey, Integer\u003e} map:\n *\n * \u003cpre\u003e\u003ccode\u003e\n * {@literal @}MapKey(unwrapValue \u003d false)\n * {@literal @}interface MyMapKey {\n *   String someString();\n *   MyEnum someEnum();\n * }\n *\n * {@literal @}Module\n * class SomeModule {\n *   {@literal @}Provides\n *   {@literal @}IntoMap\n *   {@literal @}MyMapKey(someString \u003d \"foo\", someEnum \u003d BAR)\n *   Integer provideFooBarValue() {\n *     return 2;\n *   }\n * }\n *\n * class SomeInjectedType {\n *   {@literal @}Inject\n *   SomeInjectedType({@literal Map\u003cMyMapKey, Integer\u003e} map) {\n *     assert map.get(new MyMapKeyImpl(\"foo\", MyEnum.BAR)) \u003d\u003d 2;\n *   }\n * }\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003cp\u003e(Note that there must be a class {@code MyMapKeyImpl} that implements {@code MyMapKey} in\n * order to call {@link Map#get(Object)} on the provided map.)\n *\n * @see \u003ca href\u003d\"http://google.github.io/dagger/multibindings#map-multibindings\"\u003eMap\n *      multibinding\u003c/a\u003e\n */\n@Documented\n@Target(ANNOTATION_TYPE)\n@Retention(RUNTIME)\n@Beta\npublic @interface MapKey {\n  /**\n   * True to use the value of the single member of the annotated annotation as the map key; false\n   * to use the annotation instance as the map key.\n   *\n   * \u003cp\u003eIf true, the single member must not be an array.\n   */\n  boolean unwrapValue() default true;\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\MembersInjector.java",
    "code": "\"/*\n * Copyright (C) 2012 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger;\n\n/**\n * Injects dependencies into the fields and methods on instances of type {@code T}. Ignores the\n * presence or absence of an injectable constructor.\n *\n * @param \u003cT\u003e type to inject members of\n *\n * @author Bob Lee\n * @author Jesse Wilson\n * @since 2.0 (since 1.0 without the provision that {@link #injectMembers} cannot accept\n *      {@code null})\n */\npublic interface MembersInjector\u003cT\u003e {\n\n  /**\n   * Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or\n   * absence of an injectable constructor.\n   *\n   * \u003cp\u003eWhenever the object graph creates an instance, it performs this injection automatically\n   * (after first performing constructor injection), so if you\u0027re able to let the object graph\n   * create all your objects for you, you\u0027ll never need to use this method.\n   *\n   * @param instance into which members are to be injected\n   * @throws NullPointerException if {@code instance} is {@code null}\n   */\n  void injectMembers(T instance);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\Module.java",
    "code": "\"/*\n * Copyright (C) 2012 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger;\n\nimport dagger.internal.Beta;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Annotates a class that contributes to the object graph.\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface Module {\n  /**\n   * Additional {@code @Module}-annotated classes from which this module is\n   * composed. The de-duplicated contributions of the modules in\n   * {@code includes}, and of their inclusions recursively, are all contributed\n   * to the object graph.\n   */\n  Class\u003c?\u003e[] includes() default {};\n\n  /**\n   * Any {@link Subcomponent}- or {@code @ProductionSubcomponent}-annotated classes which should be\n   * children of the component in which this module is installed. A subcomponent may be listed in\n   * more than one module in a component.\n   *\n   * @since 2.7\n   */\n  @Beta\n  Class\u003c?\u003e[] subcomponents() default {};\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\multibindings\\ClassKey.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.multibindings;\n\nimport static java.lang.annotation.ElementType.METHOD;\n\nimport dagger.MapKey;\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Target;\n\n/**\n * A {@link MapKey} annotation for maps with {@code Class\u003c?\u003e} keys.\n * \n * \u003cp\u003eIf your map\u0027s keys can be constrained, consider using a custom annotation instead, with a\n * member whose type is {@code Class\u003c? extends Something\u003e}.\n */\n@Beta\n@Documented\n@Target(METHOD)\n@MapKey\npublic @interface ClassKey {\n  Class\u003c?\u003e value();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\multibindings\\ElementsIntoSet.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.multibindings;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n/**\n * The method\u0027s return type is {@code Set\u003cT\u003e} and all values are contributed to the set. The {@code\n * Set\u003cT\u003e} produced from the accumulation of values will be immutable. An example use is to provide\n * a default empty set binding, which is otherwise not possible using {@link IntoSet}.\n *\n * @see \u003ca href\u003d\"http://google.github.io/dagger/multibindings#set-multibindings\"\u003eSet\n *      multibinding\u003c/a\u003e\n */\n@Documented\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface ElementsIntoSet {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\multibindings\\IntKey.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.multibindings;\n\nimport static java.lang.annotation.ElementType.METHOD;\n\nimport dagger.MapKey;\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Target;\n\n/** A {@link MapKey} annotation for maps with {@code int} keys. */\n@Beta\n@Documented\n@Target(METHOD)\n@MapKey\npublic @interface IntKey {\n  int value();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\multibindings\\IntoMap.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.multibindings;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n/**\n * The method\u0027s return type forms the type argument for the value of a\n * {@code Map\u003cK, Provider\u003cV\u003e\u003e}, and the combination of the annotated key and the returned value\n * is contributed to the map as a key/value pair. The {@code Map\u003cK, Provider\u003cV\u003e\u003e} produced from\n * the accumulation of values will be immutable.\n *\n * @see \u003ca href\u003d\"http://google.github.io/dagger/multibindings#map-multibindings\"\u003eMap\n *      multibinding\u003c/a\u003e\n */\n@Documented\n@Target(METHOD)\n@Retention(RUNTIME)\n@Beta\npublic @interface IntoMap {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\multibindings\\IntoSet.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.multibindings;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n/**\n * The method\u0027s return type forms the generic type argument of a {@code Set\u003cT\u003e}, and the\n * returned value is contributed to the set. The object graph will pass dependencies to the\n * method as parameters. The {@code Set\u003cT\u003e} produced from the accumulation of values will be\n * immutable.\n *\n * @see \u003ca href\u003d\"http://google.github.io/dagger/multibindings#set-multibindings\"\u003eSet\n *      multibinding\u003c/a\u003e\n */\n@Documented\n@Target(METHOD)\n@Retention(RUNTIME)\npublic @interface IntoSet {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\multibindings\\LongKey.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.multibindings;\n\nimport static java.lang.annotation.ElementType.METHOD;\n\nimport dagger.MapKey;\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Target;\n\n/** A {@link MapKey} annotation for maps with {@code long} keys. */\n@Beta\n@Documented\n@Target(METHOD)\n@MapKey\npublic @interface LongKey {\n  long value();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\multibindings\\Multibinds.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.multibindings;\n\nimport static java.lang.annotation.ElementType.METHOD;\n\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Target;\n\n/**\n * Annotates abstract module methods that declare multibindings.\n *\n * \u003cp\u003eYou can declare that a multibound set or map is bound by annotating an abstract module method\n * that returns the set or map you want to declare with {@code @Multibinds}.\n *\n * \u003cp\u003eYou do not have to use {@code @Multibinds} for sets or maps that have at least one\n * contribution, but you do have to declare them if they may be empty.\n *\n * \u003cpre\u003e\u003ccode\u003e\n *   {@literal @Module} abstract class MyModule {\n *     {@literal @Multibinds Set\u003cFoo\u003e aSet();}\n *     {@literal @Multibinds @MyQualifier Set\u003cFoo\u003e aQualifiedSet();}\n *     {@literal @Multibinds Map\u003cString, Foo\u003e aMap();}\n *     {@literal @Multibinds @MyQualifier Map\u003cString, Foo\u003e aQualifiedMap();}\n *\n *     {@literal @Provides}\n *     {@literal static Object usesMultibindings(Set\u003cFoo\u003e set, @MyQualifier Map\u003cString, Foo\u003e map}) {\n *       return …\n *     }\n *   }\u003c/code\u003e\u003c/pre\u003e\n *\n * \u003cp\u003eA given set or map multibinding can be declared any number of times without error. Dagger\n * never implements calls any {@code @Multibinds} methods.\n *\n * @see \u003ca href\u003d\"http://google.github.io/dagger/multibindings\"\u003eMultibindings\u003c/a\u003e\n */\n@Documented\n@Target(METHOD)\n@Beta\npublic @interface Multibinds {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\multibindings\\package-info.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This package contains the API by which Dagger allows you to bind several objects into a\n * collection that can be injected without depending directly on each of the individual bindings.\n *\n * @see \u003ca href\u003d\"http://google.github.io/dagger/multibindings\"\u003eMultibindings in the Dagger\n *      User\u0027s Guide\u003c/a\u003e\n */\n\npackage dagger.multibindings;\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\multibindings\\StringKey.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.multibindings;\n\nimport static java.lang.annotation.ElementType.METHOD;\n\nimport dagger.MapKey;\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Target;\n\n/** A {@link MapKey} annotation for maps with {@link String} keys. */\n@Beta\n@Documented\n@Target(METHOD)\n@MapKey\npublic @interface StringKey {\n  String value();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\Multibindings.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger;\n\nimport static java.lang.annotation.ElementType.TYPE;\n\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Target;\n\n/**\n * Annotates interfaces that declare multibindings.\n *\n * \u003cp\u003eYou can declare that a multibound set or map is bound by nesting a\n * {@code @Multibindings}-annotated interface within a module, with methods that return the sets or\n * maps you want to declare.\n *\n * \u003cp\u003eYou do not have to use {@code @Multibindings} for sets or maps that have at least one\n * contribution, but you do have to declare them if they may be empty.\n *\n * \u003cpre\u003e\u003ccode\u003e\n * {@literal @Module}\n * class MyModule {\n *   {@literal @Multibindings}\n *   interface MyMultibindings {\n *     {@literal Set\u003cFoo\u003e} aSet();\n *     {@literal @MyQualifier Set\u003cFoo\u003e} aQualifiedSet();\n *     {@literal Map\u003cString, Foo\u003e} aMap();\n *     {@literal @MyQualifier Map\u003cString, Foo\u003e} aQualifiedMap();\n *   }\n *\n *   {@literal @Provides}\n *   static Object usesMultibindings(\n *       {@literal Set\u003cFoo\u003e} set, {@literal @MyQualifier Map\u003cString, Foo\u003e} map) {\n *     return …\n *   }\n * }\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003cp\u003eAll methods on the interface and any supertypes (except for methods on {@link Object}) are\n * used to declare multibindings. The names of the interface and its methods are ignored. A given\n * set or map multibinding can be declared any number of times without error. Dagger never\n * implements the interface or calls any of its methods.\n *\n * @see \u003ca href\u003d\"http://google.github.io/dagger/multibindings\"\u003eMultibindings\u003c/a\u003e\n */\n@Documented\n@Target(TYPE)\n@Beta\npublic @interface Multibindings {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\package-info.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This package contains the public API for the \u003ca href\u003d\"http://google.github.io/dagger/\"\u003eDagger\n * 2\u003c/a\u003e dependency injection framework.  By building upon\n * \u003ca href\u003d\"https://jcp.org/en/jsr/detail?id\u003d330\"\u003eJSR 330\u003c/a\u003e, Dagger 2 provides an\n * annotation-driven API for dependency injection whose implementation is entirely generated at\n * compile time by \u003ca href\u003d\"http://en.wikipedia.org/wiki/Java_annotation#Processing\"\u003eannotation\n * processors\u003c/a\u003e.\n *\n * \u003cp\u003eThe entry point into the API is the {@link Component}, which annotates abstract types for\n * Dagger 2 to implement.  The dependency graph is configured using using annotations such as\n * {@link Module}, {@link Provides} and {@link javax.inject.Inject}.\n *\n * \u003cp\u003e{@code dagger.internal.codegen.ComponentProcessor} is the processor responsible for generating\n * the implementation.  Dagger uses the annotation procesor\n * {@linkplain java.util.ServiceLoader service loader} to automatically configure the processor, so\n * explict build configuration shouldn\u0027t be necessary.\n */\n\npackage dagger;\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\Provides.java",
    "code": "\"/*\n * Copyright (C) 2007 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n/**\n * Annotates methods of a {@linkplain Module module} to create a provider method binding. The\n * method\u0027s return type is bound to its returned value. The {@linkplain Component component}\n * implementation will pass dependencies to the method as parameters.\n *\n * \u003ch3\u003eNullability\u003c/h3\u003e\n *\n * \u003cp\u003eDagger forbids injecting {@code null} by default. Component implemenations that invoke\n * {@code @Provides} methods that return {@code null} will throw a {@link NullPointerException}\n * immediately thereafter. {@code @Provides} methods may opt into allowing {@code null} by\n * annotating the method with any {@code @Nullable} annotation like\n * {@code javax.annotation.Nullable} or {@code android.support.annotation.Nullable}.\n *\n * \u003cp\u003eIf a {@code @Provides} method is marked {@code @Nullable}, Dagger will \u003cem\u003eonly\u003c/em\u003e\n * allow injection into sites that are marked {@code @Nullable} as well. A component that\n * attempts to pair a {@code @Nullable} provision with a non-{@code @Nullable} injection site\n * will fail to compile.\n *\n * @author Bob Lee\n */\n@Documented @Target(METHOD) @Retention(RUNTIME)\npublic @interface Provides {\n  /** The type of binding into which the return type of the annotated method contributes. */\n  enum Type {\n    /**\n     * The method is the only one which can produce the value for the specified return type. This\n     * is the default behavior.\n     */\n    UNIQUE,\n\n    /**\n     * The method\u0027s return type forms the generic type argument of a {@code Set\u003cT\u003e}, and the\n     * returned value is contributed to the set. The object graph will pass dependencies to the\n     * method as parameters. The {@code Set\u003cT\u003e} produced from the accumulation of values will be\n     * immutable.\n     *\n     * @see \u003ca href\u003d\"http://google.github.io/dagger/multibindings#set-multibindings\"\u003eSet\n     *      multibinding\u003c/a\u003e\n     */\n    SET,\n\n    /**\n     * Like {@link #SET}, except the method\u0027s return type is {@code Set\u003cT\u003e}, where any values are\n     * contributed to the set. An example use is to provide a default empty set binding, which is\n     * otherwise not possible using {@link #SET}.\n     *\n     * @see \u003ca href\u003d\"http://google.github.io/dagger/multibindings#set-multibindings\"\u003eSet\n     *      multibinding\u003c/a\u003e\n     */\n    SET_VALUES,\n\n    /**\n     * The method\u0027s return type forms the type argument for the value of a\n     * {@code Map\u003cK, Provider\u003cV\u003e\u003e}, and the combination of the annotated key and the returned value\n     * is contributed to the map as a key/value pair. The {@code Map\u003cK, Provider\u003cV\u003e\u003e} produced from\n     * the accumulation of values will be immutable.\n     *\n     * @see \u003ca href\u003d\"http://google.github.io/dagger/multibindings#map-multibindings\"\u003eMap\n     *      multibinding\u003c/a\u003e\n     */\n    @Beta\n    MAP;\n  }\n\n  Type type() default Type.UNIQUE;\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\Reusable.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport javax.inject.Scope;\n\n/**\n * A scope that indicates that the object returned by a binding may be (but might not be) reused.\n *\n * \u003cp\u003e{@code @Reusable} is useful when you want to limit the number of provisions of a type, but\n * there is no specific lifetime over which there must be only one instance.\n *\n * @see \u003ca href\u003d\"http://google.github.io/dagger/users-guide.html#reusable-scope\"\u003eReusable Scope\u003c/a\u003e\n */\n@Documented\n@Beta\n@Retention(RUNTIME)\n@Scope\npublic @interface Reusable {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\main\\java\\dagger\\Subcomponent.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger;\n\nimport static java.lang.annotation.ElementType.TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n/**\n * A subcomponent that inherits the bindings from a parent {@link Component} or\n * {@link Subcomponent}. The details of how to associate a subcomponent with a parent are described\n * in the documentation for {@link Component}.\n *\n * @author Gregory Kick\n * @since 2.0\n */\n@Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.\n@Target(TYPE)\n@Documented\npublic @interface Subcomponent {\n  /**\n   * A list of classes annotated with {@link Module} whose bindings are used to generate the\n   * subcomponent implementation.  Note that through the use of {@link Module#includes} the full set\n   * of modules used to implement the subcomponent may include more modules that just those listed\n   * here.\n   */\n  Class\u003c?\u003e[] modules() default {};\n  \n  /**\n   * A builder for a subcomponent.  This follows all the rules of {@link Component.Builder}, except\n   * it must appear in classes annotated with {@link Subcomponent} instead of {@code Component}.\n   * Components can have methods that return a {@link Subcomponent.Builder}-annotated type,\n   * allowing the user to set modules on the subcomponent using their defined API.\n   */\n  @Target(TYPE)\n  @Documented\n  @interface Builder {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\test\\java\\dagger\\internal\\DoubleCheckTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport com.google.common.util.concurrent.Uninterruptibles;\nimport dagger.Lazy;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport javax.inject.Provider;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic class DoubleCheckTest {\n  @Test\n  public void provider_nullPointerException() {\n    try {\n      DoubleCheck.provider(null);\n      fail();\n    } catch (NullPointerException expected) {\n    }\n  }\n\n  @Test\n  public void lazy_nullPointerException() {\n    try {\n      DoubleCheck.lazy(null);\n      fail();\n    } catch (NullPointerException expected) {\n    }\n  }\n\n  private static final Provider\u003cObject\u003e DOUBLE_CHECK_OBJECT_PROVIDER \u003d\n      DoubleCheck.provider(\n          new Provider\u003cObject\u003e() {\n            @Override\n            public Object get() {\n              return new Object();\n            }\n          });\n\n  @Test\n  public void doubleWrapping_provider() {\n    assertThat(DoubleCheck.provider(DOUBLE_CHECK_OBJECT_PROVIDER))\n        .isSameAs(DOUBLE_CHECK_OBJECT_PROVIDER);\n  }\n\n  @Test\n  public void doubleWrapping_lazy() {\n    assertThat(DoubleCheck.lazy(DOUBLE_CHECK_OBJECT_PROVIDER))\n        .isSameAs(DOUBLE_CHECK_OBJECT_PROVIDER);\n  }\n\n  @Test\n  public void get() throws Exception {\n    int numThreads \u003d 10;\n    ExecutorService executor \u003d Executors.newFixedThreadPool(numThreads);\n\n    final CountDownLatch latch \u003d new CountDownLatch(numThreads);\n    LatchedProvider provider \u003d new LatchedProvider(latch);\n    final Lazy\u003cObject\u003e lazy \u003d DoubleCheck.lazy(provider);\n\n    List\u003cCallable\u003cObject\u003e\u003e tasks \u003d Lists.newArrayListWithCapacity(numThreads);\n    for (int i \u003d 0; i \u003c numThreads; i++) {\n      tasks.add(\n          new Callable\u003cObject\u003e() {\n            @Override\n            public Object call() throws Exception {\n              latch.countDown();\n              return lazy.get();\n            }\n          });\n    }\n\n    List\u003cFuture\u003cObject\u003e\u003e futures \u003d executor.invokeAll(tasks);\n\n    assertThat(provider.provisions.get()).isEqualTo(1);\n    Set\u003cObject\u003e results \u003d Sets.newIdentityHashSet();\n    for (Future\u003cObject\u003e future : futures) {\n      results.add(future.get());\n    }\n    assertThat(results).hasSize(1);\n  }\n\n  private static class LatchedProvider implements Provider\u003cObject\u003e {\n    final AtomicInteger provisions;\n    final CountDownLatch latch;\n\n    LatchedProvider(CountDownLatch latch) {\n      this.latch \u003d latch;\n      this.provisions \u003d new AtomicInteger();\n    }\n\n    @Override\n    public Object get() {\n      if (latch !\u003d null) {\n        Uninterruptibles.awaitUninterruptibly(latch);\n      }\n      provisions.incrementAndGet();\n      return new Object();\n    }\n  }\n\n  @Test public void reentranceWithoutCondition_throwsStackOverflow() {\n    final AtomicReference\u003cProvider\u003cObject\u003e\u003e doubleCheckReference \u003d\n        new AtomicReference\u003cProvider\u003cObject\u003e\u003e();\n    Provider\u003cObject\u003e doubleCheck \u003d DoubleCheck.provider(new Provider\u003cObject\u003e() {\n      @Override\n      public Object get() {\n        return doubleCheckReference.get().get();\n      }\n    });\n    doubleCheckReference.set(doubleCheck);\n    try {\n      doubleCheck.get();\n      fail();\n    } catch (StackOverflowError expected) {}\n  }\n\n  @Test public void reentranceReturningSameInstance() {\n    final AtomicReference\u003cProvider\u003cObject\u003e\u003e doubleCheckReference \u003d\n        new AtomicReference\u003cProvider\u003cObject\u003e\u003e();\n    final AtomicInteger invocationCount \u003d new AtomicInteger();\n    final Object object \u003d new Object();\n    Provider\u003cObject\u003e doubleCheck \u003d DoubleCheck.provider(new Provider\u003cObject\u003e() {\n     @Override\n      public Object get() {\n         if (invocationCount.incrementAndGet() \u003d\u003d 1) {\n          doubleCheckReference.get().get();\n        }\n        return object;\n      }\n    });\n    doubleCheckReference.set(doubleCheck);\n    assertThat(doubleCheck.get()).isSameAs(object);\n  }\n\n  @Test public void reentranceReturningDifferentInstances_throwsIllegalStateException() {\n    final AtomicReference\u003cProvider\u003cObject\u003e\u003e doubleCheckReference \u003d\n        new AtomicReference\u003cProvider\u003cObject\u003e\u003e();\n    final AtomicInteger invocationCount \u003d new AtomicInteger();\n    Provider\u003cObject\u003e doubleCheck \u003d DoubleCheck.provider(new Provider\u003cObject\u003e() {\n     @Override\n      public Object get() {\n        if (invocationCount.incrementAndGet() \u003d\u003d 1) {\n          doubleCheckReference.get().get();\n        }\n        return new Object();\n      }\n    });\n    doubleCheckReference.set(doubleCheck);\n    try {\n      doubleCheck.get();\n      fail();\n    } catch (IllegalStateException expected) {}\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\test\\java\\dagger\\internal\\InstanceFactoryTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic final class InstanceFactoryTest {\n  @Rule public final ExpectedException thrown \u003d ExpectedException.none();\n\n  @Test public void instanceFactory() {\n    Object instance \u003d new Object();\n    Factory\u003cObject\u003e factory \u003d InstanceFactory.create(instance);\n    assertThat(factory.get()).isEqualTo(instance);\n    assertThat(factory.get()).isEqualTo(instance);\n    assertThat(factory.get()).isEqualTo(instance);\n  }\n\n  @Test public void create_throwsNullPointerException() {\n    thrown.expect(NullPointerException.class);\n    InstanceFactory.create(null);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\test\\java\\dagger\\internal\\MapProviderFactoryTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport javax.inject.Provider;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\n@SuppressWarnings(\"unchecked\")\npublic class MapProviderFactoryTest {\n  @Rule\n  public ExpectedException thrown \u003d ExpectedException.none();\n\n  @Test\n  public void nullKey() {\n    thrown.expect(NullPointerException.class);\n    MapProviderFactory.\u003cString, Integer\u003ebuilder(1).put(null, incrementingIntegerProvider(1));\n  }\n\n  @Test\n  public void nullValue() {\n    thrown.expect(NullPointerException.class);\n    MapProviderFactory.\u003cString, Integer\u003ebuilder(1).put(\"Hello\", null);\n  }\n\n  @Test\n  public void iterationOrder() {\n    Provider\u003cInteger\u003e p1 \u003d incrementingIntegerProvider(10);\n    Provider\u003cInteger\u003e p2 \u003d incrementingIntegerProvider(20);\n    Provider\u003cInteger\u003e p3 \u003d incrementingIntegerProvider(30);\n    Provider\u003cInteger\u003e p4 \u003d incrementingIntegerProvider(40);\n    Provider\u003cInteger\u003e p5 \u003d incrementingIntegerProvider(50);\n\n    Factory\u003cMap\u003cString, Provider\u003cInteger\u003e\u003e\u003e factory \u003d MapProviderFactory\n        .\u003cString, Integer\u003ebuilder(4)\n        .put(\"two\", p2)\n        .put(\"one\", p1)\n        .put(\"three\", p3)\n        .put(\"one\", p5)\n        .put(\"four\", p4)\n        .build();\n\n    Map\u003cString, Provider\u003cInteger\u003e\u003e expectedMap \u003d new LinkedHashMap\u003cString, Provider\u003cInteger\u003e\u003e();\n    expectedMap.put(\"two\", p2);\n    expectedMap.put(\"one\", p1);\n    expectedMap.put(\"three\", p3);\n    expectedMap.put(\"one\", p5);\n    expectedMap.put(\"four\", p4);\n    assertThat(factory.get().entrySet())\n        .containsExactlyElementsIn(expectedMap.entrySet())\n        .inOrder();\n  }\n\n  private static Provider\u003cInteger\u003e incrementingIntegerProvider(int seed) {\n    final AtomicInteger value \u003d new AtomicInteger(seed);\n    return new Provider\u003cInteger\u003e() {\n      @Override\n      public Integer get() {\n        return value.getAndIncrement();\n      }\n    };\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\test\\java\\dagger\\internal\\SetFactoryTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.google.common.collect.ImmutableSet;\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport javax.inject.Provider;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\n@SuppressWarnings(\"unchecked\")\npublic class SetFactoryTest {\n  @Rule public ExpectedException thrown \u003d ExpectedException.none();\n\n  @Test\n  public void providerReturnsNull() {\n    Factory\u003cSet\u003cInteger\u003e\u003e factory \u003d\n        SetFactory.\u003cInteger\u003ebuilder(0, 1).addCollectionProvider(providerOf((Set\u003cInteger\u003e) null)).build();\n    thrown.expect(NullPointerException.class);\n    factory.get();\n  }\n\n  @Test\n  public void providerReturnsNullSet() {\n    Factory\u003cSet\u003cInteger\u003e\u003e factory \u003d\n        SetFactory.\u003cInteger\u003ebuilder(1, 0).addProvider(providerOf((Integer) null)).build();\n    thrown.expect(NullPointerException.class);\n    factory.get();\n  }\n\n  @Test\n  public void providerReturnsSetWithNullElement() {\n    Set\u003cInteger\u003e set \u003d new LinkedHashSet\u003cInteger\u003e(Arrays.asList(1, null, 3));\n    Factory\u003cSet\u003cInteger\u003e\u003e factory \u003d\n        SetFactory.\u003cInteger\u003ebuilder(0, 1).addCollectionProvider(providerOf(set)).build();\n    thrown.expect(NullPointerException.class);\n    factory.get();\n  }\n\n  @Test\n  public void invokesProvidersEveryTime() {\n    Factory\u003cSet\u003cInteger\u003e\u003e factory \u003d\n        SetFactory.\u003cInteger\u003ebuilder(2, 2)\n            .addProvider(incrementingIntegerProvider(0))\n            .addProvider(incrementingIntegerProvider(10))\n            .addCollectionProvider(incrementingIntegerSetProvider(20))\n            .addCollectionProvider(incrementingIntegerSetProvider(30))\n            .build();\n    assertThat(factory.get()).containsExactly(0, 10, 20, 21, 30, 31);\n    assertThat(factory.get()).containsExactly(1, 11, 22, 23, 32, 33);\n    assertThat(factory.get()).containsExactly(2, 12, 24, 25, 34, 35);\n  }\n\n  private static \u003cT\u003e Provider\u003cT\u003e providerOf(final T value) {\n    return new Provider\u003cT\u003e() {\n      @Override\n      public T get() {\n        return value;\n      }\n    };\n  }\n\n  private static Provider\u003cInteger\u003e incrementingIntegerProvider(int seed) {\n    final AtomicInteger value \u003d new AtomicInteger(seed);\n    return new Provider\u003cInteger\u003e() {\n      @Override\n      public Integer get() {\n        return value.getAndIncrement();\n      }\n    };\n  }\n\n  private static Provider\u003cSet\u003cInteger\u003e\u003e incrementingIntegerSetProvider(int seed) {\n    final AtomicInteger value \u003d new AtomicInteger(seed);\n    return new Provider\u003cSet\u003cInteger\u003e\u003e() {\n      @Override\n      public Set\u003cInteger\u003e get() {\n        return ImmutableSet.of(value.getAndIncrement(), value.getAndIncrement());\n      }\n    };\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\core\\src\\test\\java\\dagger\\internal\\SingleCheckTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.internal;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport javax.inject.Provider;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/**\n * Tests {@link SingleCheck}.\n */\n@RunWith(JUnit4.class)\npublic class SingleCheckTest {\n  @Test(expected \u003d NullPointerException.class)\n  public void create_nullPointerException() {\n    SingleCheck.provider(null);\n  }\n\n  @Test\n  public void get() {\n    Provider\u003cInteger\u003e provider \u003d\n        SingleCheck.provider(\n            new Factory\u003cInteger\u003e() {\n              int i \u003d 0;\n\n              @Override\n              public Integer get() {\n                return i++;\n              }\n            });\n    assertThat(provider.get()).isEqualTo(0);\n    assertThat(provider.get()).isEqualTo(0);\n    assertThat(provider.get()).isEqualTo(0);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-activity-graphs\\src\\main\\java\\com\\example\\dagger\\activitygraphs\\AbstractActivityComponent.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.activitygraphs;\n\nimport android.app.Activity;\nimport dagger.Component;\n\n/**\n * A base component upon which fragment\u0027s components may depend.  Activity-level components\n * should extend this component.\n */\n@PerActivity // Subtypes of AbstractActivityComponent should be decorated with @PerActivity.\n@Component(dependencies \u003d ApplicationComponent.class, modules \u003d ActivityModule.class)\npublic interface AbstractActivityComponent {\n  Activity activity(); // Expose the activity to sub-graphs.\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-activity-graphs\\src\\main\\java\\com\\example\\dagger\\activitygraphs\\ActivityModule.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.activitygraphs;\n\nimport android.app.Activity;\nimport dagger.Module;\nimport dagger.Provides;\n\n/**\n * A module to wrap the Activity state and expose it to the graph.\n */\n@Module\npublic class ActivityModule {\n  private final Activity activity;\n\n  public ActivityModule(Activity activity) {\n    this.activity \u003d activity;\n  }\n\n  /**\n   * Expose the activity to dependents in the graph.\n   */\n  @Provides @PerActivity Activity activity() {\n    return activity;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-activity-graphs\\src\\main\\java\\com\\example\\dagger\\activitygraphs\\ApplicationComponent.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.activitygraphs;\n\nimport android.app.Application;\nimport android.location.LocationManager;\nimport dagger.Component;\nimport javax.inject.Singleton;\n\n/**\n * A component whose lifetime is the life of the application.\n */\n@Singleton // Constraints this component to one-per-application or unscoped bindings.\n@Component(modules \u003d DemoApplicationModule.class)\npublic interface ApplicationComponent {\n  // Field injections of any dependencies of the DemoApplication\n  void inject(DemoApplication application);\n\n  // Exported for child-components.\n  Application application();\n  LocationManager locationManager();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-activity-graphs\\src\\main\\java\\com\\example\\dagger\\activitygraphs\\DemoApplication.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.activitygraphs;\n\nimport android.app.Application;\nimport android.location.LocationManager;\nimport javax.inject.Inject;\n\npublic class DemoApplication extends Application {\n  private ApplicationComponent applicationComponent;\n\n  // TODO(cgruber): Figure out a better example of something one might inject into the app.\n  @Inject LocationManager locationManager; // to illustrate injecting something into the app.\n\n  @Override public void onCreate() {\n    super.onCreate();\n    applicationComponent \u003d DaggerApplicationComponent.builder()\n        .demoApplicationModule(new DemoApplicationModule(this))\n        .build();\n  }\n\n  public ApplicationComponent component() {\n    return applicationComponent;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-activity-graphs\\src\\main\\java\\com\\example\\dagger\\activitygraphs\\DemoApplicationModule.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.activitygraphs;\n\nimport static android.content.Context.LOCATION_SERVICE;\n\nimport android.app.Application;\nimport android.location.LocationManager;\nimport dagger.Module;\nimport dagger.Provides;\nimport javax.inject.Singleton;\n\n/**\n * A module for Android-specific dependencies which require a {@link Context} or\n * {@link android.app.Application} to create.\n */\n@Module\npublic class DemoApplicationModule {\n  private final Application application;\n\n  public DemoApplicationModule(Application application) {\n    this.application \u003d application;\n  }\n\n  /**\n   * Expose the application to the graph.\n   */\n  @Provides @Singleton Application application() {\n    return application;\n  }\n\n  @Provides @Singleton LocationManager provideLocationManager() {\n    return (LocationManager) application.getSystemService(LOCATION_SERVICE);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-activity-graphs\\src\\main\\java\\com\\example\\dagger\\activitygraphs\\PerActivity.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.activitygraphs;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Retention;\nimport javax.inject.Scope;\n\n/**\n * A scoping annotation to permit objects whose lifetime should\n * conform to the life of the activity to be memoized in the\n * correct component.\n */\n@Scope\n@Retention(RUNTIME)\npublic @interface PerActivity {\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-activity-graphs\\src\\main\\java\\com\\example\\dagger\\activitygraphs\\ui\\ActivityTitleController.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.activitygraphs.ui;\n\nimport android.app.Activity;\nimport com.example.dagger.activitygraphs.PerActivity;\nimport javax.inject.Inject;\n\n/**\n * A simple abstraction which provides the ability to set the title on an activity.\n * \u003cp\u003e\n * Fragments should not directly modify any part of an activity outside of the view or dialog that\n * it creates. This class provides a way for fragments to inject a controller that will allow for\n * control of the activity title. While not exceedingly useful in practice, this concept could be\n * expanded to things like facilitating control over the action bar, dialogs, notifications, etc.\n */\n@PerActivity\npublic class ActivityTitleController {\n  private final Activity activity;\n\n  @Inject public ActivityTitleController(Activity activity) {\n    this.activity \u003d activity;\n  }\n\n  public void setTitle(CharSequence title) {\n    activity.setTitle(title);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-activity-graphs\\src\\main\\java\\com\\example\\dagger\\activitygraphs\\ui\\HomeActivity.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.activitygraphs.ui;\n\nimport android.location.LocationManager;\nimport android.os.Bundle;\nimport android.support.v4.app.FragmentActivity;\nimport com.example.dagger.activitygraphs.ActivityModule;\nimport com.example.dagger.activitygraphs.DemoApplication;\nimport javax.inject.Inject;\n\npublic class HomeActivity extends FragmentActivity {\n  @Inject LocationManager locationManager;\n  private HomeComponent component;\n\n  HomeComponent component() {\n    if (component \u003d\u003d null) {\n      component \u003d DaggerHomeComponent.builder()\n          .applicationComponent(((DemoApplication) getApplication()).component())\n          .activityModule(new ActivityModule(this))\n          .build();\n    }\n    return component;\n  }\n\n  @Override protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    component().inject(this);\n\n    if (savedInstanceState \u003d\u003d null) {\n      getSupportFragmentManager().beginTransaction()\n          .add(android.R.id.content, new HomeFragment())\n          .commit();\n    }\n\n    // TODO do something with the injected dependencies here!\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-activity-graphs\\src\\main\\java\\com\\example\\dagger\\activitygraphs\\ui\\HomeComponent.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.activitygraphs.ui;\n\nimport com.example.dagger.activitygraphs.AbstractActivityComponent;\nimport com.example.dagger.activitygraphs.ActivityModule;\nimport com.example.dagger.activitygraphs.ApplicationComponent;\nimport com.example.dagger.activitygraphs.PerActivity;\nimport dagger.Component;\n\n@PerActivity\n@Component(dependencies \u003d ApplicationComponent.class, modules \u003d ActivityModule.class)\npublic interface HomeComponent extends AbstractActivityComponent {\n  void inject(HomeActivity homeActivity);\n  void inject(HomeFragment homeFragment);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-activity-graphs\\src\\main\\java\\com\\example\\dagger\\activitygraphs\\ui\\HomeFragment.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.activitygraphs.ui;\n\nimport static android.view.Gravity.CENTER;\n\nimport android.os.Bundle;\nimport android.support.v4.app.Fragment;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.TextView;\nimport javax.inject.Inject;\n\npublic class HomeFragment extends Fragment {\n  @Inject ActivityTitleController titleController;\n\n  @Override public void onActivityCreated(Bundle savedInstanceState) {\n    super.onActivityCreated(savedInstanceState);\n    ((HomeActivity) getActivity()).component().inject(this);\n  }\n\n  @Override public View onCreateView(LayoutInflater inflater, ViewGroup container,\n      Bundle savedInstanceState) {\n    TextView tv \u003d new TextView(getActivity());\n    tv.setGravity(CENTER);\n    tv.setText(\"Hello, World\");\n    return tv;\n  }\n\n  @Override public void onResume() {\n    super.onResume();\n\n    // Fragments should not modify things outside of their own view. Use an external controller to\n    // ask the activity to change its title.\n    titleController.setTitle(\"Home Fragment\");\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-simple\\src\\main\\java\\com\\example\\dagger\\simple\\AndroidModule.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.simple;\n\nimport static android.content.Context.LOCATION_SERVICE;\n\nimport android.content.Context;\nimport android.location.LocationManager;\nimport dagger.Module;\nimport dagger.Provides;\nimport javax.inject.Singleton;\n\n/**\n * A module for Android-specific dependencies which require a {@link Context} or\n * {@link android.app.Application} to create.\n */\n@Module\npublic class AndroidModule {\n  private final DemoApplication application;\n\n  public AndroidModule(DemoApplication application) {\n    this.application \u003d application;\n  }\n\n  /**\n   * Allow the application context to be injected but require that it be annotated with\n   * {@link ForApplication @Annotation} to explicitly differentiate it from an activity context.\n   */\n  @Provides @Singleton @ForApplication Context provideApplicationContext() {\n    return application;\n  }\n\n  @Provides @Singleton LocationManager provideLocationManager() {\n    return (LocationManager) application.getSystemService(LOCATION_SERVICE);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-simple\\src\\main\\java\\com\\example\\dagger\\simple\\DemoActivity.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.simple;\n\nimport android.app.Activity;\nimport android.os.Bundle;\n\npublic abstract class DemoActivity extends Activity {\n  @Override protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    // Perform injection so that when this call returns all dependencies will be available for use.\n    ((DemoApplication) getApplication()).component().inject(this);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-simple\\src\\main\\java\\com\\example\\dagger\\simple\\DemoApplication.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.simple;\n\nimport android.app.Application;\nimport android.location.LocationManager;\nimport com.example.dagger.simple.ui.HomeActivity;\nimport dagger.Component;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\n\npublic class DemoApplication extends Application {\n  \n  @Singleton\n  @Component(modules \u003d AndroidModule.class)\n  public interface ApplicationComponent {\n    void inject(DemoApplication application);\n    void inject(HomeActivity homeActivity);\n    void inject(DemoActivity demoActivity);\n  }\n  \n  @Inject LocationManager locationManager; // for some reason.\n  \n  private ApplicationComponent component;\n\n  @Override public void onCreate() {\n    super.onCreate();\n    component \u003d DaggerDemoApplication_ApplicationComponent.builder()\n        .androidModule(new AndroidModule(this))\n        .build();\n    component().inject(this); // As of now, LocationManager should be injected into this.\n  }\n\n  public ApplicationComponent component() {\n    return component;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-simple\\src\\main\\java\\com\\example\\dagger\\simple\\ForApplication.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.simple;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Retention;\nimport javax.inject.Qualifier;\n\n@Qualifier @Retention(RUNTIME)\npublic @interface ForApplication {\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\android-simple\\src\\main\\java\\com\\example\\dagger\\simple\\ui\\HomeActivity.java",
    "code": "\"/*\n * Copyright (C) 2013 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.example.dagger.simple.ui;\n\nimport android.location.LocationManager;\nimport android.os.Bundle;\nimport android.util.Log;\nimport com.example.dagger.simple.DemoActivity;\nimport com.example.dagger.simple.DemoApplication;\nimport javax.inject.Inject;\n\npublic class HomeActivity extends DemoActivity {\n  @Inject LocationManager locationManager;\n\n  @Override protected void onCreate(Bundle savedInstanceState) {\n    super.onCreate(savedInstanceState);\n    ((DemoApplication) getApplication()).component().inject(this);\n\n    // TODO do something with the injected dependencies here!\n    Log.d(\"HomeActivity\", locationManager.toString());\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\simple\\src\\main\\java\\coffee\\CoffeeApp.java",
    "code": "\"package coffee;\n\nimport dagger.Component;\nimport javax.inject.Singleton;\n\npublic class CoffeeApp {\n  @Singleton\n  @Component(modules \u003d { DripCoffeeModule.class })\n  public interface Coffee {\n    CoffeeMaker maker();\n  }\n\n  public static void main(String[] args) {\n    Coffee coffee \u003d DaggerCoffeeApp_Coffee.builder().build();\n    coffee.maker().brew();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\simple\\src\\main\\java\\coffee\\CoffeeMaker.java",
    "code": "\"package coffee;\n\nimport dagger.Lazy;\nimport javax.inject.Inject;\n\nclass CoffeeMaker {\n  private final Lazy\u003cHeater\u003e heater; // Create a possibly costly heater only when we use it.\n  private final Pump pump;\n\n  @Inject CoffeeMaker(Lazy\u003cHeater\u003e heater, Pump pump) {\n    this.heater \u003d heater;\n    this.pump \u003d pump;\n  }\n\n  public void brew() {\n    heater.get().on();\n    pump.pump();\n    System.out.println(\" [_]P coffee! [_]P \");\n    heater.get().off();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\simple\\src\\main\\java\\coffee\\DripCoffeeModule.java",
    "code": "\"package coffee;\n\nimport dagger.Module;\nimport dagger.Provides;\nimport javax.inject.Singleton;\n\n@Module(includes \u003d PumpModule.class)\nclass DripCoffeeModule {\n  @Provides @Singleton Heater provideHeater() {\n    return new ElectricHeater();\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\simple\\src\\main\\java\\coffee\\ElectricHeater.java",
    "code": "\"package coffee;\n\nclass ElectricHeater implements Heater {\n  boolean heating;\n\n  @Override public void on() {\n    System.out.println(\"~ ~ ~ heating ~ ~ ~\");\n    this.heating \u003d true;\n  }\n\n  @Override public void off() {\n    this.heating \u003d false;\n  }\n\n  @Override public boolean isHot() {\n    return heating;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\simple\\src\\main\\java\\coffee\\Heater.java",
    "code": "\"package coffee;\n\ninterface Heater {\n  void on();\n  void off();\n  boolean isHot();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\simple\\src\\main\\java\\coffee\\Pump.java",
    "code": "\"package coffee;\n\ninterface Pump {\n  void pump();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\simple\\src\\main\\java\\coffee\\PumpModule.java",
    "code": "\"package coffee;\n\nimport dagger.Binds;\nimport dagger.Module;\n\n@Module\nabstract class PumpModule {\n  @Binds\n  abstract Pump providePump(Thermosiphon pump);\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\examples\\simple\\src\\main\\java\\coffee\\Thermosiphon.java",
    "code": "\"package coffee;\n\nimport javax.inject.Inject;\n\nclass Thermosiphon implements Pump {\n  private final Heater heater;\n\n  @Inject\n  Thermosiphon(Heater heater) {\n    this.heater \u003d heater;\n  }\n\n  @Override public void pump() {\n    if (heater.isHot()) {\n      System.out.println(\"\u003d\u003e \u003d\u003e pumping \u003d\u003e \u003d\u003e\");\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\internal\\AbstractProducer.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.Producer;\nimport dagger.producers.monitoring.ProducerMonitor;\nimport dagger.producers.monitoring.ProducerToken;\nimport dagger.producers.monitoring.ProductionComponentMonitor;\nimport dagger.producers.monitoring.internal.Monitors;\nimport javax.annotation.Nullable;\nimport javax.inject.Provider;\n\n/**\n * An abstract {@link Producer} implementation that memoizes the result of its compute method.\n *\n * @author Jesse Beder\n * @since 2.0\n */\npublic abstract class AbstractProducer\u003cT\u003e implements Producer\u003cT\u003e {\n  private final Provider\u003cProductionComponentMonitor\u003e monitorProvider;\n  @Nullable private final ProducerToken token;\n  private volatile ListenableFuture\u003cT\u003e instance \u003d null;\n  protected volatile ProducerMonitor monitor \u003d null;\n\n  protected AbstractProducer() {\n    this(Monitors.noOpProductionComponentMonitorProvider(), null);\n  }\n\n  protected AbstractProducer(\n      Provider\u003cProductionComponentMonitor\u003e monitorProvider, @Nullable ProducerToken token) {\n    this.monitorProvider \u003d checkNotNull(monitorProvider);\n    this.token \u003d token;\n  }\n\n  /**\n   * Computes this producer\u0027s future, which is then cached in {@link #get}. The {@link #monitor}\n   * will be non-null from the point of this call forward.\n   */\n  protected abstract ListenableFuture\u003cT\u003e compute();\n\n  @Override\n  public final ListenableFuture\u003cT\u003e get() {\n    // double-check idiom from EJ2: Item 71\n    ListenableFuture\u003cT\u003e result \u003d instance;\n    if (result \u003d\u003d null) {\n      synchronized (this) {\n        result \u003d instance;\n        if (result \u003d\u003d null) {\n          monitor \u003d monitorProvider.get().producerMonitorFor(token);\n          monitor.requested();\n          instance \u003d result \u003d compute();\n          if (result \u003d\u003d null) {\n            throw new NullPointerException(\"compute returned null\");\n          }\n          monitor.addCallbackTo(result);\n        }\n      }\n    }\n    return result;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\internal\\MapOfProducedProducer.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Maps;\nimport com.google.common.util.concurrent.AsyncFunction;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.internal.Beta;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a\n * {@code Map\u003cK, Produced\u003cV\u003e\u003e} which is populated by calls to the delegate {@link Producer#get}\n * methods.\n *\n * @author Jesse Beder\n */\n@Beta\npublic final class MapOfProducedProducer\u003cK, V\u003e extends AbstractProducer\u003cMap\u003cK, Produced\u003cV\u003e\u003e\u003e {\n  private final Producer\u003cMap\u003cK, Producer\u003cV\u003e\u003e\u003e mapProducerProducer;\n\n  private MapOfProducedProducer(Producer\u003cMap\u003cK, Producer\u003cV\u003e\u003e\u003e mapProducerProducer) {\n    this.mapProducerProducer \u003d mapProducerProducer;\n  }\n\n  /**\n   * Returns a producer of {@code Map\u003cK, Produced\u003cV\u003e\u003e}, where the map is derived from the given map\n   * of producers by waiting for those producers\u0027 resulting futures. The iteration order mirrors the\n   * order of the input map.\n   *\n   * \u003cp\u003eIf any of the delegate producers, or their resulting values, are null, then this producer\u0027s\n   * future will succeed and the corresponding {@code Produced\u003cV\u003e} will fail with a\n   * {@link NullPointerException}.\n   *\n   * \u003cp\u003eCanceling this future will attempt to cancel all of the component futures, and if any of the\n   * component futures fails or is canceled, this one is, too.\n   */\n  public static \u003cK, V\u003e MapOfProducedProducer\u003cK, V\u003e create(\n      Producer\u003cMap\u003cK, Producer\u003cV\u003e\u003e\u003e mapProducerProducer) {\n    return new MapOfProducedProducer\u003cK, V\u003e(mapProducerProducer);\n  }\n\n  @Override\n  public ListenableFuture\u003cMap\u003cK, Produced\u003cV\u003e\u003e\u003e compute() {\n    return Futures.transformAsync(\n        mapProducerProducer.get(),\n        new AsyncFunction\u003cMap\u003cK, Producer\u003cV\u003e\u003e, Map\u003cK, Produced\u003cV\u003e\u003e\u003e() {\n          @Override\n          public ListenableFuture\u003cMap\u003cK, Produced\u003cV\u003e\u003e\u003e apply(final Map\u003cK, Producer\u003cV\u003e\u003e map) {\n            // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.\n            return Futures.transform(\n                Futures.allAsList(\n                    Iterables.transform(\n                        map.entrySet(), MapOfProducedProducer.\u003cK, V\u003eentryUnwrapper())),\n                new Function\u003cList\u003cMap.Entry\u003cK, Produced\u003cV\u003e\u003e\u003e, Map\u003cK, Produced\u003cV\u003e\u003e\u003e() {\n                  @Override\n                  public Map\u003cK, Produced\u003cV\u003e\u003e apply(List\u003cMap.Entry\u003cK, Produced\u003cV\u003e\u003e\u003e entries) {\n                    return ImmutableMap.copyOf(entries);\n                  }\n                });\n          }\n        });\n  }\n\n  private static final Function\u003c\n          Map.Entry\u003cObject, Producer\u003cObject\u003e\u003e,\n          ListenableFuture\u003cMap.Entry\u003cObject, Produced\u003cObject\u003e\u003e\u003e\u003e\n      ENTRY_UNWRAPPER \u003d\n          new Function\u003c\n              Map.Entry\u003cObject, Producer\u003cObject\u003e\u003e,\n              ListenableFuture\u003cMap.Entry\u003cObject, Produced\u003cObject\u003e\u003e\u003e\u003e() {\n            @Override\n            public ListenableFuture\u003cMap.Entry\u003cObject, Produced\u003cObject\u003e\u003e\u003e apply(\n                final Map.Entry\u003cObject, Producer\u003cObject\u003e\u003e entry) {\n              return Futures.transform(\n                  Producers.createFutureProduced(entry.getValue().get()),\n                  new Function\u003cProduced\u003cObject\u003e, Map.Entry\u003cObject, Produced\u003cObject\u003e\u003e\u003e() {\n                    @Override\n                    public Map.Entry\u003cObject, Produced\u003cObject\u003e\u003e apply(Produced\u003cObject\u003e value) {\n                      return Maps.immutableEntry(entry.getKey(), value);\n                    }\n                  });\n            }\n          };\n\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // bivariate implementation\n  private static \u003cK, V\u003e\n      Function\u003cMap.Entry\u003cK, Producer\u003cV\u003e\u003e, ListenableFuture\u003cMap.Entry\u003cK, Produced\u003cV\u003e\u003e\u003e\u003e\n          entryUnwrapper() {\n    return (Function) ENTRY_UNWRAPPER;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\internal\\MapOfProducerProducer.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.Maps.newLinkedHashMapWithExpectedSize;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.internal.Beta;\nimport dagger.producers.Producer;\nimport java.util.Map;\n\n/**\n * A {@link Producer} implementation used to implement {@link Map} bindings. This factory returns an\n * immediate future of {@code Map\u003cK, Producer\u003cV\u003e\u003e} when calling {@link #get}.\n *\n * @author Jesse Beder\n */\n@Beta\npublic final class MapOfProducerProducer\u003cK, V\u003e extends AbstractProducer\u003cMap\u003cK, Producer\u003cV\u003e\u003e\u003e {\n  private static final MapOfProducerProducer\u003cObject, Object\u003e EMPTY \u003d\n      new MapOfProducerProducer\u003cObject, Object\u003e(ImmutableMap.\u003cObject, Producer\u003cObject\u003e\u003eof());\n\n  private final ImmutableMap\u003cK, Producer\u003cV\u003e\u003e contributingMap;\n\n  /** Returns a new {@link Builder}. */\n  public static \u003cK, V\u003e Builder\u003cK, V\u003e builder(int size) {\n    return new Builder\u003cK, V\u003e(size);\n  }\n\n  /** Returns a producer of an empty map. */\n  @SuppressWarnings(\"unchecked\") // safe contravariant cast\n  public static \u003cK, V\u003e MapOfProducerProducer\u003cK, V\u003e empty() {\n    return (MapOfProducerProducer\u003cK, V\u003e) EMPTY;\n  }\n\n  private MapOfProducerProducer(ImmutableMap\u003cK, Producer\u003cV\u003e\u003e contributingMap) {\n    this.contributingMap \u003d contributingMap;\n  }\n\n  @Override\n  public ListenableFuture\u003cMap\u003cK, Producer\u003cV\u003e\u003e\u003e compute() {\n    return Futures.\u003cMap\u003cK, Producer\u003cV\u003e\u003e\u003eimmediateFuture(contributingMap);\n  }\n\n  /**\n   * A builder to help build the {@link MapOfProducerProducer}\n   */\n  public static final class Builder\u003cK, V\u003e {\n    private final Map\u003cK, Producer\u003cV\u003e\u003e mapBuilder;\n\n    private Builder(int size) {\n      this.mapBuilder \u003d newLinkedHashMapWithExpectedSize(size);\n    }\n\n    /** Returns a new {@link MapOfProducerProducer}. */\n    public MapOfProducerProducer\u003cK, V\u003e build() {\n      return new MapOfProducerProducer\u003cK, V\u003e(ImmutableMap.copyOf(mapBuilder));\n    }\n\n    /** Associates k with producerOfValue in {@code Builder}. */\n    public Builder\u003cK, V\u003e put(K key, Producer\u003cV\u003e producerOfValue) {\n      checkNotNull(key, \"key\");\n      checkNotNull(producerOfValue, \"producer of value\");\n      mapBuilder.put(key, producerOfValue);\n      return this;\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\internal\\MapProducer.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Maps;\nimport com.google.common.util.concurrent.AsyncFunction;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.internal.Beta;\nimport dagger.producers.Producer;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * A {@link Producer} implementation used to implement {@link Map} bindings. This producer returns a\n * {@code Map\u003cK, V\u003e} which is populated by calls to the delegate {@link Producer#get} methods.\n *\n * @author Jesse Beder\n */\n@Beta\npublic final class MapProducer\u003cK, V\u003e extends AbstractProducer\u003cMap\u003cK, V\u003e\u003e {\n  private final Producer\u003cMap\u003cK, Producer\u003cV\u003e\u003e\u003e mapProducerProducer;\n\n  private MapProducer(Producer\u003cMap\u003cK, Producer\u003cV\u003e\u003e\u003e mapProducerProducer) {\n    this.mapProducerProducer \u003d mapProducerProducer;\n  }\n\n  /**\n   * Returns a producer of {@code Map\u003cK, V\u003e}, where the map is derived from the given map of\n   * producers by waiting for those producers\u0027 resulting futures. The iteration order mirrors the\n   * order of the input map.\n   *\n   * \u003cp\u003eIf any of the delegate producers, or their resulting values, are null, then this producer\u0027s\n   * future will fail with a {@link NullPointerException}.\n   *\n   * \u003cp\u003eCanceling this future will attempt to cancel all of the component futures, and if any of the\n   * component futures fails or is canceled, this one is, too.\n   */\n  public static \u003cK, V\u003e MapProducer\u003cK, V\u003e create(Producer\u003cMap\u003cK, Producer\u003cV\u003e\u003e\u003e mapProducerProducer) {\n    return new MapProducer\u003cK, V\u003e(mapProducerProducer);\n  }\n\n  @Override\n  public ListenableFuture\u003cMap\u003cK, V\u003e\u003e compute() {\n    return Futures.transformAsync(\n        mapProducerProducer.get(),\n        new AsyncFunction\u003cMap\u003cK, Producer\u003cV\u003e\u003e, Map\u003cK, V\u003e\u003e() {\n          @Override\n          public ListenableFuture\u003cMap\u003cK, V\u003e\u003e apply(final Map\u003cK, Producer\u003cV\u003e\u003e map) {\n            // TODO(beder): Use Futures.whenAllComplete when Guava 20 is released.\n            return Futures.transform(\n                Futures.allAsList(\n                    Iterables.transform(map.entrySet(), MapProducer.\u003cK, V\u003eentryUnwrapper())),\n                new Function\u003cList\u003cMap.Entry\u003cK, V\u003e\u003e, Map\u003cK, V\u003e\u003e() {\n                  @Override\n                  public Map\u003cK, V\u003e apply(List\u003cMap.Entry\u003cK, V\u003e\u003e entries) {\n                    return ImmutableMap.copyOf(entries);\n                  }\n                });\n          }\n        });\n  }\n\n  private static final Function\u003c\n          Map.Entry\u003cObject, Producer\u003cObject\u003e\u003e, ListenableFuture\u003cMap.Entry\u003cObject, Object\u003e\u003e\u003e\n      ENTRY_UNWRAPPER \u003d\n          new Function\u003c\n              Map.Entry\u003cObject, Producer\u003cObject\u003e\u003e, ListenableFuture\u003cMap.Entry\u003cObject, Object\u003e\u003e\u003e() {\n            @Override\n            public ListenableFuture\u003cMap.Entry\u003cObject, Object\u003e\u003e apply(\n                final Map.Entry\u003cObject, Producer\u003cObject\u003e\u003e entry) {\n              return Futures.transform(\n                  entry.getValue().get(),\n                  new Function\u003cObject, Map.Entry\u003cObject, Object\u003e\u003e() {\n                    @Override\n                    public Map.Entry\u003cObject, Object\u003e apply(Object value) {\n                      return Maps.immutableEntry(entry.getKey(), value);\n                    }\n                  });\n            }\n          };\n\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // bivariate implementation\n  private static \u003cK, V\u003e\n      Function\u003cMap.Entry\u003cK, Producer\u003cV\u003e\u003e, ListenableFuture\u003cMap.Entry\u003cK, V\u003e\u003e\u003e entryUnwrapper() {\n    return (Function) ENTRY_UNWRAPPER;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\internal\\Producers.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.util.concurrent.AsyncFunction;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport java.util.List;\nimport java.util.Set;\nimport javax.inject.Provider;\n\n/**\n * Utility methods for use in generated producer code.\n *\n * @author Jesse Beder\n * @since 2.0\n */\npublic final class Producers {\n  /**\n   * Returns a future of {@link Produced} that represents the completion (either success or failure)\n   * of the given future. If the input future succeeds, then the resulting future also succeeds with\n   * a successful {@code Produced}; if the input future fails, then the resulting future succeeds\n   * with a failing {@code Produced}.\n   *\n   * \u003cp\u003eCancelling the resulting future will propagate the cancellation to the input future; but\n   * cancelling the input future will trigger the resulting future to succeed with a failing\n   * {@code Produced}.\n   */\n  // TODO(beder): Document what happens with an InterruptedException after you figure out how to\n  // trigger one in a test.\n  public static \u003cT\u003e ListenableFuture\u003cProduced\u003cT\u003e\u003e createFutureProduced(ListenableFuture\u003cT\u003e future) {\n    return Futures.catchingAsync(\n        Futures.transform(\n            future,\n            new Function\u003cT, Produced\u003cT\u003e\u003e() {\n              @Override\n              public Produced\u003cT\u003e apply(final T value) {\n                return Produced.successful(value);\n              }\n            }),\n        Throwable.class,\n        Producers.\u003cT\u003efutureFallbackForProduced());\n\n  }\n\n  private static final AsyncFunction\u003cThrowable, Produced\u003cObject\u003e\u003e FUTURE_FALLBACK_FOR_PRODUCED \u003d\n      new AsyncFunction\u003cThrowable, Produced\u003cObject\u003e\u003e() {\n        @Override\n        public ListenableFuture\u003cProduced\u003cObject\u003e\u003e apply(Throwable t) throws Exception {\n          Produced\u003cObject\u003e produced \u003d Produced.failed(t);\n          return Futures.immediateFuture(produced);\n        }\n      };\n\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // bivariant implementation\n  private static \u003cT\u003e AsyncFunction\u003cThrowable, Produced\u003cT\u003e\u003e futureFallbackForProduced() {\n    return (AsyncFunction) FUTURE_FALLBACK_FOR_PRODUCED;\n  }\n\n  /**\n   * Returns a future of a {@code Set} that contains a single element: the result of the input\n   * future.\n   */\n  public static \u003cT\u003e ListenableFuture\u003cSet\u003cT\u003e\u003e createFutureSingletonSet(ListenableFuture\u003cT\u003e future) {\n    return Futures.transform(future, new Function\u003cT, Set\u003cT\u003e\u003e() {\n      @Override public Set\u003cT\u003e apply(T value) {\n        return ImmutableSet.of(value);\n      }\n    });\n  }\n\n  /**\n   * Creates a new {@code ListenableFuture} whose value is a set containing the values of all its\n   * input futures, if all succeed. If any input fails, the returned future fails immediately.\n   *\n   * \u003cp\u003eThis is the set equivalent of {@link Futures#allAsList}.\n   */\n  public static \u003cT\u003e ListenableFuture\u003cSet\u003cT\u003e\u003e allAsSet(\n      Iterable\u003c? extends ListenableFuture\u003c? extends T\u003e\u003e futures) {\n    return Futures.transform(\n        Futures.allAsList(futures),\n        new Function\u003cList\u003cT\u003e, Set\u003cT\u003e\u003e() {\n          @Override\n          public Set\u003cT\u003e apply(List\u003cT\u003e values) {\n            return ImmutableSet.copyOf(values);\n          }\n        });\n  }\n\n  /**\n   * Returns a producer that immediately executes the binding logic for the given provider every\n   * time it is called.\n   */\n  public static \u003cT\u003e Producer\u003cT\u003e producerFromProvider(final Provider\u003cT\u003e provider) {\n    checkNotNull(provider);\n    return new AbstractProducer\u003cT\u003e() {\n      @Override\n      protected ListenableFuture\u003cT\u003e compute() {\n        return Futures.immediateFuture(provider.get());\n      }\n    };\n  }\n\n  /** Returns a producer that succeeds with the given value. */\n  public static \u003cT\u003e Producer\u003cT\u003e immediateProducer(final T value) {\n    return new Producer\u003cT\u003e() {\n      @Override\n      public ListenableFuture\u003cT\u003e get() {\n        return Futures.immediateFuture(value);\n      }\n    };\n  }\n\n  /** Returns a producer that fails with the given exception. */\n  public static \u003cT\u003e Producer\u003cT\u003e immediateFailedProducer(final Throwable throwable) {\n    return new Producer\u003cT\u003e() {\n      @Override\n      public ListenableFuture\u003cT\u003e get() {\n        return Futures.immediateFailedFuture(throwable);\n      }\n    };\n  }\n\n  private Producers() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\internal\\ProductionImplementation.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport javax.inject.Qualifier;\n\n/**\n * Qualifies a type that will be used as an internal implementation detail in the framework.\n *\n * \u003cp\u003eThis is only intended to be used by the framework. It is the internal counterpart to\n * {@link dagger.producers.Production}.\n */\n@Documented\n@Retention(RUNTIME)\n@Qualifier\n@Beta\npublic @interface ProductionImplementation {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\internal\\SetOfProducedProducer.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static dagger.internal.DaggerCollections.hasDuplicates;\nimport static dagger.internal.DaggerCollections.presizedList;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\n\n/**\n * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns a\n * future {@code Set\u003cProduced\u003cT\u003e\u003e} whose elements are populated by subsequent calls to the delegate\n * {@link Producer#get} methods.\n *\n * @author Jesse Beder\n * @since 2.0\n */\npublic final class SetOfProducedProducer\u003cT\u003e extends AbstractProducer\u003cSet\u003cProduced\u003cT\u003e\u003e\u003e {\n  public static \u003cT\u003e Producer\u003cSet\u003cT\u003e\u003e empty() {\n    return SetProducer.empty();\n  }\n\n  /**\n   * Constructs a new {@link Builder} for a {@link SetProducer} with {@code individualProducerSize}\n   * individual {@code Producer\u003cT\u003e} and {@code collectionProducerSize} {@code\n   * Producer\u003cCollection\u003cT\u003e\u003e} instances.\n   */\n  public static \u003cT\u003e Builder\u003cT\u003e builder(int individualProducerSize, int collectionProducerSize) {\n    return new Builder\u003cT\u003e(individualProducerSize, collectionProducerSize);\n  }\n\n  /**\n   * A builder to accumulate {@code Producer\u003cT\u003e} and {@code Producer\u003cCollection\u003cT\u003e\u003e} instances.\n   * These are only intended to be single-use and from within generated code. Do \u003cem\u003eNOT\u003c/em\u003e add\n   * producers after calling {@link #build()}.\n   */\n  public static final class Builder\u003cT\u003e {\n    private final List\u003cProducer\u003cT\u003e\u003e individualProducers;\n    private final List\u003cProducer\u003cCollection\u003cT\u003e\u003e\u003e collectionProducers;\n\n    private Builder(int individualProducerSize, int collectionProducerSize) {\n      individualProducers \u003d presizedList(individualProducerSize);\n      collectionProducers \u003d presizedList(collectionProducerSize);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public Builder\u003cT\u003e addProducer(Producer\u003c? extends T\u003e individualProducer) {\n      assert individualProducer !\u003d null : \"Codegen error? Null producer\";\n      individualProducers.add((Producer\u003cT\u003e) individualProducer);\n      return this;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public Builder\u003cT\u003e addCollectionProducer(\n        Producer\u003c? extends Collection\u003c? extends T\u003e\u003e multipleProducer) {\n      assert multipleProducer !\u003d null : \"Codegen error? Null producer\";\n      collectionProducers.add((Producer\u003cCollection\u003cT\u003e\u003e) multipleProducer);\n      return this;\n    }\n\n    public SetOfProducedProducer\u003cT\u003e build() {\n      assert !hasDuplicates(individualProducers)\n          : \"Codegen error?  Duplicates in the producer list\";\n      assert !hasDuplicates(collectionProducers)\n          : \"Codegen error?  Duplicates in the producer list\";\n\n      return new SetOfProducedProducer\u003cT\u003e(individualProducers, collectionProducers);\n    }\n  }\n\n  private final List\u003cProducer\u003cT\u003e\u003e individualProducers;\n  private final List\u003cProducer\u003cCollection\u003cT\u003e\u003e\u003e collectionProducers;\n\n  private SetOfProducedProducer(\n      List\u003cProducer\u003cT\u003e\u003e individualProducers, List\u003cProducer\u003cCollection\u003cT\u003e\u003e\u003e collectionProducers) {\n    this.individualProducers \u003d individualProducers;\n    this.collectionProducers \u003d collectionProducers;\n  }\n\n  /**\n   * Returns a future {@link Set} of {@link Produced} values whose iteration order is that of the\n   * elements given by each of the producers, which are invoked in the order given at creation.\n   *\n   * \u003cp\u003eIf any of the delegate collections, or any elements therein, are null, then that\n   * corresponding {@code Produced} element will fail with a NullPointerException.\n   *\n   * \u003cp\u003eCanceling this future will attempt to cancel all of the component futures; but if any of the\n   * delegate futures fail or are canceled, this future succeeds, with the appropriate failed\n   * {@link Produced}.\n   *\n   * @throws NullPointerException if any of the delegate producers return null\n   */\n  @Override\n  public ListenableFuture\u003cSet\u003cProduced\u003cT\u003e\u003e\u003e compute() {\n    List\u003cListenableFuture\u003c? extends Produced\u003c? extends Collection\u003cT\u003e\u003e\u003e\u003e futureProducedCollections \u003d\n        new ArrayList\u003cListenableFuture\u003c? extends Produced\u003c? extends Collection\u003cT\u003e\u003e\u003e\u003e(\n            individualProducers.size() + collectionProducers.size());\n    for (Producer\u003cT\u003e producer : individualProducers) {\n      // TODO(ronshapiro): Don\u0027t require individual productions to be added to a collection just to\n      // be materialized into futureProducedCollections.\n      futureProducedCollections.add(\n          Producers.createFutureProduced(\n              Producers.createFutureSingletonSet(checkNotNull(producer.get()))));\n    }\n    for (Producer\u003cCollection\u003cT\u003e\u003e producer : collectionProducers) {\n      futureProducedCollections.add(Producers.createFutureProduced(checkNotNull(producer.get())));\n    }\n\n    return Futures.transform(\n        Futures.allAsList(futureProducedCollections),\n        new Function\u003cList\u003cProduced\u003c? extends Collection\u003cT\u003e\u003e\u003e, Set\u003cProduced\u003cT\u003e\u003e\u003e() {\n          @Override\n          public Set\u003cProduced\u003cT\u003e\u003e apply(\n              List\u003cProduced\u003c? extends Collection\u003cT\u003e\u003e\u003e producedCollections) {\n            ImmutableSet.Builder\u003cProduced\u003cT\u003e\u003e builder \u003d ImmutableSet.builder();\n            for (Produced\u003c? extends Collection\u003cT\u003e\u003e producedCollection : producedCollections) {\n              try {\n                Collection\u003cT\u003e collection \u003d producedCollection.get();\n                if (collection \u003d\u003d null) {\n                  // TODO(beder): This is a vague exception. Can we somehow point to the failing\n                  // producer? See the similar comment in the component writer about null\n                  // provisions.\n                  builder.add(\n                      Produced.\u003cT\u003efailed(\n                          new NullPointerException(\n                              \"Cannot contribute a null collection into a producer set binding when\"\n                                  + \" it\u0027s injected as Set\u003cProduced\u003cT\u003e\u003e.\")));\n                } else {\n                  for (T value : collection) {\n                    if (value \u003d\u003d null) {\n                      builder.add(\n                          Produced.\u003cT\u003efailed(\n                              new NullPointerException(\n                                  \"Cannot contribute a null element into a producer set binding\"\n                                      + \" when it\u0027s injected as Set\u003cProduced\u003cT\u003e\u003e.\")));\n                    } else {\n                      builder.add(Produced.successful(value));\n                    }\n                  }\n                }\n              } catch (ExecutionException e) {\n                builder.add(Produced.\u003cT\u003efailed(e.getCause()));\n              }\n            }\n            return builder.build();\n          }\n        });\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\internal\\SetProducer.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static dagger.internal.DaggerCollections.hasDuplicates;\nimport static dagger.internal.DaggerCollections.presizedList;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.Producer;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * A {@link Producer} implementation used to implement {@link Set} bindings. This producer returns\n * a future {@link Set} whose elements are populated by subsequent calls to the delegate\n * {@link Producer#get} methods.\n *\n * @author Jesse Beder\n * @since 2.0\n */\npublic final class SetProducer\u003cT\u003e extends AbstractProducer\u003cSet\u003cT\u003e\u003e {\n  private static final Producer\u003cSet\u003cObject\u003e\u003e EMPTY_PRODUCER \u003d\n      new Producer\u003cSet\u003cObject\u003e\u003e() {\n        @Override\n        public ListenableFuture\u003cSet\u003cObject\u003e\u003e get() {\n          return Futures.\u003cSet\u003cObject\u003e\u003eimmediateFuture(ImmutableSet.\u003cObject\u003eof());\n        }\n      };\n\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // safe covariant cast\n  public static \u003cT\u003e Producer\u003cSet\u003cT\u003e\u003e empty() {\n    return (Producer) EMPTY_PRODUCER;\n  }\n\n  /**\n   * Constructs a new {@link Builder} for a {@link SetProducer} with {@code individualProducerSize}\n   * individual {@code Producer\u003cT\u003e} and {@code collectionProducerSize} {@code\n   * Producer\u003cCollection\u003cT\u003e\u003e} instances.\n   */\n  public static \u003cT\u003e Builder\u003cT\u003e builder(int individualProducerSize, int collectionProducerSize) {\n    return new Builder\u003cT\u003e(individualProducerSize, collectionProducerSize);\n  }\n\n  /**\n   * A builder to accumulate {@code Producer\u003cT\u003e} and {@code Producer\u003cCollection\u003cT\u003e\u003e} instances.\n   * These are only intended to be single-use and from within generated code. Do \u003cem\u003eNOT\u003c/em\u003e add\n   * producers after calling {@link #build()}.\n   */\n  public static final class Builder\u003cT\u003e {\n    private final List\u003cProducer\u003cT\u003e\u003e individualProducers;\n    private final List\u003cProducer\u003cCollection\u003cT\u003e\u003e\u003e collectionProducers;\n\n    private Builder(int individualProducerSize, int collectionProducerSize) {\n      individualProducers \u003d presizedList(individualProducerSize);\n      collectionProducers \u003d presizedList(collectionProducerSize);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public Builder\u003cT\u003e addProducer(Producer\u003c? extends T\u003e individualProducer) {\n      assert individualProducer !\u003d null : \"Codegen error? Null producer\";\n      individualProducers.add((Producer\u003cT\u003e) individualProducer);\n      return this;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public Builder\u003cT\u003e addCollectionProducer(\n        Producer\u003c? extends Collection\u003c? extends T\u003e\u003e multipleProducer) {\n      assert multipleProducer !\u003d null : \"Codegen error? Null producer\";\n      collectionProducers.add((Producer\u003cCollection\u003cT\u003e\u003e) multipleProducer);\n      return this;\n    }\n\n    public SetProducer\u003cT\u003e build() {\n      assert !hasDuplicates(individualProducers)\n          : \"Codegen error?  Duplicates in the producer list\";\n      assert !hasDuplicates(collectionProducers)\n          : \"Codegen error?  Duplicates in the producer list\";\n\n      return new SetProducer\u003cT\u003e(individualProducers, collectionProducers);\n    }\n  }\n\n  private final List\u003cProducer\u003cT\u003e\u003e individualProducers;\n  private final List\u003cProducer\u003cCollection\u003cT\u003e\u003e\u003e collectionProducers;\n\n  private SetProducer(\n      List\u003cProducer\u003cT\u003e\u003e individualProducers, List\u003cProducer\u003cCollection\u003cT\u003e\u003e\u003e collectionProducers) {\n    this.individualProducers \u003d individualProducers;\n    this.collectionProducers \u003d collectionProducers;\n  }\n\n  /**\n   * Returns a future {@link Set} whose iteration order is that of the elements given by each of the\n   * producers, which are invoked in the order given at creation.\n   *\n   * \u003cp\u003eIf any of the delegate collections, or any elements therein, are null, then this future will\n   * fail with a NullPointerException.\n   *\n   * \u003cp\u003eCanceling this future will attempt to cancel all of the component futures, and if any of the\n   * delegate futures fails or is canceled, this one is, too.\n   *\n   * @throws NullPointerException if any of the delegate producers return null\n   */\n  @Override\n  public ListenableFuture\u003cSet\u003cT\u003e\u003e compute() {\n    List\u003cListenableFuture\u003cT\u003e\u003e individualFutures \u003d\n        new ArrayList\u003cListenableFuture\u003cT\u003e\u003e(individualProducers.size());\n    for (Producer\u003cT\u003e producer : individualProducers) {\n      individualFutures.add(checkNotNull(producer.get()));\n    }\n\n    // Presize the list of collections produced by the amount of collectionProducers, with one more\n    // for the consolidate individualFutures from Futures.allAsList.\n    List\u003cListenableFuture\u003c? extends Collection\u003cT\u003e\u003e\u003e futureCollections \u003d\n        new ArrayList\u003cListenableFuture\u003c? extends Collection\u003cT\u003e\u003e\u003e(collectionProducers.size() + 1);\n    futureCollections.add(Futures.allAsList(individualFutures));\n    for (Producer\u003cCollection\u003cT\u003e\u003e producer : collectionProducers) {\n      futureCollections.add(checkNotNull(producer.get()));\n    }\n    return Futures.transform(\n        Futures.allAsList(futureCollections),\n        new Function\u003cList\u003cCollection\u003cT\u003e\u003e, Set\u003cT\u003e\u003e() {\n          @Override\n          public Set\u003cT\u003e apply(List\u003cCollection\u003cT\u003e\u003e sets) {\n            ImmutableSet.Builder\u003cT\u003e builder \u003d ImmutableSet.builder();\n            for (Collection\u003cT\u003e set : sets) {\n              builder.addAll(set);\n            }\n            return builder.build();\n          }\n        });\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\monitoring\\internal\\Monitors.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.monitoring.internal;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Iterables;\nimport dagger.producers.monitoring.ProducerMonitor;\nimport dagger.producers.monitoring.ProducerToken;\nimport dagger.producers.monitoring.ProductionComponentMonitor;\nimport java.util.Collection;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.inject.Provider;\n\n/**\n * Utility methods relating to monitoring, for use in generated producers code.\n *\n * @author Jesse Beder\n */\npublic final class Monitors {\n  private static final Logger logger \u003d Logger.getLogger(Monitors.class.getName());\n\n  /**\n   * Returns a monitor factory that delegates to the given factories, and ensures that any method\n   * called on this object, even transitively, does not throw a {@link RuntimeException} or return\n   * null.\n   *\n   * \u003cp\u003eIf the delegate monitors throw an {@link Error}, then that will escape this monitor\n   * implementation. Errors are treated as unrecoverable conditions, and may cause the entire\n   * component\u0027s execution to fail.\n   */\n  public static ProductionComponentMonitor.Factory delegatingProductionComponentMonitorFactory(\n      Collection\u003c? extends ProductionComponentMonitor.Factory\u003e factories) {\n    if (factories.isEmpty()) {\n      return ProductionComponentMonitor.Factory.noOp();\n    } else if (factories.size() \u003d\u003d 1) {\n      return new NonThrowingProductionComponentMonitor.Factory(Iterables.getOnlyElement(factories));\n    } else {\n      return new DelegatingProductionComponentMonitor.Factory(factories);\n    }\n  }\n\n  /**\n   * Creates a new monitor for the given component, from a set of monitor factories. This will not\n   * throw a {@link RuntimeException} or return null.\n   */\n  public static ProductionComponentMonitor createMonitorForComponent(\n      Provider\u003c?\u003e componentProvider,\n      Provider\u003cSet\u003cProductionComponentMonitor.Factory\u003e\u003e monitorFactorySetProvider) {\n    try {\n      ProductionComponentMonitor.Factory factory \u003d\n          delegatingProductionComponentMonitorFactory(monitorFactorySetProvider.get());\n      return factory.create(componentProvider.get());\n    } catch (RuntimeException e) {\n      logger.log(Level.SEVERE, \"RuntimeException while constructing monitor factories.\", e);\n      return ProductionComponentMonitor.noOp();\n    }\n  }\n\n  /**\n   * A component monitor that delegates to a single monitor, and catches and logs all exceptions\n   * that the delegate throws.\n   */\n  private static final class NonThrowingProductionComponentMonitor\n      extends ProductionComponentMonitor {\n    private final ProductionComponentMonitor delegate;\n\n    NonThrowingProductionComponentMonitor(ProductionComponentMonitor delegate) {\n      this.delegate \u003d delegate;\n    }\n\n    @Override\n    public ProducerMonitor producerMonitorFor(ProducerToken token) {\n      try {\n        ProducerMonitor monitor \u003d delegate.producerMonitorFor(token);\n        return monitor \u003d\u003d null ? ProducerMonitor.noOp() : new NonThrowingProducerMonitor(monitor);\n      } catch (RuntimeException e) {\n        logProducerMonitorForException(e, delegate, token);\n        return ProducerMonitor.noOp();\n      }\n    }\n\n    static final class Factory extends ProductionComponentMonitor.Factory {\n      private final ProductionComponentMonitor.Factory delegate;\n\n      Factory(ProductionComponentMonitor.Factory delegate) {\n        this.delegate \u003d delegate;\n      }\n\n      @Override\n      public ProductionComponentMonitor create(Object component) {\n        try {\n          ProductionComponentMonitor monitor \u003d delegate.create(component);\n          return monitor \u003d\u003d null\n              ? ProductionComponentMonitor.noOp()\n              : new NonThrowingProductionComponentMonitor(monitor);\n        } catch (RuntimeException e) {\n          logCreateException(e, delegate, component);\n          return ProductionComponentMonitor.noOp();\n        }\n      }\n    }\n  }\n\n  /**\n   * A producer monitor that delegates to a single monitor, and catches and logs all exceptions\n   * that the delegate throws.\n   */\n  private static final class NonThrowingProducerMonitor extends ProducerMonitor {\n    private final ProducerMonitor delegate;\n\n    NonThrowingProducerMonitor(ProducerMonitor delegate) {\n      this.delegate \u003d delegate;\n    }\n\n    @Override\n    public void requested() {\n      try {\n        delegate.requested();\n      } catch (RuntimeException e) {\n        logProducerMonitorMethodException(e, delegate, \"requested\");\n      }\n    }\n\n    @Override\n    public void methodStarting() {\n      try {\n        delegate.methodStarting();\n      } catch (RuntimeException e) {\n        logProducerMonitorMethodException(e, delegate, \"methodStarting\");\n      }\n    }\n\n    @Override\n    public void methodFinished() {\n      try {\n        delegate.methodFinished();\n      } catch (RuntimeException e) {\n        logProducerMonitorMethodException(e, delegate, \"methodFinished\");\n      }\n    }\n\n    @Override\n    public void succeeded(Object o) {\n      try {\n        delegate.succeeded(o);\n      } catch (RuntimeException e) {\n        logProducerMonitorArgMethodException(e, delegate, \"succeeded\", o);\n      }\n    }\n\n    @Override\n    public void failed(Throwable t) {\n      try {\n        delegate.failed(t);\n      } catch (RuntimeException e) {\n        logProducerMonitorArgMethodException(e, delegate, \"failed\", t);\n      }\n    }\n  }\n\n  /**\n   * A component monitor that delegates to several monitors, and catches and logs all exceptions\n   * that the delegates throw.\n   */\n  private static final class DelegatingProductionComponentMonitor\n      extends ProductionComponentMonitor {\n    private final ImmutableList\u003cProductionComponentMonitor\u003e delegates;\n\n    DelegatingProductionComponentMonitor(ImmutableList\u003cProductionComponentMonitor\u003e delegates) {\n      this.delegates \u003d delegates;\n    }\n\n    @Override\n    public ProducerMonitor producerMonitorFor(ProducerToken token) {\n      ImmutableList.Builder\u003cProducerMonitor\u003e monitorsBuilder \u003d ImmutableList.builder();\n      for (ProductionComponentMonitor delegate : delegates) {\n        try {\n          ProducerMonitor monitor \u003d delegate.producerMonitorFor(token);\n          if (monitor !\u003d null) {\n            monitorsBuilder.add(monitor);\n          }\n        } catch (RuntimeException e) {\n          logProducerMonitorForException(e, delegate, token);\n        }\n      }\n      ImmutableList\u003cProducerMonitor\u003e monitors \u003d monitorsBuilder.build();\n      if (monitors.isEmpty()) {\n        return ProducerMonitor.noOp();\n      } else if (monitors.size() \u003d\u003d 1) {\n        return new NonThrowingProducerMonitor(Iterables.getOnlyElement(monitors));\n      } else {\n        return new DelegatingProducerMonitor(monitors);\n      }\n    }\n\n    static final class Factory extends ProductionComponentMonitor.Factory {\n      private final ImmutableList\u003c? extends ProductionComponentMonitor.Factory\u003e delegates;\n\n      Factory(Iterable\u003c? extends ProductionComponentMonitor.Factory\u003e delegates) {\n        this.delegates \u003d ImmutableList.copyOf(delegates);\n      }\n\n      @Override\n      public ProductionComponentMonitor create(Object component) {\n        ImmutableList.Builder\u003cProductionComponentMonitor\u003e monitorsBuilder \u003d ImmutableList.builder();\n        for (ProductionComponentMonitor.Factory delegate : delegates) {\n          try {\n            ProductionComponentMonitor monitor \u003d delegate.create(component);\n            if (monitor !\u003d null) {\n              monitorsBuilder.add(monitor);\n            }\n          } catch (RuntimeException e) {\n            logCreateException(e, delegate, component);\n          }\n        }\n        ImmutableList\u003cProductionComponentMonitor\u003e monitors \u003d monitorsBuilder.build();\n        if (monitors.isEmpty()) {\n          return ProductionComponentMonitor.noOp();\n        } else if (monitors.size() \u003d\u003d 1) {\n          return new NonThrowingProductionComponentMonitor(Iterables.getOnlyElement(monitors));\n        } else {\n          return new DelegatingProductionComponentMonitor(monitors);\n        }\n      }\n    }\n  }\n\n  /**\n   * A producer monitor that delegates to several monitors, and catches and logs all exceptions\n   * that the delegates throw.\n   */\n  private static final class DelegatingProducerMonitor extends ProducerMonitor {\n    private final ImmutableList\u003cProducerMonitor\u003e delegates;\n\n    DelegatingProducerMonitor(ImmutableList\u003cProducerMonitor\u003e delegates) {\n      this.delegates \u003d delegates;\n    }\n\n    @Override\n    public void requested() {\n      for (ProducerMonitor delegate : delegates) {\n        try {\n          delegate.requested();\n        } catch (RuntimeException e) {\n          logProducerMonitorMethodException(e, delegate, \"requested\");\n        }\n      }\n    }\n\n    @Override\n    public void methodStarting() {\n      for (ProducerMonitor delegate : delegates) {\n        try {\n          delegate.methodStarting();\n        } catch (RuntimeException e) {\n          logProducerMonitorMethodException(e, delegate, \"methodStarting\");\n        }\n      }\n    }\n\n    @Override\n    public void methodFinished() {\n      for (ProducerMonitor delegate : delegates.reverse()) {\n        try {\n          delegate.methodFinished();\n        } catch (RuntimeException e) {\n          logProducerMonitorMethodException(e, delegate, \"methodFinished\");\n        }\n      }\n    }\n\n    @Override\n    public void succeeded(Object o) {\n      for (ProducerMonitor delegate : delegates.reverse()) {\n        try {\n          delegate.succeeded(o);\n        } catch (RuntimeException e) {\n          logProducerMonitorArgMethodException(e, delegate, \"succeeded\", o);\n        }\n      }\n    }\n\n    @Override\n    public void failed(Throwable t) {\n      for (ProducerMonitor delegate : delegates.reverse()) {\n        try {\n          delegate.failed(t);\n        } catch (RuntimeException e) {\n          logProducerMonitorArgMethodException(e, delegate, \"failed\", t);\n        }\n      }\n    }\n  }\n\n  /** Returns a provider of a no-op component monitor. */\n  public static Provider\u003cProductionComponentMonitor\u003e noOpProductionComponentMonitorProvider() {\n    return NO_OP_PRODUCTION_COMPONENT_MONITOR_PROVIDER;\n  }\n\n  private static final Provider\u003cProductionComponentMonitor\u003e\n      NO_OP_PRODUCTION_COMPONENT_MONITOR_PROVIDER \u003d\n          new Provider\u003cProductionComponentMonitor\u003e() {\n            @Override\n            public ProductionComponentMonitor get() {\n              return ProductionComponentMonitor.noOp();\n            }\n          };\n\n  private static void logCreateException(\n      RuntimeException e, ProductionComponentMonitor.Factory factory, Object component) {\n    logger.log(\n        Level.SEVERE,\n        \"RuntimeException while calling ProductionComponentMonitor.Factory.create on factory \"\n            + factory\n            + \" with component \"\n            + component,\n        e);\n  }\n\n  private static void logProducerMonitorForException(\n      RuntimeException e, ProductionComponentMonitor monitor, ProducerToken token) {\n    logger.log(\n        Level.SEVERE,\n        \"RuntimeException while calling ProductionComponentMonitor.producerMonitorFor on monitor \"\n            + monitor\n            + \" with token \"\n            + token,\n        e);\n  }\n\n  private static void logProducerMonitorMethodException(\n      RuntimeException e, ProducerMonitor monitor, String method) {\n    logger.log(\n        Level.SEVERE,\n        \"RuntimeException while calling ProducerMonitor.\" + method + \" on monitor \" + monitor,\n        e);\n  }\n\n  private static void logProducerMonitorArgMethodException(\n      RuntimeException e, ProducerMonitor monitor, String method, Object arg) {\n    logger.log(\n        Level.SEVERE,\n        \"RuntimeException while calling ProducerMonitor.\"\n            + method\n            + \" on monitor \"\n            + monitor\n            + \" with \"\n            + arg,\n        e);\n  }\n\n  private Monitors() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\monitoring\\package-info.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This package provides hooks for monitoring producers.\n *\n * \u003cp\u003eThe interfaces in this package are not stable. Do not use these interfaces unless you are\n * prepared to be broken.\n */\n\npackage dagger.producers.monitoring;\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\monitoring\\ProducerMonitor.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.monitoring;\n\nimport com.google.common.util.concurrent.FutureCallback;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.Producer;\nimport dagger.producers.Produces;\n\n/**\n * A hook for monitoring the execution of individual {@linkplain Produces producer methods}. See\n * {@link ProductionComponentMonitor} for how to install these monitors.\n *\n * \u003cp\u003eThe lifecycle of the monitor, under normal conditions, is:\n * \u003cul\u003e\n *   \u003cli\u003e{@link #requested()}\n *   \u003cli\u003e{@link #methodStarting()}\n *   \u003cli\u003eThe method is called\n *   \u003cli\u003e{@link #methodFinished()}\n *   \u003cli\u003eIf the method returns a value, then:\n *   \u003cul\u003e\n *     \u003cli\u003e{@link #succeeded(Object)} if the method returned normally; or\n *     \u003cli\u003e{@link #failed(Throwable)} if the method threw an exception.\n *   \u003c/ul\u003e\n *   \u003cli\u003eIf the method returns a future, then:\n *   \u003cul\u003e\n *     \u003cli\u003e{@link #succeeded(Object)} if the method returned normally, and the future succeeded; or\n *     \u003cli\u003e{@link #failed(Throwable)} if the method threw an exception, or returned normally and the\n *         future failed.\n *   \u003c/ul\u003e\n * \u003c/ul\u003e\n *\n * \u003cp\u003eIf any input to the monitored producer fails, {@link #failed(Throwable)} will be called\n * immediately with the failed input\u0027s exception. If more than one input fails, an arbitrary failed\n * input\u0027s exception is used.\n *\n * \u003cp\u003eFor example, given an entry point A that depends on B, which depends on C, when the entry\n * point A is called, this will trigger the following sequence of events, assuming all methods and\n * futures complete successfully:\n * \u003cul\u003e\n *   \u003cli\u003eA requested\n *   \u003cli\u003eB requested\n *   \u003cli\u003eC requested\n *   \u003cli\u003eC methodStarting\n *   \u003cli\u003eC methodFinished\n *   \u003cli\u003eC succeeded\n *   \u003cli\u003eB methodStarting\n *   \u003cli\u003eB methodFinished\n *   \u003cli\u003eB succeeded\n *   \u003cli\u003eA methodStarting\n *   \u003cli\u003eA methodFinished\n *   \u003cli\u003eA succeeded\n * \u003c/ul\u003e\n *\n * \u003cp\u003eIf any of the monitor\u0027s methods throw, then the exception will be logged and processing will\n * continue unaffected.\n *\n * @author Jesse Beder\n */\npublic abstract class ProducerMonitor {\n  /**\n   * Called when the producer\u0027s output is requested; that is, when the first method is called that\n   * requires the production of this producer\u0027s output.\n   *\n   * \u003cp\u003eNote that if a method depends on {@code Producer\u003cT\u003e}, then this does not count as requesting\n   * {@code T}; that is only triggered by calling {@link Producer#get()}.\n   *\n   * \u003cp\u003eWhen multiple monitors are installed, the order that each monitor will call this method is\n   * unspecified, but will remain consistent throughout the course of the execution of a component.\n   *\n   * \u003cp\u003eThis implementation is a no-op.\n   */\n  public void requested() {}\n\n  /**\n   * Called when the producer method is about to start executing.\n   *\n   * \u003cp\u003eWhen multiple monitors are installed, calls to this method will be in the reverse order from\n   * calls to {@link #requested()}.\n   *\n   * \u003cp\u003eThis implementation is a no-op.\n   */\n  public void methodStarting() {}\n\n  /**\n   * Called when the producer method has finished executing. This will be called from the same\n   * thread as {@link #methodStarting()}.\n   *\n   * \u003cp\u003eWhen multiple monitors are installed, calls to this method will be in the reverse order from\n   * calls to {@link #requested()}.\n   *\n   * \u003cp\u003eThis implementation is a no-op.\n   */\n  public void methodFinished() {}\n\n  /**\n   * Called when the producer’s future has completed successfully with a value.\n   *\n   * \u003cp\u003eWhen multiple monitors are installed, calls to this method will be in the reverse order from\n   * calls to {@link #requested()}.\n   *\n   * \u003cp\u003eThis implementation is a no-op.\n   */\n  public void succeeded(@SuppressWarnings(\"unused\") Object value) {}\n\n  /**\n   * Called when the producer\u0027s future has failed with an exception.\n   *\n   * \u003cp\u003eWhen multiple monitors are installed, calls to this method will be in the reverse order from\n   * calls to {@link #requested()}.\n   *\n   * \u003cp\u003eThis implementation is a no-op.\n   */\n  public void failed(@SuppressWarnings(\"unused\") Throwable t) {}\n\n  /**\n   * Adds this monitor\u0027s completion methods as a callback to the future. This is only intended to be\n   * overridden in the framework!\n   */\n  public \u003cT\u003e void addCallbackTo(ListenableFuture\u003cT\u003e future) {\n    Futures.addCallback(\n        future,\n        new FutureCallback\u003cT\u003e() {\n          @Override\n          public void onSuccess(T value) {\n            succeeded(value);\n          }\n\n          @Override\n          public void onFailure(Throwable t) {\n            failed(t);\n          }\n        });\n  }\n\n  private static final ProducerMonitor NO_OP \u003d\n      new ProducerMonitor() {\n        @Override\n        public \u003cT\u003e void addCallbackTo(ListenableFuture\u003cT\u003e future) {\n          // overridden to avoid adding a do-nothing callback\n        }\n      };\n\n  /** Returns a monitor that does no monitoring. */\n  public static ProducerMonitor noOp() {\n    return NO_OP;\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\monitoring\\ProducerTimingRecorder.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.monitoring;\n\nimport dagger.producers.Produces;\nimport dagger.producers.ProductionComponent;\n\n/**\n * A hook for recording the timing of the execution of individual\n * {@linkplain Produces producer methods}. See {@link ProductionComponentTimingRecorder} for how to\n * install these monitors.\n *\n * \u003cp\u003eIf any of the recorder\u0027s methods throw, then the exception will be logged and processing will\n * continue unaffected.\n *\n * \u003cp\u003eAll timings are measured at nanosecond precision, but not necessarily nanosecond resolution.\n * That is, timings will be reported in nanoseconds, but the timing source will not necessarily\n * update at nanosecond resolution. For example, {@link System#nanoTime()} would satisfy these\n * constraints.\n *\n * @author Jesse Beder\n */\npublic abstract class ProducerTimingRecorder {\n  /**\n   * Reports that the producer method has finished executing with the given statistics.\n   *\n   * \u003cp\u003eIf the producer was skipped due to any of its inputs failing, then this will not be called.\n   *\n   * @param startedNanos the wall-clock time, in nanoseconds, when the producer method started\n   *     executing, measured from when the first method on the\n   *     {@linkplain ProductionComponent production component} was called.\n   * @param durationNanos the wall-clock time, in nanoseconds, that the producer method took to\n   *     execute.\n   */\n  public void recordMethod(long startedNanos, long durationNanos) {}\n\n  /**\n   * Reports that the producer\u0027s future has succeeded with the given statistics.\n   *\n   * \u003cp\u003eIf the producer was skipped due to any of its inputs failing, then this will not be called.\n   *\n   * @param latencyNanos the wall-clock time, in nanoseconds, of the producer\u0027s latency, measured\n   *     from when the producer method started to when the future finished.\n   */\n  public void recordSuccess(long latencyNanos) {}\n\n  /**\n   * Reports that the producer\u0027s future has failed with the given statistics.\n   *\n   * @param exception the exception that the future failed with.\n   * @param latencyNanos the wall-clock time, in nanoseconds, of the producer\u0027s latency, measured\n   *     from when the producer method started to when the future finished.\n   */\n  public void recordFailure(Throwable exception, long latencyNanos) {}\n\n  /**\n   * Reports that the producer was skipped because one of its inputs failed.\n   *\n   * @param exception the exception that its input failed with. If multiple inputs failed, this\n   *    exception will be chosen arbitrarily from the input failures.\n   */\n  public void recordSkip(Throwable exception) {}\n\n  /** Returns a producer recorder that does nothing. */\n  public static ProducerTimingRecorder noOp() {\n    return NO_OP;\n  }\n\n  private static final ProducerTimingRecorder NO_OP \u003d new ProducerTimingRecorder() {};\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\monitoring\\ProducerToken.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.monitoring;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport dagger.producers.Produces;\nimport java.util.Objects;\nimport javax.annotation.Nullable;\n\n/** A token that represents an individual {@linkplain Produces producer method}. */\npublic final class ProducerToken {\n  @Nullable private final Class\u003c?\u003e classToken;\n  @Nullable private final String methodName;\n\n  private ProducerToken(@Nullable Class\u003c?\u003e classToken, @Nullable String methodName) {\n    this.classToken \u003d classToken;\n    this.methodName \u003d methodName;\n  }\n\n  /**\n   * Creates a token for a class token that represents the generated factory for a producer method.\n   *\n   * \u003cp\u003e\u003cb\u003eDo not use this!\u003c/b\u003e This is intended to be called by generated code only, and its\n   * signature may change at any time.\n   */\n  public static ProducerToken create(Class\u003c?\u003e classToken) {\n    return new ProducerToken(checkNotNull(classToken), null);\n  }\n\n  /**\n   * Creates a token for a producer method.\n   *\n   * \u003cp\u003e\u003cb\u003eDo not use this!\u003c/b\u003e This is intended to be called by generated code only, and its\n   * signature may change at any time.\n   */\n  public static ProducerToken create(String methodName) {\n    return new ProducerToken(null, checkNotNull(methodName));\n  }\n\n  /** Two tokens are equal if they represent the same method. */\n  @Override\n  public boolean equals(Object o) {\n    if (o \u003d\u003d this) {\n      return true;\n    } else if (o instanceof ProducerToken) {\n      ProducerToken that \u003d (ProducerToken) o;\n      return Objects.equals(this.classToken, that.classToken)\n          \u0026\u0026 Objects.equals(this.methodName, that.methodName);\n    } else {\n      return false;\n    }\n  }\n\n  /** Returns an appropriate hash code to match {@link #equals(Object)}. */\n  @Override\n  public int hashCode() {\n    int h \u003d 1;\n    h *\u003d 1000003;\n    h ^\u003d Objects.hashCode(this.classToken);\n    h *\u003d 1000003;\n    h ^\u003d Objects.hashCode(this.methodName);\n    return h;\n  }\n\n  /** Returns a representation of the method. */\n  @Override\n  public String toString() {\n    if (methodName !\u003d null) {\n      return methodName;\n    } else if (classToken !\u003d null) {\n      return classToken.getCanonicalName();\n    } else {\n      throw new IllegalStateException();\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\monitoring\\ProductionComponentMonitor.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.monitoring;\n\nimport dagger.producers.Produces;\nimport dagger.producers.ProductionComponent;\n\n/**\n * A hook for monitoring execution of {@linkplain ProductionComponent production components}. To\n * install a {@code ProductionComponentMonitor}, contribute to a set binding of\n * {@code ProductionComponentMonitor.Factory}. The factory will be asked to create one monitor for\n * the component, and the resulting single instance will be used to create individual monitors for\n * producers.\n *\n * \u003cp\u003eFor example: \u003cpre\u003e\u003ccode\u003e\n *   {@literal @Module}\n *   final class MyMonitorModule {\n *     {@literal @Provides @IntoSet} ProductionComponentMonitor.Factory provideMonitorFactory(\n *         MyProductionComponentMonitor.Factory monitorFactory) {\n *       return monitorFactory;\n *     }\n *   }\n *\n *   {@literal @ProductionComponent(modules \u003d {MyMonitorModule.class, MyProducerModule.class})}\n *   interface MyComponent {\n *     {@literal ListenableFuture\u003cSomeType\u003e} someType();\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003cp\u003eIf any of these methods throw, then the exception will be logged, and the framework will act\n * as though a no-op monitor was returned.\n *\n * @author Jesse Beder\n */\npublic abstract class ProductionComponentMonitor {\n  /** Returns a monitor for an individual {@linkplain Produces producer method}. */\n  public abstract ProducerMonitor producerMonitorFor(ProducerToken token);\n\n  private static final ProductionComponentMonitor NO_OP \u003d\n      new ProductionComponentMonitor() {\n        @Override\n        public ProducerMonitor producerMonitorFor(ProducerToken token) {\n          return ProducerMonitor.noOp();\n        }\n      };\n\n  /** Returns a monitor that does no monitoring. */\n  public static ProductionComponentMonitor noOp() {\n    return NO_OP;\n  }\n\n  public abstract static class Factory {\n    /** Creates a component-specific monitor when the component is created. */\n    public abstract ProductionComponentMonitor create(Object component);\n\n    private static final Factory NO_OP_FACTORY \u003d\n        new Factory() {\n          @Override\n          public ProductionComponentMonitor create(Object component) {\n            return ProductionComponentMonitor.noOp();\n          }\n        };\n\n    /** Returns a factory that returns no-op monitors. */\n    public static Factory noOp() {\n      return NO_OP_FACTORY;\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\monitoring\\ProductionComponentTimingRecorder.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.monitoring;\n\nimport dagger.producers.Produces;\nimport dagger.producers.ProductionComponent;\n\n/**\n * A hook for recording timing of the execution of\n * {@linkplain ProductionComponent production components}. To install a\n * {@code ProductionComponentTimingRecorder}, contribute to a set binding of\n * {@code ProductionComponentTimingRecorder.Factory}, and include the {@code TimingMonitorModule} to\n * the component. The factory will be asked to create one timing recorder for the component, and the\n * resulting instance will be used to create individual timing recorders for producers.\n *\n * \u003cp\u003eIf any of these methods throw, then the exception will be logged, and the framework will act\n * as though a no-op timing recorder was returned.\n *\n * @author Jesse Beder\n */\npublic interface ProductionComponentTimingRecorder {\n  /** Returns a timing recorder for an individual {@linkplain Produces producer method}. */\n  ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token);\n\n  public interface Factory {\n    /** Creates a component-specific timing recorder when the component is created. */\n    ProductionComponentTimingRecorder create(Object component);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\monitoring\\TimingProducerMonitor.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.monitoring;\n\nimport static java.util.concurrent.TimeUnit.NANOSECONDS;\n\nimport com.google.common.base.Stopwatch;\nimport com.google.common.base.Ticker;\n\n/**\n * A monitor that measures the timing of the execution of a producer method, and logs those timings\n * with the given recorder.\n */\nfinal class TimingProducerMonitor extends ProducerMonitor {\n  private final ProducerTimingRecorder recorder;\n  private final Stopwatch stopwatch;\n  private final Stopwatch componentStopwatch;\n  private long startNanos \u003d -1;\n\n  TimingProducerMonitor(\n      ProducerTimingRecorder recorder, Ticker ticker, Stopwatch componentStopwatch) {\n    this.recorder \u003d recorder;\n    this.stopwatch \u003d Stopwatch.createUnstarted(ticker);\n    this.componentStopwatch \u003d componentStopwatch;\n  }\n\n  @Override\n  public void methodStarting() {\n    startNanos \u003d componentStopwatch.elapsed(NANOSECONDS);\n    stopwatch.start();\n  }\n\n  @Override\n  public void methodFinished() {\n    // TODO(beder): Is a system ticker the appropriate way to track CPU time? Should we use\n    // ThreadCpuTicker instead?\n    long durationNanos \u003d stopwatch.elapsed(NANOSECONDS);\n    recorder.recordMethod(startNanos, durationNanos);\n  }\n\n  @Override\n  public void succeeded(Object o) {\n    long latencyNanos \u003d stopwatch.elapsed(NANOSECONDS);\n    recorder.recordSuccess(latencyNanos);\n  }\n\n  @Override\n  public void failed(Throwable t) {\n    if (stopwatch.isRunning()) {\n      long latencyNanos \u003d stopwatch.elapsed(NANOSECONDS);\n      recorder.recordFailure(t, latencyNanos);\n    } else {\n      recorder.recordSkip(t);\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\monitoring\\TimingProductionComponentMonitor.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.monitoring;\n\nimport com.google.common.base.Stopwatch;\nimport com.google.common.base.Ticker;\nimport dagger.internal.Beta;\n\n/**\n * A monitor that measures the timing of the execution of a production component, and logs those\n * timings with the given recorder.\n *\n * \u003cp\u003eThis assumes that the given recorders do not throw or return null; for example, by using\n * {@link TimingRecorders#delegatingProductionComponentTimingRecorderFactory}.\n */\n// TODO(beder): Reduce the visibility of this class to package-private.\n@Beta\npublic final class TimingProductionComponentMonitor extends ProductionComponentMonitor {\n  private final ProductionComponentTimingRecorder recorder;\n  private final Ticker ticker;\n  private final Stopwatch stopwatch;\n\n  TimingProductionComponentMonitor(ProductionComponentTimingRecorder recorder, Ticker ticker) {\n    this.recorder \u003d recorder;\n    this.ticker \u003d ticker;\n    this.stopwatch \u003d Stopwatch.createStarted(ticker);\n  }\n\n  @Override\n  public ProducerMonitor producerMonitorFor(ProducerToken token) {\n    return new TimingProducerMonitor(recorder.producerTimingRecorderFor(token), ticker, stopwatch);\n  }\n\n  public static final class Factory extends ProductionComponentMonitor.Factory {\n    private final ProductionComponentTimingRecorder.Factory recorderFactory;\n    private final Ticker ticker;\n\n    public Factory(ProductionComponentTimingRecorder.Factory recorderFactory) {\n      this(recorderFactory, Ticker.systemTicker());\n    }\n\n    Factory(ProductionComponentTimingRecorder.Factory recorderFactory, Ticker ticker) {\n      this.recorderFactory \u003d recorderFactory;\n      this.ticker \u003d ticker;\n    }\n\n    @Override\n    public ProductionComponentMonitor create(Object component) {\n      return new TimingProductionComponentMonitor(recorderFactory.create(component), ticker);\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\monitoring\\TimingRecorders.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.monitoring;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Iterables;\nimport dagger.internal.Beta;\nimport java.util.Collection;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Utility methods relating to timing.\n *\n * @author Jesse Beder\n */\n// TODO(beder): Reduce the visibility of this class to package-private.\n@Beta\npublic final class TimingRecorders {\n  private static final Logger logger \u003d Logger.getLogger(TimingRecorders.class.getName());\n\n  /**\n   * Returns a timing recorder factory that delegates to the given factories, and ensures that any\n   * method called on this object, even transitively, does not throw a {@link RuntimeException} or\n   * return null.\n   *\n   * \u003cp\u003eIf the delegate recorders throw an {@link Error}, then that will escape this recorder\n   * implementation. Errors are treated as unrecoverable conditions, and may cause the entire\n   * component\u0027s execution to fail.\n   */\n  public static ProductionComponentTimingRecorder.Factory\n      delegatingProductionComponentTimingRecorderFactory(\n          Collection\u003cProductionComponentTimingRecorder.Factory\u003e factories) {\n    switch (factories.size()) {\n      case 0:\n        return noOpProductionComponentTimingRecorderFactory();\n      case 1:\n        return new NonThrowingProductionComponentTimingRecorder.Factory(\n            Iterables.getOnlyElement(factories));\n      default:\n        return new DelegatingProductionComponentTimingRecorder.Factory(factories);\n    }\n  }\n\n  /**\n   * A component recorder that delegates to a single recorder, and catches and logs all exceptions\n   * that the delegate throws.\n   */\n  private static final class NonThrowingProductionComponentTimingRecorder\n      implements ProductionComponentTimingRecorder {\n    private final ProductionComponentTimingRecorder delegate;\n\n    NonThrowingProductionComponentTimingRecorder(ProductionComponentTimingRecorder delegate) {\n      this.delegate \u003d delegate;\n    }\n\n    @Override\n    public ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token) {\n      try {\n        ProducerTimingRecorder recorder \u003d delegate.producerTimingRecorderFor(token);\n        return recorder \u003d\u003d null\n            ? ProducerTimingRecorder.noOp()\n            : new NonThrowingProducerTimingRecorder(recorder);\n      } catch (RuntimeException e) {\n        logProducerTimingRecorderForException(e, delegate, token);\n        return ProducerTimingRecorder.noOp();\n      }\n    }\n\n    static final class Factory implements ProductionComponentTimingRecorder.Factory {\n      private final ProductionComponentTimingRecorder.Factory delegate;\n\n      Factory(ProductionComponentTimingRecorder.Factory delegate) {\n        this.delegate \u003d delegate;\n      }\n\n      @Override\n      public ProductionComponentTimingRecorder create(Object component) {\n        try {\n          ProductionComponentTimingRecorder recorder \u003d delegate.create(component);\n          return recorder \u003d\u003d null\n              ? noOpProductionComponentTimingRecorder()\n              : new NonThrowingProductionComponentTimingRecorder(recorder);\n        } catch (RuntimeException e) {\n          logCreateException(e, delegate, component);\n          return noOpProductionComponentTimingRecorder();\n        }\n      }\n    }\n  }\n\n  /**\n   * A producer recorder that delegates to a single recorder, and catches and logs all exceptions\n   * that the delegate throws.\n   */\n  private static final class NonThrowingProducerTimingRecorder extends ProducerTimingRecorder {\n    private final ProducerTimingRecorder delegate;\n\n    NonThrowingProducerTimingRecorder(ProducerTimingRecorder delegate) {\n      this.delegate \u003d delegate;\n    }\n\n    @Override\n    public void recordMethod(long startedNanos, long durationNanos) {\n      try {\n        delegate.recordMethod(startedNanos, durationNanos);\n      } catch (RuntimeException e) {\n        logProducerTimingRecorderMethodException(e, delegate, \"recordMethod\");\n      }\n    }\n\n    @Override\n    public void recordSuccess(long latencyNanos) {\n      try {\n        delegate.recordSuccess(latencyNanos);\n      } catch (RuntimeException e) {\n        logProducerTimingRecorderMethodException(e, delegate, \"recordSuccess\");\n      }\n    }\n\n    @Override\n    public void recordFailure(Throwable exception, long latencyNanos) {\n      try {\n        delegate.recordFailure(exception, latencyNanos);\n      } catch (RuntimeException e) {\n        logProducerTimingRecorderMethodException(e, delegate, \"recordFailure\");\n      }\n    }\n\n    @Override\n    public void recordSkip(Throwable exception) {\n      try {\n        delegate.recordSkip(exception);\n      } catch (RuntimeException e) {\n        logProducerTimingRecorderMethodException(e, delegate, \"recordSkip\");\n      }\n    }\n  }\n\n  /**\n   * A component recorder that delegates to several recorders, and catches and logs all exceptions\n   * that the delegates throw.\n   */\n  private static final class DelegatingProductionComponentTimingRecorder\n      implements ProductionComponentTimingRecorder {\n    private final ImmutableList\u003cProductionComponentTimingRecorder\u003e delegates;\n\n    DelegatingProductionComponentTimingRecorder(\n        ImmutableList\u003cProductionComponentTimingRecorder\u003e delegates) {\n      this.delegates \u003d delegates;\n    }\n\n    @Override\n    public ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token) {\n      ImmutableList.Builder\u003cProducerTimingRecorder\u003e recordersBuilder \u003d ImmutableList.builder();\n      for (ProductionComponentTimingRecorder delegate : delegates) {\n        try {\n          ProducerTimingRecorder recorder \u003d delegate.producerTimingRecorderFor(token);\n          if (recorder !\u003d null) {\n            recordersBuilder.add(recorder);\n          }\n        } catch (RuntimeException e) {\n          logProducerTimingRecorderForException(e, delegate, token);\n        }\n      }\n      ImmutableList\u003cProducerTimingRecorder\u003e recorders \u003d recordersBuilder.build();\n      switch (recorders.size()) {\n        case 0:\n          return ProducerTimingRecorder.noOp();\n        case 1:\n          return new NonThrowingProducerTimingRecorder(Iterables.getOnlyElement(recorders));\n        default:\n          return new DelegatingProducerTimingRecorder(recorders);\n      }\n    }\n\n    static final class Factory implements ProductionComponentTimingRecorder.Factory {\n      private final ImmutableList\u003c? extends ProductionComponentTimingRecorder.Factory\u003e delegates;\n\n      Factory(Iterable\u003c? extends ProductionComponentTimingRecorder.Factory\u003e delegates) {\n        this.delegates \u003d ImmutableList.copyOf(delegates);\n      }\n\n      @Override\n      public ProductionComponentTimingRecorder create(Object component) {\n        ImmutableList.Builder\u003cProductionComponentTimingRecorder\u003e recordersBuilder \u003d\n            ImmutableList.builder();\n        for (ProductionComponentTimingRecorder.Factory delegate : delegates) {\n          try {\n            ProductionComponentTimingRecorder recorder \u003d delegate.create(component);\n            if (recorder !\u003d null) {\n              recordersBuilder.add(recorder);\n            }\n          } catch (RuntimeException e) {\n            logCreateException(e, delegate, component);\n          }\n        }\n        ImmutableList\u003cProductionComponentTimingRecorder\u003e recorders \u003d recordersBuilder.build();\n        switch (recorders.size()) {\n          case 0:\n            return noOpProductionComponentTimingRecorder();\n          case 1:\n            return new NonThrowingProductionComponentTimingRecorder(\n                Iterables.getOnlyElement(recorders));\n          default:\n            return new DelegatingProductionComponentTimingRecorder(recorders);\n        }\n      }\n    }\n  }\n\n  /**\n   * A producer recorder that delegates to several recorders, and catches and logs all exceptions\n   * that the delegates throw.\n   */\n  private static final class DelegatingProducerTimingRecorder extends ProducerTimingRecorder {\n    private final ImmutableList\u003cProducerTimingRecorder\u003e delegates;\n\n    DelegatingProducerTimingRecorder(ImmutableList\u003cProducerTimingRecorder\u003e delegates) {\n      this.delegates \u003d delegates;\n    }\n\n    @Override\n    public void recordMethod(long startedNanos, long durationNanos) {\n      for (ProducerTimingRecorder delegate : delegates) {\n        try {\n          delegate.recordMethod(startedNanos, durationNanos);\n        } catch (RuntimeException e) {\n          logProducerTimingRecorderMethodException(e, delegate, \"recordMethod\");\n        }\n      }\n    }\n\n    @Override\n    public void recordSuccess(long latencyNanos) {\n      for (ProducerTimingRecorder delegate : delegates) {\n        try {\n          delegate.recordSuccess(latencyNanos);\n        } catch (RuntimeException e) {\n          logProducerTimingRecorderMethodException(e, delegate, \"recordSuccess\");\n        }\n      }\n    }\n\n    @Override\n    public void recordFailure(Throwable exception, long latencyNanos) {\n      for (ProducerTimingRecorder delegate : delegates) {\n        try {\n          delegate.recordFailure(exception, latencyNanos);\n        } catch (RuntimeException e) {\n          logProducerTimingRecorderMethodException(e, delegate, \"recordFailure\");\n        }\n      }\n    }\n\n    @Override\n    public void recordSkip(Throwable exception) {\n      for (ProducerTimingRecorder delegate : delegates) {\n        try {\n          delegate.recordSkip(exception);\n        } catch (RuntimeException e) {\n          logProducerTimingRecorderMethodException(e, delegate, \"recordSkip\");\n        }\n      }\n    }\n  }\n\n  /** Returns a recorder factory that returns no-op component recorders. */\n  public static ProductionComponentTimingRecorder.Factory\n      noOpProductionComponentTimingRecorderFactory() {\n    return NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER_FACTORY;\n  }\n\n  /** Returns a component recorder that returns no-op producer recorders. */\n  public static ProductionComponentTimingRecorder noOpProductionComponentTimingRecorder() {\n    return NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER;\n  }\n\n  private static final ProductionComponentTimingRecorder.Factory\n      NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER_FACTORY \u003d\n          new ProductionComponentTimingRecorder.Factory() {\n            @Override\n            public ProductionComponentTimingRecorder create(Object component) {\n              return noOpProductionComponentTimingRecorder();\n            }\n          };\n\n  private static final ProductionComponentTimingRecorder\n      NO_OP_PRODUCTION_COMPONENT_TIMING_RECORDER \u003d\n          new ProductionComponentTimingRecorder() {\n            @Override\n            public ProducerTimingRecorder producerTimingRecorderFor(ProducerToken token) {\n              return ProducerTimingRecorder.noOp();\n            }\n          };\n\n  private static void logCreateException(\n      RuntimeException e, ProductionComponentTimingRecorder.Factory factory, Object component) {\n    logger.log(\n        Level.SEVERE,\n        \"RuntimeException while calling ProductionComponentTimingRecorder.Factory.create on\"\n            + \" factory \"\n            + factory\n            + \" with component \"\n            + component,\n        e);\n  }\n\n  private static void logProducerTimingRecorderForException(\n      RuntimeException e, ProductionComponentTimingRecorder recorder, ProducerToken token) {\n    logger.log(\n        Level.SEVERE,\n        \"RuntimeException while calling ProductionComponentTimingRecorder.producerTimingRecorderFor\"\n            + \"on recorder \"\n            + recorder\n            + \" with token \"\n            + token,\n        e);\n  }\n\n  private static void logProducerTimingRecorderMethodException(\n      RuntimeException e, ProducerTimingRecorder recorder, String method) {\n    logger.log(\n        Level.SEVERE,\n        \"RuntimeException while calling ProducerTimingRecorder.\"\n            + method\n            + \" on recorder \"\n            + recorder,\n        e);\n  }\n\n  private TimingRecorders() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\package-info.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * This package contains the public API for Dagger 2\u0027s producer functionality.\n *\n * \u003cp\u003eDagger Producers is an extension to Dagger that implements asynchronous\n * dependency injection in Java.\n *\n * \u003cp\u003eExtended documentation on Dagger Producers can be found at\n * \u003ca href\u003d\"http://google.github.io/dagger/producers\"\u003e\n * google.github.io/dagger/producers\u003c/a\u003e.\n *\n */\n\npackage dagger.producers;\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\Produced.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.base.Objects;\nimport dagger.internal.Beta;\nimport java.util.concurrent.ExecutionException;\nimport javax.annotation.CheckReturnValue;\nimport javax.annotation.Nullable;\n\n/**\n * An interface that represents the result of a {@linkplain Producer production} of type {@code T},\n * or an exception that was thrown during that production. For any type {@code T} that can be\n * injected, you can also inject {@code Produced\u003cT\u003e}, which enables handling of any exceptions that\n * were thrown during the production of {@code T}.\n *\n * \u003cp\u003eFor example: \u003cpre\u003e\u003ccode\u003e\n *   {@literal @}Produces Html getResponse(\n *       UserInfo criticalInfo, {@literal Produced\u003cExtraInfo\u003e} noncriticalInfo) {\n *     try {\n *       return new Html(criticalInfo, noncriticalInfo.get());\n *     } catch (ExecutionException e) {\n *       logger.warning(e, \"Noncritical info\");\n *       return new Html(criticalInfo);\n *     }\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * @author Jesse Beder\n */\n@Beta\n@CheckReturnValue\npublic abstract class Produced\u003cT\u003e {\n  /**\n   * Returns the result of a production.\n   *\n   * @throws ExecutionException if the production threw an exception\n   */\n  public abstract T get() throws ExecutionException;\n\n  /**\n   * Two {@code Produced} objects compare equal if both are successful with equal values, or both\n   * are failed with equal exceptions.\n   */\n  @Override\n  public abstract boolean equals(Object o);\n\n  /** Returns an appropriate hash code to match {@link #equals(Object)}. */\n  @Override\n  public abstract int hashCode();\n\n  /** Returns a successful {@code Produced}, whose {@link #get} will return the given value. */\n  public static \u003cT\u003e Produced\u003cT\u003e successful(@Nullable T value) {\n    return new Successful\u003cT\u003e(value);\n  }\n\n  /**\n   * Returns a failed {@code Produced}, whose {@link #get} will throw an\n   * {@code ExecutionException} with the given cause.\n   */\n  public static \u003cT\u003e Produced\u003cT\u003e failed(Throwable throwable) {\n    return new Failed\u003cT\u003e(checkNotNull(throwable));\n  }\n\n  private static final class Successful\u003cT\u003e extends Produced\u003cT\u003e {\n    @Nullable private final T value;\n\n    private Successful(@Nullable T value) {\n      this.value \u003d value;\n    }\n\n    @Override public T get() {\n      return value;\n    }\n\n    @Override public boolean equals(Object o) {\n      if (o \u003d\u003d this) {\n        return true;\n      } else if (o instanceof Successful) {\n        Successful\u003c?\u003e that \u003d (Successful\u003c?\u003e) o;\n        return Objects.equal(this.value, that.value);\n      } else {\n        return false;\n      }\n    }\n\n    @Override public int hashCode() {\n      return value \u003d\u003d null ? 0 : value.hashCode();\n    }\n  }\n\n  private static final class Failed\u003cT\u003e extends Produced\u003cT\u003e {\n    private final Throwable throwable;\n\n    private Failed(Throwable throwable) {\n      this.throwable \u003d checkNotNull(throwable);\n    }\n\n    @Override public T get() throws ExecutionException {\n      throw new ExecutionException(throwable);\n    }\n\n    @Override public boolean equals(Object o) {\n      if (o \u003d\u003d this) {\n        return true;\n      } else if (o instanceof Failed) {\n        Failed\u003c?\u003e that \u003d (Failed\u003c?\u003e) o;\n        return this.throwable.equals(that.throwable);\n      } else {\n        return false;\n      }\n    }\n\n    @Override public int hashCode() {\n      return throwable.hashCode();\n    }\n  }\n\n  private Produced() {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\Producer.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.internal.Beta;\nimport javax.annotation.CheckReturnValue;\n\n/**\n * An interface that represents the production of a type {@code T}. You can also inject\n * {@code Producer\u003cT\u003e} instead of {@code T}, which will delay the execution of any code that\n * produces the {@code T} until {@link #get} is called.\n *\n * \u003cp\u003eFor example, you might inject {@code Producer} to lazily choose between several different\n * implementations of some type: \u003cpre\u003e\u003ccode\u003e\n *   {@literal @Produces ListenableFuture\u003cHeater\u003e} getHeater(\n *       HeaterFlag flag,\n *       {@literal @Electric Producer\u003cHeater\u003e} electricHeater,\n *       {@literal @Gas Producer\u003cHeater\u003e} gasHeater) {\n *     return flag.useElectricHeater() ? electricHeater.get() : gasHeater.get();\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003cp\u003eHere is a complete example that demonstrates how calling {@code get()} will cause each\n * method to be executed: \u003cpre\u003e\u003ccode\u003e\n *\n *   {@literal @}ProducerModule\n *   final class MyModule {\n *     {@literal @Produces ListenableFuture\u003cA\u003e} a() {\n *       System.out.println(\"a\");\n *       return Futures.immediateFuture(new A());\n *     }\n *\n *     {@literal @Produces ListenableFuture\u003cB\u003e} b(A a) {\n *       System.out.println(\"b\");\n *       return Futures.immediateFuture(new B(a));\n *     }\n *\n *     {@literal @Produces ListenableFuture\u003cC\u003e} c(B b) {\n *       System.out.println(\"c\");\n *       return Futures.immediateFuture(new C(b));\n *     }\n *\n *     {@literal @Produces @Delayed ListenableFuture\u003cC\u003e} delayedC(A a, {@literal Producer\u003cC\u003e} c) {\n *       System.out.println(\"delayed c\");\n *       return c.get();\n *     }\n *   }\n *\n *   {@literal @}ProductionComponent(modules \u003d MyModule.class)\n *   interface MyComponent {\n *     {@literal @Delayed ListenableFuture\u003cC\u003e} delayedC();\n *   }\n * \u003c/code\u003e\u003c/pre\u003e\n * Suppose we instantiate the generated implementation of this component and call\n * {@code delayedC()}: \u003cpre\u003e\u003ccode\u003e\n *   MyComponent component \u003d DaggerMyComponent\n *       .builder()\n *       .executor(MoreExecutors.directExecutor())\n *       .build();\n *   System.out.println(\"Constructed component\");\n *   {@literal ListenableFuture\u003cC\u003e} cFuture \u003d component.delayedC();\n *   System.out.println(\"Retrieved future\");\n *   C c \u003d cFuture.get();\n *   System.out.println(\"Retrieved c\");\n * \u003c/code\u003e\u003c/pre\u003e\n * Here, we\u0027re using {@code MoreExecutors.directExecutor} in order to illustrate how each call\n * directly causes code to execute. The above code will print: \u003cpre\u003e\u003ccode\u003e\n *   Constructed component\n *   a\n *   delayed c\n *   b\n *   c\n *   Retrieved future\n *   Retrieved c\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * @author Jesse Beder\n */\n@Beta\npublic interface Producer\u003cT\u003e {\n  /**\n   * Returns a future representing a running task that produces a value. Calling this method will\n   * trigger the submission of this task to the executor, if it has not already been triggered. In\n   * order to trigger this task\u0027s submission, the transitive dependencies required to produce the\n   * {@code T} will be submitted to the executor, as their dependencies become available.\n   *\n   * \u003cp\u003eIf the key is bound to a {@link Produces} method, then calling this method multiple times\n   * will return the same future.\n   */\n  @CheckReturnValue\n  ListenableFuture\u003cT\u003e get();\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\ProducerModule.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers;\n\nimport static java.lang.annotation.ElementType.TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport dagger.Module;\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n/**\n * Annotates a class that contributes {@link Produces} bindings to the production component.\n *\n * @author Jesse Beder\n */\n@Documented\n@Target(TYPE)\n@Retention(RUNTIME)\n@Beta\npublic @interface ProducerModule {\n  /**\n   * Additional {@code @ProducerModule}- or {@link Module}-annotated classes from which this module\n   * is composed. The de-duplicated contributions of the modules in {@code includes}, and of their\n   * inclusions recursively, are all contributed to the object graph.\n   */\n  Class\u003c?\u003e[] includes() default {};\n\n  /**\n   * Any {@link dagger.Subcomponent}- or {@link ProductionSubcomponent}-annotated classes which\n   * should be children of the component in which this module is installed. A subcomponent may be\n   * listed in more than one module in a component.\n   *\n   * @since 2.7\n   */\n  Class\u003c?\u003e[] subcomponents() default {};\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\Produces.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n/**\n * Annotates methods of a producer module to create a production binding. If the method returns\n * a {@link ListenableFuture}, then the parameter type of the future is bound to the value that the\n * future provides; otherwise, the return type is bound to the returned value. The production\n * component will pass dependencies to the method as parameters.\n *\n * @author Jesse Beder\n */\n@Documented\n@Target(METHOD)\n@Retention(RUNTIME)\n@Beta\npublic @interface Produces {\n  /** The type of binding into which the return type of the annotated method contributes. */\n  enum Type {\n    /**\n     * The method is the only one which can produce the value for the specified type. This is the\n     * default behavior.\n     */\n    UNIQUE,\n\n    /**\n     * The method\u0027s resulting type forms the generic type argument of a {@code Set\u003cT\u003e}, and the\n     * returned value or future is contributed to the set. The {@code Set\u003cT\u003e} produced from the\n     * accumulation of values will be immutable.\n     */\n    SET,\n\n    /**\n     * Like {@link #SET}, except the method\u0027s return type is either {@code Set\u003cT\u003e} or\n     * {@code Set\u003cListenableFuture\u003cT\u003e\u003e}, where any values are contributed to the set. An example use\n     * is to provide a default empty set binding, which is otherwise not possible using\n     * {@link #SET}.\n     */\n    SET_VALUES,\n\n    /**\n     * The method\u0027s return type forms the type argument for the value of a\n     * {@code Map\u003cK, Producer\u003cV\u003e\u003e}, and the combination of the annotated key and the returned value\n     * is contributed to the map as a key/value pair. The {@code Map\u003cK, Producer\u003cV\u003e\u003e} produced from\n     * the accumulation of values will be immutable.\n     */\n    MAP;\n  }\n\n  Type type() default Type.UNIQUE;\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\Production.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport javax.inject.Qualifier;\n\n/**\n * Qualifies a type that will be provided to the framework for use internally.\n *\n * \u003cp\u003eThe only type that may be so qualified is {@link java.util.concurrent.Executor}. In this case,\n * the resulting executor is used to schedule {@linkplain Produces producer methods} in a\n * {@link ProductionComponent} or {@link ProductionSubcomponent}.\n */\n@Documented\n@Retention(RUNTIME)\n@Qualifier\n@Beta\npublic @interface Production {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\ProductionComponent.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers;\n\nimport static java.lang.annotation.ElementType.TYPE;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.Module;\nimport dagger.Provides;\nimport dagger.internal.Beta;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Target;\nimport javax.inject.Inject;\nimport javax.inject.Qualifier;\n\n/**\n * Annotates an interface or abstract class for which a fully-formed, dependency-injected\n * implementation is to be generated from a set of {@linkplain #modules modules}. The generated\n * class will have the name of the type annotated with {@code @ProductionComponent} prepended with\n * {@code Dagger}.  For example, {@code @ProductionComponent interface MyComponent {...}} will\n * produce an implementation named {@code DaggerMyComponent}.\n *\n * \u003cp\u003eEach {@link Produces} method that contributes to the component will be called at most once per\n * component instance, no matter how many times that binding is used as a dependency.\n * TODO(beder): Decide on how scope works for producers.\n *\n * \u003ch2\u003eComponent methods\u003c/h2\u003e\n *\n * \u003cp\u003eEvery type annotated with {@code @ProductionComponent} must contain at least one abstract\n * component method. Component methods must represent {@linkplain Producer production}.\n *\n * Production methods have no arguments and return either a {@link ListenableFuture} or\n * {@link Producer} of a type that is {@link Inject injected}, {@link Provides provided}, or\n * {@link Produces produced}. Each may have a {@link Qualifier} annotation as well. The following\n * are all valid production method declarations: \u003cpre\u003e\u003ccode\u003e\n *   {@literal ListenableFuture\u003cSomeType\u003e} getSomeType();\n *   {@literal Producer\u003cSet\u003cSomeType\u003e\u003e} getSomeTypes();\n *   {@literal @Response ListenableFuture\u003cHtml\u003e} getResponse();\n * \u003c/code\u003e\u003c/pre\u003e\n *\n * \u003ch2\u003eExceptions\u003c/h2\u003e\n *\n * \u003cp\u003eWhen a producer throws an exception, the exception will be propagated to its downstream\n * producers in the following way: if the downstream producer injects a type {@code T}, then that\n * downstream producer will be skipped, and the exception propagated to its downstream producers;\n * and if the downstream producer injects a {@code Produced\u003cT\u003e}, then the downstream producer will\n * be run with the exception stored in the {@code Produced\u003cT\u003e}.\n *\n * \u003cp\u003eIf a non-execution exception is thrown (e.g., an {@code InterruptedException} or\n * {@code CancellationException}), then exception is handled as in\n * {@link com.google.common.util.concurrent.Futures#transform}.\n * \u003c!-- TODO(beder): Explain this more thoroughly, and update the javadocs of those utilities. --\u003e\n *\n * \u003ch2\u003eExecutor\u003c/h2\u003e\n *\n * \u003cp\u003eThe component must include a binding for \u003ccode\u003e{@literal @}Production Executor\u003c/code\u003e;\n * this binding will be called exactly once, and the provided executor will be used by the framework\n * to schedule all producer methods (for this component, and any {@link ProductionSubcomponent} it\n * may have.\n *\n * @author Jesse Beder\n */\n@Documented\n@Target(TYPE)\n@Beta\npublic @interface ProductionComponent {\n  /**\n   * A list of classes annotated with {@link Module} or {@link ProducerModule} whose bindings are\n   * used to generate the component implementation.\n   */\n  Class\u003c?\u003e[] modules() default {};\n\n  /**\n   * A list of types that are to be used as component dependencies.\n   */\n  Class\u003c?\u003e[] dependencies() default {};\n\n  /**\n   * A builder for a component. Components may have a single nested static abstract class or\n   * interface annotated with {@code @ProductionComponent.Builder}. If they do, then the component\u0027s\n   * generated builder will match the API in the type.  Builders must follow some rules:\n   * \u003cul\u003e\n   * \u003cli\u003e A single abstract method with no arguments must exist, and must return the component.\n   *      (This is typically the {@code build()} method.)\n   * \u003cli\u003e All other abstract methods must take a single argument and must return void,\n   *      the builder type, or a supertype of the builder.\n   * \u003cli\u003e Each component dependency \u003cb\u003emust\u003c/b\u003e have an abstract setter method.\n   * \u003cli\u003e Each module dependency that Dagger can\u0027t instantiate itself (i.e., the module\n   *      doesn\u0027t have a visible no-args constructor) \u003cb\u003emust\u003c/b\u003e have an abstract setter method.\n   *      Other module dependencies (ones that Dagger can instantiate) are allowed, but not\n   *      required.\n   * \u003cli\u003e Non-abstract methods are allowed, but ignored as far as validation and builder generation\n   *      are concerned.\n   * \u003c/ul\u003e\n   *\n   * For example, this could be a valid {@code ProductionComponent} with a builder: \u003cpre\u003e\u003ccode\u003e\n   * {@literal @}ProductionComponent(modules \u003d {BackendModule.class, FrontendModule.class})\n   * interface MyComponent {\n   *   {@literal ListenableFuture\u003cMyWidget\u003e} myWidget();\n   *\n   *   {@literal @}ProductionComponent.Builder\n   *   interface Builder {\n   *     MyComponent build();\n   *     Builder backendModule(BackendModule bm);\n   *     Builder frontendModule(FrontendModule fm);\n   *   }\n   * }\u003c/code\u003e\u003c/pre\u003e\n   */\n  @Target(TYPE)\n  @Documented\n  @interface Builder {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\ProductionScope.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport javax.inject.Scope;\n\n/**\n * A scope annotation for provision bindings that are tied to the lifetime of a\n * {@link ProductionComponent} or {@link ProductionSubcomponent}.\n */\n@Documented\n@Retention(RUNTIME)\n@Scope\npublic @interface ProductionScope {}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\main\\java\\dagger\\producers\\ProductionSubcomponent.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers;\n\nimport static java.lang.annotation.ElementType.TYPE;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport dagger.Component;\nimport dagger.Module;\nimport dagger.Subcomponent;\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\n/**\n * A subcomponent that inherits the bindings from a parent {@link Component}, {@link Subcomponent},\n * {@link ProductionComponent}, or {@link ProductionSubcomponent}. The details of how to associate a\n * subcomponent with a parent are described in the documentation for {@link Component}.\n *\n * \u003cp\u003eThe executor for a production subcomponent is supplied by binding\n * \u003ccode\u003e{@literal @}Production Executor\u003c/code\u003e, similar to {@link ProductionComponent}. Note that\n * this binding may be in an ancestor component.\n *\n * @author Jesse Beder\n */\n@Retention(RUNTIME) // Allows runtimes to have specialized behavior interoperating with Dagger.\n@Target(TYPE)\n@Documented\npublic @interface ProductionSubcomponent {\n  /**\n   * A list of classes annotated with {@link Module} or {@link ProducerModule} whose bindings are\n   * used to generate the subcomponent implementation.  Note that through the use of\n   * {@link Module#includes} or {@link ProducerModule#includes} the full set of modules used to\n   * implement the subcomponent may include more modules that just those listed here.\n   */\n  Class\u003c?\u003e[] modules() default {};\n\n  /**\n   * A builder for a subcomponent.  This follows all the rules of\n   * {@link ProductionComponent.Builder}, except it must appear in classes annotated with\n   * {@link ProductionSubcomponent} instead of {@code ProductionComponent}. Components can have\n   * methods that return a {@link ProductionSubcomponent.Builder}-annotated type, allowing the user\n   * to set modules on the subcomponent using their defined API.\n   */\n  @Target(TYPE)\n  @Documented\n  @interface Builder {}\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\test\\java\\dagger\\producers\\internal\\AbstractProducerTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.common.util.concurrent.SettableFuture;\nimport dagger.producers.Producer;\nimport dagger.producers.monitoring.ProducerMonitor;\nimport dagger.producers.monitoring.ProducerToken;\nimport dagger.producers.monitoring.ProductionComponentMonitor;\nimport java.util.concurrent.ExecutionException;\nimport javax.inject.Provider;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport org.mockito.Mock;\nimport org.mockito.Mockito;\nimport org.mockito.MockitoAnnotations;\n\n/**\n * Tests {@link AbstractProducer}.\n */\n@RunWith(JUnit4.class)\npublic class AbstractProducerTest {\n  @Mock private ProductionComponentMonitor componentMonitor;\n  private ProducerMonitor monitor;\n  private Provider\u003cProductionComponentMonitor\u003e componentMonitorProvider;\n\n  @Before\n  public void initMocks() {\n    MockitoAnnotations.initMocks(this);\n    monitor \u003d Mockito.mock(ProducerMonitor.class, Mockito.CALLS_REAL_METHODS);\n    when(componentMonitor.producerMonitorFor(any(ProducerToken.class))).thenReturn(monitor);\n    componentMonitorProvider \u003d\n        new Provider\u003cProductionComponentMonitor\u003e() {\n          @Override\n          public ProductionComponentMonitor get() {\n            return componentMonitor;\n          }\n        };\n  }\n\n  @Test\n  @SuppressWarnings(\"CheckReturnValue\")\n  public void get_nullPointerException() {\n    Producer\u003cObject\u003e producer \u003d new DelegateProducer\u003c\u003e(componentMonitorProvider, null);\n    try {\n      producer.get();\n      fail();\n    } catch (NullPointerException expected) {\n    }\n  }\n\n  @Test public void get() throws Exception {\n    Producer\u003cInteger\u003e producer \u003d\n        new AbstractProducer\u003cInteger\u003e(componentMonitorProvider, null) {\n          int i \u003d 0;\n\n          @Override\n          public ListenableFuture\u003cInteger\u003e compute() {\n            return Futures.immediateFuture(i++);\n          }\n        };\n    assertThat(producer.get().get()).isEqualTo(0);\n    assertThat(producer.get().get()).isEqualTo(0);\n    assertThat(producer.get().get()).isEqualTo(0);\n  }\n\n  @Test\n  public void monitor_success() throws Exception {\n    SettableFuture\u003cInteger\u003e delegateFuture \u003d SettableFuture.create();\n    Producer\u003cInteger\u003e producer \u003d new DelegateProducer\u003c\u003e(componentMonitorProvider, delegateFuture);\n\n    ListenableFuture\u003cInteger\u003e future \u003d producer.get();\n    assertThat(future.isDone()).isFalse();\n    verify(monitor).requested();\n    verify(monitor).addCallbackTo(anyListenableFuture());\n    delegateFuture.set(-42);\n    assertThat(future.get()).isEqualTo(-42);\n    verify(monitor).succeeded(-42);\n    verifyNoMoreInteractions(monitor);\n  }\n\n  @Test\n  public void monitor_failure() throws Exception {\n    SettableFuture\u003cInteger\u003e delegateFuture \u003d SettableFuture.create();\n    Producer\u003cInteger\u003e producer \u003d new DelegateProducer\u003c\u003e(componentMonitorProvider, delegateFuture);\n\n    ListenableFuture\u003cInteger\u003e future \u003d producer.get();\n    assertThat(future.isDone()).isFalse();\n    verify(monitor).requested();\n    verify(monitor).addCallbackTo(anyListenableFuture());\n    Throwable t \u003d new RuntimeException(\"monkey\");\n    delegateFuture.setException(t);\n    try {\n      future.get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).isSameAs(t);\n    }\n    verify(monitor).failed(t);\n    verifyNoMoreInteractions(monitor);\n  }\n\n  private ListenableFuture\u003c?\u003e anyListenableFuture() {\n    return any(ListenableFuture.class);\n  }\n\n  @Test(expected \u003d NullPointerException.class)\n  public void monitor_null() throws Exception {\n    new DelegateProducer\u003c\u003e(null, Futures.immediateFuture(42));\n  }\n\n  static final class DelegateProducer\u003cT\u003e extends AbstractProducer\u003cT\u003e {\n    private final ListenableFuture\u003cT\u003e delegate;\n\n    DelegateProducer(\n        Provider\u003cProductionComponentMonitor\u003e componentMonitorProvider,\n        ListenableFuture\u003cT\u003e delegate) {\n      super(componentMonitorProvider, null);\n      this.delegate \u003d delegate;\n    }\n\n    @Override\n    public ListenableFuture\u003cT\u003e compute() {\n      assertThat(monitor).isNotNull();\n      return delegate;\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\test\\java\\dagger\\producers\\internal\\MapOfProducerProducerTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\n\nimport dagger.producers.Producer;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic final class MapOfProducerProducerTest {\n  @Test\n  public void success() throws Exception {\n    MapOfProducerProducer\u003cInteger, String\u003e mapOfProducerProducer \u003d\n        MapOfProducerProducer.\u003cInteger, String\u003ebuilder(2)\n            .put(15, Producers.\u003cString\u003eimmediateProducer(\"fifteen\"))\n            .put(42, Producers.\u003cString\u003eimmediateProducer(\"forty two\"))\n            .build();\n    Map\u003cInteger, Producer\u003cString\u003e\u003e map \u003d mapOfProducerProducer.get().get();\n    assertThat(map).hasSize(2);\n    assertThat(map).containsKey(15);\n    assertThat(map.get(15).get().get()).isEqualTo(\"fifteen\");\n    assertThat(map).containsKey(42);\n    assertThat(map.get(42).get().get()).isEqualTo(\"forty two\");\n  }\n\n  @Test\n  public void failingContributionDoesNotFailMap() throws Exception {\n    RuntimeException cause \u003d new RuntimeException(\"monkey\");\n    MapOfProducerProducer\u003cInteger, String\u003e mapOfProducerProducer \u003d\n        MapOfProducerProducer.\u003cInteger, String\u003ebuilder(2)\n            .put(15, Producers.\u003cString\u003eimmediateProducer(\"fifteen\"))\n            .put(42, Producers.\u003cString\u003eimmediateFailedProducer(cause))\n            .build();\n    Map\u003cInteger, Producer\u003cString\u003e\u003e map \u003d mapOfProducerProducer.get().get();\n    assertThat(map).hasSize(2);\n    assertThat(map).containsKey(15);\n    assertThat(map.get(15).get().get()).isEqualTo(\"fifteen\");\n    assertThat(map).containsKey(42);\n    try {\n      map.get(42).get().get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).isSameAs(cause);\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\test\\java\\dagger\\producers\\internal\\MapProducerTest.java",
    "code": "\"/*\n * Copyright (C) 2016 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\n\nimport com.google.common.collect.ImmutableMap;\nimport dagger.producers.Producer;\nimport java.util.Map;\nimport java.util.concurrent.ExecutionException;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n@RunWith(JUnit4.class)\npublic final class MapProducerTest {\n  @Test\n  public void success() throws Exception {\n    Producer\u003cMap\u003cInteger, String\u003e\u003e mapProducer \u003d\n        MapProducer.create(\n            Producers.\u003cMap\u003cInteger, Producer\u003cString\u003e\u003e\u003eimmediateProducer(\n                ImmutableMap.\u003cInteger, Producer\u003cString\u003e\u003eof(\n                    15,\n                    Producers.\u003cString\u003eimmediateProducer(\"fifteen\"),\n                    42,\n                    Producers.\u003cString\u003eimmediateProducer(\"forty two\"))));\n    Map\u003cInteger, String\u003e map \u003d mapProducer.get().get();\n    assertThat(map).hasSize(2);\n    assertThat(map).containsEntry(15, \"fifteen\");\n    assertThat(map).containsEntry(42, \"forty two\");\n  }\n\n  @Test\n  public void failingContribution() throws Exception {\n    RuntimeException cause \u003d new RuntimeException(\"monkey\");\n    Producer\u003cMap\u003cInteger, String\u003e\u003e mapProducer \u003d\n        MapProducer.create(\n            Producers.\u003cMap\u003cInteger, Producer\u003cString\u003e\u003e\u003eimmediateProducer(\n                ImmutableMap.\u003cInteger, Producer\u003cString\u003e\u003eof(\n                    15,\n                    Producers.\u003cString\u003eimmediateProducer(\"fifteen\"),\n                    42,\n                    Producers.\u003cString\u003eimmediateFailedProducer(cause))));\n    try {\n      mapProducer.get().get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).isSameAs(cause);\n    }\n  }\n\n  @Test\n  public void failingInput() throws Exception {\n    RuntimeException cause \u003d new RuntimeException(\"monkey\");\n    Producer\u003cMap\u003cInteger, String\u003e\u003e mapProducer \u003d\n        MapProducer.create(\n            Producers.\u003cMap\u003cInteger, Producer\u003cString\u003e\u003e\u003eimmediateFailedProducer(cause));\n    try {\n      mapProducer.get().get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).isSameAs(cause);\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\test\\java\\dagger\\producers\\internal\\ProducersTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.common.util.concurrent.SettableFuture;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport java.util.Set;\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport javax.inject.Provider;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/**\n * Tests {@link Producers}.\n */\n@RunWith(JUnit4.class)\npublic class ProducersTest {\n  @Test public void createFutureProduced_success() throws Exception {\n    ListenableFuture\u003cString\u003e future \u003d Futures.immediateFuture(\"monkey\");\n    ListenableFuture\u003cProduced\u003cString\u003e\u003e producedFuture \u003d Producers.createFutureProduced(future);\n    assertThat(producedFuture.isDone()).isTrue();\n    assertThat(producedFuture.get().get()).isEqualTo(\"monkey\");\n  }\n\n  @Test public void createFutureProduced_failure() throws Exception {\n    ListenableFuture\u003cString\u003e future \u003d Futures.immediateFailedFuture(new RuntimeException(\"monkey\"));\n    ListenableFuture\u003cProduced\u003cString\u003e\u003e producedFuture \u003d Producers.createFutureProduced(future);\n    assertThat(producedFuture.isDone()).isTrue();\n    assertThat(getProducedException(producedFuture.get()).getCause()).hasMessage(\"monkey\");\n  }\n\n  @Test public void createFutureProduced_cancelPropagatesBackwards() throws Exception {\n    ListenableFuture\u003cString\u003e future \u003d SettableFuture.create();\n    ListenableFuture\u003cProduced\u003cString\u003e\u003e producedFuture \u003d Producers.createFutureProduced(future);\n    assertThat(producedFuture.isDone()).isFalse();\n    producedFuture.cancel(false);\n    assertThat(future.isCancelled()).isTrue();\n  }\n\n  @Test public void createFutureProduced_cancelDoesNotPropagateForwards() throws Exception {\n    ListenableFuture\u003cString\u003e future \u003d SettableFuture.create();\n    ListenableFuture\u003cProduced\u003cString\u003e\u003e producedFuture \u003d Producers.createFutureProduced(future);\n    assertThat(producedFuture.isDone()).isFalse();\n    future.cancel(false);\n    assertThat(producedFuture.isCancelled()).isFalse();\n    assertThat(getProducedException(producedFuture.get()).getCause())\n        .isInstanceOf(CancellationException.class);\n  }\n\n  private \u003cT\u003e ExecutionException getProducedException(Produced\u003cT\u003e produced) {\n    try {\n      T value \u003d produced.get();\n      throw new IllegalArgumentException(\"produced did not throw, but returned \" + value);\n    } catch (ExecutionException e) {\n      return e;\n    }\n  }\n\n  @Test public void createFutureSingletonSet_success() throws Exception {\n    ListenableFuture\u003cString\u003e future \u003d Futures.immediateFuture(\"monkey\");\n    ListenableFuture\u003cSet\u003cString\u003e\u003e setFuture \u003d Producers.createFutureSingletonSet(future);\n    assertThat(setFuture.isDone()).isTrue();\n    assertThat(setFuture.get()).containsExactly(\"monkey\");\n  }\n\n  @Test public void createFutureSingletonSet_failure() throws Exception {\n    ListenableFuture\u003cString\u003e future \u003d Futures.immediateFailedFuture(new RuntimeException(\"monkey\"));\n    ListenableFuture\u003cSet\u003cString\u003e\u003e setFuture \u003d Producers.createFutureSingletonSet(future);\n    assertThat(setFuture.isDone()).isTrue();\n    try {\n      setFuture.get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).hasMessage(\"monkey\");\n    }\n  }\n\n  @Test\n  public void allAsSet_success() throws Exception {\n    ListenableFuture\u003cSet\u003cString\u003e\u003e future \u003d\n        Producers.allAsSet(\n            ImmutableList.of(\n                Futures.immediateFuture(\"monkey\"), Futures.immediateFuture(\"gorilla\")));\n    assertThat(future.isDone()).isTrue();\n    assertThat(future.get()).containsExactly(\"monkey\", \"gorilla\");\n  }\n\n  @Test\n  public void allAsSet_failure() throws Exception {\n    ListenableFuture\u003cSet\u003cString\u003e\u003e future \u003d\n        Producers.allAsSet(\n            ImmutableList.of(\n                Futures.immediateFuture(\"monkey\"),\n                Futures.\u003cString\u003eimmediateFailedFuture(new RuntimeException(\"gorilla\"))));\n    assertThat(future.isDone()).isTrue();\n    try {\n      future.get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).hasMessage(\"gorilla\");\n    }\n  }\n\n  @Test public void producerFromProvider() throws Exception {\n    Producer\u003cInteger\u003e producer \u003d Producers.producerFromProvider(new Provider\u003cInteger\u003e() {\n      int i \u003d 0;\n\n      @Override public Integer get() {\n        return i++;\n      }\n    });\n    assertThat(producer.get().get()).isEqualTo(0);\n    assertThat(producer.get().get()).isEqualTo(0);\n    assertThat(producer.get().get()).isEqualTo(0);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\test\\java\\dagger\\producers\\internal\\SetOfProducedProducerTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport static com.google.common.truth.Truth.assertThat;\n\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Sets;\nimport dagger.producers.Produced;\nimport dagger.producers.Producer;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/**\n * Tests {@link SetOfProducedProducer}.\n */\n@RunWith(JUnit4.class)\npublic class SetOfProducedProducerTest {\n  @Test\n  public void success() throws Exception {\n    Producer\u003cSet\u003cProduced\u003cInteger\u003e\u003e\u003e producer \u003d\n        SetOfProducedProducer.\u003cInteger\u003ebuilder(1, 1)\n            .addProducer(Producers.immediateProducer(1))\n            .addCollectionProducer(Producers.\u003cSet\u003cInteger\u003e\u003eimmediateProducer(ImmutableSet.of(5, 7)))\n            .build();\n    assertThat(producer.get().get())\n        .containsExactly(\n            Produced.successful(1),\n            Produced.successful(5),\n            Produced.successful(7));\n  }\n\n  @Test\n  public void failure() throws Exception {\n    RuntimeException e \u003d new RuntimeException(\"monkey\");\n    Producer\u003cSet\u003cProduced\u003cInteger\u003e\u003e\u003e producer \u003d\n        SetOfProducedProducer.\u003cInteger\u003ebuilder(1, 1)\n            .addCollectionProducer(Producers.\u003cSet\u003cInteger\u003e\u003eimmediateProducer(ImmutableSet.of(1, 2)))\n            .addProducer(Producers.\u003cInteger\u003eimmediateFailedProducer(e))\n            .build();\n    assertThat(producer.get().get())\n        .containsExactly(\n            Produced.successful(1), Produced.successful(2), Produced.\u003cInteger\u003efailed(e));\n  }\n\n  @Test\n  public void delegateNpe() throws Exception {\n    Producer\u003cSet\u003cProduced\u003cInteger\u003e\u003e\u003e producer \u003d\n        SetOfProducedProducer.\u003cInteger\u003ebuilder(1, 0)\n            .addProducer(Producers.\u003cInteger\u003eimmediateProducer(null))\n            .build();\n    Results\u003cInteger\u003e results \u003d Results.create(producer.get().get());\n    assertThat(results.successes).isEmpty();\n    assertThat(results.failures).hasSize(1);\n    assertThat(Iterables.getOnlyElement(results.failures).getCause())\n        .isInstanceOf(NullPointerException.class);\n  }\n\n  @Test\n  public void delegateSetNpe() throws Exception {\n    Producer\u003cSet\u003cProduced\u003cInteger\u003e\u003e\u003e producer \u003d\n        SetOfProducedProducer.\u003cInteger\u003ebuilder(0, 1)\n            .addCollectionProducer(Producers.\u003cSet\u003cInteger\u003e\u003eimmediateProducer(null))\n            .build();\n    Results\u003cInteger\u003e results \u003d Results.create(producer.get().get());\n    assertThat(results.successes).isEmpty();\n    assertThat(results.failures).hasSize(1);\n    assertThat(Iterables.getOnlyElement(results.failures).getCause())\n        .isInstanceOf(NullPointerException.class);\n  }\n\n  @Test\n  public void delegateElementNpe() throws Exception {\n    Producer\u003cSet\u003cProduced\u003cInteger\u003e\u003e\u003e producer \u003d\n        SetOfProducedProducer.\u003cInteger\u003ebuilder(0, 1)\n            .addCollectionProducer(\n                Producers.\u003cSet\u003cInteger\u003e\u003eimmediateProducer(Collections.\u003cInteger\u003esingleton(null)))\n            .build();\n    Results\u003cInteger\u003e results \u003d Results.create(producer.get().get());\n    assertThat(results.successes).isEmpty();\n    assertThat(results.failures).hasSize(1);\n    assertThat(Iterables.getOnlyElement(results.failures).getCause())\n        .isInstanceOf(NullPointerException.class);\n  }\n\n  @Test\n  public void oneOfDelegateElementNpe() throws Exception {\n    Producer\u003cSet\u003cProduced\u003cInteger\u003e\u003e\u003e producer \u003d\n        SetOfProducedProducer.\u003cInteger\u003ebuilder(0, 1)\n            .addCollectionProducer(\n                Producers.\u003cSet\u003cInteger\u003e\u003eimmediateProducer(\n                    Sets.newHashSet(Arrays.asList(5, 2, null))))\n            .build();\n    Results\u003cInteger\u003e results \u003d Results.create(producer.get().get());\n    assertThat(results.successes).containsExactly(2, 5);\n    assertThat(results.failures).hasSize(1);\n    assertThat(Iterables.getOnlyElement(results.failures).getCause())\n        .isInstanceOf(NullPointerException.class);\n  }\n\n  static final class Results\u003cT\u003e {\n    final ImmutableSet\u003cT\u003e successes;\n    final ImmutableSet\u003cExecutionException\u003e failures;\n\n    private Results(ImmutableSet\u003cT\u003e successes, ImmutableSet\u003cExecutionException\u003e failures) {\n      this.successes \u003d successes;\n      this.failures \u003d failures;\n    }\n\n    static \u003cT\u003e Results\u003cT\u003e create(Set\u003cProduced\u003cT\u003e\u003e setOfProduced) {\n      ImmutableSet.Builder\u003cT\u003e successes \u003d ImmutableSet.builder();\n      ImmutableSet.Builder\u003cExecutionException\u003e failures \u003d ImmutableSet.builder();\n      for (Produced\u003cT\u003e produced : setOfProduced) {\n        try {\n          successes.add(produced.get());\n        } catch (ExecutionException e) {\n          failures.add(e);\n        }\n      }\n      return new Results\u003cT\u003e(successes.build(), failures.build());\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\test\\java\\dagger\\producers\\internal\\SetProducerTest.java",
    "code": "\"/*\n * Copyright (C) 2014 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.internal;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\n\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport dagger.producers.Producer;\nimport java.util.Collections;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/**\n * Tests {@link SetProducer}.\n */\n@RunWith(JUnit4.class)\npublic class SetProducerTest {\n  @Test\n  public void success() throws Exception {\n    Producer\u003cSet\u003cInteger\u003e\u003e producer \u003d\n        SetProducer.\u003cInteger\u003ebuilder(1, 1)\n            .addProducer(Producers.immediateProducer(1))\n            .addCollectionProducer(Producers.\u003cSet\u003cInteger\u003e\u003eimmediateProducer(ImmutableSet.of(5, 7)))\n            .build();\n    assertThat(producer.get().get()).containsExactly(1, 5, 7);\n  }\n\n  @Test\n  public void delegateNpe() throws Exception {\n    Producer\u003cSet\u003cInteger\u003e\u003e producer \u003d\n        SetProducer.\u003cInteger\u003ebuilder(1, 0)\n            .addProducer(Producers.\u003cInteger\u003eimmediateProducer(null))\n            .build();\n    ListenableFuture\u003cSet\u003cInteger\u003e\u003e future \u003d producer.get();\n    try {\n      future.get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).isInstanceOf(NullPointerException.class);\n    }\n  }\n\n  @Test\n  public void delegateSetNpe() throws Exception {\n    Producer\u003cSet\u003cInteger\u003e\u003e producer \u003d\n        SetProducer.\u003cInteger\u003ebuilder(0, 1)\n            .addCollectionProducer(Producers.\u003cSet\u003cInteger\u003e\u003eimmediateProducer(null))\n            .build();\n    ListenableFuture\u003cSet\u003cInteger\u003e\u003e future \u003d producer.get();\n    try {\n      future.get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).isInstanceOf(NullPointerException.class);\n    }\n  }\n\n  @Test\n  public void delegateElementNpe() throws Exception {\n    Producer\u003cSet\u003cInteger\u003e\u003e producer \u003d\n        SetProducer.\u003cInteger\u003ebuilder(0, 2)\n            .addCollectionProducer(Producers.\u003cSet\u003cInteger\u003e\u003eimmediateProducer(ImmutableSet.of(1, 2)))\n            .addCollectionProducer(\n                Producers.\u003cSet\u003cInteger\u003e\u003eimmediateProducer(Collections.\u003cInteger\u003esingleton(null)))\n            .build();\n    ListenableFuture\u003cSet\u003cInteger\u003e\u003e future \u003d producer.get();\n    try {\n      future.get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).isInstanceOf(NullPointerException.class);\n    }\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\test\\java\\dagger\\producers\\monitoring\\internal\\MonitorsTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.monitoring.internal;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.collect.ImmutableList;\nimport dagger.producers.monitoring.ProducerMonitor;\nimport dagger.producers.monitoring.ProducerToken;\nimport dagger.producers.monitoring.ProductionComponentMonitor;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\n@RunWith(JUnit4.class)\npublic final class MonitorsTest {\n  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactory;\n  @Mock private ProductionComponentMonitor mockProductionComponentMonitor;\n  @Mock private ProducerMonitor mockProducerMonitor;\n  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactoryA;\n  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactoryB;\n  @Mock private ProductionComponentMonitor.Factory mockProductionComponentMonitorFactoryC;\n  @Mock private ProductionComponentMonitor mockProductionComponentMonitorA;\n  @Mock private ProductionComponentMonitor mockProductionComponentMonitorB;\n  @Mock private ProductionComponentMonitor mockProductionComponentMonitorC;\n  @Mock private ProducerMonitor mockProducerMonitorA;\n  @Mock private ProducerMonitor mockProducerMonitorB;\n  @Mock private ProducerMonitor mockProducerMonitorC;\n\n  @Before\n  public void initMocks() {\n    MockitoAnnotations.initMocks(this);\n  }\n\n  @Test\n  public void zeroMonitorsReturnsNoOp() {\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.\u003cProductionComponentMonitor.Factory\u003eof());\n    assertThat(factory).isSameAs(ProductionComponentMonitor.Factory.noOp());\n  }\n\n  @Test\n  public void singleMonitor_nullProductionComponentMonitor() {\n    when(mockProductionComponentMonitorFactory.create(any(Object.class))).thenReturn(null);\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(mockProductionComponentMonitorFactory));\n    assertThat(factory.create(new Object())).isSameAs(ProductionComponentMonitor.noOp());\n  }\n\n  @Test\n  public void singleMonitor_throwingProductionComponentMonitorFactory() {\n    doThrow(new RuntimeException(\"monkey\"))\n        .when(mockProductionComponentMonitorFactory)\n        .create(any(Object.class));\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(mockProductionComponentMonitorFactory));\n    assertThat(factory.create(new Object())).isSameAs(ProductionComponentMonitor.noOp());\n  }\n\n  @Test\n  public void singleMonitor_nullProducerMonitor() {\n    when(mockProductionComponentMonitorFactory.create(any(Object.class)))\n        .thenReturn(mockProductionComponentMonitor);\n    when(mockProductionComponentMonitor.producerMonitorFor(any(ProducerToken.class)))\n        .thenReturn(null);\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(mockProductionComponentMonitorFactory));\n    ProductionComponentMonitor monitor \u003d factory.create(new Object());\n    assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class)))\n        .isSameAs(ProducerMonitor.noOp());\n  }\n\n  @Test\n  public void singleMonitor_throwingProductionComponentMonitor() {\n    when(mockProductionComponentMonitorFactory.create(any(Object.class)))\n        .thenReturn(mockProductionComponentMonitor);\n    doThrow(new RuntimeException(\"monkey\"))\n        .when(mockProductionComponentMonitor)\n        .producerMonitorFor(any(ProducerToken.class));\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(mockProductionComponentMonitorFactory));\n    ProductionComponentMonitor monitor \u003d factory.create(new Object());\n    assertThat(monitor.producerMonitorFor(ProducerToken.create(Object.class)))\n        .isSameAs(ProducerMonitor.noOp());\n  }\n\n  @Test\n  public void singleMonitor_normalProducerMonitorSuccess() {\n    setUpNormalSingleMonitor();\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(mockProductionComponentMonitorFactory));\n    ProductionComponentMonitor monitor \u003d factory.create(new Object());\n    ProducerMonitor producerMonitor \u003d\n        monitor.producerMonitorFor(ProducerToken.create(Object.class));\n    Object o \u003d new Object();\n    producerMonitor.requested();\n    producerMonitor.methodStarting();\n    producerMonitor.methodFinished();\n    producerMonitor.succeeded(o);\n\n    InOrder order \u003d inOrder(mockProducerMonitor);\n    order.verify(mockProducerMonitor).requested();\n    order.verify(mockProducerMonitor).methodStarting();\n    order.verify(mockProducerMonitor).methodFinished();\n    order.verify(mockProducerMonitor).succeeded(o);\n    verifyNoMoreInteractions(mockProducerMonitor);\n  }\n\n  @Test\n  public void singleMonitor_normalProducerMonitorFailure() {\n    setUpNormalSingleMonitor();\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(mockProductionComponentMonitorFactory));\n    ProductionComponentMonitor monitor \u003d factory.create(new Object());\n    ProducerMonitor producerMonitor \u003d\n        monitor.producerMonitorFor(ProducerToken.create(Object.class));\n    Throwable t \u003d new RuntimeException(\"monkey\");\n    producerMonitor.requested();\n    producerMonitor.methodStarting();\n    producerMonitor.methodFinished();\n    producerMonitor.failed(t);\n\n    InOrder order \u003d inOrder(mockProducerMonitor);\n    order.verify(mockProducerMonitor).requested();\n    order.verify(mockProducerMonitor).methodStarting();\n    order.verify(mockProducerMonitor).methodFinished();\n    order.verify(mockProducerMonitor).failed(t);\n    verifyNoMoreInteractions(mockProducerMonitor);\n  }\n\n  @Test\n  public void singleMonitor_throwingProducerMonitorSuccess() {\n    setUpNormalSingleMonitor();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitor).requested();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitor).methodStarting();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitor).methodFinished();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitor).succeeded(any(Object.class));\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(mockProductionComponentMonitorFactory));\n    ProductionComponentMonitor monitor \u003d factory.create(new Object());\n    ProducerMonitor producerMonitor \u003d\n        monitor.producerMonitorFor(ProducerToken.create(Object.class));\n    Object o \u003d new Object();\n    producerMonitor.requested();\n    producerMonitor.methodStarting();\n    producerMonitor.methodFinished();\n    producerMonitor.succeeded(o);\n\n    InOrder order \u003d inOrder(mockProducerMonitor);\n    order.verify(mockProducerMonitor).requested();\n    order.verify(mockProducerMonitor).methodStarting();\n    order.verify(mockProducerMonitor).methodFinished();\n    order.verify(mockProducerMonitor).succeeded(o);\n    verifyNoMoreInteractions(mockProducerMonitor);\n  }\n\n  @Test\n  public void singleMonitor_throwingProducerMonitorFailure() {\n    setUpNormalSingleMonitor();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitor).requested();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitor).methodStarting();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitor).methodFinished();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitor).failed(any(Throwable.class));\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(mockProductionComponentMonitorFactory));\n    ProductionComponentMonitor monitor \u003d factory.create(new Object());\n    ProducerMonitor producerMonitor \u003d\n        monitor.producerMonitorFor(ProducerToken.create(Object.class));\n    Throwable t \u003d new RuntimeException(\"gorilla\");\n    producerMonitor.requested();\n    producerMonitor.methodStarting();\n    producerMonitor.methodFinished();\n    producerMonitor.failed(t);\n\n    InOrder order \u003d inOrder(mockProducerMonitor);\n    order.verify(mockProducerMonitor).requested();\n    order.verify(mockProducerMonitor).methodStarting();\n    order.verify(mockProducerMonitor).methodFinished();\n    order.verify(mockProducerMonitor).failed(t);\n    verifyNoMoreInteractions(mockProducerMonitor);\n  }\n\n  @Test\n  public void multipleMonitors_nullProductionComponentMonitors() {\n    when(mockProductionComponentMonitorFactoryA.create(any(Object.class))).thenReturn(null);\n    when(mockProductionComponentMonitorFactoryB.create(any(Object.class))).thenReturn(null);\n    when(mockProductionComponentMonitorFactoryC.create(any(Object.class))).thenReturn(null);\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(\n                mockProductionComponentMonitorFactoryA,\n                mockProductionComponentMonitorFactoryB,\n                mockProductionComponentMonitorFactoryC));\n    assertThat(factory.create(new Object())).isSameAs(ProductionComponentMonitor.noOp());\n  }\n\n  @Test\n  public void multipleMonitors_throwingProductionComponentMonitorFactories() {\n    doThrow(new RuntimeException(\"monkey\"))\n        .when(mockProductionComponentMonitorFactoryA)\n        .create(any(Object.class));\n    doThrow(new RuntimeException(\"monkey\"))\n        .when(mockProductionComponentMonitorFactoryB)\n        .create(any(Object.class));\n    doThrow(new RuntimeException(\"monkey\"))\n        .when(mockProductionComponentMonitorFactoryC)\n        .create(any(Object.class));\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(\n                mockProductionComponentMonitorFactoryA,\n                mockProductionComponentMonitorFactoryB,\n                mockProductionComponentMonitorFactoryC));\n    assertThat(factory.create(new Object())).isSameAs(ProductionComponentMonitor.noOp());\n  }\n\n  @Test\n  public void multipleMonitors_someNullProductionComponentMonitors() {\n    when(mockProductionComponentMonitorFactoryA.create(any(Object.class)))\n        .thenReturn(mockProductionComponentMonitorA);\n    when(mockProductionComponentMonitorFactoryB.create(any(Object.class))).thenReturn(null);\n    when(mockProductionComponentMonitorFactoryC.create(any(Object.class))).thenReturn(null);\n    when(mockProductionComponentMonitorA.producerMonitorFor(any(ProducerToken.class)))\n        .thenReturn(mockProducerMonitorA);\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(\n                mockProductionComponentMonitorFactoryA,\n                mockProductionComponentMonitorFactoryB,\n                mockProductionComponentMonitorFactoryC));\n    ProductionComponentMonitor monitor \u003d factory.create(new Object());\n    ProducerMonitor producerMonitor \u003d\n        monitor.producerMonitorFor(ProducerToken.create(Object.class));\n\n    Object o \u003d new Object();\n    producerMonitor.requested();\n    producerMonitor.methodStarting();\n    producerMonitor.methodFinished();\n    producerMonitor.succeeded(o);\n\n    InOrder order \u003d inOrder(mockProducerMonitorA);\n    order.verify(mockProducerMonitorA).requested();\n    order.verify(mockProducerMonitorA).methodStarting();\n    order.verify(mockProducerMonitorA).methodFinished();\n    order.verify(mockProducerMonitorA).succeeded(o);\n    verifyNoMoreInteractions(mockProducerMonitorA);\n  }\n\n  @Test\n  public void multipleMonitors_someThrowingProductionComponentMonitorFactories() {\n    when(mockProductionComponentMonitorFactoryA.create(any(Object.class)))\n        .thenReturn(mockProductionComponentMonitorA);\n    doThrow(new RuntimeException(\"monkey\"))\n        .when(mockProductionComponentMonitorFactoryB)\n        .create(any(Object.class));\n    doThrow(new RuntimeException(\"monkey\"))\n        .when(mockProductionComponentMonitorFactoryC)\n        .create(any(Object.class));\n    when(mockProductionComponentMonitorA.producerMonitorFor(any(ProducerToken.class)))\n        .thenReturn(mockProducerMonitorA);\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(\n                mockProductionComponentMonitorFactoryA,\n                mockProductionComponentMonitorFactoryB,\n                mockProductionComponentMonitorFactoryC));\n    ProductionComponentMonitor monitor \u003d factory.create(new Object());\n    ProducerMonitor producerMonitor \u003d\n        monitor.producerMonitorFor(ProducerToken.create(Object.class));\n\n    Object o \u003d new Object();\n    producerMonitor.requested();\n    producerMonitor.methodStarting();\n    producerMonitor.methodFinished();\n    producerMonitor.succeeded(o);\n\n    InOrder order \u003d inOrder(mockProducerMonitorA);\n    order.verify(mockProducerMonitorA).requested();\n    order.verify(mockProducerMonitorA).methodStarting();\n    order.verify(mockProducerMonitorA).methodFinished();\n    order.verify(mockProducerMonitorA).succeeded(o);\n    verifyNoMoreInteractions(mockProducerMonitorA);\n  }\n\n  @Test\n  public void multipleMonitors_normalProductionComponentMonitorSuccess() {\n    setUpNormalMultipleMonitors();\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(\n                mockProductionComponentMonitorFactoryA,\n                mockProductionComponentMonitorFactoryB,\n                mockProductionComponentMonitorFactoryC));\n    ProductionComponentMonitor monitor \u003d factory.create(new Object());\n    ProducerMonitor producerMonitor \u003d\n        monitor.producerMonitorFor(ProducerToken.create(Object.class));\n\n    Object o \u003d new Object();\n    producerMonitor.requested();\n    producerMonitor.methodStarting();\n    producerMonitor.methodFinished();\n    producerMonitor.succeeded(o);\n\n    InOrder order \u003d inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);\n    order.verify(mockProducerMonitorA).requested();\n    order.verify(mockProducerMonitorB).requested();\n    order.verify(mockProducerMonitorC).requested();\n    order.verify(mockProducerMonitorA).methodStarting();\n    order.verify(mockProducerMonitorB).methodStarting();\n    order.verify(mockProducerMonitorC).methodStarting();\n    order.verify(mockProducerMonitorC).methodFinished();\n    order.verify(mockProducerMonitorB).methodFinished();\n    order.verify(mockProducerMonitorA).methodFinished();\n    order.verify(mockProducerMonitorC).succeeded(o);\n    order.verify(mockProducerMonitorB).succeeded(o);\n    order.verify(mockProducerMonitorA).succeeded(o);\n    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);\n  }\n\n  @Test\n  public void multipleMonitors_normalProductionComponentMonitorFailure() {\n    setUpNormalMultipleMonitors();\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(\n                mockProductionComponentMonitorFactoryA,\n                mockProductionComponentMonitorFactoryB,\n                mockProductionComponentMonitorFactoryC));\n    ProductionComponentMonitor monitor \u003d factory.create(new Object());\n    ProducerMonitor producerMonitor \u003d\n        monitor.producerMonitorFor(ProducerToken.create(Object.class));\n\n    Throwable t \u003d new RuntimeException(\"chimpanzee\");\n    producerMonitor.requested();\n    producerMonitor.methodStarting();\n    producerMonitor.methodFinished();\n    producerMonitor.failed(t);\n\n    InOrder order \u003d inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);\n    order.verify(mockProducerMonitorA).requested();\n    order.verify(mockProducerMonitorB).requested();\n    order.verify(mockProducerMonitorC).requested();\n    order.verify(mockProducerMonitorA).methodStarting();\n    order.verify(mockProducerMonitorB).methodStarting();\n    order.verify(mockProducerMonitorC).methodStarting();\n    order.verify(mockProducerMonitorC).methodFinished();\n    order.verify(mockProducerMonitorB).methodFinished();\n    order.verify(mockProducerMonitorA).methodFinished();\n    order.verify(mockProducerMonitorC).failed(t);\n    order.verify(mockProducerMonitorB).failed(t);\n    order.verify(mockProducerMonitorA).failed(t);\n    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);\n  }\n\n  @Test\n  public void multipleMonitors_someThrowingProducerMonitorsSuccess() {\n    setUpNormalMultipleMonitors();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitorA).requested();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitorA).methodStarting();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitorB).methodFinished();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitorC).succeeded(any(Object.class));\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(\n                mockProductionComponentMonitorFactoryA,\n                mockProductionComponentMonitorFactoryB,\n                mockProductionComponentMonitorFactoryC));\n    ProductionComponentMonitor monitor \u003d factory.create(new Object());\n    ProducerMonitor producerMonitor \u003d\n        monitor.producerMonitorFor(ProducerToken.create(Object.class));\n\n    Object o \u003d new Object();\n    producerMonitor.requested();\n    producerMonitor.methodStarting();\n    producerMonitor.methodFinished();\n    producerMonitor.succeeded(o);\n\n    InOrder order \u003d inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);\n    order.verify(mockProducerMonitorA).requested();\n    order.verify(mockProducerMonitorB).requested();\n    order.verify(mockProducerMonitorC).requested();\n    order.verify(mockProducerMonitorA).methodStarting();\n    order.verify(mockProducerMonitorB).methodStarting();\n    order.verify(mockProducerMonitorC).methodStarting();\n    order.verify(mockProducerMonitorC).methodFinished();\n    order.verify(mockProducerMonitorB).methodFinished();\n    order.verify(mockProducerMonitorA).methodFinished();\n    order.verify(mockProducerMonitorC).succeeded(o);\n    order.verify(mockProducerMonitorB).succeeded(o);\n    order.verify(mockProducerMonitorA).succeeded(o);\n    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);\n  }\n\n  @Test\n  public void multipleMonitors_someThrowingProducerMonitorsFailure() {\n    setUpNormalMultipleMonitors();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitorA).requested();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitorA).methodStarting();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitorB).methodFinished();\n    doThrow(new RuntimeException(\"monkey\")).when(mockProducerMonitorC).failed(any(Throwable.class));\n    ProductionComponentMonitor.Factory factory \u003d\n        Monitors.delegatingProductionComponentMonitorFactory(\n            ImmutableList.of(\n                mockProductionComponentMonitorFactoryA,\n                mockProductionComponentMonitorFactoryB,\n                mockProductionComponentMonitorFactoryC));\n    ProductionComponentMonitor monitor \u003d factory.create(new Object());\n    ProducerMonitor producerMonitor \u003d\n        monitor.producerMonitorFor(ProducerToken.create(Object.class));\n\n    Throwable t \u003d new RuntimeException(\"chimpanzee\");\n    producerMonitor.requested();\n    producerMonitor.methodStarting();\n    producerMonitor.methodFinished();\n    producerMonitor.failed(t);\n\n    InOrder order \u003d inOrder(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);\n    order.verify(mockProducerMonitorA).requested();\n    order.verify(mockProducerMonitorB).requested();\n    order.verify(mockProducerMonitorC).requested();\n    order.verify(mockProducerMonitorA).methodStarting();\n    order.verify(mockProducerMonitorB).methodStarting();\n    order.verify(mockProducerMonitorC).methodStarting();\n    order.verify(mockProducerMonitorC).methodFinished();\n    order.verify(mockProducerMonitorB).methodFinished();\n    order.verify(mockProducerMonitorA).methodFinished();\n    order.verify(mockProducerMonitorC).failed(t);\n    order.verify(mockProducerMonitorB).failed(t);\n    order.verify(mockProducerMonitorA).failed(t);\n    verifyNoMoreInteractions(mockProducerMonitorA, mockProducerMonitorB, mockProducerMonitorC);\n  }\n\n  private void setUpNormalSingleMonitor() {\n    when(mockProductionComponentMonitorFactory.create(any(Object.class)))\n        .thenReturn(mockProductionComponentMonitor);\n    when(mockProductionComponentMonitor.producerMonitorFor(any(ProducerToken.class)))\n        .thenReturn(mockProducerMonitor);\n  }\n\n  private void setUpNormalMultipleMonitors() {\n    when(mockProductionComponentMonitorFactoryA.create(any(Object.class)))\n        .thenReturn(mockProductionComponentMonitorA);\n    when(mockProductionComponentMonitorFactoryB.create(any(Object.class)))\n        .thenReturn(mockProductionComponentMonitorB);\n    when(mockProductionComponentMonitorFactoryC.create(any(Object.class)))\n        .thenReturn(mockProductionComponentMonitorC);\n    when(mockProductionComponentMonitorA.producerMonitorFor(any(ProducerToken.class)))\n        .thenReturn(mockProducerMonitorA);\n    when(mockProductionComponentMonitorB.producerMonitorFor(any(ProducerToken.class)))\n        .thenReturn(mockProducerMonitorB);\n    when(mockProductionComponentMonitorC.producerMonitorFor(any(ProducerToken.class)))\n        .thenReturn(mockProducerMonitorC);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\test\\java\\dagger\\producers\\monitoring\\TimingProductionComponentMonitorTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.monitoring;\n\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.testing.FakeTicker;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\n@RunWith(JUnit4.class)\npublic final class TimingProductionComponentMonitorTest {\n  private static final class ProducerClassA {}\n\n  private static final class ProducerClassB {}\n\n  @Mock private ProductionComponentTimingRecorder.Factory productionComponentTimingRecorderFactory;\n  @Mock private ProductionComponentTimingRecorder productionComponentTimingRecorder;\n  @Mock private ProducerTimingRecorder producerTimingRecorderA;\n  @Mock private ProducerTimingRecorder producerTimingRecorderB;\n\n  private FakeTicker ticker;\n  private ProductionComponentMonitor.Factory monitorFactory;\n\n  @Before\n  public void setUp() {\n    MockitoAnnotations.initMocks(this);\n    when(productionComponentTimingRecorderFactory.create(any(Object.class)))\n        .thenReturn(productionComponentTimingRecorder);\n    when(\n            productionComponentTimingRecorder.producerTimingRecorderFor(\n                ProducerToken.create(ProducerClassA.class)))\n        .thenReturn(producerTimingRecorderA);\n    when(\n            productionComponentTimingRecorder.producerTimingRecorderFor(\n                ProducerToken.create(ProducerClassB.class)))\n        .thenReturn(producerTimingRecorderB);\n    ticker \u003d new FakeTicker();\n    monitorFactory \u003d\n        new TimingProductionComponentMonitor.Factory(\n            productionComponentTimingRecorderFactory, ticker);\n  }\n\n  @Test\n  public void normalExecution_success() {\n    ProductionComponentMonitor monitor \u003d monitorFactory.create(new Object());\n    ProducerMonitor producerMonitorA \u003d\n        monitor.producerMonitorFor(ProducerToken.create(ProducerClassA.class));\n    ticker.advance(5000222);\n    producerMonitorA.methodStarting();\n    ticker.advance(1333);\n    producerMonitorA.methodFinished();\n    ticker.advance(40000555);\n    ProducerMonitor producerMonitorB \u003d\n        monitor.producerMonitorFor(ProducerToken.create(ProducerClassB.class));\n    producerMonitorB.methodStarting();\n    ticker.advance(2000777);\n    producerMonitorA.succeeded(new Object());\n    ticker.advance(3000999);\n    producerMonitorB.methodFinished();\n    ticker.advance(100000222);\n    producerMonitorB.succeeded(new Object());\n\n    verify(producerTimingRecorderA).recordMethod(5000222, 1333);\n    verify(producerTimingRecorderA).recordSuccess(1333 + 40000555 + 2000777);\n    verify(producerTimingRecorderB).recordMethod(5000222 + 1333 + 40000555, 2000777 + 3000999);\n    verify(producerTimingRecorderB).recordSuccess(2000777 + 3000999 + 100000222);\n    verifyNoMoreInteractions(producerTimingRecorderA, producerTimingRecorderB);\n  }\n\n  @Test\n  public void normalExecution_failure() {\n    Throwable failureA \u003d new RuntimeException(\"monkey\");\n    Throwable failureB \u003d new RuntimeException(\"gorilla\");\n    ProductionComponentMonitor monitor \u003d monitorFactory.create(new Object());\n    ProducerMonitor producerMonitorA \u003d\n        monitor.producerMonitorFor(ProducerToken.create(ProducerClassA.class));\n    ticker.advance(5000222);\n    producerMonitorA.methodStarting();\n    ticker.advance(1333);\n    producerMonitorA.methodFinished();\n    ticker.advance(40000555);\n    ProducerMonitor producerMonitorB \u003d\n        monitor.producerMonitorFor(ProducerToken.create(ProducerClassB.class));\n    producerMonitorB.methodStarting();\n    ticker.advance(2000777);\n    producerMonitorA.failed(failureA);\n    ticker.advance(3000999);\n    producerMonitorB.methodFinished();\n    ticker.advance(100000222);\n    producerMonitorB.failed(failureB);\n\n    verify(producerTimingRecorderA).recordMethod(5000222, 1333);\n    verify(producerTimingRecorderA).recordFailure(failureA, 1333 + 40000555 + 2000777);\n    verify(producerTimingRecorderB).recordMethod(5000222 + 1333 + 40000555, 2000777 + 3000999);\n    verify(producerTimingRecorderB).recordFailure(failureB, 2000777 + 3000999 + 100000222);\n    verifyNoMoreInteractions(producerTimingRecorderA, producerTimingRecorderB);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\test\\java\\dagger\\producers\\monitoring\\TimingRecordersTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers.monitoring;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.collect.ImmutableList;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\nimport org.mockito.InOrder;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\n\n@RunWith(JUnit4.class)\npublic final class TimingRecordersTest {\n  @Mock\n  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactory;\n\n  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorder;\n  @Mock private ProducerTimingRecorder mockProducerTimingRecorder;\n\n  @Mock\n  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryA;\n\n  @Mock\n  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryB;\n\n  @Mock\n  private ProductionComponentTimingRecorder.Factory mockProductionComponentTimingRecorderFactoryC;\n\n  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderA;\n  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderB;\n  @Mock private ProductionComponentTimingRecorder mockProductionComponentTimingRecorderC;\n  @Mock private ProducerTimingRecorder mockProducerTimingRecorderA;\n  @Mock private ProducerTimingRecorder mockProducerTimingRecorderB;\n  @Mock private ProducerTimingRecorder mockProducerTimingRecorderC;\n\n  @Before\n  public void initMocks() {\n    MockitoAnnotations.initMocks(this);\n  }\n\n  @Test\n  public void zeroRecordersReturnsNoOp() {\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.\u003cProductionComponentTimingRecorder.Factory\u003eof());\n    assertThat(factory).isSameAs(TimingRecorders.noOpProductionComponentTimingRecorderFactory());\n  }\n\n  @Test\n  public void singleRecorder_nullProductionComponentTimingRecorder() {\n    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class))).thenReturn(null);\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.of(mockProductionComponentTimingRecorderFactory));\n    assertThat(factory.create(new Object()))\n        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());\n  }\n\n  @Test\n  public void singleRecorder_throwingProductionComponentTimingRecorderFactory() {\n    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))\n        .thenThrow(new RuntimeException(\"monkey\"));\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.of(mockProductionComponentTimingRecorderFactory));\n    assertThat(factory.create(new Object()))\n        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());\n  }\n\n  @Test\n  public void singleRecorder_nullProducerTimingRecorder() {\n    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))\n        .thenReturn(mockProductionComponentTimingRecorder);\n    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))\n        .thenReturn(null);\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.of(mockProductionComponentTimingRecorderFactory));\n    ProductionComponentTimingRecorder recorder \u003d factory.create(new Object());\n    assertThat(recorder.producerTimingRecorderFor(ProducerToken.create(Object.class)))\n        .isSameAs(ProducerTimingRecorder.noOp());\n  }\n\n  @Test\n  public void singleRecorder_throwingProductionComponentTimingRecorder() {\n    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))\n        .thenReturn(mockProductionComponentTimingRecorder);\n    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))\n        .thenThrow(new RuntimeException(\"monkey\"));\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.of(mockProductionComponentTimingRecorderFactory));\n    ProductionComponentTimingRecorder recorder \u003d factory.create(new Object());\n    assertThat(recorder.producerTimingRecorderFor(ProducerToken.create(Object.class)))\n        .isSameAs(ProducerTimingRecorder.noOp());\n  }\n\n  @Test\n  public void singleRecorder_normalProducerTimingRecorderSuccess() {\n    setUpNormalSingleRecorder();\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.of(mockProductionComponentTimingRecorderFactory));\n    ProductionComponentTimingRecorder recorder \u003d factory.create(new Object());\n    ProducerTimingRecorder producerTimingRecorder \u003d\n        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));\n    producerTimingRecorder.recordMethod(15, 42);\n    producerTimingRecorder.recordSuccess(100);\n\n    InOrder order \u003d inOrder(mockProducerTimingRecorder);\n    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);\n    order.verify(mockProducerTimingRecorder).recordSuccess(100);\n    verifyNoMoreInteractions(mockProducerTimingRecorder);\n  }\n\n  @Test\n  public void singleRecorder_normalProducerTimingRecorderFailure() {\n    setUpNormalSingleRecorder();\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.of(mockProductionComponentTimingRecorderFactory));\n    ProductionComponentTimingRecorder recorder \u003d factory.create(new Object());\n    ProducerTimingRecorder producerTimingRecorder \u003d\n        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));\n    Throwable t \u003d new RuntimeException(\"monkey\");\n    producerTimingRecorder.recordMethod(15, 42);\n    producerTimingRecorder.recordFailure(t, 100);\n\n    InOrder order \u003d inOrder(mockProducerTimingRecorder);\n    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);\n    order.verify(mockProducerTimingRecorder).recordFailure(t, 100);\n    verifyNoMoreInteractions(mockProducerTimingRecorder);\n  }\n\n  @Test\n  public void singleRecorder_throwingProducerTimingRecorderSuccess() {\n    setUpNormalSingleRecorder();\n    doThrow(new RuntimeException(\"monkey\"))\n        .when(mockProducerTimingRecorder)\n        .recordMethod(any(Long.class), any(Long.class));\n    doThrow(new RuntimeException(\"monkey\"))\n        .when(mockProducerTimingRecorder)\n        .recordSuccess(any(Long.class));\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.of(mockProductionComponentTimingRecorderFactory));\n    ProductionComponentTimingRecorder recorder \u003d factory.create(new Object());\n    ProducerTimingRecorder producerTimingRecorder \u003d\n        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));\n    producerTimingRecorder.recordMethod(15, 42);\n    producerTimingRecorder.recordSuccess(100);\n\n    InOrder order \u003d inOrder(mockProducerTimingRecorder);\n    order.verify(mockProducerTimingRecorder).recordMethod(15, 42);\n    order.verify(mockProducerTimingRecorder).recordSuccess(100);\n    verifyNoMoreInteractions(mockProducerTimingRecorder);\n  }\n\n  @Test\n  public void multipleRecorders_nullProductionComponentTimingRecorders() {\n    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class))).thenReturn(null);\n    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class))).thenReturn(null);\n    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class))).thenReturn(null);\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.of(\n                mockProductionComponentTimingRecorderFactoryA,\n                mockProductionComponentTimingRecorderFactoryB,\n                mockProductionComponentTimingRecorderFactoryC));\n    assertThat(factory.create(new Object()))\n        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());\n  }\n\n  @Test\n  public void multipleRecorders_throwingProductionComponentTimingRecorderFactories() {\n    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))\n        .thenThrow(new RuntimeException(\"monkey\"));\n    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))\n        .thenThrow(new RuntimeException(\"monkey\"));\n    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))\n        .thenThrow(new RuntimeException(\"monkey\"));\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.of(\n                mockProductionComponentTimingRecorderFactoryA,\n                mockProductionComponentTimingRecorderFactoryB,\n                mockProductionComponentTimingRecorderFactoryC));\n    assertThat(factory.create(new Object()))\n        .isSameAs(TimingRecorders.noOpProductionComponentTimingRecorder());\n  }\n\n  @Test\n  public void multipleRecorders_someNullProductionComponentTimingRecorders() {\n    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))\n        .thenReturn(mockProductionComponentTimingRecorderA);\n    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class))).thenReturn(null);\n    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class))).thenReturn(null);\n    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))\n        .thenReturn(mockProducerTimingRecorderA);\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.of(\n                mockProductionComponentTimingRecorderFactoryA,\n                mockProductionComponentTimingRecorderFactoryB,\n                mockProductionComponentTimingRecorderFactoryC));\n    ProductionComponentTimingRecorder recorder \u003d factory.create(new Object());\n    ProducerTimingRecorder producerTimingRecorder \u003d\n        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));\n\n    producerTimingRecorder.recordMethod(15, 42);\n    producerTimingRecorder.recordSuccess(100);\n\n    InOrder order \u003d inOrder(mockProducerTimingRecorderA);\n    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);\n    order.verify(mockProducerTimingRecorderA).recordSuccess(100);\n    verifyNoMoreInteractions(mockProducerTimingRecorderA);\n  }\n\n  @Test\n  public void multipleRecorders_someThrowingProductionComponentTimingRecorderFactories() {\n    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))\n        .thenReturn(mockProductionComponentTimingRecorderA);\n    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))\n        .thenThrow(new RuntimeException(\"monkey\"));\n    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))\n        .thenThrow(new RuntimeException(\"monkey\"));\n    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))\n        .thenReturn(mockProducerTimingRecorderA);\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.of(\n                mockProductionComponentTimingRecorderFactoryA,\n                mockProductionComponentTimingRecorderFactoryB,\n                mockProductionComponentTimingRecorderFactoryC));\n    ProductionComponentTimingRecorder recorder \u003d factory.create(new Object());\n    ProducerTimingRecorder producerTimingRecorder \u003d\n        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));\n\n    producerTimingRecorder.recordMethod(15, 42);\n    producerTimingRecorder.recordSuccess(100);\n\n    InOrder order \u003d inOrder(mockProducerTimingRecorderA);\n    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);\n    order.verify(mockProducerTimingRecorderA).recordSuccess(100);\n    verifyNoMoreInteractions(mockProducerTimingRecorderA);\n  }\n\n  @Test\n  public void multipleRecorders_normalProductionComponentTimingRecorderSuccess() {\n    setUpNormalMultipleRecorders();\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.of(\n                mockProductionComponentTimingRecorderFactoryA,\n                mockProductionComponentTimingRecorderFactoryB,\n                mockProductionComponentTimingRecorderFactoryC));\n    ProductionComponentTimingRecorder recorder \u003d factory.create(new Object());\n    ProducerTimingRecorder producerTimingRecorder \u003d\n        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));\n\n    producerTimingRecorder.recordMethod(15, 42);\n    producerTimingRecorder.recordSuccess(100);\n\n    InOrder order \u003d\n        inOrder(\n            mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);\n    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);\n    order.verify(mockProducerTimingRecorderB).recordMethod(15, 42);\n    order.verify(mockProducerTimingRecorderC).recordMethod(15, 42);\n    order.verify(mockProducerTimingRecorderA).recordSuccess(100);\n    order.verify(mockProducerTimingRecorderB).recordSuccess(100);\n    order.verify(mockProducerTimingRecorderC).recordSuccess(100);\n    verifyNoMoreInteractions(\n        mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);\n  }\n\n  @Test\n  public void multipleRecorders_someThrowingProducerTimingRecordersSuccess() {\n    setUpNormalMultipleRecorders();\n    doThrow(new RuntimeException(\"monkey\"))\n        .when(mockProducerTimingRecorderA)\n        .recordMethod(any(Long.class), any(Long.class));\n    doThrow(new RuntimeException(\"monkey\"))\n        .when(mockProducerTimingRecorderB)\n        .recordSuccess(any(Long.class));\n    doThrow(new RuntimeException(\"monkey\"))\n        .when(mockProducerTimingRecorderC)\n        .recordMethod(any(Long.class), any(Long.class));\n    ProductionComponentTimingRecorder.Factory factory \u003d\n        TimingRecorders.delegatingProductionComponentTimingRecorderFactory(\n            ImmutableList.of(\n                mockProductionComponentTimingRecorderFactoryA,\n                mockProductionComponentTimingRecorderFactoryB,\n                mockProductionComponentTimingRecorderFactoryC));\n    ProductionComponentTimingRecorder recorder \u003d factory.create(new Object());\n    ProducerTimingRecorder producerTimingRecorder \u003d\n        recorder.producerTimingRecorderFor(ProducerToken.create(Object.class));\n\n    producerTimingRecorder.recordMethod(15, 42);\n    producerTimingRecorder.recordSuccess(100);\n\n    InOrder order \u003d\n        inOrder(\n            mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);\n    order.verify(mockProducerTimingRecorderA).recordMethod(15, 42);\n    order.verify(mockProducerTimingRecorderB).recordMethod(15, 42);\n    order.verify(mockProducerTimingRecorderC).recordMethod(15, 42);\n    order.verify(mockProducerTimingRecorderA).recordSuccess(100);\n    order.verify(mockProducerTimingRecorderB).recordSuccess(100);\n    order.verify(mockProducerTimingRecorderC).recordSuccess(100);\n    verifyNoMoreInteractions(\n        mockProducerTimingRecorderA, mockProducerTimingRecorderB, mockProducerTimingRecorderC);\n  }\n\n  private void setUpNormalSingleRecorder() {\n    when(mockProductionComponentTimingRecorderFactory.create(any(Object.class)))\n        .thenReturn(mockProductionComponentTimingRecorder);\n    when(mockProductionComponentTimingRecorder.producerTimingRecorderFor(any(ProducerToken.class)))\n        .thenReturn(mockProducerTimingRecorder);\n  }\n\n  private void setUpNormalMultipleRecorders() {\n    when(mockProductionComponentTimingRecorderFactoryA.create(any(Object.class)))\n        .thenReturn(mockProductionComponentTimingRecorderA);\n    when(mockProductionComponentTimingRecorderFactoryB.create(any(Object.class)))\n        .thenReturn(mockProductionComponentTimingRecorderB);\n    when(mockProductionComponentTimingRecorderFactoryC.create(any(Object.class)))\n        .thenReturn(mockProductionComponentTimingRecorderC);\n    when(mockProductionComponentTimingRecorderA.producerTimingRecorderFor(any(ProducerToken.class)))\n        .thenReturn(mockProducerTimingRecorderA);\n    when(mockProductionComponentTimingRecorderB.producerTimingRecorderFor(any(ProducerToken.class)))\n        .thenReturn(mockProducerTimingRecorderB);\n    when(mockProductionComponentTimingRecorderC.producerTimingRecorderFor(any(ProducerToken.class)))\n        .thenReturn(mockProducerTimingRecorderC);\n  }\n}\n\""
  },
  {
    "path": "C:\\Users\\clint\\Documents\\dagger\\producers\\src\\test\\java\\dagger\\producers\\ProducedTest.java",
    "code": "\"/*\n * Copyright (C) 2015 The Dagger Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage dagger.producers;\n\nimport static com.google.common.truth.Truth.assertThat;\nimport static org.junit.Assert.fail;\n\nimport com.google.common.testing.EqualsTester;\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.JUnit4;\n\n/**\n * Tests {@link Produced}.\n */\n@RunWith(JUnit4.class)\npublic class ProducedTest {\n  @Test public void successfulProduced() throws ExecutionException {\n    Object o \u003d new Object();\n    assertThat(Produced.successful(5).get()).isEqualTo(5);\n    assertThat(Produced.successful(\"monkey\").get()).isEqualTo(\"monkey\");\n    assertThat(Produced.successful(o).get()).isSameAs(o);\n  }\n\n  @Test public void failedProduced() {\n    RuntimeException cause \u003d new RuntimeException(\"monkey\");\n    try {\n      Produced.failed(cause).get();\n      fail();\n    } catch (ExecutionException e) {\n      assertThat(e.getCause()).isSameAs(cause);\n    }\n  }\n\n  @Test public void producedEquivalence() {\n    RuntimeException e1 \u003d new RuntimeException(\"monkey\");\n    RuntimeException e2 \u003d new CancellationException();\n    new EqualsTester()\n        .addEqualityGroup(Produced.successful(132435), Produced.successful(132435))\n        .addEqualityGroup(Produced.successful(\"hi\"), Produced.successful(\"hi\"))\n        .addEqualityGroup(Produced.failed(e1), Produced.failed(e1))\n        .addEqualityGroup(Produced.failed(e2), Produced.failed(e2))\n        .testEquals();\n  }\n}\n\""
  }
];